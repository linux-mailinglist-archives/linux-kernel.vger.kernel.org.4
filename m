Return-Path: <linux-kernel-owner@vger.kernel.org>
X-Original-To: lists+linux-kernel@lfdr.de
Delivered-To: lists+linux-kernel@lfdr.de
Received: from out1.vger.email (out1.vger.email [IPv6:2620:137:e000::1:20])
	by mail.lfdr.de (Postfix) with ESMTP id 92F7364D6AD
	for <lists+linux-kernel@lfdr.de>; Thu, 15 Dec 2022 07:51:04 +0100 (CET)
Received: (majordomo@vger.kernel.org) by vger.kernel.org via listexpand
        id S229471AbiLOGu7 (ORCPT <rfc822;lists+linux-kernel@lfdr.de>);
        Thu, 15 Dec 2022 01:50:59 -0500
Received: from lindbergh.monkeyblade.net ([23.128.96.19]:47428 "EHLO
        lindbergh.monkeyblade.net" rhost-flags-OK-OK-OK-OK) by vger.kernel.org
        with ESMTP id S229732AbiLOGuw (ORCPT
        <rfc822;linux-kernel@vger.kernel.org>);
        Thu, 15 Dec 2022 01:50:52 -0500
Received: from mail-pj1-x1049.google.com (mail-pj1-x1049.google.com [IPv6:2607:f8b0:4864:20::1049])
        by lindbergh.monkeyblade.net (Postfix) with ESMTPS id 055D0EBD
        for <linux-kernel@vger.kernel.org>; Wed, 14 Dec 2022 22:50:52 -0800 (PST)
Received: by mail-pj1-x1049.google.com with SMTP id hg4-20020a17090b300400b002215a3c02c3so5311411pjb.4
        for <linux-kernel@vger.kernel.org>; Wed, 14 Dec 2022 22:50:52 -0800 (PST)
DKIM-Signature: v=1; a=rsa-sha256; c=relaxed/relaxed;
        d=google.com; s=20210112;
        h=content-transfer-encoding:cc:to:from:subject:references
         :mime-version:message-id:in-reply-to:date:from:to:cc:subject:date
         :message-id:reply-to;
        bh=a2P0Yk7AMtZcUvfw5mCSGvcQaXFF18auc2QdNeVMa6I=;
        b=FxyZHX5ToZ0UgUMqaixgyYhYvuSy4f1OG8kTFzHGGkEvEVERHUN/4BwIJYDH3KYzBu
         14UbX3cTnKEnbAVRP6PiMriog7Md6lJjDPpt2EASJgCOgBc+ucKXcb2CHC4SRLd/lsb+
         sfGsm7sV4P3Mm60X7n8EJ3NvqINVBbey3wKrmrK46kh73mvOpLQVm2yLc+185QL4kv2i
         vggwD6Esb+fQqkINeuBgJvO6SRoMzzWIHf9yXO0LpC5vBTN8RYg/4KBN/+B3eFcoM7hC
         tov5fZVLKzJLJVjpz1WLL9O3u7bKDVzsUjwO1f1lQek0GNxtqz1dCG/yA+58euwnMrCe
         eE5Q==
X-Google-DKIM-Signature: v=1; a=rsa-sha256; c=relaxed/relaxed;
        d=1e100.net; s=20210112;
        h=content-transfer-encoding:cc:to:from:subject:references
         :mime-version:message-id:in-reply-to:date:x-gm-message-state:from:to
         :cc:subject:date:message-id:reply-to;
        bh=a2P0Yk7AMtZcUvfw5mCSGvcQaXFF18auc2QdNeVMa6I=;
        b=Vdbmxbjm807+DWuGItZhx1qa8UlLwiFk5gArGNXDTF7vnNmVx0AxHbnDbUFesjYSr7
         vAjK/CmnqB9+fhkAX91RT64atwPh/odvG0ZlimTvNMviHwtz/zCesMl5HVHi6gPL1rKp
         z6UiLbBBbjbMvMQl1yh1IdC4kv0tb3qHc4y97owVT+5vKiCVR3w0nKXG5azyYDtt3wVZ
         Ib22WY+o4h8wFUutEpDpPYjmUfEj6jfZ1r1J4O15MRREuePxLL31SncC+snbDqGwEytf
         MLTAWieZ+0PiP6uVLaZK/U0W/2FR+KKcqCw9KH06f+Pbz4nxWFd1bgJGVq8JsQfKEZpl
         rrkQ==
X-Gm-Message-State: AFqh2kqd+vVqZtfjPy9IDCSxIY+ihScGAQW2irOWvT9dLHsic7aX1kCI
        pkG7s1loJ+GCHKgbMT53NZEKoVzubuJ5
X-Google-Smtp-Source: AA0mqf7/IB2c3zG4OG8fdfx0tayXigTF8NHaH0Un944+RBgNGI5gtCnSaOdh/wU/kakpTB0tgi4cZS35+dJx
X-Received: from irogers.svl.corp.google.com ([2620:15c:2d4:203:c7dc:d96f:4f9:f59d])
 (user=irogers job=sendgmr) by 2002:a17:90a:c296:b0:218:7734:499 with SMTP id
 f22-20020a17090ac29600b0021877340499mr829525pjt.2.1671087051377; Wed, 14 Dec
 2022 22:50:51 -0800 (PST)
Date:   Wed, 14 Dec 2022 22:49:52 -0800
In-Reply-To: <20221215065017.1621020-1-irogers@google.com>
Message-Id: <20221215065017.1621020-2-irogers@google.com>
Mime-Version: 1.0
References: <20221215065017.1621020-1-irogers@google.com>
X-Mailer: git-send-email 2.39.0.314.g84b9a713c41-goog
Subject: [PATCH v1 07/32] perf vendor events intel: Refresh broadwellx metrics
 and events
From:   Ian Rogers <irogers@google.com>
To:     Peter Zijlstra <peterz@infradead.org>,
        Ingo Molnar <mingo@redhat.com>,
        Arnaldo Carvalho de Melo <acme@kernel.org>,
        Mark Rutland <mark.rutland@arm.com>,
        Alexander Shishkin <alexander.shishkin@linux.intel.com>,
        Jiri Olsa <jolsa@kernel.org>,
        Namhyung Kim <namhyung@kernel.org>,
        Adrian Hunter <adrian.hunter@intel.com>,
        Kan Liang <kan.liang@linux.intel.com>,
        Xing Zhengjun <zhengjun.xing@linux.intel.com>,
        linux-perf-users@vger.kernel.org, linux-kernel@vger.kernel.org
Cc:     John Garry <john.g.garry@oracle.com>,
        Stephane Eranian <eranian@google.com>,
        Perry Taylor <perry.taylor@intel.com>,
        Caleb Biggers <caleb.biggers@intel.com>,
        Ian Rogers <irogers@google.com>
Content-Type: text/plain; charset="UTF-8"
Content-Transfer-Encoding: quoted-printable
Precedence: bulk
List-ID: <linux-kernel.vger.kernel.org>
X-Mailing-List: linux-kernel@vger.kernel.org

Update the broadwellx metrics and events using the new tooling from:
https://github.com/intel/perfmon

The metrics are unchanged but the formulas differ due to parentheses,
use of exponents and removal of redundant operations like "* 1". The
order of metrics varies as TMA metrics are first converted and then
removed if perfmon versions are found. The events are updated with
fixes to uncore events and improved descriptions. The formatting
changes increase consistency across the json files.

Signed-off-by: Ian Rogers <irogers@google.com>
---
 .../arch/x86/broadwellx/bdx-metrics.json      | 1703 ++++----
 .../pmu-events/arch/x86/broadwellx/cache.json |  191 -
 .../arch/x86/broadwellx/floating-point.json   |   40 -
 .../arch/x86/broadwellx/frontend.json         |   56 -
 .../arch/x86/broadwellx/memory.json           |  143 -
 .../pmu-events/arch/x86/broadwellx/other.json |    8 -
 .../arch/x86/broadwellx/pipeline.json         |  272 --
 .../arch/x86/broadwellx/uncore-cache.json     | 3740 ++++++++---------
 .../x86/broadwellx/uncore-interconnect.json   | 1225 +++---
 .../arch/x86/broadwellx/uncore-memory.json    | 2052 +++++----
 .../arch/x86/broadwellx/uncore-other.json     | 2410 ++++++-----
 .../arch/x86/broadwellx/uncore-power.json     |  198 +-
 .../arch/x86/broadwellx/virtual-memory.json   |   76 -
 13 files changed, 5577 insertions(+), 6537 deletions(-)

diff --git a/tools/perf/pmu-events/arch/x86/broadwellx/bdx-metrics.json b/t=
ools/perf/pmu-events/arch/x86/broadwellx/bdx-metrics.json
index e89fa536ca03..f5c8f707c692 100644
--- a/tools/perf/pmu-events/arch/x86/broadwellx/bdx-metrics.json
+++ b/tools/perf/pmu-events/arch/x86/broadwellx/bdx-metrics.json
@@ -1,1206 +1,1189 @@
 [
     {
-        "BriefDescription": "This category represents fraction of slots wh=
ere the processor's Frontend undersupplies its Backend",
-        "MetricExpr": "IDQ_UOPS_NOT_DELIVERED.CORE / SLOTS",
-        "MetricGroup": "PGO;TopdownL1;tma_L1_group",
-        "MetricName": "tma_frontend_bound",
-        "PublicDescription": "This category represents fraction of slots w=
here the processor's Frontend undersupplies its Backend. Frontend denotes t=
he first part of the processor core responsible to fetch operations that ar=
e executed later on by the Backend part. Within the Frontend; a branch pred=
ictor predicts the next address to fetch; cache-lines are fetched from the =
memory subsystem; parsed into instructions; and lastly decoded into micro-o=
perations (uops). Ideally the Frontend can issue Machine_Width uops every c=
ycle to the Backend. Frontend Bound denotes unutilized issue-slots when the=
re is no Backend stall; i.e. bubbles where Frontend delivered no uops while=
 Backend could have accepted them. For example; stalls due to instruction-c=
ache misses would be categorized under Frontend Bound.",
-        "ScaleUnit": "100%"
+        "BriefDescription": "Instructions Per Cycle (per Logical Processor=
)",
+        "MetricExpr": "INST_RETIRED.ANY / CLKS",
+        "MetricGroup": "Ret;Summary",
+        "MetricName": "IPC"
     },
     {
-        "BriefDescription": "This metric represents fraction of slots the =
CPU was stalled due to Frontend latency issues",
-        "MetricExpr": "4 * IDQ_UOPS_NOT_DELIVERED.CYCLES_0_UOPS_DELIV.CORE=
 / SLOTS",
-        "MetricGroup": "Frontend;TopdownL2;tma_L2_group;tma_frontend_bound=
_group",
-        "MetricName": "tma_fetch_latency",
-        "PublicDescription": "This metric represents fraction of slots the=
 CPU was stalled due to Frontend latency issues.  For example; instruction-=
cache misses; iTLB misses or fetch stalls after a branch misprediction are =
categorized under Frontend Latency. In such cases; the Frontend eventually =
delivers no uops for some period. Sample with: RS_EVENTS.EMPTY_END",
-        "ScaleUnit": "100%"
+        "BriefDescription": "Uops Per Instruction",
+        "MetricExpr": "UOPS_RETIRED.RETIRE_SLOTS / INST_RETIRED.ANY",
+        "MetricGroup": "Pipeline;Ret;Retire",
+        "MetricName": "UPI"
     },
     {
-        "BriefDescription": "This metric represents fraction of cycles the=
 CPU was stalled due to instruction cache misses.",
-        "MetricExpr": "ICACHE.IFDATA_STALL / CLKS",
-        "MetricGroup": "BigFoot;FetchLat;IcMiss;TopdownL3;tma_fetch_latenc=
y_group",
-        "MetricName": "tma_icache_misses",
-        "ScaleUnit": "100%"
+        "BriefDescription": "Instruction per taken branch",
+        "MetricExpr": "UOPS_RETIRED.RETIRE_SLOTS / BR_INST_RETIRED.NEAR_TA=
KEN",
+        "MetricGroup": "Branches;Fed;FetchBW",
+        "MetricName": "UpTB"
     },
     {
-        "BriefDescription": "This metric represents fraction of cycles the=
 CPU was stalled due to Instruction TLB (ITLB) misses",
-        "MetricExpr": "(14 * ITLB_MISSES.STLB_HIT + cpu@ITLB_MISSES.WALK_D=
URATION\\,cmask\\=3D1@ + 7 * ITLB_MISSES.WALK_COMPLETED) / CLKS",
-        "MetricGroup": "BigFoot;FetchLat;MemoryTLB;TopdownL3;tma_fetch_lat=
ency_group",
-        "MetricName": "tma_itlb_misses",
-        "PublicDescription": "This metric represents fraction of cycles th=
e CPU was stalled due to Instruction TLB (ITLB) misses. Sample with: ITLB_M=
ISSES.WALK_COMPLETED",
-        "ScaleUnit": "100%"
+        "BriefDescription": "Cycles Per Instruction (per Logical Processor=
)",
+        "MetricExpr": "1 / IPC",
+        "MetricGroup": "Mem;Pipeline",
+        "MetricName": "CPI"
     },
     {
-        "BriefDescription": "This metric represents fraction of cycles the=
 CPU was stalled due to Branch Resteers",
-        "MetricExpr": "12 * (BR_MISP_RETIRED.ALL_BRANCHES + MACHINE_CLEARS=
.COUNT + BACLEARS.ANY) / CLKS",
-        "MetricGroup": "FetchLat;TopdownL3;tma_fetch_latency_group",
-        "MetricName": "tma_branch_resteers",
-        "PublicDescription": "This metric represents fraction of cycles th=
e CPU was stalled due to Branch Resteers. Branch Resteers estimates the Fro=
ntend delay in fetching operations from corrected path; following all sorts=
 of miss-predicted branches. For example; branchy code with lots of miss-pr=
edictions might get categorized under Branch Resteers. Note the value of th=
is node may overlap with its siblings. Sample with: BR_MISP_RETIRED.ALL_BRA=
NCHES",
-        "ScaleUnit": "100%"
+        "BriefDescription": "Per-Logical Processor actual clocks when the =
Logical Processor is active.",
+        "MetricExpr": "CPU_CLK_UNHALTED.THREAD",
+        "MetricGroup": "Pipeline",
+        "MetricName": "CLKS"
     },
     {
-        "BriefDescription": "This metric represents fraction of cycles the=
 CPU was stalled due to Branch Resteers as a result of Branch Misprediction=
 at execution stage. ",
-        "MetricExpr": "BR_MISP_RETIRED.ALL_BRANCHES * tma_branch_resteers =
/ (BR_MISP_RETIRED.ALL_BRANCHES + MACHINE_CLEARS.COUNT + BACLEARS.ANY)",
-        "MetricGroup": "BadSpec;BrMispredicts;TopdownL4;tma_branch_resteer=
s_group",
-        "MetricName": "tma_mispredicts_resteers",
-        "ScaleUnit": "100%"
+        "BriefDescription": "Total issue-pipeline slots (per-Physical Core=
 till ICL; per-Logical Processor ICL onward)",
+        "MetricExpr": "4 * CORE_CLKS",
+        "MetricGroup": "tma_L1_group",
+        "MetricName": "SLOTS"
     },
     {
-        "BriefDescription": "This metric represents fraction of cycles the=
 CPU was stalled due to Branch Resteers as a result of Machine Clears. ",
-        "MetricExpr": "MACHINE_CLEARS.COUNT * tma_branch_resteers / (BR_MI=
SP_RETIRED.ALL_BRANCHES + MACHINE_CLEARS.COUNT + BACLEARS.ANY)",
-        "MetricGroup": "BadSpec;MachineClears;TopdownL4;tma_branch_resteer=
s_group",
-        "MetricName": "tma_clears_resteers",
-        "ScaleUnit": "100%"
+        "BriefDescription": "The ratio of Executed- by Issued-Uops",
+        "MetricExpr": "UOPS_EXECUTED.THREAD / UOPS_ISSUED.ANY",
+        "MetricGroup": "Cor;Pipeline",
+        "MetricName": "Execute_per_Issue",
+        "PublicDescription": "The ratio of Executed- by Issued-Uops. Ratio=
 > 1 suggests high rate of uop micro-fusions. Ratio < 1 suggest high rate o=
f \"execute\" at rename stage."
     },
     {
-        "BriefDescription": "This metric represents fraction of cycles the=
 CPU was stalled due to new branch address clears",
-        "MetricExpr": "tma_branch_resteers - tma_mispredicts_resteers - tm=
a_clears_resteers",
-        "MetricGroup": "BigFoot;FetchLat;TopdownL4;tma_branch_resteers_gro=
up",
-        "MetricName": "tma_unknown_branches",
-        "PublicDescription": "This metric represents fraction of cycles th=
e CPU was stalled due to new branch address clears. These are fetched branc=
hes the Branch Prediction Unit was unable to recognize (First fetch or hitt=
ing BPU capacity limit). Sample with: BACLEARS.ANY",
-        "ScaleUnit": "100%"
+        "BriefDescription": "Instructions Per Cycle across hyper-threads (=
per physical core)",
+        "MetricExpr": "INST_RETIRED.ANY / CORE_CLKS",
+        "MetricGroup": "Ret;SMT;tma_L1_group",
+        "MetricName": "CoreIPC"
     },
     {
-        "BriefDescription": "This metric represents fraction of cycles the=
 CPU was stalled due to switches from DSB to MITE pipelines",
-        "MetricExpr": "DSB2MITE_SWITCHES.PENALTY_CYCLES / CLKS",
-        "MetricGroup": "DSBmiss;FetchLat;TopdownL3;tma_fetch_latency_group=
",
-        "MetricName": "tma_dsb_switches",
-        "PublicDescription": "This metric represents fraction of cycles th=
e CPU was stalled due to switches from DSB to MITE pipelines. The DSB (deco=
ded i-cache) is a Uop Cache where the front-end directly delivers Uops (mic=
ro operations) avoiding heavy x86 decoding. The DSB pipeline has shorter la=
tency and delivered higher bandwidth than the MITE (legacy instruction deco=
de pipeline). Switching between the two pipelines can cause penalties hence=
 this metric measures the exposed penalty.",
-        "ScaleUnit": "100%"
+        "BriefDescription": "Floating Point Operations Per Cycle",
+        "MetricExpr": "(FP_ARITH_INST_RETIRED.SCALAR_SINGLE + FP_ARITH_INS=
T_RETIRED.SCALAR_DOUBLE + 2 * FP_ARITH_INST_RETIRED.128B_PACKED_DOUBLE + 4 =
* (FP_ARITH_INST_RETIRED.128B_PACKED_SINGLE + FP_ARITH_INST_RETIRED.256B_PA=
CKED_DOUBLE) + 8 * FP_ARITH_INST_RETIRED.256B_PACKED_SINGLE) / CORE_CLKS",
+        "MetricGroup": "Flops;Ret",
+        "MetricName": "FLOPc"
     },
     {
-        "BriefDescription": "This metric represents fraction of cycles CPU=
 was stalled due to Length Changing Prefixes (LCPs)",
-        "MetricExpr": "ILD_STALL.LCP / CLKS",
-        "MetricGroup": "FetchLat;TopdownL3;tma_fetch_latency_group",
-        "MetricName": "tma_lcp",
-        "PublicDescription": "This metric represents fraction of cycles CP=
U was stalled due to Length Changing Prefixes (LCPs). Using proper compiler=
 flags or Intel Compiler by default will certainly avoid this. #Link: Optim=
ization Guide about LCP BKMs.",
-        "ScaleUnit": "100%"
+        "BriefDescription": "Actual per-core usage of the Floating Point n=
on-X87 execution units (regardless of precision or vector-width)",
+        "MetricExpr": "(FP_ARITH_INST_RETIRED.SCALAR_SINGLE + FP_ARITH_INS=
T_RETIRED.SCALAR_DOUBLE + (FP_ARITH_INST_RETIRED.128B_PACKED_DOUBLE + FP_AR=
ITH_INST_RETIRED.128B_PACKED_SINGLE + FP_ARITH_INST_RETIRED.256B_PACKED_DOU=
BLE + FP_ARITH_INST_RETIRED.256B_PACKED_SINGLE)) / (2 * CORE_CLKS)",
+        "MetricGroup": "Cor;Flops;HPC",
+        "MetricName": "FP_Arith_Utilization",
+        "PublicDescription": "Actual per-core usage of the Floating Point =
non-X87 execution units (regardless of precision or vector-width). Values >=
 1 are possible due to ([BDW+] Fused-Multiply Add (FMA) counting - common; =
[ADL+] use all of ADD/MUL/FMA in Scalar or 128/256-bit vectors - less commo=
n)."
     },
     {
-        "BriefDescription": "This metric estimates the fraction of cycles =
when the CPU was stalled due to switches of uop delivery to the Microcode S=
equencer (MS)",
-        "MetricExpr": "2 * IDQ.MS_SWITCHES / CLKS",
-        "MetricGroup": "FetchLat;MicroSeq;TopdownL3;tma_fetch_latency_grou=
p",
-        "MetricName": "tma_ms_switches",
-        "PublicDescription": "This metric estimates the fraction of cycles=
 when the CPU was stalled due to switches of uop delivery to the Microcode =
Sequencer (MS). Commonly used instructions are optimized for delivery by th=
e DSB (decoded i-cache) or MITE (legacy instruction decode) pipelines. Cert=
ain operations cannot be handled natively by the execution pipeline; and mu=
st be performed by microcode (small programs injected into the execution st=
ream). Switching to the MS too often can negatively impact performance. The=
 MS is designated to deliver long uop flows required by CISC instructions l=
ike CPUID; or uncommon conditions like Floating Point Assists when dealing =
with Denormals. Sample with: IDQ.MS_SWITCHES",
-        "ScaleUnit": "100%"
+        "BriefDescription": "Instruction-Level-Parallelism (average number=
 of uops executed when there is execution) per-core",
+        "MetricExpr": "UOPS_EXECUTED.THREAD / (cpu@UOPS_EXECUTED.CORE\\,cm=
ask\\=3D1@ / 2 if #SMT_on else UOPS_EXECUTED.CYCLES_GE_1_UOP_EXEC)",
+        "MetricGroup": "Backend;Cor;Pipeline;PortsUtil",
+        "MetricName": "ILP"
     },
     {
-        "BriefDescription": "This metric represents fraction of slots the =
CPU was stalled due to Frontend bandwidth issues",
-        "MetricExpr": "tma_frontend_bound - tma_fetch_latency",
-        "MetricGroup": "FetchBW;Frontend;TopdownL2;tma_L2_group;tma_fronte=
nd_bound_group",
-        "MetricName": "tma_fetch_bandwidth",
-        "PublicDescription": "This metric represents fraction of slots the=
 CPU was stalled due to Frontend bandwidth issues.  For example; inefficien=
cies at the instruction decoders; or restrictions for caching in the DSB (d=
ecoded uops cache) are categorized under Fetch Bandwidth. In such cases; th=
e Frontend typically delivers suboptimal amount of uops to the Backend.",
-        "ScaleUnit": "100%"
+        "BriefDescription": "Core actual clocks when any Logical Processor=
 is active on the Physical Core",
+        "MetricExpr": "(CPU_CLK_UNHALTED.THREAD / 2 * (1 + CPU_CLK_UNHALTE=
D.ONE_THREAD_ACTIVE / CPU_CLK_UNHALTED.REF_XCLK) if #core_wide < 1 else (CP=
U_CLK_UNHALTED.THREAD_ANY / 2 if #SMT_on else CLKS))",
+        "MetricGroup": "SMT",
+        "MetricName": "CORE_CLKS"
     },
     {
-        "BriefDescription": "This metric represents Core fraction of cycle=
s in which CPU was likely limited due to the MITE pipeline (the legacy deco=
de pipeline)",
-        "MetricExpr": "(IDQ.ALL_MITE_CYCLES_ANY_UOPS - IDQ.ALL_MITE_CYCLES=
_4_UOPS) / CORE_CLKS / 2",
-        "MetricGroup": "DSBmiss;FetchBW;TopdownL3;tma_fetch_bandwidth_grou=
p",
-        "MetricName": "tma_mite",
-        "PublicDescription": "This metric represents Core fraction of cycl=
es in which CPU was likely limited due to the MITE pipeline (the legacy dec=
ode pipeline). This pipeline is used for code that was not pre-cached in th=
e DSB or LSD. For example; inefficiencies due to asymmetric decoders; use o=
f long immediate or LCP can manifest as MITE fetch bandwidth bottleneck.",
-        "ScaleUnit": "100%"
+        "BriefDescription": "Instructions per Load (lower number means hig=
her occurrence rate)",
+        "MetricExpr": "INST_RETIRED.ANY / MEM_UOPS_RETIRED.ALL_LOADS",
+        "MetricGroup": "InsType",
+        "MetricName": "IpLoad"
     },
     {
-        "BriefDescription": "This metric represents Core fraction of cycle=
s in which CPU was likely limited due to DSB (decoded uop cache) fetch pipe=
line",
-        "MetricExpr": "(IDQ.ALL_DSB_CYCLES_ANY_UOPS - IDQ.ALL_DSB_CYCLES_4=
_UOPS) / CORE_CLKS / 2",
-        "MetricGroup": "DSB;FetchBW;TopdownL3;tma_fetch_bandwidth_group",
-        "MetricName": "tma_dsb",
-        "PublicDescription": "This metric represents Core fraction of cycl=
es in which CPU was likely limited due to DSB (decoded uop cache) fetch pip=
eline.  For example; inefficient utilization of the DSB cache structure or =
bank conflict when reading from it; are categorized here.",
-        "ScaleUnit": "100%"
+        "BriefDescription": "Instructions per Store (lower number means hi=
gher occurrence rate)",
+        "MetricExpr": "INST_RETIRED.ANY / MEM_UOPS_RETIRED.ALL_STORES",
+        "MetricGroup": "InsType",
+        "MetricName": "IpStore"
     },
     {
-        "BriefDescription": "This category represents fraction of slots wa=
sted due to incorrect speculations",
-        "MetricExpr": "(UOPS_ISSUED.ANY - UOPS_RETIRED.RETIRE_SLOTS + 4 * =
((INT_MISC.RECOVERY_CYCLES_ANY / 2) if #SMT_on else INT_MISC.RECOVERY_CYCLE=
S)) / SLOTS",
-        "MetricGroup": "TopdownL1;tma_L1_group",
-        "MetricName": "tma_bad_speculation",
-        "PublicDescription": "This category represents fraction of slots w=
asted due to incorrect speculations. This include slots used to issue uops =
that do not eventually get retired and slots for which the issue-pipeline w=
as blocked due to recovery from earlier incorrect speculation. For example;=
 wasted work due to miss-predicted branches are categorized under Bad Specu=
lation category. Incorrect data speculation followed by Memory Ordering Nuk=
es is another example.",
-        "ScaleUnit": "100%"
+        "BriefDescription": "Instructions per Branch (lower number means h=
igher occurrence rate)",
+        "MetricExpr": "INST_RETIRED.ANY / BR_INST_RETIRED.ALL_BRANCHES",
+        "MetricGroup": "Branches;Fed;InsType",
+        "MetricName": "IpBranch"
     },
     {
-        "BriefDescription": "This metric represents fraction of slots the =
CPU has wasted due to Branch Misprediction",
-        "MetricExpr": "(BR_MISP_RETIRED.ALL_BRANCHES / (BR_MISP_RETIRED.AL=
L_BRANCHES + MACHINE_CLEARS.COUNT)) * tma_bad_speculation",
-        "MetricGroup": "BadSpec;BrMispredicts;TopdownL2;tma_L2_group;tma_b=
ad_speculation_group",
-        "MetricName": "tma_branch_mispredicts",
-        "PublicDescription": "This metric represents fraction of slots the=
 CPU has wasted due to Branch Misprediction.  These slots are either wasted=
 by uops fetched from an incorrectly speculated program path; or stalls whe=
n the out-of-order part of the machine needs to recover its state from a sp=
eculative path. Sample with: BR_MISP_RETIRED.ALL_BRANCHES",
-        "ScaleUnit": "100%"
+        "BriefDescription": "Instructions per (near) call (lower number me=
ans higher occurrence rate)",
+        "MetricExpr": "INST_RETIRED.ANY / BR_INST_RETIRED.NEAR_CALL",
+        "MetricGroup": "Branches;Fed;PGO",
+        "MetricName": "IpCall"
     },
     {
-        "BriefDescription": "This metric represents fraction of slots the =
CPU has wasted due to Machine Clears",
-        "MetricExpr": "tma_bad_speculation - tma_branch_mispredicts",
-        "MetricGroup": "BadSpec;MachineClears;TopdownL2;tma_L2_group;tma_b=
ad_speculation_group",
-        "MetricName": "tma_machine_clears",
-        "PublicDescription": "This metric represents fraction of slots the=
 CPU has wasted due to Machine Clears.  These slots are either wasted by uo=
ps fetched prior to the clear; or stalls the out-of-order portion of the ma=
chine needs to recover its state after the clear. For example; this can hap=
pen due to memory ordering Nukes (e.g. Memory Disambiguation) or Self-Modif=
ying-Code (SMC) nukes. Sample with: MACHINE_CLEARS.COUNT",
-        "ScaleUnit": "100%"
+        "BriefDescription": "Instruction per taken branch",
+        "MetricExpr": "INST_RETIRED.ANY / BR_INST_RETIRED.NEAR_TAKEN",
+        "MetricGroup": "Branches;Fed;FetchBW;Frontend;PGO",
+        "MetricName": "IpTB"
     },
     {
-        "BriefDescription": "This category represents fraction of slots wh=
ere no uops are being delivered due to a lack of required resources for acc=
epting new uops in the Backend",
-        "MetricExpr": "1 - (tma_frontend_bound + tma_bad_speculation + tma=
_retiring)",
-        "MetricGroup": "TopdownL1;tma_L1_group",
-        "MetricName": "tma_backend_bound",
-        "PublicDescription": "This category represents fraction of slots w=
here no uops are being delivered due to a lack of required resources for ac=
cepting new uops in the Backend. Backend is the portion of the processor co=
re where the out-of-order scheduler dispatches ready uops into their respec=
tive execution units; and once completed these uops get retired according t=
o program order. For example; stalls due to data-cache misses or stalls due=
 to the divider unit being overloaded are both categorized under Backend Bo=
und. Backend Bound is further divided into two main categories: Memory Boun=
d and Core Bound.",
-        "ScaleUnit": "100%"
+        "BriefDescription": "Branch instructions per taken branch. ",
+        "MetricExpr": "BR_INST_RETIRED.ALL_BRANCHES / BR_INST_RETIRED.NEAR=
_TAKEN",
+        "MetricGroup": "Branches;Fed;PGO",
+        "MetricName": "BpTkBranch"
     },
     {
-        "BriefDescription": "This metric represents fraction of slots the =
Memory subsystem within the Backend was a bottleneck",
-        "MetricExpr": "((CYCLE_ACTIVITY.STALLS_MEM_ANY + RESOURCE_STALLS.S=
B) / (CYCLE_ACTIVITY.STALLS_TOTAL + UOPS_EXECUTED.CYCLES_GE_1_UOP_EXEC - UO=
PS_EXECUTED.CYCLES_GE_3_UOPS_EXEC if (IPC > 1.8) else UOPS_EXECUTED.CYCLES_=
GE_2_UOPS_EXEC - RS_EVENTS.EMPTY_CYCLES if (tma_fetch_latency > 0.1) else R=
ESOURCE_STALLS.SB)) * tma_backend_bound",
-        "MetricGroup": "Backend;TopdownL2;tma_L2_group;tma_backend_bound_g=
roup",
-        "MetricName": "tma_memory_bound",
-        "PublicDescription": "This metric represents fraction of slots the=
 Memory subsystem within the Backend was a bottleneck.  Memory Bound estima=
tes fraction of slots where pipeline is likely stalled due to demand load o=
r store instructions. This accounts mainly for (1) non-completed in-flight =
memory demand loads which coincides with execution units starvation; in add=
ition to (2) cases where stores could impose backpressure on the pipeline w=
hen many of them get buffered at the same time (less common out of the two)=
.",
-        "ScaleUnit": "100%"
+        "BriefDescription": "Instructions per Floating Point (FP) Operatio=
n (lower number means higher occurrence rate)",
+        "MetricExpr": "INST_RETIRED.ANY / (FP_ARITH_INST_RETIRED.SCALAR_SI=
NGLE + FP_ARITH_INST_RETIRED.SCALAR_DOUBLE + 2 * FP_ARITH_INST_RETIRED.128B=
_PACKED_DOUBLE + 4 * (FP_ARITH_INST_RETIRED.128B_PACKED_SINGLE + FP_ARITH_I=
NST_RETIRED.256B_PACKED_DOUBLE) + 8 * FP_ARITH_INST_RETIRED.256B_PACKED_SIN=
GLE)",
+        "MetricGroup": "Flops;InsType",
+        "MetricName": "IpFLOP"
     },
     {
-        "BriefDescription": "This metric estimates how often the CPU was s=
talled without loads missing the L1 data cache",
-        "MetricExpr": "max((CYCLE_ACTIVITY.STALLS_MEM_ANY - CYCLE_ACTIVITY=
.STALLS_L1D_MISS) / CLKS, 0)",
-        "MetricGroup": "CacheMisses;MemoryBound;TmaL3mem;TopdownL3;tma_mem=
ory_bound_group",
-        "MetricName": "tma_l1_bound",
-        "PublicDescription": "This metric estimates how often the CPU was =
stalled without loads missing the L1 data cache.  The L1 data cache typical=
ly has the shortest latency.  However; in certain cases like loads blocked =
on older stores; a load might suffer due to high latency even though it is =
being satisfied by the L1. Another example is loads who miss in the TLB. Th=
ese cases are characterized by execution unit stalls; while some non-comple=
ted demand load lives in the machine without having that demand load missin=
g the L1 cache. Sample with: MEM_LOAD_UOPS_RETIRED.L1_HIT_PS;MEM_LOAD_UOPS_=
RETIRED.HIT_LFB_PS",
-        "ScaleUnit": "100%"
+        "BriefDescription": "Instructions per FP Arithmetic instruction (l=
ower number means higher occurrence rate)",
+        "MetricExpr": "INST_RETIRED.ANY / (FP_ARITH_INST_RETIRED.SCALAR_SI=
NGLE + FP_ARITH_INST_RETIRED.SCALAR_DOUBLE + (FP_ARITH_INST_RETIRED.128B_PA=
CKED_DOUBLE + FP_ARITH_INST_RETIRED.128B_PACKED_SINGLE + FP_ARITH_INST_RETI=
RED.256B_PACKED_DOUBLE + FP_ARITH_INST_RETIRED.256B_PACKED_SINGLE))",
+        "MetricGroup": "Flops;InsType",
+        "MetricName": "IpArith",
+        "PublicDescription": "Instructions per FP Arithmetic instruction (=
lower number means higher occurrence rate). May undercount due to FMA doubl=
e counting. Approximated prior to BDW."
     },
     {
-        "BriefDescription": "This metric roughly estimates the fraction of=
 cycles where the Data TLB (DTLB) was missed by load accesses",
-        "MetricExpr": "(8 * DTLB_LOAD_MISSES.STLB_HIT + cpu@DTLB_LOAD_MISS=
ES.WALK_DURATION\\,cmask\\=3D1@ + 7 * DTLB_LOAD_MISSES.WALK_COMPLETED) / CL=
KS",
-        "MetricGroup": "MemoryTLB;TopdownL4;tma_l1_bound_group",
-        "MetricName": "tma_dtlb_load",
-        "PublicDescription": "This metric roughly estimates the fraction o=
f cycles where the Data TLB (DTLB) was missed by load accesses. TLBs (Trans=
lation Look-aside Buffers) are processor caches for recently used entries o=
ut of the Page Tables that are used to map virtual- to physical-addresses b=
y the operating system. This metric approximates the potential delay of dem=
and loads missing the first-level data TLB (assuming worst case scenario wi=
th back to back misses to different pages). This includes hitting in the se=
cond-level TLB (STLB) as well as performing a hardware page walk on an STLB=
 miss. Sample with: MEM_UOPS_RETIRED.STLB_MISS_LOADS_PS",
-        "ScaleUnit": "100%"
+        "BriefDescription": "Instructions per FP Arithmetic Scalar Single-=
Precision instruction (lower number means higher occurrence rate)",
+        "MetricExpr": "INST_RETIRED.ANY / FP_ARITH_INST_RETIRED.SCALAR_SIN=
GLE",
+        "MetricGroup": "Flops;FpScalar;InsType",
+        "MetricName": "IpArith_Scalar_SP",
+        "PublicDescription": "Instructions per FP Arithmetic Scalar Single=
-Precision instruction (lower number means higher occurrence rate). May und=
ercount due to FMA double counting."
     },
     {
-        "BriefDescription": "This metric roughly estimates fraction of cyc=
les when the memory subsystem had loads blocked since they could not forwar=
d data from earlier (in program order) overlapping stores",
-        "MetricExpr": "13 * LD_BLOCKS.STORE_FORWARD / CLKS",
-        "MetricGroup": "TopdownL4;tma_l1_bound_group",
-        "MetricName": "tma_store_fwd_blk",
-        "PublicDescription": "This metric roughly estimates fraction of cy=
cles when the memory subsystem had loads blocked since they could not forwa=
rd data from earlier (in program order) overlapping stores. To streamline m=
emory operations in the pipeline; a load can avoid waiting for memory if a =
prior in-flight store is writing the data that the load wants to read (stor=
e forwarding process). However; in some cases the load may be blocked for a=
 significant time pending the store forward. For example; when the prior st=
ore is writing a smaller region than the load is reading.",
-        "ScaleUnit": "100%"
+        "BriefDescription": "Instructions per FP Arithmetic Scalar Double-=
Precision instruction (lower number means higher occurrence rate)",
+        "MetricExpr": "INST_RETIRED.ANY / FP_ARITH_INST_RETIRED.SCALAR_DOU=
BLE",
+        "MetricGroup": "Flops;FpScalar;InsType",
+        "MetricName": "IpArith_Scalar_DP",
+        "PublicDescription": "Instructions per FP Arithmetic Scalar Double=
-Precision instruction (lower number means higher occurrence rate). May und=
ercount due to FMA double counting."
     },
     {
-        "BriefDescription": "This metric represents fraction of cycles the=
 CPU spent handling cache misses due to lock operations",
-        "MetricExpr": "(MEM_UOPS_RETIRED.LOCK_LOADS / MEM_UOPS_RETIRED.ALL=
_STORES) * min(CPU_CLK_UNHALTED.THREAD, OFFCORE_REQUESTS_OUTSTANDING.CYCLES=
_WITH_DEMAND_RFO) / CLKS",
-        "MetricGroup": "Offcore;TopdownL4;tma_l1_bound_group",
-        "MetricName": "tma_lock_latency",
-        "PublicDescription": "This metric represents fraction of cycles th=
e CPU spent handling cache misses due to lock operations. Due to the microa=
rchitecture handling of locks; they are classified as L1_Bound regardless o=
f what memory source satisfied them. Sample with: MEM_UOPS_RETIRED.LOCK_LOA=
DS_PS",
-        "ScaleUnit": "100%"
+        "BriefDescription": "Instructions per FP Arithmetic AVX/SSE 128-bi=
t instruction (lower number means higher occurrence rate)",
+        "MetricExpr": "INST_RETIRED.ANY / (FP_ARITH_INST_RETIRED.128B_PACK=
ED_DOUBLE + FP_ARITH_INST_RETIRED.128B_PACKED_SINGLE)",
+        "MetricGroup": "Flops;FpVector;InsType",
+        "MetricName": "IpArith_AVX128",
+        "PublicDescription": "Instructions per FP Arithmetic AVX/SSE 128-b=
it instruction (lower number means higher occurrence rate). May undercount =
due to FMA double counting."
     },
     {
-        "BriefDescription": "This metric estimates fraction of cycles hand=
ling memory load split accesses - load that cross 64-byte cache line bounda=
ry",
-        "MetricExpr": "Load_Miss_Real_Latency * LD_BLOCKS.NO_SR / CLKS",
-        "MetricGroup": "TopdownL4;tma_l1_bound_group",
-        "MetricName": "tma_split_loads",
-        "PublicDescription": "This metric estimates fraction of cycles han=
dling memory load split accesses - load that cross 64-byte cache line bound=
ary.  Sample with: MEM_UOPS_RETIRED.SPLIT_LOADS_PS",
-        "ScaleUnit": "100%"
+        "BriefDescription": "Instructions per FP Arithmetic AVX* 256-bit i=
nstruction (lower number means higher occurrence rate)",
+        "MetricExpr": "INST_RETIRED.ANY / (FP_ARITH_INST_RETIRED.256B_PACK=
ED_DOUBLE + FP_ARITH_INST_RETIRED.256B_PACKED_SINGLE)",
+        "MetricGroup": "Flops;FpVector;InsType",
+        "MetricName": "IpArith_AVX256",
+        "PublicDescription": "Instructions per FP Arithmetic AVX* 256-bit =
instruction (lower number means higher occurrence rate). May undercount due=
 to FMA double counting."
     },
     {
-        "BriefDescription": "This metric estimates how often memory load a=
ccesses were aliased by preceding stores (in program order) with a 4K addre=
ss offset",
-        "MetricExpr": "LD_BLOCKS_PARTIAL.ADDRESS_ALIAS / CLKS",
-        "MetricGroup": "TopdownL4;tma_l1_bound_group",
-        "MetricName": "tma_4k_aliasing",
-        "PublicDescription": "This metric estimates how often memory load =
accesses were aliased by preceding stores (in program order) with a 4K addr=
ess offset. False match is possible; which incur a few cycles load re-issue=
. However; the short re-issue duration is often hidden by the out-of-order =
core and HW optimizations; hence a user may safely ignore a high value of t=
his metric unless it manages to propagate up into parent nodes of the hiera=
rchy (e.g. to L1_Bound).",
-        "ScaleUnit": "100%"
+        "BriefDescription": "Total number of retired Instructions Sample w=
ith: INST_RETIRED.PREC_DIST",
+        "MetricExpr": "INST_RETIRED.ANY",
+        "MetricGroup": "Summary;tma_L1_group",
+        "MetricName": "Instructions"
     },
     {
-        "BriefDescription": "This metric does a *rough estimation* of how =
often L1D Fill Buffer unavailability limited additional L1D miss memory acc=
ess requests to proceed",
-        "MetricExpr": "Load_Miss_Real_Latency * cpu@L1D_PEND_MISS.FB_FULL\=
\,cmask\\=3D1@ / CLKS",
-        "MetricGroup": "MemoryBW;TopdownL4;tma_l1_bound_group",
-        "MetricName": "tma_fb_full",
-        "PublicDescription": "This metric does a *rough estimation* of how=
 often L1D Fill Buffer unavailability limited additional L1D miss memory ac=
cess requests to proceed. The higher the metric value; the deeper the memor=
y hierarchy level the misses are satisfied from (metric values >1 are valid=
). Often it hints on approaching bandwidth limits (to L2 cache; L3 cache or=
 external memory).",
-        "ScaleUnit": "100%"
+        "BriefDescription": "Average number of Uops retired in cycles wher=
e at least one uop has retired.",
+        "MetricExpr": "UOPS_RETIRED.RETIRE_SLOTS / cpu@UOPS_RETIRED.RETIRE=
_SLOTS\\,cmask\\=3D1@",
+        "MetricGroup": "Pipeline;Ret",
+        "MetricName": "Retire"
     },
     {
-        "BriefDescription": "This metric estimates how often the CPU was s=
talled due to L2 cache accesses by loads",
-        "MetricExpr": "(CYCLE_ACTIVITY.STALLS_L1D_MISS - CYCLE_ACTIVITY.ST=
ALLS_L2_MISS) / CLKS",
-        "MetricGroup": "CacheMisses;MemoryBound;TmaL3mem;TopdownL3;tma_mem=
ory_bound_group",
-        "MetricName": "tma_l2_bound",
-        "PublicDescription": "This metric estimates how often the CPU was =
stalled due to L2 cache accesses by loads.  Avoiding cache misses (i.e. L1 =
misses/L2 hits) can improve the latency and increase performance. Sample wi=
th: MEM_LOAD_UOPS_RETIRED.L2_HIT_PS",
-        "ScaleUnit": "100%"
+        "BriefDescription": "",
+        "MetricExpr": "UOPS_EXECUTED.THREAD / cpu@UOPS_EXECUTED.THREAD\\,c=
mask\\=3D1@",
+        "MetricGroup": "Cor;Pipeline;PortsUtil;SMT",
+        "MetricName": "Execute"
     },
     {
-        "BriefDescription": "This metric estimates how often the CPU was s=
talled due to loads accesses to L3 cache or contended with a sibling Core",
-        "MetricExpr": "(MEM_LOAD_UOPS_RETIRED.L3_HIT / (MEM_LOAD_UOPS_RETI=
RED.L3_HIT + 7 * MEM_LOAD_UOPS_RETIRED.L3_MISS)) * CYCLE_ACTIVITY.STALLS_L2=
_MISS / CLKS",
-        "MetricGroup": "CacheMisses;MemoryBound;TmaL3mem;TopdownL3;tma_mem=
ory_bound_group",
-        "MetricName": "tma_l3_bound",
-        "PublicDescription": "This metric estimates how often the CPU was =
stalled due to loads accesses to L3 cache or contended with a sibling Core.=
  Avoiding cache misses (i.e. L2 misses/L3 hits) can improve the latency an=
d increase performance. Sample with: MEM_LOAD_UOPS_RETIRED.L3_HIT_PS",
-        "ScaleUnit": "100%"
+        "BriefDescription": "Fraction of Uops delivered by the DSB (aka De=
coded ICache; or Uop Cache)",
+        "MetricExpr": "IDQ.DSB_UOPS / (IDQ.DSB_UOPS + LSD.UOPS + IDQ.MITE_=
UOPS + IDQ.MS_UOPS)",
+        "MetricGroup": "DSB;Fed;FetchBW",
+        "MetricName": "DSB_Coverage"
     },
     {
-        "BriefDescription": "This metric estimates fraction of cycles whil=
e the memory subsystem was handling synchronizations due to contested acces=
ses",
-        "MetricExpr": "(60 * (MEM_LOAD_UOPS_L3_HIT_RETIRED.XSNP_HITM * (1 =
+ mem_load_uops_retired.hit_lfb / ((MEM_LOAD_UOPS_RETIRED.L2_HIT + MEM_LOAD=
_UOPS_RETIRED.L3_HIT + MEM_LOAD_UOPS_L3_HIT_RETIRED.XSNP_HIT + MEM_LOAD_UOP=
S_L3_HIT_RETIRED.XSNP_HITM + MEM_LOAD_UOPS_L3_HIT_RETIRED.XSNP_MISS) + MEM_=
LOAD_UOPS_L3_MISS_RETIRED.LOCAL_DRAM + MEM_LOAD_UOPS_L3_MISS_RETIRED.REMOTE=
_DRAM + MEM_LOAD_UOPS_L3_MISS_RETIRED.REMOTE_HITM + MEM_LOAD_UOPS_L3_MISS_R=
ETIRED.REMOTE_FWD))) + 43 * (MEM_LOAD_UOPS_L3_HIT_RETIRED.XSNP_MISS * (1 + =
mem_load_uops_retired.hit_lfb / ((MEM_LOAD_UOPS_RETIRED.L2_HIT + MEM_LOAD_U=
OPS_RETIRED.L3_HIT + MEM_LOAD_UOPS_L3_HIT_RETIRED.XSNP_HIT + MEM_LOAD_UOPS_=
L3_HIT_RETIRED.XSNP_HITM + MEM_LOAD_UOPS_L3_HIT_RETIRED.XSNP_MISS) + MEM_LO=
AD_UOPS_L3_MISS_RETIRED.LOCAL_DRAM + MEM_LOAD_UOPS_L3_MISS_RETIRED.REMOTE_D=
RAM + MEM_LOAD_UOPS_L3_MISS_RETIRED.REMOTE_HITM + MEM_LOAD_UOPS_L3_MISS_RET=
IRED.REMOTE_FWD)))) / CLKS",
-        "MetricGroup": "DataSharing;Offcore;Snoop;TopdownL4;tma_l3_bound_g=
roup",
-        "MetricName": "tma_contested_accesses",
-        "PublicDescription": "This metric estimates fraction of cycles whi=
le the memory subsystem was handling synchronizations due to contested acce=
sses. Contested accesses occur when data written by one Logical Processor a=
re read by another Logical Processor on a different Physical Core. Examples=
 of contested accesses include synchronizations such as locks; true data sh=
aring such as modified locked variables; and false sharing. Sample with: ME=
M_LOAD_L3_HIT_RETIRED.XSNP_HITM_PS;MEM_LOAD_L3_HIT_RETIRED.XSNP_MISS_PS",
-        "ScaleUnit": "100%"
+        "BriefDescription": "Number of Instructions per non-speculative Br=
anch Misprediction (JEClear) (lower number means higher occurrence rate)",
+        "MetricExpr": "INST_RETIRED.ANY / BR_MISP_RETIRED.ALL_BRANCHES",
+        "MetricGroup": "Bad;BadSpec;BrMispredicts",
+        "MetricName": "IpMispredict"
     },
     {
-        "BriefDescription": "This metric estimates fraction of cycles whil=
e the memory subsystem was handling synchronizations due to data-sharing ac=
cesses",
-        "MetricExpr": "43 * (MEM_LOAD_UOPS_L3_HIT_RETIRED.XSNP_HIT * (1 + =
mem_load_uops_retired.hit_lfb / ((MEM_LOAD_UOPS_RETIRED.L2_HIT + MEM_LOAD_U=
OPS_RETIRED.L3_HIT + MEM_LOAD_UOPS_L3_HIT_RETIRED.XSNP_HIT + MEM_LOAD_UOPS_=
L3_HIT_RETIRED.XSNP_HITM + MEM_LOAD_UOPS_L3_HIT_RETIRED.XSNP_MISS) + MEM_LO=
AD_UOPS_L3_MISS_RETIRED.LOCAL_DRAM + MEM_LOAD_UOPS_L3_MISS_RETIRED.REMOTE_D=
RAM + MEM_LOAD_UOPS_L3_MISS_RETIRED.REMOTE_HITM + MEM_LOAD_UOPS_L3_MISS_RET=
IRED.REMOTE_FWD))) / CLKS",
-        "MetricGroup": "Offcore;Snoop;TopdownL4;tma_l3_bound_group",
-        "MetricName": "tma_data_sharing",
-        "PublicDescription": "This metric estimates fraction of cycles whi=
le the memory subsystem was handling synchronizations due to data-sharing a=
ccesses. Data shared by multiple Logical Processors (even just read shared)=
 may cause increased access latency due to cache coherency. Excessive data =
sharing can drastically harm multithreaded performance. Sample with: MEM_LO=
AD_L3_HIT_RETIRED.XSNP_HIT_PS",
-        "ScaleUnit": "100%"
+        "BriefDescription": "Branch Misprediction Cost: Fraction of TMA sl=
ots wasted per non-speculative branch misprediction (retired JEClear)",
+        "MetricExpr": "(tma_branch_mispredicts + tma_fetch_latency * tma_m=
ispredicts_resteers / (tma_branch_resteers + tma_dsb_switches + tma_icache_=
misses + tma_itlb_misses + tma_lcp + tma_ms_switches)) * SLOTS / BR_MISP_RE=
TIRED.ALL_BRANCHES",
+        "MetricGroup": "Bad;BrMispredicts",
+        "MetricName": "Branch_Misprediction_Cost"
     },
     {
-        "BriefDescription": "This metric represents fraction of cycles wit=
h demand load accesses that hit the L3 cache under unloaded scenarios (poss=
ibly L3 latency limited)",
-        "MetricExpr": "41 * (MEM_LOAD_UOPS_RETIRED.L3_HIT * (1 + mem_load_=
uops_retired.hit_lfb / ((MEM_LOAD_UOPS_RETIRED.L2_HIT + MEM_LOAD_UOPS_RETIR=
ED.L3_HIT + MEM_LOAD_UOPS_L3_HIT_RETIRED.XSNP_HIT + MEM_LOAD_UOPS_L3_HIT_RE=
TIRED.XSNP_HITM + MEM_LOAD_UOPS_L3_HIT_RETIRED.XSNP_MISS) + MEM_LOAD_UOPS_L=
3_MISS_RETIRED.LOCAL_DRAM + MEM_LOAD_UOPS_L3_MISS_RETIRED.REMOTE_DRAM + MEM=
_LOAD_UOPS_L3_MISS_RETIRED.REMOTE_HITM + MEM_LOAD_UOPS_L3_MISS_RETIRED.REMO=
TE_FWD))) / CLKS",
-        "MetricGroup": "MemoryLat;TopdownL4;tma_l3_bound_group",
-        "MetricName": "tma_l3_hit_latency",
-        "PublicDescription": "This metric represents fraction of cycles wi=
th demand load accesses that hit the L3 cache under unloaded scenarios (pos=
sibly L3 latency limited).  Avoiding private cache misses (i.e. L2 misses/L=
3 hits) will improve the latency; reduce contention with sibling physical c=
ores and increase performance.  Note the value of this node may overlap wit=
h its siblings. Sample with: MEM_LOAD_UOPS_RETIRED.L3_HIT_PS",
-        "ScaleUnit": "100%"
+        "BriefDescription": "Actual Average Latency for L1 data-cache miss=
 demand load operations (in core cycles)",
+        "MetricExpr": "L1D_PEND_MISS.PENDING / (MEM_LOAD_UOPS_RETIRED.L1_M=
ISS + MEM_LOAD_UOPS_RETIRED.HIT_LFB)",
+        "MetricGroup": "Mem;MemoryBound;MemoryLat",
+        "MetricName": "Load_Miss_Real_Latency"
     },
     {
-        "BriefDescription": "This metric measures fraction of cycles where=
 the Super Queue (SQ) was full taking into account all request-types and bo=
th hardware SMT threads (Logical Processors)",
-        "MetricExpr": "((OFFCORE_REQUESTS_BUFFER.SQ_FULL / 2) if #SMT_on e=
lse OFFCORE_REQUESTS_BUFFER.SQ_FULL) / CORE_CLKS",
-        "MetricGroup": "MemoryBW;Offcore;TopdownL4;tma_l3_bound_group",
-        "MetricName": "tma_sq_full",
-        "PublicDescription": "This metric measures fraction of cycles wher=
e the Super Queue (SQ) was full taking into account all request-types and b=
oth hardware SMT threads (Logical Processors). The Super Queue is used for =
requests to access the L2 cache or to go out to the Uncore.",
-        "ScaleUnit": "100%"
+        "BriefDescription": "Memory-Level-Parallelism (average number of L=
1 miss demand load when there is at least one such miss. Per-Logical Proces=
sor)",
+        "MetricExpr": "L1D_PEND_MISS.PENDING / L1D_PEND_MISS.PENDING_CYCLE=
S",
+        "MetricGroup": "Mem;MemoryBW;MemoryBound",
+        "MetricName": "MLP"
     },
     {
-        "BriefDescription": "This metric estimates how often the CPU was s=
talled on accesses to external memory (DRAM) by loads",
-        "MetricExpr": "(1 - (MEM_LOAD_UOPS_RETIRED.L3_HIT / (MEM_LOAD_UOPS=
_RETIRED.L3_HIT + 7 * MEM_LOAD_UOPS_RETIRED.L3_MISS))) * CYCLE_ACTIVITY.STA=
LLS_L2_MISS / CLKS",
-        "MetricGroup": "MemoryBound;TmaL3mem;TopdownL3;tma_memory_bound_gr=
oup",
-        "MetricName": "tma_dram_bound",
-        "PublicDescription": "This metric estimates how often the CPU was =
stalled on accesses to external memory (DRAM) by loads. Better caching can =
improve the latency and increase performance. Sample with: MEM_LOAD_UOPS_RE=
TIRED.L3_MISS_PS",
-        "ScaleUnit": "100%"
+        "BriefDescription": "L1 cache true misses per kilo instruction for=
 retired demand loads",
+        "MetricExpr": "1e3 * MEM_LOAD_UOPS_RETIRED.L1_MISS / INST_RETIRED.=
ANY",
+        "MetricGroup": "CacheMisses;Mem",
+        "MetricName": "L1MPKI"
     },
     {
-        "BriefDescription": "This metric estimates fraction of cycles wher=
e the core's performance was likely hurt due to approaching bandwidth limit=
s of external memory (DRAM)",
-        "MetricExpr": "min(CPU_CLK_UNHALTED.THREAD, cpu@OFFCORE_REQUESTS_O=
UTSTANDING.ALL_DATA_RD\\,cmask\\=3D4@) / CLKS",
-        "MetricGroup": "MemoryBW;Offcore;TopdownL4;tma_dram_bound_group",
-        "MetricName": "tma_mem_bandwidth",
-        "PublicDescription": "This metric estimates fraction of cycles whe=
re the core's performance was likely hurt due to approaching bandwidth limi=
ts of external memory (DRAM).  The underlying heuristic assumes that a simi=
lar off-core traffic is generated by all IA cores. This metric does not agg=
regate non-data-read requests by this logical processor; requests from othe=
r IA Logical Processors/Physical Cores/sockets; or other non-IA devices lik=
e GPU; hence the maximum external memory bandwidth limits may or may not be=
 approached when this metric is flagged (see Uncore counters for that).",
-        "ScaleUnit": "100%"
+        "BriefDescription": "L2 cache true misses per kilo instruction for=
 retired demand loads",
+        "MetricExpr": "1e3 * MEM_LOAD_UOPS_RETIRED.L2_MISS / INST_RETIRED.=
ANY",
+        "MetricGroup": "Backend;CacheMisses;Mem",
+        "MetricName": "L2MPKI"
     },
     {
-        "BriefDescription": "This metric estimates fraction of cycles wher=
e the performance was likely hurt due to latency from external memory (DRAM=
)",
-        "MetricExpr": "min(CPU_CLK_UNHALTED.THREAD, OFFCORE_REQUESTS_OUTST=
ANDING.CYCLES_WITH_DATA_RD) / CLKS - tma_mem_bandwidth",
-        "MetricGroup": "MemoryLat;Offcore;TopdownL4;tma_dram_bound_group",
-        "MetricName": "tma_mem_latency",
-        "PublicDescription": "This metric estimates fraction of cycles whe=
re the performance was likely hurt due to latency from external memory (DRA=
M).  This metric does not aggregate requests from other Logical Processors/=
Physical Cores/sockets (see Uncore counters for that).",
-        "ScaleUnit": "100%"
+        "BriefDescription": "L2 cache ([RKL+] true) misses per kilo instru=
ction for all request types (including speculative)",
+        "MetricExpr": "1e3 * L2_RQSTS.MISS / INST_RETIRED.ANY",
+        "MetricGroup": "CacheMisses;Mem;Offcore",
+        "MetricName": "L2MPKI_All"
     },
     {
-        "BriefDescription": "This metric estimates fraction of cycles whil=
e the memory subsystem was handling loads from local memory",
-        "MetricExpr": "200 * (MEM_LOAD_UOPS_L3_MISS_RETIRED.LOCAL_DRAM * (=
1 + mem_load_uops_retired.hit_lfb / ((MEM_LOAD_UOPS_RETIRED.L2_HIT + MEM_LO=
AD_UOPS_RETIRED.L3_HIT + MEM_LOAD_UOPS_L3_HIT_RETIRED.XSNP_HIT + MEM_LOAD_U=
OPS_L3_HIT_RETIRED.XSNP_HITM + MEM_LOAD_UOPS_L3_HIT_RETIRED.XSNP_MISS) + ME=
M_LOAD_UOPS_L3_MISS_RETIRED.LOCAL_DRAM + MEM_LOAD_UOPS_L3_MISS_RETIRED.REMO=
TE_DRAM + MEM_LOAD_UOPS_L3_MISS_RETIRED.REMOTE_HITM + MEM_LOAD_UOPS_L3_MISS=
_RETIRED.REMOTE_FWD))) / CLKS",
-        "MetricGroup": "Server;TopdownL5;tma_mem_latency_group",
-        "MetricName": "tma_local_dram",
-        "PublicDescription": "This metric estimates fraction of cycles whi=
le the memory subsystem was handling loads from local memory. Caching will =
improve the latency and increase performance. Sample with: MEM_LOAD_UOPS_L3=
_MISS_RETIRED.LOCAL_DRAM_PS",
-        "ScaleUnit": "100%"
+        "BriefDescription": "L2 cache ([RKL+] true) misses per kilo instru=
ction for all demand loads  (including speculative)",
+        "MetricExpr": "1e3 * L2_RQSTS.DEMAND_DATA_RD_MISS / INST_RETIRED.A=
NY",
+        "MetricGroup": "CacheMisses;Mem",
+        "MetricName": "L2MPKI_Load"
     },
     {
-        "BriefDescription": "This metric estimates fraction of cycles whil=
e the memory subsystem was handling loads from remote memory",
-        "MetricExpr": "310 * (MEM_LOAD_UOPS_L3_MISS_RETIRED.REMOTE_DRAM * =
(1 + mem_load_uops_retired.hit_lfb / ((MEM_LOAD_UOPS_RETIRED.L2_HIT + MEM_L=
OAD_UOPS_RETIRED.L3_HIT + MEM_LOAD_UOPS_L3_HIT_RETIRED.XSNP_HIT + MEM_LOAD_=
UOPS_L3_HIT_RETIRED.XSNP_HITM + MEM_LOAD_UOPS_L3_HIT_RETIRED.XSNP_MISS) + M=
EM_LOAD_UOPS_L3_MISS_RETIRED.LOCAL_DRAM + MEM_LOAD_UOPS_L3_MISS_RETIRED.REM=
OTE_DRAM + MEM_LOAD_UOPS_L3_MISS_RETIRED.REMOTE_HITM + MEM_LOAD_UOPS_L3_MIS=
S_RETIRED.REMOTE_FWD))) / CLKS",
-        "MetricGroup": "Server;Snoop;TopdownL5;tma_mem_latency_group",
-        "MetricName": "tma_remote_dram",
-        "PublicDescription": "This metric estimates fraction of cycles whi=
le the memory subsystem was handling loads from remote memory. This is caus=
ed often due to non-optimal NUMA allocations. #link to NUMA article Sample =
with: MEM_LOAD_UOPS_L3_MISS_RETIRED.REMOTE_DRAM_PS",
-        "ScaleUnit": "100%"
+        "BriefDescription": "L2 cache hits per kilo instruction for all re=
quest types (including speculative)",
+        "MetricExpr": "1e3 * (L2_RQSTS.REFERENCES - L2_RQSTS.MISS) / INST_=
RETIRED.ANY",
+        "MetricGroup": "CacheMisses;Mem",
+        "MetricName": "L2HPKI_All"
     },
     {
-        "BriefDescription": "This metric estimates fraction of cycles whil=
e the memory subsystem was handling loads from remote cache in other socket=
s including synchronizations issues",
-        "MetricExpr": "(200 * (MEM_LOAD_UOPS_L3_MISS_RETIRED.REMOTE_HITM *=
 (1 + mem_load_uops_retired.hit_lfb / ((MEM_LOAD_UOPS_RETIRED.L2_HIT + MEM_=
LOAD_UOPS_RETIRED.L3_HIT + MEM_LOAD_UOPS_L3_HIT_RETIRED.XSNP_HIT + MEM_LOAD=
_UOPS_L3_HIT_RETIRED.XSNP_HITM + MEM_LOAD_UOPS_L3_HIT_RETIRED.XSNP_MISS) + =
MEM_LOAD_UOPS_L3_MISS_RETIRED.LOCAL_DRAM + MEM_LOAD_UOPS_L3_MISS_RETIRED.RE=
MOTE_DRAM + MEM_LOAD_UOPS_L3_MISS_RETIRED.REMOTE_HITM + MEM_LOAD_UOPS_L3_MI=
SS_RETIRED.REMOTE_FWD))) + 180 * (MEM_LOAD_UOPS_L3_MISS_RETIRED.REMOTE_FWD =
* (1 + mem_load_uops_retired.hit_lfb / ((MEM_LOAD_UOPS_RETIRED.L2_HIT + MEM=
_LOAD_UOPS_RETIRED.L3_HIT + MEM_LOAD_UOPS_L3_HIT_RETIRED.XSNP_HIT + MEM_LOA=
D_UOPS_L3_HIT_RETIRED.XSNP_HITM + MEM_LOAD_UOPS_L3_HIT_RETIRED.XSNP_MISS) +=
 MEM_LOAD_UOPS_L3_MISS_RETIRED.LOCAL_DRAM + MEM_LOAD_UOPS_L3_MISS_RETIRED.R=
EMOTE_DRAM + MEM_LOAD_UOPS_L3_MISS_RETIRED.REMOTE_HITM + MEM_LOAD_UOPS_L3_M=
ISS_RETIRED.REMOTE_FWD)))) / CLKS",
-        "MetricGroup": "Offcore;Server;Snoop;TopdownL5;tma_mem_latency_gro=
up",
-        "MetricName": "tma_remote_cache",
-        "PublicDescription": "This metric estimates fraction of cycles whi=
le the memory subsystem was handling loads from remote cache in other socke=
ts including synchronizations issues. This is caused often due to non-optim=
al NUMA allocations. #link to NUMA article Sample with: MEM_LOAD_UOPS_L3_MI=
SS_RETIRED.REMOTE_HITM_PS;MEM_LOAD_UOPS_L3_MISS_RETIRED.REMOTE_FWD_PS",
-        "ScaleUnit": "100%"
+        "BriefDescription": "L2 cache hits per kilo instruction for all de=
mand loads  (including speculative)",
+        "MetricExpr": "1e3 * L2_RQSTS.DEMAND_DATA_RD_HIT / INST_RETIRED.AN=
Y",
+        "MetricGroup": "CacheMisses;Mem",
+        "MetricName": "L2HPKI_Load"
     },
     {
-        "BriefDescription": "This metric estimates how often CPU was stall=
ed  due to RFO store memory accesses; RFO store issue a read-for-ownership =
request before the write",
-        "MetricExpr": "RESOURCE_STALLS.SB / CLKS",
-        "MetricGroup": "MemoryBound;TmaL3mem;TopdownL3;tma_memory_bound_gr=
oup",
-        "MetricName": "tma_store_bound",
-        "PublicDescription": "This metric estimates how often CPU was stal=
led  due to RFO store memory accesses; RFO store issue a read-for-ownership=
 request before the write. Even though store accesses do not typically stal=
l out-of-order CPUs; there are few cases where stores can lead to actual st=
alls. This metric will be flagged should RFO stores be a bottleneck. Sample=
 with: MEM_UOPS_RETIRED.ALL_STORES_PS",
-        "ScaleUnit": "100%"
+        "BriefDescription": "L3 cache true misses per kilo instruction for=
 retired demand loads",
+        "MetricExpr": "1e3 * MEM_LOAD_UOPS_RETIRED.L3_MISS / INST_RETIRED.=
ANY",
+        "MetricGroup": "CacheMisses;Mem",
+        "MetricName": "L3MPKI"
     },
     {
-        "BriefDescription": "This metric estimates fraction of cycles the =
CPU spent handling L1D store misses",
-        "MetricExpr": "((L2_RQSTS.RFO_HIT * 9 * (1 - (MEM_UOPS_RETIRED.LOC=
K_LOADS / MEM_UOPS_RETIRED.ALL_STORES))) + (1 - (MEM_UOPS_RETIRED.LOCK_LOAD=
S / MEM_UOPS_RETIRED.ALL_STORES)) * min(CPU_CLK_UNHALTED.THREAD, OFFCORE_RE=
QUESTS_OUTSTANDING.CYCLES_WITH_DEMAND_RFO)) / CLKS",
-        "MetricGroup": "MemoryLat;Offcore;TopdownL4;tma_store_bound_group"=
,
-        "MetricName": "tma_store_latency",
-        "PublicDescription": "This metric estimates fraction of cycles the=
 CPU spent handling L1D store misses. Store accesses usually less impact ou=
t-of-order core performance; however; holding resources for longer time can=
 lead into undesired implications (e.g. contention on L1D fill-buffer entri=
es - see FB_Full)",
-        "ScaleUnit": "100%"
+        "BriefDescription": "Utilization of the core's Page Walker(s) serv=
ing STLB misses triggered by instruction/Load/Store accesses",
+        "MetricConstraint": "NO_NMI_WATCHDOG",
+        "MetricExpr": "(ITLB_MISSES.WALK_DURATION + DTLB_LOAD_MISSES.WALK_=
DURATION + DTLB_STORE_MISSES.WALK_DURATION + 7 * (DTLB_STORE_MISSES.WALK_CO=
MPLETED + DTLB_LOAD_MISSES.WALK_COMPLETED + ITLB_MISSES.WALK_COMPLETED)) / =
(2 * CORE_CLKS)",
+        "MetricGroup": "Mem;MemoryTLB",
+        "MetricName": "Page_Walks_Utilization"
     },
     {
-        "BriefDescription": "This metric roughly estimates how often CPU w=
as handling synchronizations due to False Sharing",
-        "MetricExpr": "(200 * OFFCORE_RESPONSE.DEMAND_RFO.LLC_MISS.REMOTE_=
HITM + 60 * OFFCORE_RESPONSE.DEMAND_RFO.LLC_HIT.HITM_OTHER_CORE) / CLKS",
-        "MetricGroup": "DataSharing;Offcore;Snoop;TopdownL4;tma_store_boun=
d_group",
-        "MetricName": "tma_false_sharing",
-        "PublicDescription": "This metric roughly estimates how often CPU =
was handling synchronizations due to False Sharing. False Sharing is a mult=
ithreading hiccup; where multiple Logical Processors contend on different d=
ata-elements mapped into the same cache line.  Sample with: MEM_LOAD_L3_HIT=
_RETIRED.XSNP_HITM_PS;OFFCORE_RESPONSE.DEMAND_RFO.L3_HIT.SNOOP_HITM",
-        "ScaleUnit": "100%"
+        "BriefDescription": "Average per-core data fill bandwidth to the L=
1 data cache [GB / sec]",
+        "MetricExpr": "64 * L1D.REPLACEMENT / 1e9 / duration_time",
+        "MetricGroup": "Mem;MemoryBW",
+        "MetricName": "L1D_Cache_Fill_BW"
     },
     {
-        "BriefDescription": "This metric represents rate of split store ac=
cesses",
-        "MetricExpr": "2 * MEM_UOPS_RETIRED.SPLIT_STORES / CORE_CLKS",
-        "MetricGroup": "TopdownL4;tma_store_bound_group",
-        "MetricName": "tma_split_stores",
-        "PublicDescription": "This metric represents rate of split store a=
ccesses.  Consider aligning your data to the 64-byte cache line granularity=
. Sample with: MEM_UOPS_RETIRED.SPLIT_STORES_PS",
-        "ScaleUnit": "100%"
+        "BriefDescription": "Average per-core data fill bandwidth to the L=
2 cache [GB / sec]",
+        "MetricExpr": "64 * L2_LINES_IN.ALL / 1e9 / duration_time",
+        "MetricGroup": "Mem;MemoryBW",
+        "MetricName": "L2_Cache_Fill_BW"
     },
     {
-        "BriefDescription": "This metric roughly estimates the fraction of=
 cycles spent handling first-level data TLB store misses",
-        "MetricExpr": "(8 * DTLB_STORE_MISSES.STLB_HIT + cpu@DTLB_STORE_MI=
SSES.WALK_DURATION\\,cmask\\=3D1@ + 7 * DTLB_STORE_MISSES.WALK_COMPLETED) /=
 CLKS",
-        "MetricGroup": "MemoryTLB;TopdownL4;tma_store_bound_group",
-        "MetricName": "tma_dtlb_store",
-        "PublicDescription": "This metric roughly estimates the fraction o=
f cycles spent handling first-level data TLB store misses.  As with ordinar=
y data caching; focus on improving data locality and reducing working-set s=
ize to reduce DTLB overhead.  Additionally; consider using profile-guided o=
ptimization (PGO) to collocate frequently-used data on the same page.  Try =
using larger page sizes for large amounts of frequently-used data. Sample w=
ith: MEM_UOPS_RETIRED.STLB_MISS_STORES_PS",
-        "ScaleUnit": "100%"
+        "BriefDescription": "Average per-core data fill bandwidth to the L=
3 cache [GB / sec]",
+        "MetricExpr": "64 * LONGEST_LAT_CACHE.MISS / 1e9 / duration_time",
+        "MetricGroup": "Mem;MemoryBW",
+        "MetricName": "L3_Cache_Fill_BW"
     },
     {
-        "BriefDescription": "This metric represents fraction of slots wher=
e Core non-memory issues were of a bottleneck",
-        "MetricExpr": "tma_backend_bound - tma_memory_bound",
-        "MetricGroup": "Backend;Compute;TopdownL2;tma_L2_group;tma_backend=
_bound_group",
-        "MetricName": "tma_core_bound",
-        "PublicDescription": "This metric represents fraction of slots whe=
re Core non-memory issues were of a bottleneck.  Shortage in hardware compu=
te resources; or dependencies in software's instructions are both categoriz=
ed under Core Bound. Hence it may indicate the machine ran out of an out-of=
-order resource; certain execution units are overloaded or dependencies in =
program's data- or instruction-flow are limiting the performance (e.g. FP-c=
hained long-latency arithmetic operations).",
-        "ScaleUnit": "100%"
+        "BriefDescription": "Average per-thread data fill bandwidth to the=
 L1 data cache [GB / sec]",
+        "MetricExpr": "L1D_Cache_Fill_BW",
+        "MetricGroup": "Mem;MemoryBW",
+        "MetricName": "L1D_Cache_Fill_BW_1T"
     },
     {
-        "BriefDescription": "This metric represents fraction of cycles whe=
re the Divider unit was active",
-        "MetricExpr": "ARITH.FPU_DIV_ACTIVE / CORE_CLKS",
-        "MetricGroup": "TopdownL3;tma_core_bound_group",
-        "MetricName": "tma_divider",
-        "PublicDescription": "This metric represents fraction of cycles wh=
ere the Divider unit was active. Divide and square root instructions are pe=
rformed by the Divider unit and can take considerably longer latency than i=
nteger or Floating Point addition; subtraction; or multiplication. Sample w=
ith: ARITH.DIVIDER_UOPS",
-        "ScaleUnit": "100%"
+        "BriefDescription": "Average per-thread data fill bandwidth to the=
 L2 cache [GB / sec]",
+        "MetricExpr": "L2_Cache_Fill_BW",
+        "MetricGroup": "Mem;MemoryBW",
+        "MetricName": "L2_Cache_Fill_BW_1T"
     },
     {
-        "BriefDescription": "This metric estimates fraction of cycles the =
CPU performance was potentially limited due to Core computation issues (non=
 divider-related)",
-        "MetricExpr": "((CYCLE_ACTIVITY.STALLS_TOTAL + UOPS_EXECUTED.CYCLE=
S_GE_1_UOP_EXEC - UOPS_EXECUTED.CYCLES_GE_3_UOPS_EXEC if (IPC > 1.8) else U=
OPS_EXECUTED.CYCLES_GE_2_UOPS_EXEC - RS_EVENTS.EMPTY_CYCLES if (tma_fetch_l=
atency > 0.1) else RESOURCE_STALLS.SB) - RESOURCE_STALLS.SB - CYCLE_ACTIVIT=
Y.STALLS_MEM_ANY) / CLKS",
-        "MetricGroup": "PortsUtil;TopdownL3;tma_core_bound_group",
-        "MetricName": "tma_ports_utilization",
-        "PublicDescription": "This metric estimates fraction of cycles the=
 CPU performance was potentially limited due to Core computation issues (no=
n divider-related).  Two distinct categories can be attributed into this me=
tric: (1) heavy data-dependency among contiguous instructions would manifes=
t in this metric - such cases are often referred to as low Instruction Leve=
l Parallelism (ILP). (2) Contention on some hardware execution unit other t=
han Divider. For example; when there are too many multiply operations.",
-        "ScaleUnit": "100%"
+        "BriefDescription": "Average per-thread data fill bandwidth to the=
 L3 cache [GB / sec]",
+        "MetricExpr": "L3_Cache_Fill_BW",
+        "MetricGroup": "Mem;MemoryBW",
+        "MetricName": "L3_Cache_Fill_BW_1T"
     },
     {
-        "BriefDescription": "This metric represents fraction of cycles CPU=
 executed no uops on any execution port (Logical Processor cycles since ICL=
, Physical Core cycles otherwise)",
-        "MetricExpr": "(cpu@UOPS_EXECUTED.CORE\\,inv\\,cmask\\=3D1@) / 2 i=
f #SMT_on else (CYCLE_ACTIVITY.STALLS_TOTAL - RS_EVENTS.EMPTY_CYCLES if (tm=
a_fetch_latency > 0.1) else 0) / CORE_CLKS",
-        "MetricGroup": "PortsUtil;TopdownL4;tma_ports_utilization_group",
-        "MetricName": "tma_ports_utilized_0",
-        "PublicDescription": "This metric represents fraction of cycles CP=
U executed no uops on any execution port (Logical Processor cycles since IC=
L, Physical Core cycles otherwise). Long-latency instructions like divides =
may contribute to this metric.",
-        "ScaleUnit": "100%"
+        "BriefDescription": "Average per-thread data access bandwidth to t=
he L3 cache [GB / sec]",
+        "MetricExpr": "0",
+        "MetricGroup": "Mem;MemoryBW;Offcore",
+        "MetricName": "L3_Cache_Access_BW_1T"
     },
     {
-        "BriefDescription": "This metric represents fraction of cycles whe=
re the CPU executed total of 1 uop per cycle on all execution ports (Logica=
l Processor cycles since ICL, Physical Core cycles otherwise)",
-        "MetricExpr": "(cpu@UOPS_EXECUTED.CORE\\,cmask\\=3D1@ - cpu@UOPS_E=
XECUTED.CORE\\,cmask\\=3D2@) / 2 if #SMT_on else (UOPS_EXECUTED.CYCLES_GE_1=
_UOP_EXEC - UOPS_EXECUTED.CYCLES_GE_2_UOPS_EXEC) / CORE_CLKS",
-        "MetricGroup": "PortsUtil;TopdownL4;tma_ports_utilization_group",
-        "MetricName": "tma_ports_utilized_1",
-        "PublicDescription": "This metric represents fraction of cycles wh=
ere the CPU executed total of 1 uop per cycle on all execution ports (Logic=
al Processor cycles since ICL, Physical Core cycles otherwise). This can be=
 due to heavy data-dependency among software instructions; or over oversubs=
cribing a particular hardware resource. In some other cases with high 1_Por=
t_Utilized and L1_Bound; this metric can point to L1 data-cache latency bot=
tleneck that may not necessarily manifest with complete execution starvatio=
n (due to the short L1 latency e.g. walking a linked list) - looking at the=
 assembly can be helpful.",
-        "ScaleUnit": "100%"
+        "BriefDescription": "Average CPU Utilization",
+        "MetricExpr": "CPU_CLK_UNHALTED.REF_TSC / TSC",
+        "MetricGroup": "HPC;Summary",
+        "MetricName": "CPU_Utilization"
     },
     {
-        "BriefDescription": "This metric represents fraction of cycles CPU=
 executed total of 2 uops per cycle on all execution ports (Logical Process=
or cycles since ICL, Physical Core cycles otherwise)",
-        "MetricExpr": "(cpu@UOPS_EXECUTED.CORE\\,cmask\\=3D2@ - cpu@UOPS_E=
XECUTED.CORE\\,cmask\\=3D3@) / 2 if #SMT_on else (UOPS_EXECUTED.CYCLES_GE_2=
_UOPS_EXEC - UOPS_EXECUTED.CYCLES_GE_3_UOPS_EXEC) / CORE_CLKS",
-        "MetricGroup": "PortsUtil;TopdownL4;tma_ports_utilization_group",
-        "MetricName": "tma_ports_utilized_2",
-        "PublicDescription": "This metric represents fraction of cycles CP=
U executed total of 2 uops per cycle on all execution ports (Logical Proces=
sor cycles since ICL, Physical Core cycles otherwise).  Loop Vectorization =
-most compilers feature auto-Vectorization options today- reduces pressure =
on the execution ports as multiple elements are calculated with same uop.",
-        "ScaleUnit": "100%"
+        "BriefDescription": "Measured Average Frequency for unhalted proce=
ssors [GHz]",
+        "MetricExpr": "Turbo_Utilization * TSC / 1e9 / duration_time",
+        "MetricGroup": "Power;Summary",
+        "MetricName": "Average_Frequency"
     },
     {
-        "BriefDescription": "This metric represents fraction of cycles CPU=
 executed total of 3 or more uops per cycle on all execution ports (Logical=
 Processor cycles since ICL, Physical Core cycles otherwise).",
-        "MetricExpr": "((cpu@UOPS_EXECUTED.CORE\\,cmask\\=3D3@ / 2) if #SM=
T_on else UOPS_EXECUTED.CYCLES_GE_3_UOPS_EXEC) / CORE_CLKS",
-        "MetricGroup": "PortsUtil;TopdownL4;tma_ports_utilization_group",
-        "MetricName": "tma_ports_utilized_3m",
-        "ScaleUnit": "100%"
+        "BriefDescription": "Giga Floating Point Operations Per Second",
+        "MetricExpr": "(FP_ARITH_INST_RETIRED.SCALAR_SINGLE + FP_ARITH_INS=
T_RETIRED.SCALAR_DOUBLE + 2 * FP_ARITH_INST_RETIRED.128B_PACKED_DOUBLE + 4 =
* (FP_ARITH_INST_RETIRED.128B_PACKED_SINGLE + FP_ARITH_INST_RETIRED.256B_PA=
CKED_DOUBLE) + 8 * FP_ARITH_INST_RETIRED.256B_PACKED_SINGLE) / 1e9 / durati=
on_time",
+        "MetricGroup": "Cor;Flops;HPC",
+        "MetricName": "GFLOPs",
+        "PublicDescription": "Giga Floating Point Operations Per Second. A=
ggregate across all supported options of: FP precisions, scalar and vector =
instructions, vector-width and AMX engine."
     },
     {
-        "BriefDescription": "This metric represents Core fraction of cycle=
s CPU dispatched uops on execution ports for ALU operations.",
-        "MetricExpr": "(UOPS_DISPATCHED_PORT.PORT_0 + UOPS_DISPATCHED_PORT=
.PORT_1 + UOPS_DISPATCHED_PORT.PORT_5 + UOPS_DISPATCHED_PORT.PORT_6) / (4 *=
 CORE_CLKS)",
-        "MetricGroup": "TopdownL5;tma_ports_utilized_3m_group",
-        "MetricName": "tma_alu_op_utilization",
-        "ScaleUnit": "100%"
+        "BriefDescription": "Average Frequency Utilization relative nomina=
l frequency",
+        "MetricExpr": "CLKS / CPU_CLK_UNHALTED.REF_TSC",
+        "MetricGroup": "Power",
+        "MetricName": "Turbo_Utilization"
     },
     {
-        "BriefDescription": "This metric represents Core fraction of cycle=
s CPU dispatched uops on execution port 0 ([SNB+] ALU; [HSW+] ALU and 2nd b=
ranch) Sample with: UOPS_DISPATCHED_PORT.PORT_0",
-        "MetricExpr": "UOPS_DISPATCHED_PORT.PORT_0 / CORE_CLKS",
-        "MetricGroup": "Compute;TopdownL6;tma_alu_op_utilization_group",
-        "MetricName": "tma_port_0",
-        "ScaleUnit": "100%"
+        "BriefDescription": "Fraction of cycles where both hardware Logica=
l Processors were active",
+        "MetricExpr": "(1 - CPU_CLK_UNHALTED.ONE_THREAD_ACTIVE / (CPU_CLK_=
UNHALTED.REF_XCLK_ANY / 2) if #SMT_on else 0)",
+        "MetricGroup": "SMT",
+        "MetricName": "SMT_2T_Utilization"
     },
     {
-        "BriefDescription": "This metric represents Core fraction of cycle=
s CPU dispatched uops on execution port 1 (ALU) Sample with: UOPS_DISPATCHE=
D_PORT.PORT_1",
-        "MetricExpr": "UOPS_DISPATCHED_PORT.PORT_1 / CORE_CLKS",
-        "MetricGroup": "TopdownL6;tma_alu_op_utilization_group",
-        "MetricName": "tma_port_1",
-        "ScaleUnit": "100%"
+        "BriefDescription": "Fraction of cycles spent in the Operating Sys=
tem (OS) Kernel mode",
+        "MetricExpr": "CPU_CLK_UNHALTED.THREAD_P:k / CPU_CLK_UNHALTED.THRE=
AD",
+        "MetricGroup": "OS",
+        "MetricName": "Kernel_Utilization"
     },
     {
-        "BriefDescription": "This metric represents Core fraction of cycle=
s CPU dispatched uops on execution port 5 ([SNB+] Branches and ALU; [HSW+] =
ALU) Sample with: UOPS_DISPATCHED.PORT_5",
-        "MetricExpr": "UOPS_DISPATCHED_PORT.PORT_5 / CORE_CLKS",
-        "MetricGroup": "TopdownL6;tma_alu_op_utilization_group",
-        "MetricName": "tma_port_5",
-        "ScaleUnit": "100%"
+        "BriefDescription": "Cycles Per Instruction for the Operating Syst=
em (OS) Kernel mode",
+        "MetricExpr": "CPU_CLK_UNHALTED.THREAD_P:k / INST_RETIRED.ANY_P:k"=
,
+        "MetricGroup": "OS",
+        "MetricName": "Kernel_CPI"
     },
     {
-        "BriefDescription": "This metric represents Core fraction of cycle=
s CPU dispatched uops on execution port 6 ([HSW+]Primary Branch and simple =
ALU) Sample with: UOPS_DISPATCHED_PORT.PORT_6",
-        "MetricExpr": "UOPS_DISPATCHED_PORT.PORT_6 / CORE_CLKS",
-        "MetricGroup": "TopdownL6;tma_alu_op_utilization_group",
-        "MetricName": "tma_port_6",
-        "ScaleUnit": "100%"
+        "BriefDescription": "Average external Memory Bandwidth Use for rea=
ds and writes [GB / sec]",
+        "MetricExpr": "64 * (UNC_M_CAS_COUNT.RD + UNC_M_CAS_COUNT.WR) / 1e=
9 / duration_time",
+        "MetricGroup": "HPC;Mem;MemoryBW;SoC",
+        "MetricName": "DRAM_BW_Use"
     },
     {
-        "BriefDescription": "This metric represents Core fraction of cycle=
s CPU dispatched uops on execution port for Load operations Sample with: UO=
PS_DISPATCHED.PORT_2_3",
-        "MetricExpr": "(UOPS_DISPATCHED_PORT.PORT_2 + UOPS_DISPATCHED_PORT=
.PORT_3 + UOPS_DISPATCHED_PORT.PORT_7 - UOPS_DISPATCHED_PORT.PORT_4) / (2 *=
 CORE_CLKS)",
-        "MetricGroup": "TopdownL5;tma_ports_utilized_3m_group",
-        "MetricName": "tma_load_op_utilization",
-        "ScaleUnit": "100%"
+        "BriefDescription": "Average latency of data read request to exter=
nal memory (in nanoseconds). Accounts for demand loads and L1/L2 prefetches=
",
+        "MetricExpr": "1e9 * (UNC_C_TOR_OCCUPANCY.MISS_OPCODE@filter_opc\\=
=3D0x182@ / UNC_C_TOR_INSERTS.MISS_OPCODE@filter_opc\\=3D0x182@) / (Socket_=
CLKS / duration_time)",
+        "MetricGroup": "Mem;MemoryLat;SoC",
+        "MetricName": "MEM_Read_Latency"
     },
     {
-        "BriefDescription": "This metric represents Core fraction of cycle=
s CPU dispatched uops on execution port 2 ([SNB+]Loads and Store-address; [=
ICL+] Loads) Sample with: UOPS_DISPATCHED_PORT.PORT_2",
-        "MetricExpr": "UOPS_DISPATCHED_PORT.PORT_2 / CORE_CLKS",
-        "MetricGroup": "TopdownL6;tma_load_op_utilization_group",
-        "MetricName": "tma_port_2",
-        "ScaleUnit": "100%"
+        "BriefDescription": "Average number of parallel data read requests=
 to external memory. Accounts for demand loads and L1/L2 prefetches",
+        "MetricExpr": "UNC_C_TOR_OCCUPANCY.MISS_OPCODE@filter_opc\\=3D0x18=
2@ / UNC_C_TOR_OCCUPANCY.MISS_OPCODE@filter_opc\\=3D0x182\\,thresh\\=3D1@",
+        "MetricGroup": "Mem;MemoryBW;SoC",
+        "MetricName": "MEM_Parallel_Reads"
     },
     {
-        "BriefDescription": "This metric represents Core fraction of cycle=
s CPU dispatched uops on execution port 3 ([SNB+]Loads and Store-address; [=
ICL+] Loads) Sample with: UOPS_DISPATCHED_PORT.PORT_3",
-        "MetricExpr": "UOPS_DISPATCHED_PORT.PORT_3 / CORE_CLKS",
-        "MetricGroup": "TopdownL6;tma_load_op_utilization_group",
-        "MetricName": "tma_port_3",
-        "ScaleUnit": "100%"
+        "BriefDescription": "Socket actual clocks when any core is active =
on that socket",
+        "MetricExpr": "cbox_0@event\\=3D0x0@",
+        "MetricGroup": "SoC",
+        "MetricName": "Socket_CLKS"
     },
     {
-        "BriefDescription": "This metric represents Core fraction of cycle=
s CPU dispatched uops on execution port for Store operations",
-        "MetricExpr": "UOPS_DISPATCHED_PORT.PORT_4 / CORE_CLKS",
-        "MetricGroup": "TopdownL5;tma_ports_utilized_3m_group",
-        "MetricName": "tma_store_op_utilization",
-        "ScaleUnit": "100%"
+        "BriefDescription": "Instructions per Far Branch ( Far Branches ap=
ply upon transition from application to operating system, handling interrup=
ts, exceptions) [lower number means higher occurrence rate]",
+        "MetricExpr": "INST_RETIRED.ANY / BR_INST_RETIRED.FAR_BRANCH:u",
+        "MetricGroup": "Branches;OS",
+        "MetricName": "IpFarBranch"
     },
     {
-        "BriefDescription": "This metric represents Core fraction of cycle=
s CPU dispatched uops on execution port 4 (Store-data) Sample with: UOPS_DI=
SPATCHED_PORT.PORT_4",
-        "MetricExpr": "UOPS_DISPATCHED_PORT.PORT_4 / CORE_CLKS",
-        "MetricGroup": "TopdownL6;tma_store_op_utilization_group",
-        "MetricName": "tma_port_4",
-        "ScaleUnit": "100%"
+        "BriefDescription": "Uncore frequency per die [GHZ]",
+        "MetricExpr": "Socket_CLKS / #num_dies / duration_time / 1e9",
+        "MetricGroup": "SoC",
+        "MetricName": "UNCORE_FREQ"
     },
     {
-        "BriefDescription": "This metric represents Core fraction of cycle=
s CPU dispatched uops on execution port 7 ([HSW+]simple Store-address) Samp=
le with: UOPS_DISPATCHED_PORT.PORT_7",
-        "MetricExpr": "UOPS_DISPATCHED_PORT.PORT_7 / CORE_CLKS",
-        "MetricGroup": "TopdownL6;tma_store_op_utilization_group",
-        "MetricName": "tma_port_7",
-        "ScaleUnit": "100%"
+        "BriefDescription": "CPU operating frequency (in GHz)",
+        "MetricExpr": "CPU_CLK_UNHALTED.THREAD / CPU_CLK_UNHALTED.REF_TSC =
* #SYSTEM_TSC_FREQ / 1e9 / duration_time",
+        "MetricName": "cpu_operating_frequency",
+        "ScaleUnit": "1GHz"
+    },
+    {
+        "BriefDescription": "Cycles per instruction retired; indicating ho=
w much time each executed instruction took; in units of cycles.",
+        "MetricExpr": "CPU_CLK_UNHALTED.THREAD / INST_RETIRED.ANY",
+        "MetricName": "cpi",
+        "ScaleUnit": "1per_instr"
     },
     {
-        "BriefDescription": "This category represents fraction of slots ut=
ilized by useful work i.e. issued uops that eventually get retired",
-        "MetricExpr": "UOPS_RETIRED.RETIRE_SLOTS / SLOTS",
-        "MetricGroup": "TopdownL1;tma_L1_group",
-        "MetricName": "tma_retiring",
-        "PublicDescription": "This category represents fraction of slots u=
tilized by useful work i.e. issued uops that eventually get retired. Ideall=
y; all pipeline slots would be attributed to the Retiring category.  Retiri=
ng of 100% would indicate the maximum Pipeline_Width throughput was achieve=
d.  Maximizing Retiring typically increases the Instructions-per-cycle (see=
 IPC metric). Note that a high Retiring value does not necessary mean there=
 is no room for more performance.  For example; Heavy-operations or Microco=
de Assists are categorized under Retiring. They often indicate suboptimal p=
erformance and can often be optimized or avoided.  Sample with: UOPS_RETIRE=
D.RETIRE_SLOTS",
-        "ScaleUnit": "100%"
+        "BriefDescription": "The ratio of number of completed memory load =
instructions to the total number completed instructions",
+        "MetricExpr": "MEM_UOPS_RETIRED.ALL_LOADS / INST_RETIRED.ANY",
+        "MetricName": "loads_per_instr",
+        "ScaleUnit": "1per_instr"
     },
     {
-        "BriefDescription": "This metric represents fraction of slots wher=
e the CPU was retiring light-weight operations -- instructions that require=
 no more than one uop (micro-operation)",
-        "MetricExpr": "tma_retiring - tma_heavy_operations",
-        "MetricGroup": "Retire;TopdownL2;tma_L2_group;tma_retiring_group",
-        "MetricName": "tma_light_operations",
-        "PublicDescription": "This metric represents fraction of slots whe=
re the CPU was retiring light-weight operations -- instructions that requir=
e no more than one uop (micro-operation). This correlates with total number=
 of instructions used by the program. A uops-per-instruction (see UPI metri=
c) ratio of 1 or less should be expected for decently optimized software ru=
nning on Intel Core/Xeon products. While this often indicates efficient X86=
 instructions were executed; high value does not necessarily mean better pe=
rformance cannot be achieved. Sample with: INST_RETIRED.PREC_DIST",
-        "ScaleUnit": "100%"
+        "BriefDescription": "The ratio of number of completed memory store=
 instructions to the total number completed instructions",
+        "MetricExpr": "MEM_UOPS_RETIRED.ALL_STORES / INST_RETIRED.ANY",
+        "MetricName": "stores_per_instr",
+        "ScaleUnit": "1per_instr"
     },
     {
-        "BriefDescription": "This metric represents overall arithmetic flo=
ating-point (FP) operations fraction the CPU has executed (retired)",
-        "MetricExpr": "tma_x87_use + tma_fp_scalar + tma_fp_vector",
-        "MetricGroup": "HPC;TopdownL3;tma_light_operations_group",
-        "MetricName": "tma_fp_arith",
-        "PublicDescription": "This metric represents overall arithmetic fl=
oating-point (FP) operations fraction the CPU has executed (retired). Note =
this metric's value may exceed its parent due to use of \"Uops\" CountDomai=
n and FMA double-counting.",
-        "ScaleUnit": "100%"
+        "BriefDescription": "Ratio of number of requests missing L1 data c=
ache (includes data+rfo w/ prefetches) to the total number of completed ins=
tructions",
+        "MetricExpr": "L1D.REPLACEMENT / INST_RETIRED.ANY",
+        "MetricName": "l1d_mpi",
+        "ScaleUnit": "1per_instr"
     },
     {
-        "BriefDescription": "This metric serves as an approximation of leg=
acy x87 usage",
-        "MetricExpr": "INST_RETIRED.X87 * UPI / UOPS_RETIRED.RETIRE_SLOTS"=
,
-        "MetricGroup": "Compute;TopdownL4;tma_fp_arith_group",
-        "MetricName": "tma_x87_use",
-        "PublicDescription": "This metric serves as an approximation of le=
gacy x87 usage. It accounts for instructions beyond X87 FP arithmetic opera=
tions; hence may be used as a thermometer to avoid X87 high usage and prefe=
rably upgrade to modern ISA. See Tip under Tuning Hint.",
-        "ScaleUnit": "100%"
+        "BriefDescription": "Ratio of number of demand load requests hitti=
ng in L1 data cache to the total number of completed instructions",
+        "MetricExpr": "MEM_LOAD_UOPS_RETIRED.L1_HIT / INST_RETIRED.ANY",
+        "MetricName": "l1d_demand_data_read_hits_per_instr",
+        "ScaleUnit": "1per_instr"
     },
     {
-        "BriefDescription": "This metric approximates arithmetic floating-=
point (FP) scalar uops fraction the CPU has retired",
-        "MetricExpr": "(FP_ARITH_INST_RETIRED.SCALAR_SINGLE + FP_ARITH_INS=
T_RETIRED.SCALAR_DOUBLE) / UOPS_RETIRED.RETIRE_SLOTS",
-        "MetricGroup": "Compute;Flops;TopdownL4;tma_fp_arith_group",
-        "MetricName": "tma_fp_scalar",
-        "PublicDescription": "This metric approximates arithmetic floating=
-point (FP) scalar uops fraction the CPU has retired. May overcount due to =
FMA double counting.",
-        "ScaleUnit": "100%"
+        "BriefDescription": "Ratio of number of code read requests missing=
 in L1 instruction cache (includes prefetches) to the total number of compl=
eted instructions",
+        "MetricExpr": "L2_RQSTS.ALL_CODE_RD / INST_RETIRED.ANY",
+        "MetricName": "l1_i_code_read_misses_with_prefetches_per_instr",
+        "ScaleUnit": "1per_instr"
     },
     {
-        "BriefDescription": "This metric approximates arithmetic floating-=
point (FP) vector uops fraction the CPU has retired aggregated across all v=
ector widths",
-        "MetricExpr": "(FP_ARITH_INST_RETIRED.128B_PACKED_DOUBLE + FP_ARIT=
H_INST_RETIRED.128B_PACKED_SINGLE + FP_ARITH_INST_RETIRED.256B_PACKED_DOUBL=
E + FP_ARITH_INST_RETIRED.256B_PACKED_SINGLE) / UOPS_RETIRED.RETIRE_SLOTS",
-        "MetricGroup": "Compute;Flops;TopdownL4;tma_fp_arith_group",
-        "MetricName": "tma_fp_vector",
-        "PublicDescription": "This metric approximates arithmetic floating=
-point (FP) vector uops fraction the CPU has retired aggregated across all =
vector widths. May overcount due to FMA double counting.",
-        "ScaleUnit": "100%"
+        "BriefDescription": "Ratio of number of completed demand load requ=
ests hitting in L2 cache to the total number of completed instructions",
+        "MetricExpr": "MEM_LOAD_UOPS_RETIRED.L2_HIT / INST_RETIRED.ANY",
+        "MetricName": "l2_demand_data_read_hits_per_instr",
+        "ScaleUnit": "1per_instr"
     },
     {
-        "BriefDescription": "This metric approximates arithmetic FP vector=
 uops fraction the CPU has retired for 128-bit wide vectors",
-        "MetricExpr": "(FP_ARITH_INST_RETIRED.128B_PACKED_DOUBLE + FP_ARIT=
H_INST_RETIRED.128B_PACKED_SINGLE) / UOPS_RETIRED.RETIRE_SLOTS",
-        "MetricGroup": "Compute;Flops;TopdownL5;tma_fp_vector_group",
-        "MetricName": "tma_fp_vector_128b",
-        "PublicDescription": "This metric approximates arithmetic FP vecto=
r uops fraction the CPU has retired for 128-bit wide vectors. May overcount=
 due to FMA double counting.",
-        "ScaleUnit": "100%"
+        "BriefDescription": "Ratio of number of requests missing L2 cache =
(includes code+data+rfo w/ prefetches) to the total number of completed ins=
tructions",
+        "MetricExpr": "L2_LINES_IN.ALL / INST_RETIRED.ANY",
+        "MetricName": "l2_mpi",
+        "ScaleUnit": "1per_instr"
     },
     {
-        "BriefDescription": "This metric approximates arithmetic FP vector=
 uops fraction the CPU has retired for 256-bit wide vectors",
-        "MetricExpr": "(FP_ARITH_INST_RETIRED.256B_PACKED_DOUBLE + FP_ARIT=
H_INST_RETIRED.256B_PACKED_SINGLE) / UOPS_RETIRED.RETIRE_SLOTS",
-        "MetricGroup": "Compute;Flops;TopdownL5;tma_fp_vector_group",
-        "MetricName": "tma_fp_vector_256b",
-        "PublicDescription": "This metric approximates arithmetic FP vecto=
r uops fraction the CPU has retired for 256-bit wide vectors. May overcount=
 due to FMA double counting.",
-        "ScaleUnit": "100%"
+        "BriefDescription": "Ratio of number of completed data read reques=
t missing L2 cache to the total number of completed instructions",
+        "MetricExpr": "MEM_LOAD_UOPS_RETIRED.L2_MISS / INST_RETIRED.ANY",
+        "MetricName": "l2_demand_data_read_mpi",
+        "ScaleUnit": "1per_instr"
     },
     {
-        "BriefDescription": "This metric represents fraction of slots wher=
e the CPU was retiring heavy-weight operations -- instructions that require=
 two or more uops or microcoded sequences",
-        "MetricExpr": "tma_microcode_sequencer",
-        "MetricGroup": "Retire;TopdownL2;tma_L2_group;tma_retiring_group",
-        "MetricName": "tma_heavy_operations",
-        "PublicDescription": "This metric represents fraction of slots whe=
re the CPU was retiring heavy-weight operations -- instructions that requir=
e two or more uops or microcoded sequences. This highly-correlates with the=
 uop length of these instructions/sequences.",
-        "ScaleUnit": "100%"
+        "BriefDescription": "Ratio of number of code read request missing =
L2 cache to the total number of completed instructions",
+        "MetricExpr": "L2_RQSTS.CODE_RD_MISS / INST_RETIRED.ANY",
+        "MetricName": "l2_demand_code_mpi",
+        "ScaleUnit": "1per_instr"
     },
     {
-        "BriefDescription": "This metric represents fraction of slots the =
CPU was retiring uops fetched by the Microcode Sequencer (MS) unit",
-        "MetricExpr": "(UOPS_RETIRED.RETIRE_SLOTS / UOPS_ISSUED.ANY) * IDQ=
.MS_UOPS / SLOTS",
-        "MetricGroup": "MicroSeq;TopdownL3;tma_heavy_operations_group",
-        "MetricName": "tma_microcode_sequencer",
-        "PublicDescription": "This metric represents fraction of slots the=
 CPU was retiring uops fetched by the Microcode Sequencer (MS) unit.  The M=
S is used for CISC instructions not supported by the default decoders (like=
 repeat move strings; or CPUID); or by microcode assists used to address so=
me operation modes (like in Floating Point assists). These cases can often =
be avoided. Sample with: IDQ.MS_UOPS",
-        "ScaleUnit": "100%"
+        "BriefDescription": "Ratio of number of data read requests missing=
 last level core cache (includes demand w/ prefetches) to the total number =
of completed instructions",
+        "MetricExpr": "(cbox@UNC_C_TOR_INSERTS.MISS_OPCODE\\,filter_opc\\=
=3D0x182@ + cbox@UNC_C_TOR_INSERTS.MISS_OPCODE\\,filter_opc\\=3D0x192@) / I=
NST_RETIRED.ANY",
+        "MetricName": "llc_data_read_mpi_demand_plus_prefetch",
+        "ScaleUnit": "1per_instr"
     },
     {
-        "BriefDescription": "This metric estimates fraction of slots the C=
PU retired uops delivered by the Microcode_Sequencer as a result of Assists=
",
-        "MetricExpr": "100 * OTHER_ASSISTS.ANY_WB_ASSIST / SLOTS",
-        "MetricGroup": "TopdownL4;tma_microcode_sequencer_group",
-        "MetricName": "tma_assists",
-        "PublicDescription": "This metric estimates fraction of slots the =
CPU retired uops delivered by the Microcode_Sequencer as a result of Assist=
s. Assists are long sequences of uops that are required in certain corner-c=
ases for operations that cannot be handled natively by the execution pipeli=
ne. For example; when working with very small floating point values (so-cal=
led Denormals); the FP units are not set up to perform these operations nat=
ively. Instead; a sequence of instructions to perform the computation on th=
e Denormals is injected into the pipeline. Since these microcode sequences =
might be dozens of uops long; Assists can be extremely deleterious to perfo=
rmance and they can be avoided in many cases. Sample with: OTHER_ASSISTS.AN=
Y",
-        "ScaleUnit": "100%"
+        "BriefDescription": "Ratio of number of code read requests missing=
 last level core cache (includes demand w/ prefetches) to the total number =
of completed instructions",
+        "MetricExpr": "(cbox@UNC_C_TOR_INSERTS.MISS_OPCODE\\,filter_opc\\=
=3D0x181@ + cbox@UNC_C_TOR_INSERTS.MISS_OPCODE\\,filter_opc\\=3D0x191@) / I=
NST_RETIRED.ANY",
+        "MetricName": "llc_code_read_mpi_demand_plus_prefetch",
+        "ScaleUnit": "1per_instr"
     },
     {
-        "BriefDescription": "This metric estimates fraction of cycles the =
CPU retired uops originated from CISC (complex instruction set computer) in=
struction",
-        "MetricExpr": "max(0, tma_microcode_sequencer - tma_assists)",
-        "MetricGroup": "TopdownL4;tma_microcode_sequencer_group",
-        "MetricName": "tma_cisc",
-        "PublicDescription": "This metric estimates fraction of cycles the=
 CPU retired uops originated from CISC (complex instruction set computer) i=
nstruction. A CISC instruction has multiple uops that are required to perfo=
rm the instruction's functionality as in the case of read-modify-write as a=
n example. Since these instructions require multiple uops they may or may n=
ot imply sub-optimal use of machine resources.",
-        "ScaleUnit": "100%"
+        "BriefDescription": "Average latency of a last level cache (LLC) d=
emand and prefetch data read miss (read memory access) in nano seconds",
+        "MetricExpr": "1e9 * (cbox@UNC_C_TOR_OCCUPANCY.MISS_OPCODE\\,filte=
r_opc\\=3D0x182@ / cbox@UNC_C_TOR_INSERTS.MISS_OPCODE\\,filter_opc\\=3D0x18=
2@) / (UNC_C_CLOCKTICKS / (#num_cores / #num_packages * #num_packages)) * d=
uration_time",
+        "MetricName": "llc_data_read_demand_plus_prefetch_miss_latency",
+        "ScaleUnit": "1ns"
     },
     {
-        "BriefDescription": "Instructions Per Cycle (per Logical Processor=
)",
-        "MetricExpr": "INST_RETIRED.ANY / CLKS",
-        "MetricGroup": "Ret;Summary",
-        "MetricName": "IPC"
+        "BriefDescription": "Average latency of a last level cache (LLC) d=
emand and prefetch data read miss (read memory access) addressed to local m=
emory in nano seconds",
+        "MetricExpr": "1e9 * (cbox@UNC_C_TOR_OCCUPANCY.MISS_LOCAL_OPCODE\\=
,filter_opc\\=3D0x182@ / cbox@UNC_C_TOR_INSERTS.MISS_LOCAL_OPCODE\\,filter_=
opc\\=3D0x182@) / (UNC_C_CLOCKTICKS / (#num_cores / #num_packages * #num_pa=
ckages)) * duration_time",
+        "MetricName": "llc_data_read_demand_plus_prefetch_miss_latency_for=
_local_requests",
+        "ScaleUnit": "1ns"
     },
     {
-        "BriefDescription": "Uops Per Instruction",
-        "MetricExpr": "UOPS_RETIRED.RETIRE_SLOTS / INST_RETIRED.ANY",
-        "MetricGroup": "Pipeline;Ret;Retire",
-        "MetricName": "UPI"
+        "BriefDescription": "Average latency of a last level cache (LLC) d=
emand and prefetch data read miss (read memory access) addressed to remote =
memory in nano seconds",
+        "MetricExpr": "1e9 * (cbox@UNC_C_TOR_OCCUPANCY.MISS_REMOTE_OPCODE\=
\,filter_opc\\=3D0x182@ / cbox@UNC_C_TOR_INSERTS.MISS_REMOTE_OPCODE\\,filte=
r_opc\\=3D0x182@) / (UNC_C_CLOCKTICKS / (#num_cores / #num_packages * #num_=
packages)) * duration_time",
+        "MetricName": "llc_data_read_demand_plus_prefetch_miss_latency_for=
_remote_requests",
+        "ScaleUnit": "1ns"
     },
     {
-        "BriefDescription": "Instruction per taken branch",
-        "MetricExpr": "UOPS_RETIRED.RETIRE_SLOTS / BR_INST_RETIRED.NEAR_TA=
KEN",
-        "MetricGroup": "Branches;Fed;FetchBW",
-        "MetricName": "UpTB"
+        "BriefDescription": "Ratio of number of completed page walks (for =
all page sizes) caused by a code fetch to the total number of completed ins=
tructions",
+        "MetricExpr": "ITLB_MISSES.WALK_COMPLETED / INST_RETIRED.ANY",
+        "MetricName": "itlb_mpi",
+        "PublicDescription": "Ratio of number of completed page walks (for=
 all page sizes) caused by a code fetch to the total number of completed in=
structions. This implies it missed in the ITLB (Instruction TLB) and furthe=
r levels of TLB.",
+        "ScaleUnit": "1per_instr"
     },
     {
-        "BriefDescription": "Cycles Per Instruction (per Logical Processor=
)",
-        "MetricExpr": "1 / IPC",
-        "MetricGroup": "Mem;Pipeline",
-        "MetricName": "CPI"
+        "BriefDescription": "Ratio of number of completed page walks (for =
2 megabyte and 4 megabyte page sizes) caused by a code fetch to the total n=
umber of completed instructions",
+        "MetricExpr": "ITLB_MISSES.WALK_COMPLETED_2M_4M / INST_RETIRED.ANY=
",
+        "MetricName": "itlb_large_page_mpi",
+        "PublicDescription": "Ratio of number of completed page walks (for=
 2 megabyte and 4 megabyte page sizes) caused by a code fetch to the total =
number of completed instructions. This implies it missed in the Instruction=
 Translation Lookaside Buffer (ITLB) and further levels of TLB.",
+        "ScaleUnit": "1per_instr"
     },
     {
-        "BriefDescription": "Per-Logical Processor actual clocks when the =
Logical Processor is active.",
-        "MetricExpr": "CPU_CLK_UNHALTED.THREAD",
-        "MetricGroup": "Pipeline",
-        "MetricName": "CLKS"
+        "BriefDescription": "Ratio of number of completed page walks (for =
all page sizes) caused by demand data loads to the total number of complete=
d instructions",
+        "MetricExpr": "DTLB_LOAD_MISSES.WALK_COMPLETED / INST_RETIRED.ANY"=
,
+        "MetricName": "dtlb_load_mpi",
+        "PublicDescription": "Ratio of number of completed page walks (for=
 all page sizes) caused by demand data loads to the total number of complet=
ed instructions. This implies it missed in the DTLB and further levels of T=
LB.",
+        "ScaleUnit": "1per_instr"
     },
     {
-        "BriefDescription": "Total issue-pipeline slots (per-Physical Core=
 till ICL; per-Logical Processor ICL onward)",
-        "MetricExpr": "4 * CORE_CLKS",
-        "MetricGroup": "tma_L1_group",
-        "MetricName": "SLOTS"
+        "BriefDescription": "Ratio of number of completed page walks (for =
all page sizes) caused by demand data stores to the total number of complet=
ed instructions",
+        "MetricExpr": "DTLB_STORE_MISSES.WALK_COMPLETED / INST_RETIRED.ANY=
",
+        "MetricName": "dtlb_store_mpi",
+        "PublicDescription": "Ratio of number of completed page walks (for=
 all page sizes) caused by demand data stores to the total number of comple=
ted instructions. This implies it missed in the DTLB and further levels of =
TLB.",
+        "ScaleUnit": "1per_instr"
     },
     {
-        "BriefDescription": "The ratio of Executed- by Issued-Uops",
-        "MetricExpr": "UOPS_EXECUTED.THREAD / UOPS_ISSUED.ANY",
-        "MetricGroup": "Cor;Pipeline",
-        "MetricName": "Execute_per_Issue",
-        "PublicDescription": "The ratio of Executed- by Issued-Uops. Ratio=
 > 1 suggests high rate of uop micro-fusions. Ratio < 1 suggest high rate o=
f \"execute\" at rename stage."
+        "BriefDescription": "Memory read that miss the last level cache (L=
LC) addressed to local DRAM as a percentage of total memory read accesses, =
does not include LLC prefetches.",
+        "MetricExpr": "cbox@UNC_C_TOR_INSERTS.MISS_LOCAL_OPCODE\\,filter_o=
pc\\=3D0x182@ / (cbox@UNC_C_TOR_INSERTS.MISS_LOCAL_OPCODE\\,filter_opc\\=3D=
0x182@ + cbox@UNC_C_TOR_INSERTS.MISS_REMOTE_OPCODE\\,filter_opc\\=3D0x182@)=
",
+        "MetricName": "numa_reads_addressed_to_local_dram",
+        "ScaleUnit": "100%"
     },
     {
-        "BriefDescription": "Instructions Per Cycle across hyper-threads (=
per physical core)",
-        "MetricExpr": "INST_RETIRED.ANY / CORE_CLKS",
-        "MetricGroup": "Ret;SMT;tma_L1_group",
-        "MetricName": "CoreIPC"
+        "BriefDescription": "Memory reads that miss the last level cache (=
LLC) addressed to remote DRAM as a percentage of total memory read accesses=
, does not include LLC prefetches.",
+        "MetricExpr": "cbox@UNC_C_TOR_INSERTS.MISS_REMOTE_OPCODE\\,filter_=
opc\\=3D0x182@ / (cbox@UNC_C_TOR_INSERTS.MISS_LOCAL_OPCODE\\,filter_opc\\=
=3D0x182@ + cbox@UNC_C_TOR_INSERTS.MISS_REMOTE_OPCODE\\,filter_opc\\=3D0x18=
2@)",
+        "MetricName": "numa_reads_addressed_to_remote_dram",
+        "ScaleUnit": "100%"
     },
     {
-        "BriefDescription": "Floating Point Operations Per Cycle",
-        "MetricExpr": "(1 * (FP_ARITH_INST_RETIRED.SCALAR_SINGLE + FP_ARIT=
H_INST_RETIRED.SCALAR_DOUBLE) + 2 * FP_ARITH_INST_RETIRED.128B_PACKED_DOUBL=
E + 4 * (FP_ARITH_INST_RETIRED.128B_PACKED_SINGLE + FP_ARITH_INST_RETIRED.2=
56B_PACKED_DOUBLE) + 8 * FP_ARITH_INST_RETIRED.256B_PACKED_SINGLE) / CORE_C=
LKS",
-        "MetricGroup": "Flops;Ret",
-        "MetricName": "FLOPc"
+        "BriefDescription": "Uncore operating frequency in GHz",
+        "MetricExpr": "UNC_C_CLOCKTICKS / (#num_cores / #num_packages * #n=
um_packages) / 1e9 / duration_time",
+        "MetricName": "uncore_frequency",
+        "ScaleUnit": "1GHz"
     },
     {
-        "BriefDescription": "Actual per-core usage of the Floating Point n=
on-X87 execution units (regardless of precision or vector-width)",
-        "MetricExpr": "((FP_ARITH_INST_RETIRED.SCALAR_SINGLE + FP_ARITH_IN=
ST_RETIRED.SCALAR_DOUBLE) + (FP_ARITH_INST_RETIRED.128B_PACKED_DOUBLE + FP_=
ARITH_INST_RETIRED.128B_PACKED_SINGLE + FP_ARITH_INST_RETIRED.256B_PACKED_D=
OUBLE + FP_ARITH_INST_RETIRED.256B_PACKED_SINGLE)) / (2 * CORE_CLKS)",
-        "MetricGroup": "Cor;Flops;HPC",
-        "MetricName": "FP_Arith_Utilization",
-        "PublicDescription": "Actual per-core usage of the Floating Point =
non-X87 execution units (regardless of precision or vector-width). Values >=
 1 are possible due to ([BDW+] Fused-Multiply Add (FMA) counting - common; =
[ADL+] use all of ADD/MUL/FMA in Scalar or 128/256-bit vectors - less commo=
n)."
+        "BriefDescription": "Intel(R) Quick Path Interconnect (QPI) data t=
ransmit bandwidth (MB/sec)",
+        "MetricExpr": "UNC_Q_TxL_FLITS_G0.DATA * 8 / 1e6 / duration_time",
+        "MetricName": "qpi_data_transmit_bw",
+        "ScaleUnit": "1MB/s"
     },
     {
-        "BriefDescription": "Instruction-Level-Parallelism (average number=
 of uops executed when there is execution) per-core",
-        "MetricExpr": "UOPS_EXECUTED.THREAD / ((cpu@UOPS_EXECUTED.CORE\\,c=
mask\\=3D1@ / 2) if #SMT_on else UOPS_EXECUTED.CYCLES_GE_1_UOP_EXEC)",
-        "MetricGroup": "Backend;Cor;Pipeline;PortsUtil",
-        "MetricName": "ILP"
+        "BriefDescription": "DDR memory read bandwidth (MB/sec)",
+        "MetricExpr": "UNC_M_CAS_COUNT.RD * 64 / 1e6 / duration_time",
+        "MetricName": "memory_bandwidth_read",
+        "ScaleUnit": "1MB/s"
     },
     {
-        "BriefDescription": "Core actual clocks when any Logical Processor=
 is active on the Physical Core",
-        "MetricExpr": "((CPU_CLK_UNHALTED.THREAD / 2) * (1 + CPU_CLK_UNHAL=
TED.ONE_THREAD_ACTIVE / CPU_CLK_UNHALTED.REF_XCLK)) if #core_wide < 1 else =
(CPU_CLK_UNHALTED.THREAD_ANY / 2) if #SMT_on else CLKS",
-        "MetricGroup": "SMT",
-        "MetricName": "CORE_CLKS"
+        "BriefDescription": "DDR memory write bandwidth (MB/sec)",
+        "MetricExpr": "UNC_M_CAS_COUNT.WR * 64 / 1e6 / duration_time",
+        "MetricName": "memory_bandwidth_write",
+        "ScaleUnit": "1MB/s"
     },
     {
-        "BriefDescription": "Instructions per Load (lower number means hig=
her occurrence rate)",
-        "MetricExpr": "INST_RETIRED.ANY / MEM_UOPS_RETIRED.ALL_LOADS",
-        "MetricGroup": "InsType",
-        "MetricName": "IpLoad"
+        "BriefDescription": "DDR memory bandwidth (MB/sec)",
+        "MetricExpr": "(UNC_M_CAS_COUNT.RD + UNC_M_CAS_COUNT.WR) * 64 / 1e=
6 / duration_time",
+        "MetricName": "memory_bandwidth_total",
+        "ScaleUnit": "1MB/s"
     },
     {
-        "BriefDescription": "Instructions per Store (lower number means hi=
gher occurrence rate)",
-        "MetricExpr": "INST_RETIRED.ANY / MEM_UOPS_RETIRED.ALL_STORES",
-        "MetricGroup": "InsType",
-        "MetricName": "IpStore"
+        "BriefDescription": "Bandwidth of IO reads that are initiated by e=
nd device controllers that are requesting memory from the CPU.",
+        "MetricExpr": "cbox@UNC_C_TOR_INSERTS.OPCODE\\,filter_opc\\=3D0x19=
e@ * 64 / 1e6 / duration_time",
+        "MetricName": "io_bandwidth_disk_or_network_writes",
+        "ScaleUnit": "1MB/s"
     },
     {
-        "BriefDescription": "Instructions per Branch (lower number means h=
igher occurrence rate)",
-        "MetricExpr": "INST_RETIRED.ANY / BR_INST_RETIRED.ALL_BRANCHES",
-        "MetricGroup": "Branches;Fed;InsType",
-        "MetricName": "IpBranch"
+        "BriefDescription": "Bandwidth of IO writes that are initiated by =
end device controllers that are writing memory to the CPU.",
+        "MetricExpr": "(cbox@UNC_C_TOR_INSERTS.OPCODE\\,filter_opc\\=3D0x1=
c8\\,filter_tid\\=3D0x3e@ + cbox@UNC_C_TOR_INSERTS.OPCODE\\,filter_opc\\=3D=
0x180\\,filter_tid\\=3D0x3e@) * 64 / 1e6 / duration_time",
+        "MetricName": "io_bandwidth_disk_or_network_reads",
+        "ScaleUnit": "1MB/s"
     },
     {
-        "BriefDescription": "Instructions per (near) call (lower number me=
ans higher occurrence rate)",
-        "MetricExpr": "INST_RETIRED.ANY / BR_INST_RETIRED.NEAR_CALL",
-        "MetricGroup": "Branches;Fed;PGO",
-        "MetricName": "IpCall"
+        "BriefDescription": "Uops delivered from decoded instruction cache=
 (decoded stream buffer or DSB) as a percent of total uops delivered to Ins=
truction Decode Queue",
+        "MetricExpr": "IDQ.DSB_UOPS / UOPS_ISSUED.ANY",
+        "MetricName": "percent_uops_delivered_from_decoded_icache",
+        "ScaleUnit": "100%"
     },
     {
-        "BriefDescription": "Instruction per taken branch",
-        "MetricExpr": "INST_RETIRED.ANY / BR_INST_RETIRED.NEAR_TAKEN",
-        "MetricGroup": "Branches;Fed;FetchBW;Frontend;PGO",
-        "MetricName": "IpTB"
+        "BriefDescription": "Uops delivered from legacy decode pipeline (M=
icro-instruction Translation Engine or MITE) as a percent of total uops del=
ivered to Instruction Decode Queue",
+        "MetricExpr": "IDQ.MITE_UOPS / UOPS_ISSUED.ANY",
+        "MetricName": "percent_uops_delivered_from_legacy_decode_pipeline"=
,
+        "ScaleUnit": "100%"
     },
     {
-        "BriefDescription": "Branch instructions per taken branch. ",
-        "MetricExpr": "BR_INST_RETIRED.ALL_BRANCHES / BR_INST_RETIRED.NEAR=
_TAKEN",
-        "MetricGroup": "Branches;Fed;PGO",
-        "MetricName": "BpTkBranch"
+        "BriefDescription": "Uops delivered from microcode sequencer (MS) =
as a percent of total uops delivered to Instruction Decode Queue",
+        "MetricExpr": "IDQ.MS_UOPS / UOPS_ISSUED.ANY",
+        "MetricName": "percent_uops_delivered_from_microcode_sequencer",
+        "ScaleUnit": "100%"
     },
     {
-        "BriefDescription": "Instructions per Floating Point (FP) Operatio=
n (lower number means higher occurrence rate)",
-        "MetricExpr": "INST_RETIRED.ANY / (1 * (FP_ARITH_INST_RETIRED.SCAL=
AR_SINGLE + FP_ARITH_INST_RETIRED.SCALAR_DOUBLE) + 2 * FP_ARITH_INST_RETIRE=
D.128B_PACKED_DOUBLE + 4 * (FP_ARITH_INST_RETIRED.128B_PACKED_SINGLE + FP_A=
RITH_INST_RETIRED.256B_PACKED_DOUBLE) + 8 * FP_ARITH_INST_RETIRED.256B_PACK=
ED_SINGLE)",
-        "MetricGroup": "Flops;InsType",
-        "MetricName": "IpFLOP"
+        "BriefDescription": "Uops delivered from loop stream detector(LSD)=
 as a percent of total uops delivered to Instruction Decode Queue",
+        "MetricExpr": "LSD.UOPS / UOPS_ISSUED.ANY",
+        "MetricName": "percent_uops_delivered_from_loop_stream_detector",
+        "ScaleUnit": "100%"
     },
     {
-        "BriefDescription": "Instructions per FP Arithmetic instruction (l=
ower number means higher occurrence rate)",
-        "MetricExpr": "INST_RETIRED.ANY / ((FP_ARITH_INST_RETIRED.SCALAR_S=
INGLE + FP_ARITH_INST_RETIRED.SCALAR_DOUBLE) + (FP_ARITH_INST_RETIRED.128B_=
PACKED_DOUBLE + FP_ARITH_INST_RETIRED.128B_PACKED_SINGLE + FP_ARITH_INST_RE=
TIRED.256B_PACKED_DOUBLE + FP_ARITH_INST_RETIRED.256B_PACKED_SINGLE))",
-        "MetricGroup": "Flops;InsType",
-        "MetricName": "IpArith",
-        "PublicDescription": "Instructions per FP Arithmetic instruction (=
lower number means higher occurrence rate). May undercount due to FMA doubl=
e counting. Approximated prior to BDW."
+        "BriefDescription": "This category represents fraction of slots wh=
ere the processor's Frontend undersupplies its Backend",
+        "MetricExpr": "IDQ_UOPS_NOT_DELIVERED.CORE / SLOTS",
+        "MetricGroup": "PGO;TopdownL1;tma_L1_group;tma_L1_group",
+        "MetricName": "tma_frontend_bound",
+        "PublicDescription": "This category represents fraction of slots w=
here the processor's Frontend undersupplies its Backend. Frontend denotes t=
he first part of the processor core responsible to fetch operations that ar=
e executed later on by the Backend part. Within the Frontend; a branch pred=
ictor predicts the next address to fetch; cache-lines are fetched from the =
memory subsystem; parsed into instructions; and lastly decoded into micro-o=
perations (uops). Ideally the Frontend can issue Machine_Width uops every c=
ycle to the Backend. Frontend Bound denotes unutilized issue-slots when the=
re is no Backend stall; i.e. bubbles where Frontend delivered no uops while=
 Backend could have accepted them. For example; stalls due to instruction-c=
ache misses would be categorized under Frontend Bound.",
+        "ScaleUnit": "100%"
     },
     {
-        "BriefDescription": "Instructions per FP Arithmetic Scalar Single-=
Precision instruction (lower number means higher occurrence rate)",
-        "MetricExpr": "INST_RETIRED.ANY / FP_ARITH_INST_RETIRED.SCALAR_SIN=
GLE",
-        "MetricGroup": "Flops;FpScalar;InsType",
-        "MetricName": "IpArith_Scalar_SP",
-        "PublicDescription": "Instructions per FP Arithmetic Scalar Single=
-Precision instruction (lower number means higher occurrence rate). May und=
ercount due to FMA double counting."
+        "BriefDescription": "This metric represents fraction of slots the =
CPU was stalled due to Frontend latency issues",
+        "MetricExpr": "4 * IDQ_UOPS_NOT_DELIVERED.CYCLES_0_UOPS_DELIV.CORE=
 / SLOTS",
+        "MetricGroup": "Frontend;TopdownL2;tma_L2_group;tma_L2_group;tma_f=
rontend_bound_group",
+        "MetricName": "tma_fetch_latency",
+        "PublicDescription": "This metric represents fraction of slots the=
 CPU was stalled due to Frontend latency issues.  For example; instruction-=
cache misses; iTLB misses or fetch stalls after a branch misprediction are =
categorized under Frontend Latency. In such cases; the Frontend eventually =
delivers no uops for some period.",
+        "ScaleUnit": "100%"
     },
     {
-        "BriefDescription": "Instructions per FP Arithmetic Scalar Double-=
Precision instruction (lower number means higher occurrence rate)",
-        "MetricExpr": "INST_RETIRED.ANY / FP_ARITH_INST_RETIRED.SCALAR_DOU=
BLE",
-        "MetricGroup": "Flops;FpScalar;InsType",
-        "MetricName": "IpArith_Scalar_DP",
-        "PublicDescription": "Instructions per FP Arithmetic Scalar Double=
-Precision instruction (lower number means higher occurrence rate). May und=
ercount due to FMA double counting."
+        "BriefDescription": "This metric represents fraction of cycles the=
 CPU was stalled due to instruction cache misses.",
+        "MetricExpr": "ICACHE.IFDATA_STALL / CPU_CLK_UNHALTED.THREAD",
+        "MetricGroup": "BigFoot;FetchLat;IcMiss;TopdownL3;tma_L3_group;tma=
_fetch_latency_group",
+        "MetricName": "tma_icache_misses",
+        "ScaleUnit": "100%"
     },
     {
-        "BriefDescription": "Instructions per FP Arithmetic AVX/SSE 128-bi=
t instruction (lower number means higher occurrence rate)",
-        "MetricExpr": "INST_RETIRED.ANY / (FP_ARITH_INST_RETIRED.128B_PACK=
ED_DOUBLE + FP_ARITH_INST_RETIRED.128B_PACKED_SINGLE)",
-        "MetricGroup": "Flops;FpVector;InsType",
-        "MetricName": "IpArith_AVX128",
-        "PublicDescription": "Instructions per FP Arithmetic AVX/SSE 128-b=
it instruction (lower number means higher occurrence rate). May undercount =
due to FMA double counting."
+        "BriefDescription": "This metric represents fraction of cycles the=
 CPU was stalled due to Instruction TLB (ITLB) misses.",
+        "MetricExpr": "(14 * ITLB_MISSES.STLB_HIT + cpu@ITLB_MISSES.WALK_D=
URATION\\,cmask\\=3D0x1@ + 7 * ITLB_MISSES.WALK_COMPLETED) / CPU_CLK_UNHALT=
ED.THREAD",
+        "MetricGroup": "BigFoot;FetchLat;MemoryTLB;TopdownL3;tma_L3_group;=
tma_fetch_latency_group",
+        "MetricName": "tma_itlb_misses",
+        "ScaleUnit": "100%"
     },
     {
-        "BriefDescription": "Instructions per FP Arithmetic AVX* 256-bit i=
nstruction (lower number means higher occurrence rate)",
-        "MetricExpr": "INST_RETIRED.ANY / (FP_ARITH_INST_RETIRED.256B_PACK=
ED_DOUBLE + FP_ARITH_INST_RETIRED.256B_PACKED_SINGLE)",
-        "MetricGroup": "Flops;FpVector;InsType",
-        "MetricName": "IpArith_AVX256",
-        "PublicDescription": "Instructions per FP Arithmetic AVX* 256-bit =
instruction (lower number means higher occurrence rate). May undercount due=
 to FMA double counting."
+        "BriefDescription": "This metric represents fraction of cycles the=
 CPU was stalled due to Branch Resteers",
+        "MetricExpr": "12 * (BR_MISP_RETIRED.ALL_BRANCHES + MACHINE_CLEARS=
.COUNT + BACLEARS.ANY) / CPU_CLK_UNHALTED.THREAD",
+        "MetricGroup": "FetchLat;TopdownL3;tma_L3_group;tma_fetch_latency_=
group",
+        "MetricName": "tma_branch_resteers",
+        "PublicDescription": "This metric represents fraction of cycles th=
e CPU was stalled due to Branch Resteers. Branch Resteers estimates the Fro=
ntend delay in fetching operations from corrected path; following all sorts=
 of miss-predicted branches. For example; branchy code with lots of miss-pr=
edictions might get categorized under Branch Resteers. Note the value of th=
is node may overlap with its siblings.",
+        "ScaleUnit": "100%"
     },
     {
-        "BriefDescription": "Total number of retired Instructions Sample w=
ith: INST_RETIRED.PREC_DIST",
-        "MetricExpr": "INST_RETIRED.ANY",
-        "MetricGroup": "Summary;tma_L1_group",
-        "MetricName": "Instructions"
+        "BriefDescription": "This metric represents fraction of cycles the=
 CPU was stalled due to Branch Resteers as a result of Branch Misprediction=
 at execution stage. ",
+        "MetricExpr": "BR_MISP_RETIRED.ALL_BRANCHES * tma_branch_resteers =
/ (BR_MISP_RETIRED.ALL_BRANCHES + MACHINE_CLEARS.COUNT + BACLEARS.ANY)",
+        "MetricGroup": "BadSpec;BrMispredicts;TopdownL4;tma_L4_group;tma_b=
ranch_resteers_group",
+        "MetricName": "tma_mispredicts_resteers",
+        "ScaleUnit": "100%"
     },
     {
-        "BriefDescription": "Average number of Uops retired in cycles wher=
e at least one uop has retired.",
-        "MetricExpr": "UOPS_RETIRED.RETIRE_SLOTS / cpu@UOPS_RETIRED.RETIRE=
_SLOTS\\,cmask\\=3D1@",
-        "MetricGroup": "Pipeline;Ret",
-        "MetricName": "Retire"
+        "BriefDescription": "This metric represents fraction of cycles the=
 CPU was stalled due to Branch Resteers as a result of Machine Clears. ",
+        "MetricExpr": "MACHINE_CLEARS.COUNT * tma_branch_resteers / (BR_MI=
SP_RETIRED.ALL_BRANCHES + MACHINE_CLEARS.COUNT + BACLEARS.ANY)",
+        "MetricGroup": "BadSpec;MachineClears;TopdownL4;tma_L4_group;tma_b=
ranch_resteers_group",
+        "MetricName": "tma_clears_resteers",
+        "ScaleUnit": "100%"
     },
     {
-        "BriefDescription": "",
-        "MetricExpr": "UOPS_EXECUTED.THREAD / cpu@UOPS_EXECUTED.THREAD\\,c=
mask\\=3D1@",
-        "MetricGroup": "Cor;Pipeline;PortsUtil;SMT",
-        "MetricName": "Execute"
+        "BriefDescription": "This metric represents fraction of cycles the=
 CPU was stalled due to new branch address clears",
+        "MetricExpr": "tma_branch_resteers - tma_mispredicts_resteers - tm=
a_clears_resteers",
+        "MetricGroup": "BigFoot;FetchLat;TopdownL4;tma_L4_group;tma_branch=
_resteers_group",
+        "MetricName": "tma_unknown_branches",
+        "PublicDescription": "This metric represents fraction of cycles th=
e CPU was stalled due to new branch address clears. These are fetched branc=
hes the Branch Prediction Unit was unable to recognize (First fetch or hitt=
ing BPU capacity limit).",
+        "ScaleUnit": "100%"
     },
     {
-        "BriefDescription": "Fraction of Uops delivered by the DSB (aka De=
coded ICache; or Uop Cache)",
-        "MetricExpr": "IDQ.DSB_UOPS / ((IDQ.DSB_UOPS + LSD.UOPS + IDQ.MITE=
_UOPS + IDQ.MS_UOPS))",
-        "MetricGroup": "DSB;Fed;FetchBW",
-        "MetricName": "DSB_Coverage"
+        "BriefDescription": "This metric represents fraction of cycles the=
 CPU was stalled due to switches from DSB to MITE pipelines",
+        "MetricExpr": "DSB2MITE_SWITCHES.PENALTY_CYCLES / CPU_CLK_UNHALTED=
.THREAD",
+        "MetricGroup": "DSBmiss;FetchLat;TopdownL3;tma_L3_group;tma_fetch_=
latency_group",
+        "MetricName": "tma_dsb_switches",
+        "PublicDescription": "This metric represents fraction of cycles th=
e CPU was stalled due to switches from DSB to MITE pipelines. The DSB (deco=
ded i-cache) is a Uop Cache where the front-end directly delivers Uops (mic=
ro operations) avoiding heavy x86 decoding. The DSB pipeline has shorter la=
tency and delivered higher bandwidth than the MITE (legacy instruction deco=
de pipeline). Switching between the two pipelines can cause penalties hence=
 this metric measures the exposed penalty.",
+        "ScaleUnit": "100%"
     },
     {
-        "BriefDescription": "Number of Instructions per non-speculative Br=
anch Misprediction (JEClear) (lower number means higher occurrence rate)",
-        "MetricExpr": "INST_RETIRED.ANY / BR_MISP_RETIRED.ALL_BRANCHES",
-        "MetricGroup": "Bad;BadSpec;BrMispredicts",
-        "MetricName": "IpMispredict"
+        "BriefDescription": "This metric represents fraction of cycles CPU=
 was stalled due to Length Changing Prefixes (LCPs)",
+        "MetricExpr": "ILD_STALL.LCP / CPU_CLK_UNHALTED.THREAD",
+        "MetricGroup": "FetchLat;TopdownL3;tma_L3_group;tma_fetch_latency_=
group",
+        "MetricName": "tma_lcp",
+        "PublicDescription": "This metric represents fraction of cycles CP=
U was stalled due to Length Changing Prefixes (LCPs). Using proper compiler=
 flags or Intel Compiler by default will certainly avoid this. #Link: Optim=
ization Guide about LCP BKMs.",
+        "ScaleUnit": "100%"
     },
     {
-        "BriefDescription": "Branch Misprediction Cost: Fraction of TMA sl=
ots wasted per non-speculative branch misprediction (retired JEClear)",
-        "MetricExpr": " (tma_branch_mispredicts + tma_fetch_latency * tma_=
mispredicts_resteers / (tma_branch_resteers + tma_dsb_switches + tma_icache=
_misses + tma_itlb_misses + tma_lcp + tma_ms_switches)) * SLOTS / BR_MISP_R=
ETIRED.ALL_BRANCHES",
-        "MetricGroup": "Bad;BrMispredicts",
-        "MetricName": "Branch_Misprediction_Cost"
+        "BriefDescription": "This metric estimates the fraction of cycles =
when the CPU was stalled due to switches of uop delivery to the Microcode S=
equencer (MS)",
+        "MetricExpr": "2 * IDQ.MS_SWITCHES / CPU_CLK_UNHALTED.THREAD",
+        "MetricGroup": "FetchLat;MicroSeq;TopdownL3;tma_L3_group;tma_fetch=
_latency_group",
+        "MetricName": "tma_ms_switches",
+        "PublicDescription": "This metric estimates the fraction of cycles=
 when the CPU was stalled due to switches of uop delivery to the Microcode =
Sequencer (MS). Commonly used instructions are optimized for delivery by th=
e DSB (decoded i-cache) or MITE (legacy instruction decode) pipelines. Cert=
ain operations cannot be handled natively by the execution pipeline; and mu=
st be performed by microcode (small programs injected into the execution st=
ream). Switching to the MS too often can negatively impact performance. The=
 MS is designated to deliver long uop flows required by CISC instructions l=
ike CPUID; or uncommon conditions like Floating Point Assists when dealing =
with Denormals.",
+        "ScaleUnit": "100%"
     },
     {
-        "BriefDescription": "Actual Average Latency for L1 data-cache miss=
 demand load operations (in core cycles)",
-        "MetricExpr": "L1D_PEND_MISS.PENDING / (MEM_LOAD_UOPS_RETIRED.L1_M=
ISS + mem_load_uops_retired.hit_lfb)",
-        "MetricGroup": "Mem;MemoryBound;MemoryLat",
-        "MetricName": "Load_Miss_Real_Latency"
+        "BriefDescription": "This metric represents fraction of slots the =
CPU was stalled due to Frontend bandwidth issues",
+        "MetricExpr": "tma_frontend_bound - tma_fetch_latency",
+        "MetricGroup": "FetchBW;Frontend;TopdownL2;tma_L2_group;tma_L2_gro=
up;tma_frontend_bound_group",
+        "MetricName": "tma_fetch_bandwidth",
+        "PublicDescription": "This metric represents fraction of slots the=
 CPU was stalled due to Frontend bandwidth issues.  For example; inefficien=
cies at the instruction decoders; or restrictions for caching in the DSB (d=
ecoded uops cache) are categorized under Fetch Bandwidth. In such cases; th=
e Frontend typically delivers suboptimal amount of uops to the Backend.",
+        "ScaleUnit": "100%"
     },
     {
-        "BriefDescription": "Memory-Level-Parallelism (average number of L=
1 miss demand load when there is at least one such miss. Per-Logical Proces=
sor)",
-        "MetricExpr": "L1D_PEND_MISS.PENDING / L1D_PEND_MISS.PENDING_CYCLE=
S",
-        "MetricGroup": "Mem;MemoryBW;MemoryBound",
-        "MetricName": "MLP"
+        "BriefDescription": "This metric represents Core fraction of cycle=
s in which CPU was likely limited due to the MITE pipeline (the legacy deco=
de pipeline)",
+        "MetricExpr": "(IDQ.ALL_MITE_CYCLES_ANY_UOPS - IDQ.ALL_MITE_CYCLES=
_4_UOPS) / CORE_CLKS / 2",
+        "MetricGroup": "DSBmiss;FetchBW;TopdownL3;tma_L3_group;tma_fetch_b=
andwidth_group",
+        "MetricName": "tma_mite",
+        "PublicDescription": "This metric represents Core fraction of cycl=
es in which CPU was likely limited due to the MITE pipeline (the legacy dec=
ode pipeline). This pipeline is used for code that was not pre-cached in th=
e DSB or LSD. For example; inefficiencies due to asymmetric decoders; use o=
f long immediate or LCP can manifest as MITE fetch bandwidth bottleneck.",
+        "ScaleUnit": "100%"
     },
     {
-        "BriefDescription": "L1 cache true misses per kilo instruction for=
 retired demand loads",
-        "MetricExpr": "1000 * MEM_LOAD_UOPS_RETIRED.L1_MISS / INST_RETIRED=
.ANY",
-        "MetricGroup": "CacheMisses;Mem",
-        "MetricName": "L1MPKI"
+        "BriefDescription": "This metric represents Core fraction of cycle=
s in which CPU was likely limited due to DSB (decoded uop cache) fetch pipe=
line",
+        "MetricExpr": "(IDQ.ALL_DSB_CYCLES_ANY_UOPS - IDQ.ALL_DSB_CYCLES_4=
_UOPS) / CORE_CLKS / 2",
+        "MetricGroup": "DSB;FetchBW;TopdownL3;tma_L3_group;tma_fetch_bandw=
idth_group",
+        "MetricName": "tma_dsb",
+        "PublicDescription": "This metric represents Core fraction of cycl=
es in which CPU was likely limited due to DSB (decoded uop cache) fetch pip=
eline.  For example; inefficient utilization of the DSB cache structure or =
bank conflict when reading from it; are categorized here.",
+        "ScaleUnit": "100%"
     },
     {
-        "BriefDescription": "L2 cache true misses per kilo instruction for=
 retired demand loads",
-        "MetricExpr": "1000 * MEM_LOAD_UOPS_RETIRED.L2_MISS / INST_RETIRED=
.ANY",
-        "MetricGroup": "Backend;CacheMisses;Mem",
-        "MetricName": "L2MPKI"
+        "BriefDescription": "This category represents fraction of slots wa=
sted due to incorrect speculations",
+        "MetricExpr": "(UOPS_ISSUED.ANY - UOPS_RETIRED.RETIRE_SLOTS + 4 * =
(INT_MISC.RECOVERY_CYCLES_ANY / 2 if #SMT_on else INT_MISC.RECOVERY_CYCLES)=
) / SLOTS",
+        "MetricGroup": "TopdownL1;tma_L1_group;tma_L1_group",
+        "MetricName": "tma_bad_speculation",
+        "PublicDescription": "This category represents fraction of slots w=
asted due to incorrect speculations. This include slots used to issue uops =
that do not eventually get retired and slots for which the issue-pipeline w=
as blocked due to recovery from earlier incorrect speculation. For example;=
 wasted work due to miss-predicted branches are categorized under Bad Specu=
lation category. Incorrect data speculation followed by Memory Ordering Nuk=
es is another example.",
+        "ScaleUnit": "100%"
     },
     {
-        "BriefDescription": "L2 cache ([RKL+] true) misses per kilo instru=
ction for all request types (including speculative)",
-        "MetricExpr": "1000 * L2_RQSTS.MISS / INST_RETIRED.ANY",
-        "MetricGroup": "CacheMisses;Mem;Offcore",
-        "MetricName": "L2MPKI_All"
+        "BriefDescription": "This metric represents fraction of slots the =
CPU has wasted due to Branch Misprediction",
+        "MetricExpr": "BR_MISP_RETIRED.ALL_BRANCHES / (BR_MISP_RETIRED.ALL=
_BRANCHES + MACHINE_CLEARS.COUNT) * tma_bad_speculation",
+        "MetricGroup": "BadSpec;BrMispredicts;TopdownL2;tma_L2_group;tma_L=
2_group;tma_bad_speculation_group",
+        "MetricName": "tma_branch_mispredicts",
+        "PublicDescription": "This metric represents fraction of slots the=
 CPU has wasted due to Branch Misprediction.  These slots are either wasted=
 by uops fetched from an incorrectly speculated program path; or stalls whe=
n the out-of-order part of the machine needs to recover its state from a sp=
eculative path.",
+        "ScaleUnit": "100%"
     },
     {
-        "BriefDescription": "L2 cache ([RKL+] true) misses per kilo instru=
ction for all demand loads  (including speculative)",
-        "MetricExpr": "1000 * L2_RQSTS.DEMAND_DATA_RD_MISS / INST_RETIRED.=
ANY",
-        "MetricGroup": "CacheMisses;Mem",
-        "MetricName": "L2MPKI_Load"
+        "BriefDescription": "This metric represents fraction of slots the =
CPU has wasted due to Machine Clears",
+        "MetricExpr": "tma_bad_speculation - tma_branch_mispredicts",
+        "MetricGroup": "BadSpec;MachineClears;TopdownL2;tma_L2_group;tma_L=
2_group;tma_bad_speculation_group",
+        "MetricName": "tma_machine_clears",
+        "PublicDescription": "This metric represents fraction of slots the=
 CPU has wasted due to Machine Clears.  These slots are either wasted by uo=
ps fetched prior to the clear; or stalls the out-of-order portion of the ma=
chine needs to recover its state after the clear. For example; this can hap=
pen due to memory ordering Nukes (e.g. Memory Disambiguation) or Self-Modif=
ying-Code (SMC) nukes.",
+        "ScaleUnit": "100%"
     },
     {
-        "BriefDescription": "L2 cache hits per kilo instruction for all re=
quest types (including speculative)",
-        "MetricExpr": "1000 * (L2_RQSTS.REFERENCES - L2_RQSTS.MISS) / INST=
_RETIRED.ANY",
-        "MetricGroup": "CacheMisses;Mem",
-        "MetricName": "L2HPKI_All"
+        "BriefDescription": "This category represents fraction of slots wh=
ere no uops are being delivered due to a lack of required resources for acc=
epting new uops in the Backend",
+        "MetricExpr": "1 - (tma_frontend_bound + tma_bad_speculation + UOP=
S_RETIRED.RETIRE_SLOTS / SLOTS)",
+        "MetricGroup": "TopdownL1;tma_L1_group;tma_L1_group",
+        "MetricName": "tma_backend_bound",
+        "PublicDescription": "This category represents fraction of slots w=
here no uops are being delivered due to a lack of required resources for ac=
cepting new uops in the Backend. Backend is the portion of the processor co=
re where the out-of-order scheduler dispatches ready uops into their respec=
tive execution units; and once completed these uops get retired according t=
o program order. For example; stalls due to data-cache misses or stalls due=
 to the divider unit being overloaded are both categorized under Backend Bo=
und. Backend Bound is further divided into two main categories: Memory Boun=
d and Core Bound.",
+        "ScaleUnit": "100%"
     },
     {
-        "BriefDescription": "L2 cache hits per kilo instruction for all de=
mand loads  (including speculative)",
-        "MetricExpr": "1000 * L2_RQSTS.DEMAND_DATA_RD_HIT / INST_RETIRED.A=
NY",
-        "MetricGroup": "CacheMisses;Mem",
-        "MetricName": "L2HPKI_Load"
+        "BriefDescription": "This metric represents fraction of slots the =
Memory subsystem within the Backend was a bottleneck",
+        "MetricExpr": "(CYCLE_ACTIVITY.STALLS_MEM_ANY + RESOURCE_STALLS.SB=
) / (CYCLE_ACTIVITY.STALLS_TOTAL + UOPS_EXECUTED.CYCLES_GE_1_UOP_EXEC - (UO=
PS_EXECUTED.CYCLES_GE_3_UOPS_EXEC if INST_RETIRED.ANY / CPU_CLK_UNHALTED.TH=
READ > 1.8 else UOPS_EXECUTED.CYCLES_GE_2_UOPS_EXEC) - (RS_EVENTS.EMPTY_CYC=
LES if tma_fetch_latency > 0.1 else 0) + RESOURCE_STALLS.SB) * tma_backend_=
bound",
+        "MetricGroup": "Backend;TopdownL2;tma_L2_group;tma_L2_group;tma_ba=
ckend_bound_group",
+        "MetricName": "tma_memory_bound",
+        "PublicDescription": "This metric represents fraction of slots the=
 Memory subsystem within the Backend was a bottleneck.  Memory Bound estima=
tes fraction of slots where pipeline is likely stalled due to demand load o=
r store instructions. This accounts mainly for (1) non-completed in-flight =
memory demand loads which coincides with execution units starvation; in add=
ition to (2) cases where stores could impose backpressure on the pipeline w=
hen many of them get buffered at the same time (less common out of the two)=
.",
+        "ScaleUnit": "100%"
     },
     {
-        "BriefDescription": "L3 cache true misses per kilo instruction for=
 retired demand loads",
-        "MetricExpr": "1000 * MEM_LOAD_UOPS_RETIRED.L3_MISS / INST_RETIRED=
.ANY",
-        "MetricGroup": "CacheMisses;Mem",
-        "MetricName": "L3MPKI"
+        "BriefDescription": "This metric estimates how often the CPU was s=
talled without loads missing the L1 data cache",
+        "MetricExpr": "max((CYCLE_ACTIVITY.STALLS_MEM_ANY - CYCLE_ACTIVITY=
.STALLS_L1D_MISS) / CPU_CLK_UNHALTED.THREAD, 0)",
+        "MetricGroup": "CacheMisses;MemoryBound;TmaL3mem;TopdownL3;tma_L3_=
group;tma_memory_bound_group",
+        "MetricName": "tma_l1_bound",
+        "PublicDescription": "This metric estimates how often the CPU was =
stalled without loads missing the L1 data cache.  The L1 data cache typical=
ly has the shortest latency.  However; in certain cases like loads blocked =
on older stores; a load might suffer due to high latency even though it is =
being satisfied by the L1. Another example is loads who miss in the TLB. Th=
ese cases are characterized by execution unit stalls; while some non-comple=
ted demand load lives in the machine without having that demand load missin=
g the L1 cache.",
+        "ScaleUnit": "100%"
     },
     {
-        "BriefDescription": "Utilization of the core's Page Walker(s) serv=
ing STLB misses triggered by instruction/Load/Store accesses",
-        "MetricConstraint": "NO_NMI_WATCHDOG",
-        "MetricExpr": "(ITLB_MISSES.WALK_DURATION + DTLB_LOAD_MISSES.WALK_=
DURATION + DTLB_STORE_MISSES.WALK_DURATION + 7 * (DTLB_STORE_MISSES.WALK_CO=
MPLETED + DTLB_LOAD_MISSES.WALK_COMPLETED + ITLB_MISSES.WALK_COMPLETED)) / =
(2 * CORE_CLKS)",
-        "MetricGroup": "Mem;MemoryTLB",
-        "MetricName": "Page_Walks_Utilization"
+        "BriefDescription": "This metric roughly estimates the fraction of=
 cycles where the Data TLB (DTLB) was missed by load accesses",
+        "MetricExpr": "(8 * DTLB_LOAD_MISSES.STLB_HIT + cpu@DTLB_LOAD_MISS=
ES.WALK_DURATION\\,cmask\\=3D0x1@ + 7 * DTLB_LOAD_MISSES.WALK_COMPLETED) / =
CPU_CLK_UNHALTED.THREAD",
+        "MetricGroup": "MemoryTLB;TopdownL4;tma_L4_group;tma_l1_bound_grou=
p",
+        "MetricName": "tma_dtlb_load",
+        "PublicDescription": "This metric roughly estimates the fraction o=
f cycles where the Data TLB (DTLB) was missed by load accesses. TLBs (Trans=
lation Look-aside Buffers) are processor caches for recently used entries o=
ut of the Page Tables that are used to map virtual- to physical-addresses b=
y the operating system. This metric approximates the potential delay of dem=
and loads missing the first-level data TLB (assuming worst case scenario wi=
th back to back misses to different pages). This includes hitting in the se=
cond-level TLB (STLB) as well as performing a hardware page walk on an STLB=
 miss.",
+        "ScaleUnit": "100%"
     },
     {
-        "BriefDescription": "Average per-core data fill bandwidth to the L=
1 data cache [GB / sec]",
-        "MetricExpr": "64 * L1D.REPLACEMENT / 1000000000 / duration_time",
-        "MetricGroup": "Mem;MemoryBW",
-        "MetricName": "L1D_Cache_Fill_BW"
+        "BriefDescription": "This metric roughly estimates fraction of cyc=
les when the memory subsystem had loads blocked since they could not forwar=
d data from earlier (in program order) overlapping stores",
+        "MetricExpr": "min(13 * LD_BLOCKS.STORE_FORWARD / CPU_CLK_UNHALTED=
.THREAD, 1)",
+        "MetricGroup": "TopdownL4;tma_L4_group;tma_l1_bound_group",
+        "MetricName": "tma_store_fwd_blk",
+        "PublicDescription": "This metric roughly estimates fraction of cy=
cles when the memory subsystem had loads blocked since they could not forwa=
rd data from earlier (in program order) overlapping stores. To streamline m=
emory operations in the pipeline; a load can avoid waiting for memory if a =
prior in-flight store is writing the data that the load wants to read (stor=
e forwarding process). However; in some cases the load may be blocked for a=
 significant time pending the store forward. For example; when the prior st=
ore is writing a smaller region than the load is reading.",
+        "ScaleUnit": "100%"
     },
     {
-        "BriefDescription": "Average per-core data fill bandwidth to the L=
2 cache [GB / sec]",
-        "MetricExpr": "64 * L2_LINES_IN.ALL / 1000000000 / duration_time",
-        "MetricGroup": "Mem;MemoryBW",
-        "MetricName": "L2_Cache_Fill_BW"
+        "BriefDescription": "This metric represents fraction of cycles the=
 CPU spent handling cache misses due to lock operations",
+        "MetricExpr": "min(MEM_UOPS_RETIRED.LOCK_LOADS / MEM_UOPS_RETIRED.=
ALL_STORES * min(CPU_CLK_UNHALTED.THREAD, OFFCORE_REQUESTS_OUTSTANDING.CYCL=
ES_WITH_DEMAND_RFO) / CPU_CLK_UNHALTED.THREAD, 1)",
+        "MetricGroup": "Offcore;TopdownL4;tma_L4_group;tma_l1_bound_group"=
,
+        "MetricName": "tma_lock_latency",
+        "PublicDescription": "This metric represents fraction of cycles th=
e CPU spent handling cache misses due to lock operations. Due to the microa=
rchitecture handling of locks; they are classified as L1_Bound regardless o=
f what memory source satisfied them.",
+        "ScaleUnit": "100%"
     },
     {
-        "BriefDescription": "Average per-core data fill bandwidth to the L=
3 cache [GB / sec]",
-        "MetricExpr": "64 * LONGEST_LAT_CACHE.MISS / 1000000000 / duration=
_time",
-        "MetricGroup": "Mem;MemoryBW",
-        "MetricName": "L3_Cache_Fill_BW"
+        "BriefDescription": "This metric estimates fraction of cycles hand=
ling memory load split accesses - load that cross 64-byte cache line bounda=
ry. ",
+        "MetricExpr": "min(Load_Miss_Real_Latency * LD_BLOCKS.NO_SR / CPU_=
CLK_UNHALTED.THREAD, 1)",
+        "MetricGroup": "TopdownL4;tma_L4_group;tma_l1_bound_group",
+        "MetricName": "tma_split_loads",
+        "ScaleUnit": "100%"
     },
     {
-        "BriefDescription": "Average per-thread data fill bandwidth to the=
 L1 data cache [GB / sec]",
-        "MetricExpr": "L1D_Cache_Fill_BW",
-        "MetricGroup": "Mem;MemoryBW",
-        "MetricName": "L1D_Cache_Fill_BW_1T"
+        "BriefDescription": "This metric estimates how often memory load a=
ccesses were aliased by preceding stores (in program order) with a 4K addre=
ss offset",
+        "MetricExpr": "LD_BLOCKS_PARTIAL.ADDRESS_ALIAS / CPU_CLK_UNHALTED.=
THREAD",
+        "MetricGroup": "TopdownL4;tma_L4_group;tma_l1_bound_group",
+        "MetricName": "tma_4k_aliasing",
+        "PublicDescription": "This metric estimates how often memory load =
accesses were aliased by preceding stores (in program order) with a 4K addr=
ess offset. False match is possible; which incur a few cycles load re-issue=
. However; the short re-issue duration is often hidden by the out-of-order =
core and HW optimizations; hence a user may safely ignore a high value of t=
his metric unless it manages to propagate up into parent nodes of the hiera=
rchy (e.g. to L1_Bound).",
+        "ScaleUnit": "100%"
     },
     {
-        "BriefDescription": "Average per-thread data fill bandwidth to the=
 L2 cache [GB / sec]",
-        "MetricExpr": "L2_Cache_Fill_BW",
-        "MetricGroup": "Mem;MemoryBW",
-        "MetricName": "L2_Cache_Fill_BW_1T"
+        "BriefDescription": "This metric does a *rough estimation* of how =
often L1D Fill Buffer unavailability limited additional L1D miss memory acc=
ess requests to proceed",
+        "MetricExpr": "Load_Miss_Real_Latency * cpu@L1D_PEND_MISS.FB_FULL\=
\,cmask\\=3D0x1@ / CPU_CLK_UNHALTED.THREAD",
+        "MetricGroup": "MemoryBW;TopdownL4;tma_L4_group;tma_l1_bound_group=
",
+        "MetricName": "tma_fb_full",
+        "PublicDescription": "This metric does a *rough estimation* of how=
 often L1D Fill Buffer unavailability limited additional L1D miss memory ac=
cess requests to proceed. The higher the metric value; the deeper the memor=
y hierarchy level the misses are satisfied from (metric values >1 are valid=
). Often it hints on approaching bandwidth limits (to L2 cache; L3 cache or=
 external memory).",
+        "ScaleUnit": "100%"
     },
     {
-        "BriefDescription": "Average per-thread data fill bandwidth to the=
 L3 cache [GB / sec]",
-        "MetricExpr": "L3_Cache_Fill_BW",
-        "MetricGroup": "Mem;MemoryBW",
-        "MetricName": "L3_Cache_Fill_BW_1T"
+        "BriefDescription": "This metric estimates how often the CPU was s=
talled due to L2 cache accesses by loads",
+        "MetricExpr": "(CYCLE_ACTIVITY.STALLS_L1D_MISS - CYCLE_ACTIVITY.ST=
ALLS_L2_MISS) / CPU_CLK_UNHALTED.THREAD",
+        "MetricGroup": "CacheMisses;MemoryBound;TmaL3mem;TopdownL3;tma_L3_=
group;tma_memory_bound_group",
+        "MetricName": "tma_l2_bound",
+        "PublicDescription": "This metric estimates how often the CPU was =
stalled due to L2 cache accesses by loads.  Avoiding cache misses (i.e. L1 =
misses/L2 hits) can improve the latency and increase performance.",
+        "ScaleUnit": "100%"
     },
     {
-        "BriefDescription": "Average per-thread data access bandwidth to t=
he L3 cache [GB / sec]",
-        "MetricExpr": "0",
-        "MetricGroup": "Mem;MemoryBW;Offcore",
-        "MetricName": "L3_Cache_Access_BW_1T"
+        "BriefDescription": "This metric estimates how often the CPU was s=
talled due to loads accesses to L3 cache or contended with a sibling Core",
+        "MetricExpr": "MEM_LOAD_UOPS_RETIRED.L3_HIT / (MEM_LOAD_UOPS_RETIR=
ED.L3_HIT + 7 * MEM_LOAD_UOPS_RETIRED.L3_MISS) * CYCLE_ACTIVITY.STALLS_L2_M=
ISS / CPU_CLK_UNHALTED.THREAD",
+        "MetricGroup": "CacheMisses;MemoryBound;TmaL3mem;TopdownL3;tma_L3_=
group;tma_memory_bound_group",
+        "MetricName": "tma_l3_bound",
+        "PublicDescription": "This metric estimates how often the CPU was =
stalled due to loads accesses to L3 cache or contended with a sibling Core.=
  Avoiding cache misses (i.e. L2 misses/L3 hits) can improve the latency an=
d increase performance.",
+        "ScaleUnit": "100%"
     },
     {
-        "BriefDescription": "Average CPU Utilization",
-        "MetricExpr": "CPU_CLK_UNHALTED.REF_TSC / msr@tsc@",
-        "MetricGroup": "HPC;Summary",
-        "MetricName": "CPU_Utilization"
+        "BriefDescription": "This metric estimates fraction of cycles whil=
e the memory subsystem was handling synchronizations due to contested acces=
ses",
+        "MetricExpr": "min((60 * (MEM_LOAD_UOPS_L3_HIT_RETIRED.XSNP_HITM *=
 (1 + MEM_LOAD_UOPS_RETIRED.HIT_LFB / (MEM_LOAD_UOPS_RETIRED.L2_HIT + MEM_L=
OAD_UOPS_RETIRED.L3_HIT + MEM_LOAD_UOPS_L3_HIT_RETIRED.XSNP_HIT + MEM_LOAD_=
UOPS_L3_HIT_RETIRED.XSNP_HITM + MEM_LOAD_UOPS_L3_HIT_RETIRED.XSNP_MISS + ME=
M_LOAD_UOPS_L3_MISS_RETIRED.LOCAL_DRAM + MEM_LOAD_UOPS_L3_MISS_RETIRED.REMO=
TE_DRAM + MEM_LOAD_UOPS_L3_MISS_RETIRED.REMOTE_HITM + MEM_LOAD_UOPS_L3_MISS=
_RETIRED.REMOTE_FWD))) + 43 * (MEM_LOAD_UOPS_L3_HIT_RETIRED.XSNP_MISS * (1 =
+ MEM_LOAD_UOPS_RETIRED.HIT_LFB / (MEM_LOAD_UOPS_RETIRED.L2_HIT + MEM_LOAD_=
UOPS_RETIRED.L3_HIT + MEM_LOAD_UOPS_L3_HIT_RETIRED.XSNP_HIT + MEM_LOAD_UOPS=
_L3_HIT_RETIRED.XSNP_HITM + MEM_LOAD_UOPS_L3_HIT_RETIRED.XSNP_MISS + MEM_LO=
AD_UOPS_L3_MISS_RETIRED.LOCAL_DRAM + MEM_LOAD_UOPS_L3_MISS_RETIRED.REMOTE_D=
RAM + MEM_LOAD_UOPS_L3_MISS_RETIRED.REMOTE_HITM + MEM_LOAD_UOPS_L3_MISS_RET=
IRED.REMOTE_FWD)))) / CPU_CLK_UNHALTED.THREAD, 1)",
+        "MetricGroup": "DataSharing;Offcore;Snoop;TopdownL4;tma_L4_group;t=
ma_l3_bound_group",
+        "MetricName": "tma_contested_accesses",
+        "PublicDescription": "This metric estimates fraction of cycles whi=
le the memory subsystem was handling synchronizations due to contested acce=
sses. Contested accesses occur when data written by one Logical Processor a=
re read by another Logical Processor on a different Physical Core. Examples=
 of contested accesses include synchronizations such as locks; true data sh=
aring such as modified locked variables; and false sharing.",
+        "ScaleUnit": "100%"
     },
     {
-        "BriefDescription": "Measured Average Frequency for unhalted proce=
ssors [GHz]",
-        "MetricExpr": "Turbo_Utilization * msr@tsc@ / 1000000000 / duratio=
n_time",
-        "MetricGroup": "Power;Summary",
-        "MetricName": "Average_Frequency"
+        "BriefDescription": "This metric estimates fraction of cycles whil=
e the memory subsystem was handling synchronizations due to data-sharing ac=
cesses",
+        "MetricExpr": "min(43 * (MEM_LOAD_UOPS_L3_HIT_RETIRED.XSNP_HIT * (=
1 + MEM_LOAD_UOPS_RETIRED.HIT_LFB / (MEM_LOAD_UOPS_RETIRED.L2_HIT + MEM_LOA=
D_UOPS_RETIRED.L3_HIT + MEM_LOAD_UOPS_L3_HIT_RETIRED.XSNP_HIT + MEM_LOAD_UO=
PS_L3_HIT_RETIRED.XSNP_HITM + MEM_LOAD_UOPS_L3_HIT_RETIRED.XSNP_MISS + MEM_=
LOAD_UOPS_L3_MISS_RETIRED.LOCAL_DRAM + MEM_LOAD_UOPS_L3_MISS_RETIRED.REMOTE=
_DRAM + MEM_LOAD_UOPS_L3_MISS_RETIRED.REMOTE_HITM + MEM_LOAD_UOPS_L3_MISS_R=
ETIRED.REMOTE_FWD))) / CPU_CLK_UNHALTED.THREAD, 1)",
+        "MetricGroup": "Offcore;Snoop;TopdownL4;tma_L4_group;tma_l3_bound_=
group",
+        "MetricName": "tma_data_sharing",
+        "PublicDescription": "This metric estimates fraction of cycles whi=
le the memory subsystem was handling synchronizations due to data-sharing a=
ccesses. Data shared by multiple Logical Processors (even just read shared)=
 may cause increased access latency due to cache coherency. Excessive data =
sharing can drastically harm multithreaded performance.",
+        "ScaleUnit": "100%"
     },
     {
-        "BriefDescription": "Giga Floating Point Operations Per Second",
-        "MetricExpr": "((1 * (FP_ARITH_INST_RETIRED.SCALAR_SINGLE + FP_ARI=
TH_INST_RETIRED.SCALAR_DOUBLE) + 2 * FP_ARITH_INST_RETIRED.128B_PACKED_DOUB=
LE + 4 * (FP_ARITH_INST_RETIRED.128B_PACKED_SINGLE + FP_ARITH_INST_RETIRED.=
256B_PACKED_DOUBLE) + 8 * FP_ARITH_INST_RETIRED.256B_PACKED_SINGLE) / 10000=
00000) / duration_time",
-        "MetricGroup": "Cor;Flops;HPC",
-        "MetricName": "GFLOPs",
-        "PublicDescription": "Giga Floating Point Operations Per Second. A=
ggregate across all supported options of: FP precisions, scalar and vector =
instructions, vector-width and AMX engine."
+        "BriefDescription": "This metric represents fraction of cycles wit=
h demand load accesses that hit the L3 cache under unloaded scenarios (poss=
ibly L3 latency limited)",
+        "MetricExpr": "min(41 * (MEM_LOAD_UOPS_RETIRED.L3_HIT * (1 + MEM_L=
OAD_UOPS_RETIRED.HIT_LFB / (MEM_LOAD_UOPS_RETIRED.L2_HIT + MEM_LOAD_UOPS_RE=
TIRED.L3_HIT + MEM_LOAD_UOPS_L3_HIT_RETIRED.XSNP_HIT + MEM_LOAD_UOPS_L3_HIT=
_RETIRED.XSNP_HITM + MEM_LOAD_UOPS_L3_HIT_RETIRED.XSNP_MISS + MEM_LOAD_UOPS=
_L3_MISS_RETIRED.LOCAL_DRAM + MEM_LOAD_UOPS_L3_MISS_RETIRED.REMOTE_DRAM + M=
EM_LOAD_UOPS_L3_MISS_RETIRED.REMOTE_HITM + MEM_LOAD_UOPS_L3_MISS_RETIRED.RE=
MOTE_FWD))) / CPU_CLK_UNHALTED.THREAD, 1)",
+        "MetricGroup": "MemoryLat;TopdownL4;tma_L4_group;tma_l3_bound_grou=
p",
+        "MetricName": "tma_l3_hit_latency",
+        "PublicDescription": "This metric represents fraction of cycles wi=
th demand load accesses that hit the L3 cache under unloaded scenarios (pos=
sibly L3 latency limited).  Avoiding private cache misses (i.e. L2 misses/L=
3 hits) will improve the latency; reduce contention with sibling physical c=
ores and increase performance.  Note the value of this node may overlap wit=
h its siblings.",
+        "ScaleUnit": "100%"
     },
     {
-        "BriefDescription": "Average Frequency Utilization relative nomina=
l frequency",
-        "MetricExpr": "CLKS / CPU_CLK_UNHALTED.REF_TSC",
-        "MetricGroup": "Power",
-        "MetricName": "Turbo_Utilization"
+        "BriefDescription": "This metric measures fraction of cycles where=
 the Super Queue (SQ) was full taking into account all request-types and bo=
th hardware SMT threads (Logical Processors)",
+        "MetricExpr": "(OFFCORE_REQUESTS_BUFFER.SQ_FULL / 2 if #SMT_on els=
e OFFCORE_REQUESTS_BUFFER.SQ_FULL) / CORE_CLKS",
+        "MetricGroup": "MemoryBW;Offcore;TopdownL4;tma_L4_group;tma_l3_bou=
nd_group",
+        "MetricName": "tma_sq_full",
+        "PublicDescription": "This metric measures fraction of cycles wher=
e the Super Queue (SQ) was full taking into account all request-types and b=
oth hardware SMT threads (Logical Processors). The Super Queue is used for =
requests to access the L2 cache or to go out to the Uncore.",
+        "ScaleUnit": "100%"
     },
     {
-        "BriefDescription": "Fraction of cycles where both hardware Logica=
l Processors were active",
-        "MetricExpr": "1 - CPU_CLK_UNHALTED.ONE_THREAD_ACTIVE / (CPU_CLK_U=
NHALTED.REF_XCLK_ANY / 2) if #SMT_on else 0",
-        "MetricGroup": "SMT",
-        "MetricName": "SMT_2T_Utilization"
+        "BriefDescription": "This metric estimates how often the CPU was s=
talled on accesses to external memory (DRAM) by loads",
+        "MetricExpr": "min((1 - MEM_LOAD_UOPS_RETIRED.L3_HIT / (MEM_LOAD_U=
OPS_RETIRED.L3_HIT + 7 * MEM_LOAD_UOPS_RETIRED.L3_MISS)) * CYCLE_ACTIVITY.S=
TALLS_L2_MISS / CPU_CLK_UNHALTED.THREAD, 1)",
+        "MetricGroup": "MemoryBound;TmaL3mem;TopdownL3;tma_L3_group;tma_me=
mory_bound_group",
+        "MetricName": "tma_dram_bound",
+        "PublicDescription": "This metric estimates how often the CPU was =
stalled on accesses to external memory (DRAM) by loads. Better caching can =
improve the latency and increase performance.",
+        "ScaleUnit": "100%"
     },
     {
-        "BriefDescription": "Fraction of cycles spent in the Operating Sys=
tem (OS) Kernel mode",
-        "MetricExpr": "CPU_CLK_UNHALTED.THREAD_P:k / CPU_CLK_UNHALTED.THRE=
AD",
-        "MetricGroup": "OS",
-        "MetricName": "Kernel_Utilization"
+        "BriefDescription": "This metric estimates fraction of cycles wher=
e the core's performance was likely hurt due to approaching bandwidth limit=
s of external memory (DRAM)",
+        "MetricExpr": "min(CPU_CLK_UNHALTED.THREAD, cpu@OFFCORE_REQUESTS_O=
UTSTANDING.ALL_DATA_RD\\,cmask\\=3D0x4@) / CPU_CLK_UNHALTED.THREAD",
+        "MetricGroup": "MemoryBW;Offcore;TopdownL4;tma_L4_group;tma_dram_b=
ound_group",
+        "MetricName": "tma_mem_bandwidth",
+        "PublicDescription": "This metric estimates fraction of cycles whe=
re the core's performance was likely hurt due to approaching bandwidth limi=
ts of external memory (DRAM).  The underlying heuristic assumes that a simi=
lar off-core traffic is generated by all IA cores. This metric does not agg=
regate non-data-read requests by this logical processor; requests from othe=
r IA Logical Processors/Physical Cores/sockets; or other non-IA devices lik=
e GPU; hence the maximum external memory bandwidth limits may or may not be=
 approached when this metric is flagged (see Uncore counters for that).",
+        "ScaleUnit": "100%"
     },
     {
-        "BriefDescription": "Cycles Per Instruction for the Operating Syst=
em (OS) Kernel mode",
-        "MetricExpr": "CPU_CLK_UNHALTED.THREAD_P:k / INST_RETIRED.ANY_P:k"=
,
-        "MetricGroup": "OS",
-        "MetricName": "Kernel_CPI"
+        "BriefDescription": "This metric estimates fraction of cycles wher=
e the performance was likely hurt due to latency from external memory (DRAM=
)",
+        "MetricExpr": "min(CPU_CLK_UNHALTED.THREAD, OFFCORE_REQUESTS_OUTST=
ANDING.CYCLES_WITH_DATA_RD) / CPU_CLK_UNHALTED.THREAD - tma_mem_bandwidth",
+        "MetricGroup": "MemoryLat;Offcore;TopdownL4;tma_L4_group;tma_dram_=
bound_group",
+        "MetricName": "tma_mem_latency",
+        "PublicDescription": "This metric estimates fraction of cycles whe=
re the performance was likely hurt due to latency from external memory (DRA=
M).  This metric does not aggregate requests from other Logical Processors/=
Physical Cores/sockets (see Uncore counters for that).",
+        "ScaleUnit": "100%"
     },
     {
-        "BriefDescription": "Average external Memory Bandwidth Use for rea=
ds and writes [GB / sec]",
-        "MetricExpr": "(64 * (uncore_imc@cas_count_read@ + uncore_imc@cas_=
count_write@) / 1000000000) / duration_time",
-        "MetricGroup": "HPC;Mem;MemoryBW;SoC",
-        "MetricName": "DRAM_BW_Use"
+        "BriefDescription": "This metric estimates fraction of cycles whil=
e the memory subsystem was handling loads from local memory",
+        "MetricExpr": "min(200 * (MEM_LOAD_UOPS_L3_MISS_RETIRED.LOCAL_DRAM=
 * (1 + MEM_LOAD_UOPS_RETIRED.HIT_LFB / (MEM_LOAD_UOPS_RETIRED.L2_HIT + MEM=
_LOAD_UOPS_RETIRED.L3_HIT + MEM_LOAD_UOPS_L3_HIT_RETIRED.XSNP_HIT + MEM_LOA=
D_UOPS_L3_HIT_RETIRED.XSNP_HITM + MEM_LOAD_UOPS_L3_HIT_RETIRED.XSNP_MISS + =
MEM_LOAD_UOPS_L3_MISS_RETIRED.LOCAL_DRAM + MEM_LOAD_UOPS_L3_MISS_RETIRED.RE=
MOTE_DRAM + MEM_LOAD_UOPS_L3_MISS_RETIRED.REMOTE_HITM + MEM_LOAD_UOPS_L3_MI=
SS_RETIRED.REMOTE_FWD))) / CPU_CLK_UNHALTED.THREAD, 1)",
+        "MetricGroup": "Server;TopdownL5;tma_L5_group;tma_mem_latency_grou=
p",
+        "MetricName": "tma_local_dram",
+        "PublicDescription": "This metric estimates fraction of cycles whi=
le the memory subsystem was handling loads from local memory. Caching will =
improve the latency and increase performance.",
+        "ScaleUnit": "100%"
     },
     {
-        "BriefDescription": "Average latency of data read request to exter=
nal memory (in nanoseconds). Accounts for demand loads and L1/L2 prefetches=
",
-        "MetricExpr": "1000000000 * (cbox@event\\=3D0x36\\,umask\\=3D0x3\\=
,filter_opc\\=3D0x182@ / cbox@event\\=3D0x35\\,umask\\=3D0x3\\,filter_opc\\=
=3D0x182@) / (Socket_CLKS / duration_time)",
-        "MetricGroup": "Mem;MemoryLat;SoC",
-        "MetricName": "MEM_Read_Latency"
+        "BriefDescription": "This metric estimates fraction of cycles whil=
e the memory subsystem was handling loads from remote memory",
+        "MetricExpr": "min(310 * (MEM_LOAD_UOPS_L3_MISS_RETIRED.REMOTE_DRA=
M * (1 + MEM_LOAD_UOPS_RETIRED.HIT_LFB / (MEM_LOAD_UOPS_RETIRED.L2_HIT + ME=
M_LOAD_UOPS_RETIRED.L3_HIT + MEM_LOAD_UOPS_L3_HIT_RETIRED.XSNP_HIT + MEM_LO=
AD_UOPS_L3_HIT_RETIRED.XSNP_HITM + MEM_LOAD_UOPS_L3_HIT_RETIRED.XSNP_MISS +=
 MEM_LOAD_UOPS_L3_MISS_RETIRED.LOCAL_DRAM + MEM_LOAD_UOPS_L3_MISS_RETIRED.R=
EMOTE_DRAM + MEM_LOAD_UOPS_L3_MISS_RETIRED.REMOTE_HITM + MEM_LOAD_UOPS_L3_M=
ISS_RETIRED.REMOTE_FWD))) / CPU_CLK_UNHALTED.THREAD, 1)",
+        "MetricGroup": "Server;Snoop;TopdownL5;tma_L5_group;tma_mem_latenc=
y_group",
+        "MetricName": "tma_remote_dram",
+        "PublicDescription": "This metric estimates fraction of cycles whi=
le the memory subsystem was handling loads from remote memory. This is caus=
ed often due to non-optimal NUMA allocations. #link to NUMA article",
+        "ScaleUnit": "100%"
     },
     {
-        "BriefDescription": "Average number of parallel data read requests=
 to external memory. Accounts for demand loads and L1/L2 prefetches",
-        "MetricExpr": "cbox@event\\=3D0x36\\,umask\\=3D0x3\\,filter_opc\\=
=3D0x182@ / cbox@event\\=3D0x36\\,umask\\=3D0x3\\,filter_opc\\=3D0x182\\,th=
resh\\=3D1@",
-        "MetricGroup": "Mem;MemoryBW;SoC",
-        "MetricName": "MEM_Parallel_Reads"
+        "BriefDescription": "This metric estimates fraction of cycles whil=
e the memory subsystem was handling loads from remote cache in other socket=
s including synchronizations issues",
+        "MetricExpr": "min((200 * (MEM_LOAD_UOPS_L3_MISS_RETIRED.REMOTE_HI=
TM * (1 + MEM_LOAD_UOPS_RETIRED.HIT_LFB / (MEM_LOAD_UOPS_RETIRED.L2_HIT + M=
EM_LOAD_UOPS_RETIRED.L3_HIT + MEM_LOAD_UOPS_L3_HIT_RETIRED.XSNP_HIT + MEM_L=
OAD_UOPS_L3_HIT_RETIRED.XSNP_HITM + MEM_LOAD_UOPS_L3_HIT_RETIRED.XSNP_MISS =
+ MEM_LOAD_UOPS_L3_MISS_RETIRED.LOCAL_DRAM + MEM_LOAD_UOPS_L3_MISS_RETIRED.=
REMOTE_DRAM + MEM_LOAD_UOPS_L3_MISS_RETIRED.REMOTE_HITM + MEM_LOAD_UOPS_L3_=
MISS_RETIRED.REMOTE_FWD))) + 180 * (MEM_LOAD_UOPS_L3_MISS_RETIRED.REMOTE_FW=
D * (1 + MEM_LOAD_UOPS_RETIRED.HIT_LFB / (MEM_LOAD_UOPS_RETIRED.L2_HIT + ME=
M_LOAD_UOPS_RETIRED.L3_HIT + MEM_LOAD_UOPS_L3_HIT_RETIRED.XSNP_HIT + MEM_LO=
AD_UOPS_L3_HIT_RETIRED.XSNP_HITM + MEM_LOAD_UOPS_L3_HIT_RETIRED.XSNP_MISS +=
 MEM_LOAD_UOPS_L3_MISS_RETIRED.LOCAL_DRAM + MEM_LOAD_UOPS_L3_MISS_RETIRED.R=
EMOTE_DRAM + MEM_LOAD_UOPS_L3_MISS_RETIRED.REMOTE_HITM + MEM_LOAD_UOPS_L3_M=
ISS_RETIRED.REMOTE_FWD)))) / CPU_CLK_UNHALTED.THREAD, 1)",
+        "MetricGroup": "Offcore;Server;Snoop;TopdownL5;tma_L5_group;tma_me=
m_latency_group",
+        "MetricName": "tma_remote_cache",
+        "PublicDescription": "This metric estimates fraction of cycles whi=
le the memory subsystem was handling loads from remote cache in other socke=
ts including synchronizations issues. This is caused often due to non-optim=
al NUMA allocations. #link to NUMA article",
+        "ScaleUnit": "100%"
     },
     {
-        "BriefDescription": "Socket actual clocks when any core is active =
on that socket",
-        "MetricExpr": "cbox_0@event\\=3D0x0@",
-        "MetricGroup": "SoC",
-        "MetricName": "Socket_CLKS"
+        "BriefDescription": "This metric estimates how often CPU was stall=
ed  due to RFO store memory accesses; RFO store issue a read-for-ownership =
request before the write",
+        "MetricExpr": "RESOURCE_STALLS.SB / CPU_CLK_UNHALTED.THREAD",
+        "MetricGroup": "MemoryBound;TmaL3mem;TopdownL3;tma_L3_group;tma_me=
mory_bound_group",
+        "MetricName": "tma_store_bound",
+        "PublicDescription": "This metric estimates how often CPU was stal=
led  due to RFO store memory accesses; RFO store issue a read-for-ownership=
 request before the write. Even though store accesses do not typically stal=
l out-of-order CPUs; there are few cases where stores can lead to actual st=
alls. This metric will be flagged should RFO stores be a bottleneck.",
+        "ScaleUnit": "100%"
     },
     {
-        "BriefDescription": "Instructions per Far Branch ( Far Branches ap=
ply upon transition from application to operating system, handling interrup=
ts, exceptions) [lower number means higher occurrence rate]",
-        "MetricExpr": "INST_RETIRED.ANY / BR_INST_RETIRED.FAR_BRANCH:u",
-        "MetricGroup": "Branches;OS",
-        "MetricName": "IpFarBranch"
+        "BriefDescription": "This metric estimates fraction of cycles the =
CPU spent handling L1D store misses",
+        "MetricExpr": "(L2_RQSTS.RFO_HIT * 9 * (1 - MEM_UOPS_RETIRED.LOCK_=
LOADS / MEM_UOPS_RETIRED.ALL_STORES) + (1 - MEM_UOPS_RETIRED.LOCK_LOADS / M=
EM_UOPS_RETIRED.ALL_STORES) * min(CPU_CLK_UNHALTED.THREAD, OFFCORE_REQUESTS=
_OUTSTANDING.CYCLES_WITH_DEMAND_RFO)) / CPU_CLK_UNHALTED.THREAD",
+        "MetricGroup": "MemoryLat;Offcore;TopdownL4;tma_L4_group;tma_store=
_bound_group",
+        "MetricName": "tma_store_latency",
+        "PublicDescription": "This metric estimates fraction of cycles the=
 CPU spent handling L1D store misses. Store accesses usually less impact ou=
t-of-order core performance; however; holding resources for longer time can=
 lead into undesired implications (e.g. contention on L1D fill-buffer entri=
es - see FB_Full)",
+        "ScaleUnit": "100%"
     },
     {
-        "BriefDescription": "C3 residency percent per core",
-        "MetricExpr": "(cstate_core@c3\\-residency@ / msr@tsc@) * 100",
-        "MetricGroup": "Power",
-        "MetricName": "C3_Core_Residency"
+        "BriefDescription": "This metric roughly estimates how often CPU w=
as handling synchronizations due to False Sharing",
+        "MetricExpr": "min((200 * OFFCORE_RESPONSE.DEMAND_RFO.LLC_MISS.REM=
OTE_HITM + 60 * OFFCORE_RESPONSE.DEMAND_RFO.LLC_HIT.HITM_OTHER_CORE) / CPU_=
CLK_UNHALTED.THREAD, 1)",
+        "MetricGroup": "DataSharing;Offcore;Snoop;TopdownL4;tma_L4_group;t=
ma_store_bound_group",
+        "MetricName": "tma_false_sharing",
+        "PublicDescription": "This metric roughly estimates how often CPU =
was handling synchronizations due to False Sharing. False Sharing is a mult=
ithreading hiccup; where multiple Logical Processors contend on different d=
ata-elements mapped into the same cache line. ",
+        "ScaleUnit": "100%"
     },
     {
-        "BriefDescription": "C6 residency percent per core",
-        "MetricExpr": "(cstate_core@c6\\-residency@ / msr@tsc@) * 100",
-        "MetricGroup": "Power",
-        "MetricName": "C6_Core_Residency"
+        "BriefDescription": "This metric represents rate of split store ac=
cesses",
+        "MetricExpr": "2 * MEM_UOPS_RETIRED.SPLIT_STORES / CORE_CLKS",
+        "MetricGroup": "TopdownL4;tma_L4_group;tma_store_bound_group",
+        "MetricName": "tma_split_stores",
+        "PublicDescription": "This metric represents rate of split store a=
ccesses.  Consider aligning your data to the 64-byte cache line granularity=
.",
+        "ScaleUnit": "100%"
     },
     {
-        "BriefDescription": "C7 residency percent per core",
-        "MetricExpr": "(cstate_core@c7\\-residency@ / msr@tsc@) * 100",
-        "MetricGroup": "Power",
-        "MetricName": "C7_Core_Residency"
+        "BriefDescription": "This metric roughly estimates the fraction of=
 cycles spent handling first-level data TLB store misses",
+        "MetricExpr": "min((8 * DTLB_STORE_MISSES.STLB_HIT + cpu@DTLB_STOR=
E_MISSES.WALK_DURATION\\,cmask\\=3D0x1@ + 7 * DTLB_STORE_MISSES.WALK_COMPLE=
TED) / CPU_CLK_UNHALTED.THREAD, 1)",
+        "MetricGroup": "MemoryTLB;TopdownL4;tma_L4_group;tma_store_bound_g=
roup",
+        "MetricName": "tma_dtlb_store",
+        "PublicDescription": "This metric roughly estimates the fraction o=
f cycles spent handling first-level data TLB store misses.  As with ordinar=
y data caching; focus on improving data locality and reducing working-set s=
ize to reduce DTLB overhead.  Additionally; consider using profile-guided o=
ptimization (PGO) to collocate frequently-used data on the same page.  Try =
using larger page sizes for large amounts of frequently-used data.",
+        "ScaleUnit": "100%"
     },
     {
-        "BriefDescription": "C2 residency percent per package",
-        "MetricExpr": "(cstate_pkg@c2\\-residency@ / msr@tsc@) * 100",
-        "MetricGroup": "Power",
-        "MetricName": "C2_Pkg_Residency"
+        "BriefDescription": "This metric represents fraction of slots wher=
e Core non-memory issues were of a bottleneck",
+        "MetricExpr": "tma_backend_bound - tma_memory_bound",
+        "MetricGroup": "Backend;Compute;TopdownL2;tma_L2_group;tma_L2_grou=
p;tma_backend_bound_group",
+        "MetricName": "tma_core_bound",
+        "PublicDescription": "This metric represents fraction of slots whe=
re Core non-memory issues were of a bottleneck.  Shortage in hardware compu=
te resources; or dependencies in software's instructions are both categoriz=
ed under Core Bound. Hence it may indicate the machine ran out of an out-of=
-order resource; certain execution units are overloaded or dependencies in =
program's data- or instruction-flow are limiting the performance (e.g. FP-c=
hained long-latency arithmetic operations).",
+        "ScaleUnit": "100%"
     },
     {
-        "BriefDescription": "C3 residency percent per package",
-        "MetricExpr": "(cstate_pkg@c3\\-residency@ / msr@tsc@) * 100",
-        "MetricGroup": "Power",
-        "MetricName": "C3_Pkg_Residency"
+        "BriefDescription": "This metric represents fraction of cycles whe=
re the Divider unit was active",
+        "MetricExpr": "ARITH.FPU_DIV_ACTIVE / CORE_CLKS",
+        "MetricGroup": "TopdownL3;tma_L3_group;tma_core_bound_group",
+        "MetricName": "tma_divider",
+        "PublicDescription": "This metric represents fraction of cycles wh=
ere the Divider unit was active. Divide and square root instructions are pe=
rformed by the Divider unit and can take considerably longer latency than i=
nteger or Floating Point addition; subtraction; or multiplication.",
+        "ScaleUnit": "100%"
     },
     {
-        "BriefDescription": "C6 residency percent per package",
-        "MetricExpr": "(cstate_pkg@c6\\-residency@ / msr@tsc@) * 100",
-        "MetricGroup": "Power",
-        "MetricName": "C6_Pkg_Residency"
+        "BriefDescription": "This metric estimates fraction of cycles the =
CPU performance was potentially limited due to Core computation issues (non=
 divider-related)",
+        "MetricExpr": "(CYCLE_ACTIVITY.STALLS_TOTAL + UOPS_EXECUTED.CYCLES=
_GE_1_UOP_EXEC - (UOPS_EXECUTED.CYCLES_GE_3_UOPS_EXEC if INST_RETIRED.ANY /=
 CPU_CLK_UNHALTED.THREAD > 1.8 else UOPS_EXECUTED.CYCLES_GE_2_UOPS_EXEC) - =
(RS_EVENTS.EMPTY_CYCLES if tma_fetch_latency > 0.1 else 0) + RESOURCE_STALL=
S.SB - RESOURCE_STALLS.SB - CYCLE_ACTIVITY.STALLS_MEM_ANY) / CPU_CLK_UNHALT=
ED.THREAD",
+        "MetricGroup": "PortsUtil;TopdownL3;tma_L3_group;tma_core_bound_gr=
oup",
+        "MetricName": "tma_ports_utilization",
+        "PublicDescription": "This metric estimates fraction of cycles the=
 CPU performance was potentially limited due to Core computation issues (no=
n divider-related).  Two distinct categories can be attributed into this me=
tric: (1) heavy data-dependency among contiguous instructions would manifes=
t in this metric - such cases are often referred to as low Instruction Leve=
l Parallelism (ILP). (2) Contention on some hardware execution unit other t=
han Divider. For example; when there are too many multiply operations.",
+        "ScaleUnit": "100%"
     },
     {
-        "BriefDescription": "C7 residency percent per package",
-        "MetricExpr": "(cstate_pkg@c7\\-residency@ / msr@tsc@) * 100",
-        "MetricGroup": "Power",
-        "MetricName": "C7_Pkg_Residency"
+        "BriefDescription": "This metric represents fraction of cycles CPU=
 executed no uops on any execution port (Logical Processor cycles since ICL=
, Physical Core cycles otherwise)",
+        "MetricExpr": "(cpu@UOPS_EXECUTED.CORE\\,inv\\=3D0x1\\,cmask\\=3D0=
x1@ / 2 if #SMT_on else CYCLE_ACTIVITY.STALLS_TOTAL - (RS_EVENTS.EMPTY_CYCL=
ES if tma_fetch_latency > 0.1 else 0)) / CORE_CLKS",
+        "MetricGroup": "PortsUtil;TopdownL4;tma_L4_group;tma_ports_utiliza=
tion_group",
+        "MetricName": "tma_ports_utilized_0",
+        "PublicDescription": "This metric represents fraction of cycles CP=
U executed no uops on any execution port (Logical Processor cycles since IC=
L, Physical Core cycles otherwise). Long-latency instructions like divides =
may contribute to this metric.",
+        "ScaleUnit": "100%"
     },
     {
-        "BriefDescription": "Uncore frequency per die [GHZ]",
-        "MetricExpr": "Socket_CLKS / #num_dies / duration_time / 100000000=
0",
-        "MetricGroup": "SoC",
-        "MetricName": "UNCORE_FREQ"
+        "BriefDescription": "This metric represents fraction of cycles whe=
re the CPU executed total of 1 uop per cycle on all execution ports (Logica=
l Processor cycles since ICL, Physical Core cycles otherwise)",
+        "MetricExpr": "((cpu@UOPS_EXECUTED.CORE\\,cmask\\=3D0x1@ - cpu@UOP=
S_EXECUTED.CORE\\,cmask\\=3D0x2@) / 2 if #SMT_on else UOPS_EXECUTED.CYCLES_=
GE_1_UOP_EXEC - UOPS_EXECUTED.CYCLES_GE_2_UOPS_EXEC) / CORE_CLKS",
+        "MetricGroup": "PortsUtil;TopdownL4;tma_L4_group;tma_ports_utiliza=
tion_group",
+        "MetricName": "tma_ports_utilized_1",
+        "PublicDescription": "This metric represents fraction of cycles wh=
ere the CPU executed total of 1 uop per cycle on all execution ports (Logic=
al Processor cycles since ICL, Physical Core cycles otherwise). This can be=
 due to heavy data-dependency among software instructions; or over oversubs=
cribing a particular hardware resource. In some other cases with high 1_Por=
t_Utilized and L1_Bound; this metric can point to L1 data-cache latency bot=
tleneck that may not necessarily manifest with complete execution starvatio=
n (due to the short L1 latency e.g. walking a linked list) - looking at the=
 assembly can be helpful.",
+        "ScaleUnit": "100%"
     },
     {
-        "BriefDescription": "CPU operating frequency (in GHz)",
-        "MetricExpr": "(( CPU_CLK_UNHALTED.THREAD / CPU_CLK_UNHALTED.REF_T=
SC * #SYSTEM_TSC_FREQ ) / 1000000000) / duration_time",
-        "MetricGroup": "",
-        "MetricName": "cpu_operating_frequency",
-        "ScaleUnit": "1GHz"
+        "BriefDescription": "This metric represents fraction of cycles CPU=
 executed total of 2 uops per cycle on all execution ports (Logical Process=
or cycles since ICL, Physical Core cycles otherwise)",
+        "MetricExpr": "((cpu@UOPS_EXECUTED.CORE\\,cmask\\=3D0x2@ - cpu@UOP=
S_EXECUTED.CORE\\,cmask\\=3D0x3@) / 2 if #SMT_on else UOPS_EXECUTED.CYCLES_=
GE_2_UOPS_EXEC - UOPS_EXECUTED.CYCLES_GE_3_UOPS_EXEC) / CORE_CLKS",
+        "MetricGroup": "PortsUtil;TopdownL4;tma_L4_group;tma_ports_utiliza=
tion_group",
+        "MetricName": "tma_ports_utilized_2",
+        "PublicDescription": "This metric represents fraction of cycles CP=
U executed total of 2 uops per cycle on all execution ports (Logical Proces=
sor cycles since ICL, Physical Core cycles otherwise).  Loop Vectorization =
-most compilers feature auto-Vectorization options today- reduces pressure =
on the execution ports as multiple elements are calculated with same uop.",
+        "ScaleUnit": "100%"
     },
     {
-        "BriefDescription": "The ratio of number of completed memory load =
instructions to the total number completed instructions",
-        "MetricExpr": "MEM_UOPS_RETIRED.ALL_LOADS / INST_RETIRED.ANY",
-        "MetricGroup": "",
-        "MetricName": "loads_per_instr",
-        "ScaleUnit": "1per_instr"
+        "BriefDescription": "This metric represents fraction of cycles CPU=
 executed total of 3 or more uops per cycle on all execution ports (Logical=
 Processor cycles since ICL, Physical Core cycles otherwise).",
+        "MetricExpr": "(cpu@UOPS_EXECUTED.CORE\\,cmask\\=3D0x3@ / 2 if #SM=
T_on else UOPS_EXECUTED.CYCLES_GE_3_UOPS_EXEC) / CORE_CLKS",
+        "MetricGroup": "PortsUtil;TopdownL4;tma_L4_group;tma_ports_utiliza=
tion_group",
+        "MetricName": "tma_ports_utilized_3m",
+        "ScaleUnit": "100%"
     },
     {
-        "BriefDescription": "The ratio of number of completed memory store=
 instructions to the total number completed instructions",
-        "MetricExpr": "MEM_UOPS_RETIRED.ALL_STORES / INST_RETIRED.ANY",
-        "MetricGroup": "",
-        "MetricName": "stores_per_instr",
-        "ScaleUnit": "1per_instr"
+        "BriefDescription": "This metric represents Core fraction of cycle=
s CPU dispatched uops on execution ports for ALU operations.",
+        "MetricExpr": "(UOPS_DISPATCHED_PORT.PORT_0 + UOPS_DISPATCHED_PORT=
.PORT_1 + UOPS_DISPATCHED_PORT.PORT_5 + UOPS_DISPATCHED_PORT.PORT_6) / SLOT=
S",
+        "MetricGroup": "TopdownL5;tma_L5_group;tma_ports_utilized_3m_group=
",
+        "MetricName": "tma_alu_op_utilization",
+        "ScaleUnit": "100%"
     },
     {
-        "BriefDescription": "Ratio of number of requests missing L1 data c=
ache (includes data+rfo w/ prefetches) to the total number of completed ins=
tructions",
-        "MetricExpr": "L1D.REPLACEMENT / INST_RETIRED.ANY",
-        "MetricGroup": "",
-        "MetricName": "l1d_mpi",
-        "ScaleUnit": "1per_instr"
+        "BriefDescription": "This metric represents Core fraction of cycle=
s CPU dispatched uops on execution port 0 ([SNB+] ALU; [HSW+] ALU and 2nd b=
ranch)",
+        "MetricExpr": "UOPS_DISPATCHED_PORT.PORT_0 / CORE_CLKS",
+        "MetricGroup": "Compute;TopdownL6;tma_L6_group;tma_alu_op_utilizat=
ion_group",
+        "MetricName": "tma_port_0",
+        "ScaleUnit": "100%"
     },
     {
-        "BriefDescription": "Ratio of number of demand load requests hitti=
ng in L1 data cache to the total number of completed instructions",
-        "MetricExpr": "MEM_LOAD_UOPS_RETIRED.L1_HIT / INST_RETIRED.ANY",
-        "MetricGroup": "",
-        "MetricName": "l1d_demand_data_read_hits_per_instr",
-        "ScaleUnit": "1per_instr"
+        "BriefDescription": "This metric represents Core fraction of cycle=
s CPU dispatched uops on execution port 1 (ALU)",
+        "MetricExpr": "UOPS_DISPATCHED_PORT.PORT_1 / CORE_CLKS",
+        "MetricGroup": "TopdownL6;tma_L6_group;tma_alu_op_utilization_grou=
p",
+        "MetricName": "tma_port_1",
+        "ScaleUnit": "100%"
     },
     {
-        "BriefDescription": "Ratio of number of code read requests missing=
 in L1 instruction cache (includes prefetches) to the total number of compl=
eted instructions",
-        "MetricExpr": "L2_RQSTS.ALL_CODE_RD / INST_RETIRED.ANY",
-        "MetricGroup": "",
-        "MetricName": "l1_i_code_read_misses_with_prefetches_per_instr",
-        "ScaleUnit": "1per_instr"
+        "BriefDescription": "This metric represents Core fraction of cycle=
s CPU dispatched uops on execution port 5 ([SNB+] Branches and ALU; [HSW+] =
ALU)",
+        "MetricExpr": "UOPS_DISPATCHED_PORT.PORT_5 / CORE_CLKS",
+        "MetricGroup": "TopdownL6;tma_L6_group;tma_alu_op_utilization_grou=
p",
+        "MetricName": "tma_port_5",
+        "ScaleUnit": "100%"
     },
     {
-        "BriefDescription": "Ratio of number of completed demand load requ=
ests hitting in L2 cache to the total number of completed instructions",
-        "MetricExpr": "MEM_LOAD_UOPS_RETIRED.L2_HIT / INST_RETIRED.ANY",
-        "MetricGroup": "",
-        "MetricName": "l2_demand_data_read_hits_per_instr",
-        "ScaleUnit": "1per_instr"
+        "BriefDescription": "This metric represents Core fraction of cycle=
s CPU dispatched uops on execution port 6 ([HSW+]Primary Branch and simple =
ALU)",
+        "MetricExpr": "UOPS_DISPATCHED_PORT.PORT_6 / CORE_CLKS",
+        "MetricGroup": "TopdownL6;tma_L6_group;tma_alu_op_utilization_grou=
p",
+        "MetricName": "tma_port_6",
+        "ScaleUnit": "100%"
     },
     {
-        "BriefDescription": "Ratio of number of requests missing L2 cache =
(includes code+data+rfo w/ prefetches) to the total number of completed ins=
tructions",
-        "MetricExpr": "L2_LINES_IN.ALL / INST_RETIRED.ANY",
-        "MetricGroup": "",
-        "MetricName": "l2_mpi",
-        "ScaleUnit": "1per_instr"
+        "BriefDescription": "This metric represents Core fraction of cycle=
s CPU dispatched uops on execution port for Load operations",
+        "MetricExpr": "(UOPS_DISPATCHED_PORT.PORT_2 + UOPS_DISPATCHED_PORT=
.PORT_3 + UOPS_DISPATCHED_PORT.PORT_7 - UOPS_DISPATCHED_PORT.PORT_4) / (2 *=
 CORE_CLKS)",
+        "MetricGroup": "TopdownL5;tma_L5_group;tma_ports_utilized_3m_group=
",
+        "MetricName": "tma_load_op_utilization",
+        "ScaleUnit": "100%"
     },
     {
-        "BriefDescription": "Ratio of number of completed data read reques=
t missing L2 cache to the total number of completed instructions",
-        "MetricExpr": "MEM_LOAD_UOPS_RETIRED.L2_MISS / INST_RETIRED.ANY",
-        "MetricGroup": "",
-        "MetricName": "l2_demand_data_read_mpi",
-        "ScaleUnit": "1per_instr"
+        "BriefDescription": "This metric represents Core fraction of cycle=
s CPU dispatched uops on execution port 2 ([SNB+]Loads and Store-address; [=
ICL+] Loads)",
+        "MetricExpr": "UOPS_DISPATCHED_PORT.PORT_2 / CORE_CLKS",
+        "MetricGroup": "TopdownL6;tma_L6_group;tma_load_op_utilization_gro=
up",
+        "MetricName": "tma_port_2",
+        "ScaleUnit": "100%"
     },
     {
-        "BriefDescription": "Ratio of number of code read request missing =
L2 cache to the total number of completed instructions",
-        "MetricExpr": "L2_RQSTS.CODE_RD_MISS / INST_RETIRED.ANY",
-        "MetricGroup": "",
-        "MetricName": "l2_demand_code_mpi",
-        "ScaleUnit": "1per_instr"
+        "BriefDescription": "This metric represents Core fraction of cycle=
s CPU dispatched uops on execution port 3 ([SNB+]Loads and Store-address; [=
ICL+] Loads)",
+        "MetricExpr": "UOPS_DISPATCHED_PORT.PORT_3 / CORE_CLKS",
+        "MetricGroup": "TopdownL6;tma_L6_group;tma_load_op_utilization_gro=
up",
+        "MetricName": "tma_port_3",
+        "ScaleUnit": "100%"
     },
     {
-        "BriefDescription": "Ratio of number of data read requests missing=
 last level core cache (includes demand w/ prefetches) to the total number =
of completed instructions",
-        "MetricExpr": "( cbox@UNC_C_TOR_INSERTS.MISS_OPCODE\\,filter_opc\\=
=3D0x182@ + cbox@UNC_C_TOR_INSERTS.MISS_OPCODE\\,filter_opc\\=3D0x192@ ) / =
INST_RETIRED.ANY",
-        "MetricGroup": "",
-        "MetricName": "llc_data_read_mpi_demand_plus_prefetch",
-        "ScaleUnit": "1per_instr"
+        "BriefDescription": "This metric represents Core fraction of cycle=
s CPU dispatched uops on execution port for Store operations",
+        "MetricExpr": "UOPS_DISPATCHED_PORT.PORT_4 / CORE_CLKS",
+        "MetricGroup": "TopdownL5;tma_L5_group;tma_ports_utilized_3m_group=
",
+        "MetricName": "tma_store_op_utilization",
+        "ScaleUnit": "100%"
     },
     {
-        "BriefDescription": "Ratio of number of code read requests missing=
 last level core cache (includes demand w/ prefetches) to the total number =
of completed instructions",
-        "MetricExpr": "( cbox@UNC_C_TOR_INSERTS.MISS_OPCODE\\,filter_opc\\=
=3D0x181@ + cbox@UNC_C_TOR_INSERTS.MISS_OPCODE\\,filter_opc\\=3D0x191@ ) / =
INST_RETIRED.ANY",
-        "MetricGroup": "",
-        "MetricName": "llc_code_read_mpi_demand_plus_prefetch",
-        "ScaleUnit": "1per_instr"
+        "BriefDescription": "This metric represents Core fraction of cycle=
s CPU dispatched uops on execution port 4 (Store-data)",
+        "MetricExpr": "tma_store_op_utilization",
+        "MetricGroup": "TopdownL6;tma_L6_group;tma_store_op_utilization_gr=
oup",
+        "MetricName": "tma_port_4",
+        "ScaleUnit": "100%"
     },
     {
-        "BriefDescription": "Average latency of a last level cache (LLC) d=
emand and prefetch data read miss (read memory access) in nano seconds",
-        "MetricExpr": "( 1000000000 * ( cbox@UNC_C_TOR_OCCUPANCY.MISS_OPCO=
DE\\,filter_opc\\=3D0x182@ / cbox@UNC_C_TOR_INSERTS.MISS_OPCODE\\,filter_op=
c\\=3D0x182@ ) / ( UNC_C_CLOCKTICKS / ( #num_cores / #num_packages * #num_p=
ackages ) ) ) * duration_time",
-        "MetricGroup": "",
-        "MetricName": "llc_data_read_demand_plus_prefetch_miss_latency",
-        "ScaleUnit": "1ns"
+        "BriefDescription": "This metric represents Core fraction of cycle=
s CPU dispatched uops on execution port 7 ([HSW+]simple Store-address)",
+        "MetricExpr": "UOPS_DISPATCHED_PORT.PORT_7 / CORE_CLKS",
+        "MetricGroup": "TopdownL6;tma_L6_group;tma_store_op_utilization_gr=
oup",
+        "MetricName": "tma_port_7",
+        "ScaleUnit": "100%"
     },
     {
-        "BriefDescription": "Average latency of a last level cache (LLC) d=
emand and prefetch data read miss (read memory access) addressed to local m=
emory in nano seconds",
-        "MetricExpr": "( 1000000000 * ( cbox@UNC_C_TOR_OCCUPANCY.MISS_LOCA=
L_OPCODE\\,filter_opc\\=3D0x182@ / cbox@UNC_C_TOR_INSERTS.MISS_LOCAL_OPCODE=
\\,filter_opc\\=3D0x182@ ) / ( UNC_C_CLOCKTICKS / ( #num_cores / #num_packa=
ges * #num_packages ) ) ) * duration_time",
-        "MetricGroup": "",
-        "MetricName": "llc_data_read_demand_plus_prefetch_miss_latency_for=
_local_requests",
-        "ScaleUnit": "1ns"
+        "BriefDescription": "This category represents fraction of slots ut=
ilized by useful work i.e. issued uops that eventually get retired",
+        "MetricExpr": "UOPS_RETIRED.RETIRE_SLOTS / SLOTS",
+        "MetricGroup": "TopdownL1;tma_L1_group;tma_L1_group",
+        "MetricName": "tma_retiring",
+        "PublicDescription": "This category represents fraction of slots u=
tilized by useful work i.e. issued uops that eventually get retired. Ideall=
y; all pipeline slots would be attributed to the Retiring category.  Retiri=
ng of 100% would indicate the maximum Pipeline_Width throughput was achieve=
d.  Maximizing Retiring typically increases the Instructions-per-cycle (see=
 IPC metric). Note that a high Retiring value does not necessary mean there=
 is no room for more performance.  For example; Heavy-operations or Microco=
de Assists are categorized under Retiring. They often indicate suboptimal p=
erformance and can often be optimized or avoided. ",
+        "ScaleUnit": "100%"
     },
     {
-        "BriefDescription": "Average latency of a last level cache (LLC) d=
emand and prefetch data read miss (read memory access) addressed to remote =
memory in nano seconds",
-        "MetricExpr": "( 1000000000 * ( cbox@UNC_C_TOR_OCCUPANCY.MISS_REMO=
TE_OPCODE\\,filter_opc\\=3D0x182@ / cbox@UNC_C_TOR_INSERTS.MISS_REMOTE_OPCO=
DE\\,filter_opc\\=3D0x182@ ) / ( UNC_C_CLOCKTICKS / ( #num_cores / #num_pac=
kages * #num_packages ) ) ) * duration_time",
-        "MetricGroup": "",
-        "MetricName": "llc_data_read_demand_plus_prefetch_miss_latency_for=
_remote_requests",
-        "ScaleUnit": "1ns"
+        "BriefDescription": "This metric represents fraction of slots wher=
e the CPU was retiring light-weight operations -- instructions that require=
 no more than one uop (micro-operation)",
+        "MetricExpr": "tma_retiring - UOPS_RETIRED.RETIRE_SLOTS / UOPS_ISS=
UED.ANY * IDQ.MS_UOPS / SLOTS",
+        "MetricGroup": "Retire;TopdownL2;tma_L2_group;tma_L2_group;tma_ret=
iring_group",
+        "MetricName": "tma_light_operations",
+        "PublicDescription": "This metric represents fraction of slots whe=
re the CPU was retiring light-weight operations -- instructions that requir=
e no more than one uop (micro-operation). This correlates with total number=
 of instructions used by the program. A uops-per-instruction (see UPI metri=
c) ratio of 1 or less should be expected for decently optimized software ru=
nning on Intel Core/Xeon products. While this often indicates efficient X86=
 instructions were executed; high value does not necessarily mean better pe=
rformance cannot be achieved.",
+        "ScaleUnit": "100%"
     },
     {
-        "BriefDescription": "Ratio of number of completed page walks (for =
all page sizes) caused by a code fetch to the total number of completed ins=
tructions. This implies it missed in the ITLB (Instruction TLB) and further=
 levels of TLB.",
-        "MetricExpr": "ITLB_MISSES.WALK_COMPLETED / INST_RETIRED.ANY",
-        "MetricGroup": "",
-        "MetricName": "itlb_mpi",
-        "ScaleUnit": "1per_instr"
+        "BriefDescription": "This metric represents overall arithmetic flo=
ating-point (FP) operations fraction the CPU has executed (retired)",
+        "MetricExpr": "INST_RETIRED.X87 * UPI / UOPS_RETIRED.RETIRE_SLOTS =
+ tma_fp_scalar + tma_fp_vector",
+        "MetricGroup": "HPC;TopdownL3;tma_L3_group;tma_light_operations_gr=
oup",
+        "MetricName": "tma_fp_arith",
+        "PublicDescription": "This metric represents overall arithmetic fl=
oating-point (FP) operations fraction the CPU has executed (retired). Note =
this metric's value may exceed its parent due to use of \"Uops\" CountDomai=
n and FMA double-counting.",
+        "ScaleUnit": "100%"
     },
     {
-        "BriefDescription": "Ratio of number of completed page walks (for =
2 megabyte and 4 megabyte page sizes) caused by a code fetch to the total n=
umber of completed instructions. This implies it missed in the Instruction =
Translation Lookaside Buffer (ITLB) and further levels of TLB.",
-        "MetricExpr": "ITLB_MISSES.WALK_COMPLETED_2M_4M / INST_RETIRED.ANY=
",
-        "MetricGroup": "",
-        "MetricName": "itlb_large_page_mpi",
-        "ScaleUnit": "1per_instr"
+        "BriefDescription": "This metric serves as an approximation of leg=
acy x87 usage",
+        "MetricExpr": "INST_RETIRED.X87 * UPI / UOPS_RETIRED.RETIRE_SLOTS"=
,
+        "MetricGroup": "Compute;TopdownL4;tma_L4_group;tma_fp_arith_group"=
,
+        "MetricName": "tma_x87_use",
+        "PublicDescription": "This metric serves as an approximation of le=
gacy x87 usage. It accounts for instructions beyond X87 FP arithmetic opera=
tions; hence may be used as a thermometer to avoid X87 high usage and prefe=
rably upgrade to modern ISA. See Tip under Tuning Hint.",
+        "ScaleUnit": "100%"
     },
     {
-        "BriefDescription": "Ratio of number of completed page walks (for =
all page sizes) caused by demand data loads to the total number of complete=
d instructions. This implies it missed in the DTLB and further levels of TL=
B.",
-        "MetricExpr": "DTLB_LOAD_MISSES.WALK_COMPLETED / INST_RETIRED.ANY"=
,
-        "MetricGroup": "",
-        "MetricName": "dtlb_load_mpi",
-        "ScaleUnit": "1per_instr"
+        "BriefDescription": "This metric approximates arithmetic floating-=
point (FP) scalar uops fraction the CPU has retired",
+        "MetricExpr": "(FP_ARITH_INST_RETIRED.SCALAR_SINGLE + FP_ARITH_INS=
T_RETIRED.SCALAR_DOUBLE) / UOPS_RETIRED.RETIRE_SLOTS",
+        "MetricGroup": "Compute;Flops;TopdownL4;tma_L4_group;tma_fp_arith_=
group",
+        "MetricName": "tma_fp_scalar",
+        "PublicDescription": "This metric approximates arithmetic floating=
-point (FP) scalar uops fraction the CPU has retired. May overcount due to =
FMA double counting.",
+        "ScaleUnit": "100%"
     },
     {
-        "BriefDescription": "Ratio of number of completed page walks (for =
all page sizes) caused by demand data stores to the total number of complet=
ed instructions. This implies it missed in the DTLB and further levels of T=
LB.",
-        "MetricExpr": "DTLB_STORE_MISSES.WALK_COMPLETED / INST_RETIRED.ANY=
",
-        "MetricGroup": "",
-        "MetricName": "dtlb_store_mpi",
-        "ScaleUnit": "1per_instr"
+        "BriefDescription": "This metric approximates arithmetic floating-=
point (FP) vector uops fraction the CPU has retired aggregated across all v=
ector widths",
+        "MetricExpr": "min((FP_ARITH_INST_RETIRED.128B_PACKED_DOUBLE + FP_=
ARITH_INST_RETIRED.128B_PACKED_SINGLE + FP_ARITH_INST_RETIRED.256B_PACKED_D=
OUBLE + FP_ARITH_INST_RETIRED.256B_PACKED_SINGLE) / UOPS_RETIRED.RETIRE_SLO=
TS, 1)",
+        "MetricGroup": "Compute;Flops;TopdownL4;tma_L4_group;tma_fp_arith_=
group",
+        "MetricName": "tma_fp_vector",
+        "PublicDescription": "This metric approximates arithmetic floating=
-point (FP) vector uops fraction the CPU has retired aggregated across all =
vector widths. May overcount due to FMA double counting.",
+        "ScaleUnit": "100%"
     },
     {
-        "BriefDescription": "Memory read that miss the last level cache (L=
LC) addressed to local DRAM as a percentage of total memory read accesses, =
does not include LLC prefetches.",
-        "MetricExpr": "100 * cbox@UNC_C_TOR_INSERTS.MISS_LOCAL_OPCODE\\,fi=
lter_opc\\=3D0x182@ / ( cbox@UNC_C_TOR_INSERTS.MISS_LOCAL_OPCODE\\,filter_o=
pc\\=3D0x182@ + cbox@UNC_C_TOR_INSERTS.MISS_REMOTE_OPCODE\\,filter_opc\\=3D=
0x182@ )",
-        "MetricGroup": "",
-        "MetricName": "numa_reads_addressed_to_local_dram",
-        "ScaleUnit": "1%"
+        "BriefDescription": "This metric approximates arithmetic FP vector=
 uops fraction the CPU has retired for 128-bit wide vectors",
+        "MetricExpr": "min((FP_ARITH_INST_RETIRED.128B_PACKED_DOUBLE + FP_=
ARITH_INST_RETIRED.128B_PACKED_SINGLE) / UOPS_RETIRED.RETIRE_SLOTS, 1)",
+        "MetricGroup": "Compute;Flops;TopdownL5;tma_L5_group;tma_fp_vector=
_group",
+        "MetricName": "tma_fp_vector_128b",
+        "PublicDescription": "This metric approximates arithmetic FP vecto=
r uops fraction the CPU has retired for 128-bit wide vectors. May overcount=
 due to FMA double counting.",
+        "ScaleUnit": "100%"
     },
     {
-        "BriefDescription": "Memory reads that miss the last level cache (=
LLC) addressed to remote DRAM as a percentage of total memory read accesses=
, does not include LLC prefetches.",
-        "MetricExpr": "100 * cbox@UNC_C_TOR_INSERTS.MISS_REMOTE_OPCODE\\,f=
ilter_opc\\=3D0x182@ / ( cbox@UNC_C_TOR_INSERTS.MISS_LOCAL_OPCODE\\,filter_=
opc\\=3D0x182@ + cbox@UNC_C_TOR_INSERTS.MISS_REMOTE_OPCODE\\,filter_opc\\=
=3D0x182@ )",
-        "MetricGroup": "",
-        "MetricName": "numa_reads_addressed_to_remote_dram",
-        "ScaleUnit": "1%"
+        "BriefDescription": "This metric approximates arithmetic FP vector=
 uops fraction the CPU has retired for 256-bit wide vectors",
+        "MetricExpr": "min((FP_ARITH_INST_RETIRED.256B_PACKED_DOUBLE + FP_=
ARITH_INST_RETIRED.256B_PACKED_SINGLE) / UOPS_RETIRED.RETIRE_SLOTS, 1)",
+        "MetricGroup": "Compute;Flops;TopdownL5;tma_L5_group;tma_fp_vector=
_group",
+        "MetricName": "tma_fp_vector_256b",
+        "PublicDescription": "This metric approximates arithmetic FP vecto=
r uops fraction the CPU has retired for 256-bit wide vectors. May overcount=
 due to FMA double counting.",
+        "ScaleUnit": "100%"
     },
     {
-        "BriefDescription": "Uncore operating frequency in GHz",
-        "MetricExpr": "( UNC_C_CLOCKTICKS / ( #num_cores / #num_packages *=
 #num_packages ) / 1000000000) / duration_time",
-        "MetricGroup": "",
-        "MetricName": "uncore_frequency",
-        "ScaleUnit": "1GHz"
+        "BriefDescription": "This metric represents fraction of slots wher=
e the CPU was retiring heavy-weight operations -- instructions that require=
 two or more uops or microcoded sequences",
+        "MetricExpr": "UOPS_RETIRED.RETIRE_SLOTS / UOPS_ISSUED.ANY * IDQ.M=
S_UOPS / SLOTS",
+        "MetricGroup": "Retire;TopdownL2;tma_L2_group;tma_L2_group;tma_ret=
iring_group",
+        "MetricName": "tma_heavy_operations",
+        "PublicDescription": "This metric represents fraction of slots whe=
re the CPU was retiring heavy-weight operations -- instructions that requir=
e two or more uops or microcoded sequences. This highly-correlates with the=
 uop length of these instructions/sequences.",
+        "ScaleUnit": "100%"
     },
     {
-        "BriefDescription": "Intel(R) Quick Path Interconnect (QPI) data t=
ransmit bandwidth (MB/sec)",
-        "MetricExpr": "( UNC_Q_TxL_FLITS_G0.DATA * 8 / 1000000) / duration=
_time",
-        "MetricGroup": "",
-        "MetricName": "qpi_data_transmit_bw",
-        "ScaleUnit": "1MB/s"
+        "BriefDescription": "This metric represents fraction of slots the =
CPU was retiring uops fetched by the Microcode Sequencer (MS) unit",
+        "MetricExpr": "tma_heavy_operations",
+        "MetricGroup": "MicroSeq;TopdownL3;tma_L3_group;tma_heavy_operatio=
ns_group",
+        "MetricName": "tma_microcode_sequencer",
+        "PublicDescription": "This metric represents fraction of slots the=
 CPU was retiring uops fetched by the Microcode Sequencer (MS) unit.  The M=
S is used for CISC instructions not supported by the default decoders (like=
 repeat move strings; or CPUID); or by microcode assists used to address so=
me operation modes (like in Floating Point assists). These cases can often =
be avoided.",
+        "ScaleUnit": "100%"
     },
     {
-        "BriefDescription": "DDR memory read bandwidth (MB/sec)",
-        "MetricExpr": "( UNC_M_CAS_COUNT.RD * 64 / 1000000) / duration_tim=
e",
-        "MetricGroup": "",
-        "MetricName": "memory_bandwidth_read",
-        "ScaleUnit": "1MB/s"
+        "BriefDescription": "This metric estimates fraction of slots the C=
PU retired uops delivered by the Microcode_Sequencer as a result of Assists=
",
+        "MetricExpr": "min(100 * OTHER_ASSISTS.ANY_WB_ASSIST / SLOTS, 1)",
+        "MetricGroup": "TopdownL4;tma_L4_group;tma_microcode_sequencer_gro=
up",
+        "MetricName": "tma_assists",
+        "PublicDescription": "This metric estimates fraction of slots the =
CPU retired uops delivered by the Microcode_Sequencer as a result of Assist=
s. Assists are long sequences of uops that are required in certain corner-c=
ases for operations that cannot be handled natively by the execution pipeli=
ne. For example; when working with very small floating point values (so-cal=
led Denormals); the FP units are not set up to perform these operations nat=
ively. Instead; a sequence of instructions to perform the computation on th=
e Denormals is injected into the pipeline. Since these microcode sequences =
might be dozens of uops long; Assists can be extremely deleterious to perfo=
rmance and they can be avoided in many cases.",
+        "ScaleUnit": "100%"
     },
     {
-        "BriefDescription": "DDR memory write bandwidth (MB/sec)",
-        "MetricExpr": "( UNC_M_CAS_COUNT.WR * 64 / 1000000) / duration_tim=
e",
-        "MetricGroup": "",
-        "MetricName": "memory_bandwidth_write",
-        "ScaleUnit": "1MB/s"
+        "BriefDescription": "This metric estimates fraction of cycles the =
CPU retired uops originated from CISC (complex instruction set computer) in=
struction",
+        "MetricExpr": "max(0, tma_heavy_operations - tma_assists)",
+        "MetricGroup": "TopdownL4;tma_L4_group;tma_microcode_sequencer_gro=
up",
+        "MetricName": "tma_cisc",
+        "PublicDescription": "This metric estimates fraction of cycles the=
 CPU retired uops originated from CISC (complex instruction set computer) i=
nstruction. A CISC instruction has multiple uops that are required to perfo=
rm the instruction's functionality as in the case of read-modify-write as a=
n example. Since these instructions require multiple uops they may or may n=
ot imply sub-optimal use of machine resources.",
+        "ScaleUnit": "100%"
     },
     {
-        "BriefDescription": "DDR memory bandwidth (MB/sec)",
-        "MetricExpr": "(( UNC_M_CAS_COUNT.RD + UNC_M_CAS_COUNT.WR ) * 64 /=
 1000000) / duration_time",
-        "MetricGroup": "",
-        "MetricName": "memory_bandwidth_total",
-        "ScaleUnit": "1MB/s"
+        "BriefDescription": "C3 residency percent per core",
+        "MetricExpr": "cstate_core@c3\\-residency@ / TSC",
+        "MetricGroup": "Power",
+        "MetricName": "C3_Core_Residency",
+        "ScaleUnit": "100%"
     },
     {
-        "BriefDescription": "Bandwidth of IO reads that are initiated by e=
nd device controllers that are requesting memory from the CPU.",
-        "MetricExpr": "( cbox@UNC_C_TOR_INSERTS.OPCODE\\,filter_opc\\=3D0x=
19e@ * 64 / 1000000) / duration_time",
-        "MetricGroup": "",
-        "MetricName": "io_bandwidth_disk_or_network_writes",
-        "ScaleUnit": "1MB/s"
+        "BriefDescription": "C6 residency percent per core",
+        "MetricExpr": "cstate_core@c6\\-residency@ / TSC",
+        "MetricGroup": "Power",
+        "MetricName": "C6_Core_Residency",
+        "ScaleUnit": "100%"
     },
     {
-        "BriefDescription": "Bandwidth of IO writes that are initiated by =
end device controllers that are writing memory to the CPU.",
-        "MetricExpr": "(( cbox@UNC_C_TOR_INSERTS.OPCODE\\,filter_opc\\=3D0=
x1c8\\,filter_tid\\=3D0x3e@ + cbox@UNC_C_TOR_INSERTS.OPCODE\\,filter_opc\\=
=3D0x180\\,filter_tid\\=3D0x3e@ ) * 64 / 1000000) / duration_time",
-        "MetricGroup": "",
-        "MetricName": "io_bandwidth_disk_or_network_reads",
-        "ScaleUnit": "1MB/s"
+        "BriefDescription": "C7 residency percent per core",
+        "MetricExpr": "cstate_core@c7\\-residency@ / TSC",
+        "MetricGroup": "Power",
+        "MetricName": "C7_Core_Residency",
+        "ScaleUnit": "100%"
     },
     {
-        "BriefDescription": "Uops delivered from decoded instruction cache=
 (decoded stream buffer or DSB) as a percent of total uops delivered to Ins=
truction Decode Queue",
-        "MetricExpr": "100 * ( IDQ.DSB_UOPS / UOPS_ISSUED.ANY )",
-        "MetricGroup": "",
-        "MetricName": "percent_uops_delivered_from_decoded_icache",
-        "ScaleUnit": "1%"
+        "BriefDescription": "C2 residency percent per package",
+        "MetricExpr": "cstate_pkg@c2\\-residency@ / TSC",
+        "MetricGroup": "Power",
+        "MetricName": "C2_Pkg_Residency",
+        "ScaleUnit": "100%"
     },
     {
-        "BriefDescription": "Uops delivered from legacy decode pipeline (M=
icro-instruction Translation Engine or MITE) as a percent of total uops del=
ivered to Instruction Decode Queue",
-        "MetricExpr": "100 * ( IDQ.MITE_UOPS / UOPS_ISSUED.ANY )",
-        "MetricGroup": "",
-        "MetricName": "percent_uops_delivered_from_legacy_decode_pipeline"=
,
-        "ScaleUnit": "1%"
+        "BriefDescription": "C3 residency percent per package",
+        "MetricExpr": "cstate_pkg@c3\\-residency@ / TSC",
+        "MetricGroup": "Power",
+        "MetricName": "C3_Pkg_Residency",
+        "ScaleUnit": "100%"
     },
     {
-        "BriefDescription": "Uops delivered from microcode sequencer (MS) =
as a percent of total uops delivered to Instruction Decode Queue",
-        "MetricExpr": "100 * ( IDQ.MS_UOPS / UOPS_ISSUED.ANY )",
-        "MetricGroup": "",
-        "MetricName": "percent_uops_delivered_from_microcode_sequencer",
-        "ScaleUnit": "1%"
+        "BriefDescription": "C6 residency percent per package",
+        "MetricExpr": "cstate_pkg@c6\\-residency@ / TSC",
+        "MetricGroup": "Power",
+        "MetricName": "C6_Pkg_Residency",
+        "ScaleUnit": "100%"
     },
     {
-        "BriefDescription": "Uops delivered from loop stream detector(LSD)=
 as a percent of total uops delivered to Instruction Decode Queue",
-        "MetricExpr": "100 * ( LSD.UOPS / UOPS_ISSUED.ANY )",
-        "MetricGroup": "",
-        "MetricName": "percent_uops_delivered_from_loop_stream_detector",
-        "ScaleUnit": "1%"
+        "BriefDescription": "C7 residency percent per package",
+        "MetricExpr": "cstate_pkg@c7\\-residency@ / TSC",
+        "MetricGroup": "Power",
+        "MetricName": "C7_Pkg_Residency",
+        "ScaleUnit": "100%"
     }
 ]
diff --git a/tools/perf/pmu-events/arch/x86/broadwellx/cache.json b/tools/p=
erf/pmu-events/arch/x86/broadwellx/cache.json
index 2efc4c0ee740..6a134928b3f0 100644
--- a/tools/perf/pmu-events/arch/x86/broadwellx/cache.json
+++ b/tools/perf/pmu-events/arch/x86/broadwellx/cache.json
@@ -1,8 +1,6 @@
 [
     {
         "BriefDescription": "L1D data line replacements",
-        "Counter": "0,1,2,3",
-        "CounterHTOff": "0,1,2,3,4,5,6,7",
         "EventCode": "0x51",
         "EventName": "L1D.REPLACEMENT",
         "PublicDescription": "This event counts L1D data line replacements=
 including opportunistic replacements, and replacements that require stall-=
for-replace or block-for-replace.",
@@ -11,8 +9,6 @@
     },
     {
         "BriefDescription": "Cycles a demand request was blocked due to Fi=
ll Buffers inavailability.",
-        "Counter": "0,1,2,3",
-        "CounterHTOff": "0,1,2,3,4,5,6,7",
         "CounterMask": "1",
         "EventCode": "0x48",
         "EventName": "L1D_PEND_MISS.FB_FULL",
@@ -21,8 +17,6 @@
     },
     {
         "BriefDescription": "L1D miss oustandings duration in cycles",
-        "Counter": "2",
-        "CounterHTOff": "2",
         "EventCode": "0x48",
         "EventName": "L1D_PEND_MISS.PENDING",
         "PublicDescription": "This event counts duration of L1D miss outst=
anding, that is each cycle number of Fill Buffers (FB) outstanding required=
 by Demand Reads. FB either is held by demand loads, or it is held by non-d=
emand loads and gets hit at least once by demand. The valid outstanding int=
erval is defined until the FB deallocation by one of the following ways: fr=
om FB allocation, if FB is allocated by demand; from the demand Hit FB, if =
it is allocated by hardware or software prefetch.\nNote: In the L1D, a Dema=
nd Read contains cacheable or noncacheable demand loads, including ones cau=
sing cache-line splits and reads due to page walks resulted from any reques=
t type.",
@@ -31,8 +25,6 @@
     },
     {
         "BriefDescription": "Cycles with L1D load Misses outstanding.",
-        "Counter": "2",
-        "CounterHTOff": "2",
         "CounterMask": "1",
         "EventCode": "0x48",
         "EventName": "L1D_PEND_MISS.PENDING_CYCLES",
@@ -43,8 +35,6 @@
     {
         "AnyThread": "1",
         "BriefDescription": "Cycles with L1D load Misses outstanding from =
any thread on physical core.",
-        "Counter": "2",
-        "CounterHTOff": "2",
         "CounterMask": "1",
         "EventCode": "0x48",
         "EventName": "L1D_PEND_MISS.PENDING_CYCLES_ANY",
@@ -53,8 +43,6 @@
     },
     {
         "BriefDescription": "Not rejected writebacks that hit L2 cache",
-        "Counter": "0,1,2,3",
-        "CounterHTOff": "0,1,2,3,4,5,6,7",
         "EventCode": "0x27",
         "EventName": "L2_DEMAND_RQSTS.WB_HIT",
         "PublicDescription": "This event counts the number of WB requests =
that hit L2 cache.",
@@ -63,8 +51,6 @@
     },
     {
         "BriefDescription": "L2 cache lines filling L2",
-        "Counter": "0,1,2,3",
-        "CounterHTOff": "0,1,2,3,4,5,6,7",
         "EventCode": "0xF1",
         "EventName": "L2_LINES_IN.ALL",
         "PublicDescription": "This event counts the number of L2 cache lin=
es filling the L2. Counting does not cover rejects.",
@@ -73,8 +59,6 @@
     },
     {
         "BriefDescription": "L2 cache lines in E state filling L2",
-        "Counter": "0,1,2,3",
-        "CounterHTOff": "0,1,2,3,4,5,6,7",
         "EventCode": "0xF1",
         "EventName": "L2_LINES_IN.E",
         "PublicDescription": "This event counts the number of L2 cache lin=
es in the Exclusive state filling the L2. Counting does not cover rejects."=
,
@@ -83,8 +67,6 @@
     },
     {
         "BriefDescription": "L2 cache lines in I state filling L2",
-        "Counter": "0,1,2,3",
-        "CounterHTOff": "0,1,2,3,4,5,6,7",
         "EventCode": "0xF1",
         "EventName": "L2_LINES_IN.I",
         "PublicDescription": "This event counts the number of L2 cache lin=
es in the Invalidate state filling the L2. Counting does not cover rejects.=
",
@@ -93,8 +75,6 @@
     },
     {
         "BriefDescription": "L2 cache lines in S state filling L2",
-        "Counter": "0,1,2,3",
-        "CounterHTOff": "0,1,2,3,4,5,6,7",
         "EventCode": "0xF1",
         "EventName": "L2_LINES_IN.S",
         "PublicDescription": "This event counts the number of L2 cache lin=
es in the Shared state filling the L2. Counting does not cover rejects.",
@@ -103,8 +83,6 @@
     },
     {
         "BriefDescription": "Clean L2 cache lines evicted by demand.",
-        "Counter": "0,1,2,3",
-        "CounterHTOff": "0,1,2,3,4,5,6,7",
         "EventCode": "0xF2",
         "EventName": "L2_LINES_OUT.DEMAND_CLEAN",
         "SampleAfterValue": "100003",
@@ -112,8 +90,6 @@
     },
     {
         "BriefDescription": "L2 code requests",
-        "Counter": "0,1,2,3",
-        "CounterHTOff": "0,1,2,3,4,5,6,7",
         "EventCode": "0x24",
         "EventName": "L2_RQSTS.ALL_CODE_RD",
         "PublicDescription": "This event counts the total number of L2 cod=
e requests.",
@@ -122,8 +98,6 @@
     },
     {
         "BriefDescription": "Demand Data Read requests",
-        "Counter": "0,1,2,3",
-        "CounterHTOff": "0,1,2,3,4,5,6,7",
         "EventCode": "0x24",
         "EventName": "L2_RQSTS.ALL_DEMAND_DATA_RD",
         "PublicDescription": "This event counts the number of demand Data =
Read requests (including requests from L1D hardware prefetchers). These loa=
ds may hit or miss L2 cache. Only non rejected loads are counted.",
@@ -132,8 +106,6 @@
     },
     {
         "BriefDescription": "Demand requests that miss L2 cache.",
-        "Counter": "0,1,2,3",
-        "CounterHTOff": "0,1,2,3,4,5,6,7",
         "EventCode": "0x24",
         "EventName": "L2_RQSTS.ALL_DEMAND_MISS",
         "SampleAfterValue": "200003",
@@ -141,8 +113,6 @@
     },
     {
         "BriefDescription": "Demand requests to L2 cache.",
-        "Counter": "0,1,2,3",
-        "CounterHTOff": "0,1,2,3,4,5,6,7",
         "EventCode": "0x24",
         "EventName": "L2_RQSTS.ALL_DEMAND_REFERENCES",
         "SampleAfterValue": "200003",
@@ -150,8 +120,6 @@
     },
     {
         "BriefDescription": "Requests from L2 hardware prefetchers",
-        "Counter": "0,1,2,3",
-        "CounterHTOff": "0,1,2,3,4,5,6,7",
         "EventCode": "0x24",
         "EventName": "L2_RQSTS.ALL_PF",
         "PublicDescription": "This event counts the total number of reques=
ts from the L2 hardware prefetchers.",
@@ -160,8 +128,6 @@
     },
     {
         "BriefDescription": "RFO requests to L2 cache",
-        "Counter": "0,1,2,3",
-        "CounterHTOff": "0,1,2,3,4,5,6,7",
         "EventCode": "0x24",
         "EventName": "L2_RQSTS.ALL_RFO",
         "PublicDescription": "This event counts the total number of RFO (r=
ead for ownership) requests to L2 cache. L2 RFO requests include both L1D d=
emand RFO misses as well as L1D RFO prefetches.",
@@ -170,8 +136,6 @@
     },
     {
         "BriefDescription": "L2 cache hits when fetching instructions, cod=
e reads.",
-        "Counter": "0,1,2,3",
-        "CounterHTOff": "0,1,2,3,4,5,6,7",
         "EventCode": "0x24",
         "EventName": "L2_RQSTS.CODE_RD_HIT",
         "SampleAfterValue": "200003",
@@ -179,8 +143,6 @@
     },
     {
         "BriefDescription": "L2 cache misses when fetching instructions.",
-        "Counter": "0,1,2,3",
-        "CounterHTOff": "0,1,2,3,4,5,6,7",
         "EventCode": "0x24",
         "EventName": "L2_RQSTS.CODE_RD_MISS",
         "SampleAfterValue": "200003",
@@ -188,8 +150,6 @@
     },
     {
         "BriefDescription": "Demand Data Read requests that hit L2 cache",
-        "Counter": "0,1,2,3",
-        "CounterHTOff": "0,1,2,3,4,5,6,7",
         "EventCode": "0x24",
         "EventName": "L2_RQSTS.DEMAND_DATA_RD_HIT",
         "PublicDescription": "Counts the number of demand Data Read reques=
ts, initiated by load instructions, that hit L2 cache.",
@@ -198,8 +158,6 @@
     },
     {
         "BriefDescription": "Demand Data Read miss L2, no rejects",
-        "Counter": "0,1,2,3",
-        "CounterHTOff": "0,1,2,3,4,5,6,7",
         "EventCode": "0x24",
         "EventName": "L2_RQSTS.DEMAND_DATA_RD_MISS",
         "PublicDescription": "This event counts the number of demand Data =
Read requests that miss L2 cache. Only not rejected loads are counted.",
@@ -208,8 +166,6 @@
     },
     {
         "BriefDescription": "L2 prefetch requests that hit L2 cache",
-        "Counter": "0,1,2,3",
-        "CounterHTOff": "0,1,2,3,4,5,6,7",
         "EventCode": "0x24",
         "EventName": "L2_RQSTS.L2_PF_HIT",
         "PublicDescription": "This event counts the number of requests fro=
m the L2 hardware prefetchers that hit L2 cache. L3 prefetch new types.",
@@ -218,8 +174,6 @@
     },
     {
         "BriefDescription": "L2 prefetch requests that miss L2 cache",
-        "Counter": "0,1,2,3",
-        "CounterHTOff": "0,1,2,3,4,5,6,7",
         "EventCode": "0x24",
         "EventName": "L2_RQSTS.L2_PF_MISS",
         "PublicDescription": "This event counts the number of requests fro=
m the L2 hardware prefetchers that miss L2 cache.",
@@ -228,8 +182,6 @@
     },
     {
         "BriefDescription": "All requests that miss L2 cache.",
-        "Counter": "0,1,2,3",
-        "CounterHTOff": "0,1,2,3,4,5,6,7",
         "EventCode": "0x24",
         "EventName": "L2_RQSTS.MISS",
         "SampleAfterValue": "200003",
@@ -237,8 +189,6 @@
     },
     {
         "BriefDescription": "All L2 requests.",
-        "Counter": "0,1,2,3",
-        "CounterHTOff": "0,1,2,3,4,5,6,7",
         "EventCode": "0x24",
         "EventName": "L2_RQSTS.REFERENCES",
         "SampleAfterValue": "200003",
@@ -246,8 +196,6 @@
     },
     {
         "BriefDescription": "RFO requests that hit L2 cache.",
-        "Counter": "0,1,2,3",
-        "CounterHTOff": "0,1,2,3,4,5,6,7",
         "EventCode": "0x24",
         "EventName": "L2_RQSTS.RFO_HIT",
         "SampleAfterValue": "200003",
@@ -255,8 +203,6 @@
     },
     {
         "BriefDescription": "RFO requests that miss L2 cache.",
-        "Counter": "0,1,2,3",
-        "CounterHTOff": "0,1,2,3,4,5,6,7",
         "EventCode": "0x24",
         "EventName": "L2_RQSTS.RFO_MISS",
         "SampleAfterValue": "200003",
@@ -264,8 +210,6 @@
     },
     {
         "BriefDescription": "L2 or L3 HW prefetches that access L2 cache",
-        "Counter": "0,1,2,3",
-        "CounterHTOff": "0,1,2,3,4,5,6,7",
         "EventCode": "0xF0",
         "EventName": "L2_TRANS.ALL_PF",
         "PublicDescription": "This event counts L2 or L3 HW prefetches tha=
t access L2 cache including rejects.",
@@ -274,8 +218,6 @@
     },
     {
         "BriefDescription": "Transactions accessing L2 pipe",
-        "Counter": "0,1,2,3",
-        "CounterHTOff": "0,1,2,3,4,5,6,7",
         "EventCode": "0xF0",
         "EventName": "L2_TRANS.ALL_REQUESTS",
         "PublicDescription": "This event counts transactions that access t=
he L2 pipe including snoops, pagewalks, and so on.",
@@ -284,8 +226,6 @@
     },
     {
         "BriefDescription": "L2 cache accesses when fetching instructions"=
,
-        "Counter": "0,1,2,3",
-        "CounterHTOff": "0,1,2,3,4,5,6,7",
         "EventCode": "0xF0",
         "EventName": "L2_TRANS.CODE_RD",
         "PublicDescription": "This event counts the number of L2 cache acc=
esses when fetching instructions.",
@@ -294,8 +234,6 @@
     },
     {
         "BriefDescription": "Demand Data Read requests that access L2 cach=
e",
-        "Counter": "0,1,2,3",
-        "CounterHTOff": "0,1,2,3,4,5,6,7",
         "EventCode": "0xF0",
         "EventName": "L2_TRANS.DEMAND_DATA_RD",
         "PublicDescription": "This event counts Demand Data Read requests =
that access L2 cache, including rejects.",
@@ -304,8 +242,6 @@
     },
     {
         "BriefDescription": "L1D writebacks that access L2 cache",
-        "Counter": "0,1,2,3",
-        "CounterHTOff": "0,1,2,3,4,5,6,7",
         "EventCode": "0xF0",
         "EventName": "L2_TRANS.L1D_WB",
         "PublicDescription": "This event counts L1D writebacks that access=
 L2 cache.",
@@ -314,8 +250,6 @@
     },
     {
         "BriefDescription": "L2 fill requests that access L2 cache",
-        "Counter": "0,1,2,3",
-        "CounterHTOff": "0,1,2,3,4,5,6,7",
         "EventCode": "0xF0",
         "EventName": "L2_TRANS.L2_FILL",
         "PublicDescription": "This event counts L2 fill requests that acce=
ss L2 cache.",
@@ -324,8 +258,6 @@
     },
     {
         "BriefDescription": "L2 writebacks that access L2 cache",
-        "Counter": "0,1,2,3",
-        "CounterHTOff": "0,1,2,3,4,5,6,7",
         "EventCode": "0xF0",
         "EventName": "L2_TRANS.L2_WB",
         "PublicDescription": "This event counts L2 writebacks that access =
L2 cache.",
@@ -334,8 +266,6 @@
     },
     {
         "BriefDescription": "RFO requests that access L2 cache",
-        "Counter": "0,1,2,3",
-        "CounterHTOff": "0,1,2,3,4,5,6,7",
         "EventCode": "0xF0",
         "EventName": "L2_TRANS.RFO",
         "PublicDescription": "This event counts Read for Ownership (RFO) r=
equests that access L2 cache.",
@@ -344,8 +274,6 @@
     },
     {
         "BriefDescription": "Cycles when L1D is locked",
-        "Counter": "0,1,2,3",
-        "CounterHTOff": "0,1,2,3,4,5,6,7",
         "EventCode": "0x63",
         "EventName": "LOCK_CYCLES.CACHE_LOCK_DURATION",
         "PublicDescription": "This event counts the number of cycles when =
the L1D is locked. It is a superset of the 0x1 mask (BUS_LOCK_CLOCKS.BUS_LO=
CK_DURATION).",
@@ -354,8 +282,6 @@
     },
     {
         "BriefDescription": "Core-originated cacheable demand requests mis=
sed L3",
-        "Counter": "0,1,2,3",
-        "CounterHTOff": "0,1,2,3,4,5,6,7",
         "EventCode": "0x2E",
         "EventName": "LONGEST_LAT_CACHE.MISS",
         "PublicDescription": "This event counts core-originated cacheable =
demand requests that miss the last level cache (LLC). Demand requests inclu=
de loads, RFOs, and hardware prefetches from L1D, and instruction fetches f=
rom IFU.",
@@ -364,8 +290,6 @@
     },
     {
         "BriefDescription": "Core-originated cacheable demand requests tha=
t refer to L3",
-        "Counter": "0,1,2,3",
-        "CounterHTOff": "0,1,2,3,4,5,6,7",
         "EventCode": "0x2E",
         "EventName": "LONGEST_LAT_CACHE.REFERENCE",
         "PublicDescription": "This event counts core-originated cacheable =
demand requests that refer to the last level cache (LLC). Demand requests i=
nclude loads, RFOs, and hardware prefetches from L1D, and instruction fetch=
es from IFU.",
@@ -374,8 +298,6 @@
     },
     {
         "BriefDescription": "Retired load uops which data sources were L3 =
and cross-core snoop hits in on-pkg core cache.",
-        "Counter": "0,1,2,3",
-        "CounterHTOff": "0,1,2,3",
         "Data_LA": "1",
         "Errata": "BDM100",
         "EventCode": "0xD2",
@@ -387,8 +309,6 @@
     },
     {
         "BriefDescription": "Retired load uops which data sources were Hit=
M responses from shared L3.",
-        "Counter": "0,1,2,3",
-        "CounterHTOff": "0,1,2,3",
         "Data_LA": "1",
         "Errata": "BDM100",
         "EventCode": "0xD2",
@@ -400,8 +320,6 @@
     },
     {
         "BriefDescription": "Retired load uops which data sources were L3 =
hit and cross-core snoop missed in on-pkg core cache.",
-        "Counter": "0,1,2,3",
-        "CounterHTOff": "0,1,2,3",
         "Data_LA": "1",
         "Errata": "BDM100",
         "EventCode": "0xD2",
@@ -413,8 +331,6 @@
     },
     {
         "BriefDescription": "Retired load uops which data sources were hit=
s in L3 without snoops required.",
-        "Counter": "0,1,2,3",
-        "CounterHTOff": "0,1,2,3",
         "Data_LA": "1",
         "Errata": "BDM100",
         "EventCode": "0xD2",
@@ -426,8 +342,6 @@
     },
     {
         "BriefDescription": "Data from local DRAM either Snoop not needed =
or Snoop Miss (RspI)",
-        "Counter": "0,1,2,3",
-        "CounterHTOff": "0,1,2,3",
         "Data_LA": "1",
         "Errata": "BDE70, BDM100",
         "EventCode": "0xD3",
@@ -439,8 +353,6 @@
     },
     {
         "BriefDescription": "Retired load uop whose Data Source was: remot=
e DRAM either Snoop not needed or Snoop Miss (RspI)",
-        "Counter": "0,1,2,3",
-        "CounterHTOff": "0,1,2,3",
         "Data_LA": "1",
         "Errata": "BDE70",
         "EventCode": "0xD3",
@@ -451,8 +363,6 @@
     },
     {
         "BriefDescription": "Retired load uop whose Data Source was: forwa=
rded from remote cache",
-        "Counter": "0,1,2,3",
-        "CounterHTOff": "0,1,2,3",
         "Data_LA": "1",
         "Errata": "BDE70",
         "EventCode": "0xD3",
@@ -463,8 +373,6 @@
     },
     {
         "BriefDescription": "Retired load uop whose Data Source was: Remot=
e cache HITM",
-        "Counter": "0,1,2,3",
-        "CounterHTOff": "0,1,2,3",
         "Data_LA": "1",
         "Errata": "BDE70",
         "EventCode": "0xD3",
@@ -475,8 +383,6 @@
     },
     {
         "BriefDescription": "Retired load uops which data sources were loa=
d uops missed L1 but hit FB due to preceding miss to the same cache line wi=
th data not ready.",
-        "Counter": "0,1,2,3",
-        "CounterHTOff": "0,1,2,3",
         "Data_LA": "1",
         "EventCode": "0xD1",
         "EventName": "MEM_LOAD_UOPS_RETIRED.HIT_LFB",
@@ -487,8 +393,6 @@
     },
     {
         "BriefDescription": "Retired load uops with L1 cache hits as data =
sources.",
-        "Counter": "0,1,2,3",
-        "CounterHTOff": "0,1,2,3",
         "Data_LA": "1",
         "EventCode": "0xD1",
         "EventName": "MEM_LOAD_UOPS_RETIRED.L1_HIT",
@@ -499,8 +403,6 @@
     },
     {
         "BriefDescription": "Retired load uops misses in L1 cache as data =
sources.",
-        "Counter": "0,1,2,3",
-        "CounterHTOff": "0,1,2,3",
         "Data_LA": "1",
         "EventCode": "0xD1",
         "EventName": "MEM_LOAD_UOPS_RETIRED.L1_MISS",
@@ -511,8 +413,6 @@
     },
     {
         "BriefDescription": "Retired load uops with L2 cache hits as data =
sources.",
-        "Counter": "0,1,2,3",
-        "CounterHTOff": "0,1,2,3",
         "Data_LA": "1",
         "Errata": "BDM35",
         "EventCode": "0xD1",
@@ -524,8 +424,6 @@
     },
     {
         "BriefDescription": "Miss in mid-level (L2) cache. Excludes Unknow=
n data-source.",
-        "Counter": "0,1,2,3",
-        "CounterHTOff": "0,1,2,3",
         "Data_LA": "1",
         "EventCode": "0xD1",
         "EventName": "MEM_LOAD_UOPS_RETIRED.L2_MISS",
@@ -536,8 +434,6 @@
     },
     {
         "BriefDescription": "Retired load uops which data sources were dat=
a hits in L3 without snoops required.",
-        "Counter": "0,1,2,3",
-        "CounterHTOff": "0,1,2,3",
         "Data_LA": "1",
         "Errata": "BDM100",
         "EventCode": "0xD1",
@@ -549,8 +445,6 @@
     },
     {
         "BriefDescription": "Miss in last-level (L3) cache. Excludes Unkno=
wn data-source.",
-        "Counter": "0,1,2,3",
-        "CounterHTOff": "0,1,2,3",
         "Data_LA": "1",
         "Errata": "BDM100, BDE70",
         "EventCode": "0xD1",
@@ -561,8 +455,6 @@
     },
     {
         "BriefDescription": "All retired load uops.",
-        "Counter": "0,1,2,3",
-        "CounterHTOff": "0,1,2,3",
         "Data_LA": "1",
         "EventCode": "0xD0",
         "EventName": "MEM_UOPS_RETIRED.ALL_LOADS",
@@ -573,12 +465,9 @@
     },
     {
         "BriefDescription": "All retired store uops.",
-        "Counter": "0,1,2,3",
-        "CounterHTOff": "0,1,2,3",
         "Data_LA": "1",
         "EventCode": "0xD0",
         "EventName": "MEM_UOPS_RETIRED.ALL_STORES",
-        "L1_Hit_Indication": "1",
         "PEBS": "1",
         "PublicDescription": "This event counts store uops retired to the =
architected path with a filter on bits 0 and 1 applied.\nNote: This event c=
ounts AVX-256bit load/store double-pump memory uops as a single uop at reti=
rement.",
         "SampleAfterValue": "2000003",
@@ -586,8 +475,6 @@
     },
     {
         "BriefDescription": "Retired load uops with locked access.",
-        "Counter": "0,1,2,3",
-        "CounterHTOff": "0,1,2,3",
         "Data_LA": "1",
         "Errata": "BDM35",
         "EventCode": "0xD0",
@@ -599,8 +486,6 @@
     },
     {
         "BriefDescription": "Retired load uops that split across a cacheli=
ne boundary.",
-        "Counter": "0,1,2,3",
-        "CounterHTOff": "0,1,2,3",
         "Data_LA": "1",
         "EventCode": "0xD0",
         "EventName": "MEM_UOPS_RETIRED.SPLIT_LOADS",
@@ -611,12 +496,9 @@
     },
     {
         "BriefDescription": "Retired store uops that split across a cachel=
ine boundary.",
-        "Counter": "0,1,2,3",
-        "CounterHTOff": "0,1,2,3",
         "Data_LA": "1",
         "EventCode": "0xD0",
         "EventName": "MEM_UOPS_RETIRED.SPLIT_STORES",
-        "L1_Hit_Indication": "1",
         "PEBS": "1",
         "PublicDescription": "This event counts line-splitted store uops r=
etired to the architected path. A line split is across 64B cache-line which=
 includes a page split (4K).",
         "SampleAfterValue": "100003",
@@ -624,8 +506,6 @@
     },
     {
         "BriefDescription": "Retired load uops that miss the STLB.",
-        "Counter": "0,1,2,3",
-        "CounterHTOff": "0,1,2,3",
         "Data_LA": "1",
         "EventCode": "0xD0",
         "EventName": "MEM_UOPS_RETIRED.STLB_MISS_LOADS",
@@ -636,12 +516,9 @@
     },
     {
         "BriefDescription": "Retired store uops that miss the STLB.",
-        "Counter": "0,1,2,3",
-        "CounterHTOff": "0,1,2,3",
         "Data_LA": "1",
         "EventCode": "0xD0",
         "EventName": "MEM_UOPS_RETIRED.STLB_MISS_STORES",
-        "L1_Hit_Indication": "1",
         "PEBS": "1",
         "PublicDescription": "This event counts store uops with true STLB =
miss retired to the architected path. True STLB miss is an uop triggering p=
age walk that gets completed without blocks, and later gets retired. This p=
age walk can end up with or without a fault.",
         "SampleAfterValue": "100003",
@@ -649,8 +526,6 @@
     },
     {
         "BriefDescription": "Demand and prefetch data reads",
-        "Counter": "0,1,2,3",
-        "CounterHTOff": "0,1,2,3,4,5,6,7",
         "EventCode": "0xB0",
         "EventName": "OFFCORE_REQUESTS.ALL_DATA_RD",
         "PublicDescription": "This event counts the demand and prefetch da=
ta reads. All Core Data Reads include cacheable Demands and L2 prefetchers =
(not L3 prefetchers). Counting also covers reads due to page walks resulted=
 from any request type.",
@@ -659,8 +534,6 @@
     },
     {
         "BriefDescription": "Any memory transaction that reached the SQ.",
-        "Counter": "0,1,2,3",
-        "CounterHTOff": "0,1,2,3,4,5,6,7",
         "EventCode": "0xb0",
         "EventName": "OFFCORE_REQUESTS.ALL_REQUESTS",
         "PublicDescription": "This event counts memory transactions reache=
d the super queue including requests initiated by the core, all L3 prefetch=
es, page walks, and so on.",
@@ -669,8 +542,6 @@
     },
     {
         "BriefDescription": "Cacheable and noncachaeble code read requests=
",
-        "Counter": "0,1,2,3",
-        "CounterHTOff": "0,1,2,3,4,5,6,7",
         "EventCode": "0xB0",
         "EventName": "OFFCORE_REQUESTS.DEMAND_CODE_RD",
         "PublicDescription": "This event counts both cacheable and noncach=
aeble code read requests.",
@@ -679,8 +550,6 @@
     },
     {
         "BriefDescription": "Demand Data Read requests sent to uncore",
-        "Counter": "0,1,2,3",
-        "CounterHTOff": "0,1,2,3,4,5,6,7",
         "EventCode": "0xB0",
         "EventName": "OFFCORE_REQUESTS.DEMAND_DATA_RD",
         "PublicDescription": "This event counts the Demand Data Read reque=
sts sent to uncore. Use it in conjunction with OFFCORE_REQUESTS_OUTSTANDING=
 to determine average latency in the uncore.",
@@ -689,8 +558,6 @@
     },
     {
         "BriefDescription": "Demand RFO requests including regular RFOs, l=
ocks, ItoM",
-        "Counter": "0,1,2,3",
-        "CounterHTOff": "0,1,2,3,4,5,6,7",
         "EventCode": "0xB0",
         "EventName": "OFFCORE_REQUESTS.DEMAND_RFO",
         "PublicDescription": "This event counts the demand RFO (read for o=
wnership) requests including regular RFOs, locks, ItoM.",
@@ -699,8 +566,6 @@
     },
     {
         "BriefDescription": "Offcore requests buffer cannot take more entr=
ies for this thread core.",
-        "Counter": "0,1,2,3",
-        "CounterHTOff": "0,1,2,3,4,5,6,7",
         "EventCode": "0xb2",
         "EventName": "OFFCORE_REQUESTS_BUFFER.SQ_FULL",
         "PublicDescription": "This event counts the number of cases when t=
he offcore requests buffer cannot take more entries for the core. This can =
happen when the superqueue does not contain eligible entries, or when L1D w=
riteback pending FIFO requests is full.\nNote: Writeback pending FIFO has s=
ix entries.",
@@ -709,8 +574,6 @@
     },
     {
         "BriefDescription": "Offcore outstanding cacheable Core Data Read =
transactions in SuperQueue (SQ), queue to uncore",
-        "Counter": "0,1,2,3",
-        "CounterHTOff": "0,1,2,3,4,5,6,7",
         "Errata": "BDM76",
         "EventCode": "0x60",
         "EventName": "OFFCORE_REQUESTS_OUTSTANDING.ALL_DATA_RD",
@@ -720,8 +583,6 @@
     },
     {
         "BriefDescription": "Cycles when offcore outstanding cacheable Cor=
e Data Read transactions are present in SuperQueue (SQ), queue to uncore",
-        "Counter": "0,1,2,3",
-        "CounterHTOff": "0,1,2,3,4,5,6,7",
         "CounterMask": "1",
         "Errata": "BDM76",
         "EventCode": "0x60",
@@ -732,8 +593,6 @@
     },
     {
         "BriefDescription": "Cycles when offcore outstanding Demand Data R=
ead transactions are present in SuperQueue (SQ), queue to uncore",
-        "Counter": "0,1,2,3",
-        "CounterHTOff": "0,1,2,3,4,5,6,7",
         "CounterMask": "1",
         "Errata": "BDM76",
         "EventCode": "0x60",
@@ -744,8 +603,6 @@
     },
     {
         "BriefDescription": "Offcore outstanding demand rfo reads transact=
ions in SuperQueue (SQ), queue to uncore, every cycle",
-        "Counter": "0,1,2,3",
-        "CounterHTOff": "0,1,2,3,4,5,6,7",
         "CounterMask": "1",
         "Errata": "BDM76",
         "EventCode": "0x60",
@@ -756,8 +613,6 @@
     },
     {
         "BriefDescription": "Offcore outstanding code reads transactions i=
n SuperQueue (SQ), queue to uncore, every cycle",
-        "Counter": "0,1,2,3",
-        "CounterHTOff": "0,1,2,3,4,5,6,7",
         "Errata": "BDM76",
         "EventCode": "0x60",
         "EventName": "OFFCORE_REQUESTS_OUTSTANDING.DEMAND_CODE_RD",
@@ -767,8 +622,6 @@
     },
     {
         "BriefDescription": "Offcore outstanding Demand Data Read transact=
ions in uncore queue.",
-        "Counter": "0,1,2,3",
-        "CounterHTOff": "0,1,2,3,4,5,6,7",
         "Errata": "BDM76",
         "EventCode": "0x60",
         "EventName": "OFFCORE_REQUESTS_OUTSTANDING.DEMAND_DATA_RD",
@@ -778,8 +631,6 @@
     },
     {
         "BriefDescription": "Cycles with at least 6 offcore outstanding De=
mand Data Read transactions in uncore queue.",
-        "Counter": "0,1,2,3",
-        "CounterHTOff": "0,1,2,3,4,5,6,7",
         "CounterMask": "6",
         "Errata": "BDM76",
         "EventCode": "0x60",
@@ -789,8 +640,6 @@
     },
     {
         "BriefDescription": "Offcore outstanding RFO store transactions in=
 SuperQueue (SQ), queue to uncore",
-        "Counter": "0,1,2,3",
-        "CounterHTOff": "0,1,2,3,4,5,6,7",
         "Errata": "BDM76",
         "EventCode": "0x60",
         "EventName": "OFFCORE_REQUESTS_OUTSTANDING.DEMAND_RFO",
@@ -800,8 +649,6 @@
     },
     {
         "BriefDescription": "Offcore response can be programmed only with =
a specific pair of event select and counter MSR, and with specific event co=
des and predefine mask bit value in a dedicated MSR to specify attributes o=
f the offcore transaction.",
-        "Counter": "0,1,2,3",
-        "CounterHTOff": "0,1,2,3",
         "EventCode": "0xB7, 0xBB",
         "EventName": "OFFCORE_RESPONSE",
         "SampleAfterValue": "100003",
@@ -809,152 +656,114 @@
     },
     {
         "BriefDescription": "Counts all demand & prefetch code reads hit i=
n the L3 and the snoops to sibling cores hit in either E/S state and the li=
ne is not forwarded",
-        "Counter": "0,1,2,3",
-        "CounterHTOff": "0,1,2,3",
         "EventCode": "0xB7, 0xBB",
         "EventName": "OFFCORE_RESPONSE.ALL_CODE_RD.LLC_HIT.HIT_OTHER_CORE_=
NO_FWD",
         "MSRIndex": "0x1a6,0x1a7",
         "MSRValue": "0x4003C0244",
-        "Offcore": "1",
         "SampleAfterValue": "100003",
         "UMask": "0x1"
     },
     {
         "BriefDescription": "Counts all demand & prefetch data reads hit i=
n the L3 and the snoop to one of the sibling cores hits the line in M state=
 and the line is forwarded",
-        "Counter": "0,1,2,3",
-        "CounterHTOff": "0,1,2,3",
         "EventCode": "0xB7, 0xBB",
         "EventName": "OFFCORE_RESPONSE.ALL_DATA_RD.LLC_HIT.HITM_OTHER_CORE=
",
         "MSRIndex": "0x1a6,0x1a7",
         "MSRValue": "0x10003C0091",
-        "Offcore": "1",
         "SampleAfterValue": "100003",
         "UMask": "0x1"
     },
     {
         "BriefDescription": "Counts all demand & prefetch data reads hit i=
n the L3 and the snoops to sibling cores hit in either E/S state and the li=
ne is not forwarded",
-        "Counter": "0,1,2,3",
-        "CounterHTOff": "0,1,2,3",
         "EventCode": "0xB7, 0xBB",
         "EventName": "OFFCORE_RESPONSE.ALL_DATA_RD.LLC_HIT.HIT_OTHER_CORE_=
NO_FWD",
         "MSRIndex": "0x1a6,0x1a7",
         "MSRValue": "0x4003C0091",
-        "Offcore": "1",
         "SampleAfterValue": "100003",
         "UMask": "0x1"
     },
     {
         "BriefDescription": "Counts all data/code/rfo reads (demand & pref=
etch) hit in the L3 and the snoop to one of the sibling cores hits the line=
 in M state and the line is forwarded",
-        "Counter": "0,1,2,3",
-        "CounterHTOff": "0,1,2,3",
         "EventCode": "0xB7, 0xBB",
         "EventName": "OFFCORE_RESPONSE.ALL_READS.LLC_HIT.HITM_OTHER_CORE",
         "MSRIndex": "0x1a6,0x1a7",
         "MSRValue": "0x10003C07F7",
-        "Offcore": "1",
         "SampleAfterValue": "100003",
         "UMask": "0x1"
     },
     {
         "BriefDescription": "Counts all data/code/rfo reads (demand & pref=
etch) hit in the L3 and the snoops to sibling cores hit in either E/S state=
 and the line is not forwarded",
-        "Counter": "0,1,2,3",
-        "CounterHTOff": "0,1,2,3",
         "EventCode": "0xB7, 0xBB",
         "EventName": "OFFCORE_RESPONSE.ALL_READS.LLC_HIT.HIT_OTHER_CORE_NO=
_FWD",
         "MSRIndex": "0x1a6,0x1a7",
         "MSRValue": "0x4003C07F7",
-        "Offcore": "1",
         "SampleAfterValue": "100003",
         "UMask": "0x1"
     },
     {
         "BriefDescription": "Counts all requests hit in the L3",
-        "Counter": "0,1,2,3",
-        "CounterHTOff": "0,1,2,3",
         "EventCode": "0xB7, 0xBB",
         "EventName": "OFFCORE_RESPONSE.ALL_REQUESTS.LLC_HIT.ANY_RESPONSE",
         "MSRIndex": "0x1a6,0x1a7",
         "MSRValue": "0x3F803C8FFF",
-        "Offcore": "1",
         "SampleAfterValue": "100003",
         "UMask": "0x1"
     },
     {
         "BriefDescription": "Counts all demand & prefetch RFOs hit in the =
L3 and the snoop to one of the sibling cores hits the line in M state and t=
he line is forwarded",
-        "Counter": "0,1,2,3",
-        "CounterHTOff": "0,1,2,3",
         "EventCode": "0xB7, 0xBB",
         "EventName": "OFFCORE_RESPONSE.ALL_RFO.LLC_HIT.HITM_OTHER_CORE",
         "MSRIndex": "0x1a6,0x1a7",
         "MSRValue": "0x10003C0122",
-        "Offcore": "1",
         "SampleAfterValue": "100003",
         "UMask": "0x1"
     },
     {
         "BriefDescription": "Counts all demand & prefetch RFOs hit in the =
L3 and the snoops to sibling cores hit in either E/S state and the line is =
not forwarded",
-        "Counter": "0,1,2,3",
-        "CounterHTOff": "0,1,2,3",
         "EventCode": "0xB7, 0xBB",
         "EventName": "OFFCORE_RESPONSE.ALL_RFO.LLC_HIT.HIT_OTHER_CORE_NO_F=
WD",
         "MSRIndex": "0x1a6,0x1a7",
         "MSRValue": "0x4003C0122",
-        "Offcore": "1",
         "SampleAfterValue": "100003",
         "UMask": "0x1"
     },
     {
         "BriefDescription": "Counts all demand data writes (RFOs) hit in t=
he L3",
-        "Counter": "0,1,2,3",
-        "CounterHTOff": "0,1,2,3",
         "EventCode": "0xB7, 0xBB",
         "EventName": "OFFCORE_RESPONSE.DEMAND_RFO.LLC_HIT.ANY_RESPONSE",
         "MSRIndex": "0x1a6,0x1a7",
         "MSRValue": "0x3F803C0002",
-        "Offcore": "1",
         "SampleAfterValue": "100003",
         "UMask": "0x1"
     },
     {
         "BriefDescription": "Counts all demand data writes (RFOs) hit in t=
he L3 and the snoop to one of the sibling cores hits the line in M state an=
d the line is forwarded",
-        "Counter": "0,1,2,3",
-        "CounterHTOff": "0,1,2,3",
         "EventCode": "0xB7, 0xBB",
         "EventName": "OFFCORE_RESPONSE.DEMAND_RFO.LLC_HIT.HITM_OTHER_CORE"=
,
         "MSRIndex": "0x1a6,0x1a7",
         "MSRValue": "0x10003C0002",
-        "Offcore": "1",
         "SampleAfterValue": "100003",
         "UMask": "0x1"
     },
     {
         "BriefDescription": "Counts prefetch (that bring data to LLC only)=
 code reads hit in the L3",
-        "Counter": "0,1,2,3",
-        "CounterHTOff": "0,1,2,3",
         "EventCode": "0xB7, 0xBB",
         "EventName": "OFFCORE_RESPONSE.PF_LLC_CODE_RD.LLC_HIT.ANY_RESPONSE=
",
         "MSRIndex": "0x1a6,0x1a7",
         "MSRValue": "0x3F803C0200",
-        "Offcore": "1",
         "SampleAfterValue": "100003",
         "UMask": "0x1"
     },
     {
         "BriefDescription": "Counts all prefetch (that bring data to LLC o=
nly) RFOs hit in the L3",
-        "Counter": "0,1,2,3",
-        "CounterHTOff": "0,1,2,3",
         "EventCode": "0xB7, 0xBB",
         "EventName": "OFFCORE_RESPONSE.PF_LLC_RFO.LLC_HIT.ANY_RESPONSE",
         "MSRIndex": "0x1a6,0x1a7",
         "MSRValue": "0x3F803C0100",
-        "Offcore": "1",
         "SampleAfterValue": "100003",
         "UMask": "0x1"
     },
     {
         "BriefDescription": "Split locks in SQ",
-        "Counter": "0,1,2,3",
-        "CounterHTOff": "0,1,2,3,4,5,6,7",
         "EventCode": "0xf4",
         "EventName": "SQ_MISC.SPLIT_LOCK",
         "PublicDescription": "This event counts the number of split locks =
in the super queue.",
diff --git a/tools/perf/pmu-events/arch/x86/broadwellx/floating-point.json =
b/tools/perf/pmu-events/arch/x86/broadwellx/floating-point.json
index 93bbc8600321..e4826dc7f797 100644
--- a/tools/perf/pmu-events/arch/x86/broadwellx/floating-point.json
+++ b/tools/perf/pmu-events/arch/x86/broadwellx/floating-point.json
@@ -1,8 +1,6 @@
 [
     {
         "BriefDescription": "Number of SSE/AVX computational 128-bit packe=
d double precision floating-point instructions retired; some instructions w=
ill count twice as noted below.  Each count represents 2 computation operat=
ions, one for each element.  Applies to SSE* and AVX* packed double precisi=
on floating-point instructions: ADD SUB HADD HSUB SUBADD MUL DIV MIN MAX SQ=
RT DPP FM(N)ADD/SUB.  DPP and FM(N)ADD/SUB instructions count twice as they=
 perform 2 calculations per element.",
-        "Counter": "0,1,2,3",
-        "CounterHTOff": "0,1,2,3",
         "EventCode": "0xc7",
         "EventName": "FP_ARITH_INST_RETIRED.128B_PACKED_DOUBLE",
         "PublicDescription": "Number of SSE/AVX computational 128-bit pack=
ed double precision floating-point instructions retired; some instructions =
will count twice as noted below.  Each count represents 2 computation opera=
tions, one for each element.  Applies to SSE* and AVX* packed double precis=
ion floating-point instructions: ADD SUB HADD HSUB SUBADD MUL DIV MIN MAX S=
QRT DPP FM(N)ADD/SUB.  DPP and FM(N)ADD/SUB instructions count twice as the=
y perform 2 calculations per element. The DAZ and FTZ flags in the MXCSR re=
gister need to be set when using these events.",
@@ -11,8 +9,6 @@
     },
     {
         "BriefDescription": "Number of SSE/AVX computational 128-bit packe=
d single precision floating-point instructions retired; some instructions w=
ill count twice as noted below.  Each count represents 4 computation operat=
ions, one for each element.  Applies to SSE* and AVX* packed single precisi=
on floating-point instructions: ADD SUB HADD HSUB SUBADD MUL DIV MIN MAX SQ=
RT RSQRT RCP DPP FM(N)ADD/SUB.  DPP and FM(N)ADD/SUB instructions count twi=
ce as they perform 4 calculations per element.",
-        "Counter": "0,1,2,3",
-        "CounterHTOff": "0,1,2,3",
         "EventCode": "0xc7",
         "EventName": "FP_ARITH_INST_RETIRED.128B_PACKED_SINGLE",
         "PublicDescription": "Number of SSE/AVX computational 128-bit pack=
ed single precision floating-point instructions retired; some instructions =
will count twice as noted below.  Each count represents 4 computation opera=
tions, one for each element.  Applies to SSE* and AVX* packed single precis=
ion floating-point instructions: ADD SUB HADD HSUB SUBADD MUL DIV MIN MAX S=
QRT RSQRT RCP DPP FM(N)ADD/SUB.  DPP and FM(N)ADD/SUB instructions count tw=
ice as they perform 2 calculations per element. The DAZ and FTZ flags in th=
e MXCSR register need to be set when using these events.",
@@ -21,8 +17,6 @@
     },
     {
         "BriefDescription": "Number of SSE/AVX computational 256-bit packe=
d double precision floating-point instructions retired; some instructions w=
ill count twice as noted below.  Each count represents 4 computation operat=
ions, one for each element.  Applies to SSE* and AVX* packed double precisi=
on floating-point instructions: ADD SUB HADD HSUB SUBADD MUL DIV MIN MAX SQ=
RT FM(N)ADD/SUB.  FM(N)ADD/SUB instructions count twice as they perform 4 c=
alculations per element.",
-        "Counter": "0,1,2,3",
-        "CounterHTOff": "0,1,2,3",
         "EventCode": "0xc7",
         "EventName": "FP_ARITH_INST_RETIRED.256B_PACKED_DOUBLE",
         "PublicDescription": "Number of SSE/AVX computational 256-bit pack=
ed double precision floating-point instructions retired; some instructions =
will count twice as noted below.  Each count represents 4 computation opera=
tions, one for each element.  Applies to SSE* and AVX* packed double precis=
ion floating-point instructions: ADD SUB HADD HSUB SUBADD MUL DIV MIN MAX S=
QRT FM(N)ADD/SUB.  FM(N)ADD/SUB instructions count twice as they perform 2 =
calculations per element. The DAZ and FTZ flags in the MXCSR register need =
to be set when using these events.",
@@ -31,8 +25,6 @@
     },
     {
         "BriefDescription": "Number of SSE/AVX computational 256-bit packe=
d single precision floating-point instructions retired; some instructions w=
ill count twice as noted below.  Each count represents 8 computation operat=
ions, one for each element.  Applies to SSE* and AVX* packed single precisi=
on floating-point instructions: ADD SUB HADD HSUB SUBADD MUL DIV MIN MAX SQ=
RT RSQRT RCP DPP FM(N)ADD/SUB.  DPP and FM(N)ADD/SUB instructions count twi=
ce as they perform 8 calculations per element.",
-        "Counter": "0,1,2,3",
-        "CounterHTOff": "0,1,2,3",
         "EventCode": "0xc7",
         "EventName": "FP_ARITH_INST_RETIRED.256B_PACKED_SINGLE",
         "PublicDescription": "Number of SSE/AVX computational 256-bit pack=
ed single precision floating-point instructions retired; some instructions =
will count twice as noted below.  Each count represents 8 computation opera=
tions, one for each element.  Applies to SSE* and AVX* packed single precis=
ion floating-point instructions: ADD SUB HADD HSUB SUBADD MUL DIV MIN MAX S=
QRT RSQRT RCP DPP FM(N)ADD/SUB.  DPP and FM(N)ADD/SUB instructions count tw=
ice as they perform 2 calculations per element. The DAZ and FTZ flags in th=
e MXCSR register need to be set when using these events.",
@@ -41,8 +33,6 @@
     },
     {
         "BriefDescription": "Number of SSE/AVX computational double precis=
ion floating-point instructions retired; some instructions will count twice=
 as noted below. Applies to SSE* and AVX* scalar and packed double precisio=
n floating-point instructions: ADD SUB HADD HSUB SUBADD MUL DIV MIN MAX SQR=
T DPP FM(N)ADD/SUB.  DPP and FM(N)ADD/SUB instructions count twice as they =
perform multiple calculations per element.",
-        "Counter": "0,1,2,3",
-        "CounterHTOff": "0,1,2,3",
         "EventCode": "0xc7",
         "EventName": "FP_ARITH_INST_RETIRED.DOUBLE",
         "SampleAfterValue": "2000006",
@@ -50,8 +40,6 @@
     },
     {
         "BriefDescription": "Number of SSE/AVX computational packed floati=
ng-point instructions retired; some instructions will count twice as noted =
below. Applies to SSE* and AVX* packed double and single precision floating=
-point instructions: ADD SUB HADD HSUB SUBADD MUL DIV MIN MAX SQRT RSQRT RC=
P DPP FM(N)ADD/SUB.  DPP and FM(N)ADD/SUB instructions count twice as they =
perform multiple calculations per element.",
-        "Counter": "0,1,2,3",
-        "CounterHTOff": "0,1,2,3",
         "EventCode": "0xc7",
         "EventName": "FP_ARITH_INST_RETIRED.PACKED",
         "SampleAfterValue": "2000004",
@@ -59,8 +47,6 @@
     },
     {
         "BriefDescription": "Number of SSE/AVX computational scalar floati=
ng-point instructions retired; some instructions will count twice as noted =
below. Each count represents 1 computation operation.   Applies to SSE* and=
 AVX* scalar double and single precision floating-point instructions: ADD S=
UB MUL DIV MIN MAX SQRT RSQRT RCP FM(N)ADD/SUB. FM(N)ADD/SUB instructions c=
ount twice as they perform multiple calculations per element.",
-        "Counter": "0,1,2,3",
-        "CounterHTOff": "0,1,2,3",
         "EventCode": "0xc7",
         "EventName": "FP_ARITH_INST_RETIRED.SCALAR",
         "PublicDescription": "Number of SSE/AVX computational scalar singl=
e precision and double precision floating-point instructions retired; some =
instructions will count twice as noted below.  Each count represents 1 comp=
utational operation. Applies to SSE* and AVX* scalar single precision float=
ing-point instructions: ADD SUB MUL DIV MIN MAX SQRT RSQRT RCP FM(N)ADD/SUB=
.  FM(N)ADD/SUB instructions count twice as they perform 2 calculations per=
 element. The DAZ and FTZ flags in the MXCSR register need to be set when u=
sing these events.",
@@ -69,8 +55,6 @@
     },
     {
         "BriefDescription": "Number of SSE/AVX computational scalar double=
 precision floating-point instructions retired; some instructions will coun=
t twice as noted below.  Each count represents 1 computational operation. A=
pplies to SSE* and AVX* scalar double precision floating-point instructions=
: ADD SUB MUL DIV MIN MAX SQRT FM(N)ADD/SUB.  FM(N)ADD/SUB instructions cou=
nt twice as they perform multiple calculations per element.",
-        "Counter": "0,1,2,3",
-        "CounterHTOff": "0,1,2,3",
         "EventCode": "0xc7",
         "EventName": "FP_ARITH_INST_RETIRED.SCALAR_DOUBLE",
         "PublicDescription": "Number of SSE/AVX computational scalar doubl=
e precision floating-point instructions retired; some instructions will cou=
nt twice as noted below.  Each count represents 1 computational operation. =
Applies to SSE* and AVX* scalar double precision floating-point instruction=
s: ADD SUB MUL DIV MIN MAX SQRT FM(N)ADD/SUB.  FM(N)ADD/SUB instructions co=
unt twice as they perform 2 calculations per element. The DAZ and FTZ flags=
 in the MXCSR register need to be set when using these events.",
@@ -79,8 +63,6 @@
     },
     {
         "BriefDescription": "Number of SSE/AVX computational scalar single=
 precision floating-point instructions retired; some instructions will coun=
t twice as noted below.  Each count represents 1 computational operation. A=
pplies to SSE* and AVX* scalar single precision floating-point instructions=
: ADD SUB MUL DIV MIN MAX SQRT RSQRT RCP FM(N)ADD/SUB.  FM(N)ADD/SUB instru=
ctions count twice as they perform multiple calculations per element.",
-        "Counter": "0,1,2,3",
-        "CounterHTOff": "0,1,2,3",
         "EventCode": "0xc7",
         "EventName": "FP_ARITH_INST_RETIRED.SCALAR_SINGLE",
         "PublicDescription": "Number of SSE/AVX computational scalar singl=
e precision floating-point instructions retired; some instructions will cou=
nt twice as noted below.  Each count represents 1 computational operation. =
Applies to SSE* and AVX* scalar single precision floating-point instruction=
s: ADD SUB MUL DIV MIN MAX SQRT RSQRT RCP FM(N)ADD/SUB.  FM(N)ADD/SUB instr=
uctions count twice as they perform 2 calculations per element. The DAZ and=
 FTZ flags in the MXCSR register need to be set when using these events.",
@@ -89,8 +71,6 @@
     },
     {
         "BriefDescription": "Number of SSE/AVX computational single precis=
ion floating-point instructions retired; some instructions will count twice=
 as noted below. Applies to SSE* and AVX* scalar and packed single precisio=
n floating-point instructions: ADD SUB HADD HSUB SUBADD MUL DIV MIN MAX SQR=
T RSQRT RCP SQRT DPP FM(N)ADD/SUB.  DPP and FM(N)ADD/SUB instructions count=
 twice as they perform multiple calculations per element.",
-        "Counter": "0,1,2,3",
-        "CounterHTOff": "0,1,2,3",
         "EventCode": "0xc7",
         "EventName": "FP_ARITH_INST_RETIRED.SINGLE",
         "SampleAfterValue": "2000005",
@@ -98,8 +78,6 @@
     },
     {
         "BriefDescription": "Cycles with any input/output SSE or FP assist=
",
-        "Counter": "0,1,2,3",
-        "CounterHTOff": "0,1,2,3",
         "CounterMask": "1",
         "EventCode": "0xCA",
         "EventName": "FP_ASSIST.ANY",
@@ -109,8 +87,6 @@
     },
     {
         "BriefDescription": "Number of SIMD FP assists due to input values=
",
-        "Counter": "0,1,2,3",
-        "CounterHTOff": "0,1,2,3,4,5,6,7",
         "EventCode": "0xCA",
         "EventName": "FP_ASSIST.SIMD_INPUT",
         "PublicDescription": "This event counts any input SSE* FP assist -=
 invalid operation, denormal operand, dividing by zero, SNaN operand. Count=
ing includes only cases involving penalties that required micro-code assist=
 intervention.",
@@ -119,8 +95,6 @@
     },
     {
         "BriefDescription": "Number of SIMD FP assists due to Output value=
s",
-        "Counter": "0,1,2,3",
-        "CounterHTOff": "0,1,2,3,4,5,6,7",
         "EventCode": "0xCA",
         "EventName": "FP_ASSIST.SIMD_OUTPUT",
         "PublicDescription": "This event counts the number of SSE* floatin=
g point (FP) micro-code assist (numeric overflow/underflow) when the output=
 value (destination register) is invalid. Counting covers only cases involv=
ing penalties that require micro-code assist intervention.",
@@ -129,8 +103,6 @@
     },
     {
         "BriefDescription": "Number of X87 assists due to input value.",
-        "Counter": "0,1,2,3",
-        "CounterHTOff": "0,1,2,3,4,5,6,7",
         "EventCode": "0xCA",
         "EventName": "FP_ASSIST.X87_INPUT",
         "PublicDescription": "This event counts x87 floating point (FP) mi=
cro-code assist (invalid operation, denormal operand, SNaN operand) when th=
e input value (one of the source operands to an FP instruction) is invalid.=
",
@@ -139,8 +111,6 @@
     },
     {
         "BriefDescription": "Number of X87 assists due to output value.",
-        "Counter": "0,1,2,3",
-        "CounterHTOff": "0,1,2,3,4,5,6,7",
         "EventCode": "0xCA",
         "EventName": "FP_ASSIST.X87_OUTPUT",
         "PublicDescription": "This event counts the number of x87 floating=
 point (FP) micro-code assist (numeric overflow/underflow, inexact result) =
when the output value (destination register) is invalid.",
@@ -149,8 +119,6 @@
     },
     {
         "BriefDescription": "Number of SIMD Move Elimination candidate uop=
s that were eliminated.",
-        "Counter": "0,1,2,3",
-        "CounterHTOff": "0,1,2,3,4,5,6,7",
         "EventCode": "0x58",
         "EventName": "MOVE_ELIMINATION.SIMD_ELIMINATED",
         "SampleAfterValue": "1000003",
@@ -158,8 +126,6 @@
     },
     {
         "BriefDescription": "Number of SIMD Move Elimination candidate uop=
s that were not eliminated.",
-        "Counter": "0,1,2,3",
-        "CounterHTOff": "0,1,2,3,4,5,6,7",
         "EventCode": "0x58",
         "EventName": "MOVE_ELIMINATION.SIMD_NOT_ELIMINATED",
         "SampleAfterValue": "1000003",
@@ -167,8 +133,6 @@
     },
     {
         "BriefDescription": "Number of transitions from AVX-256 to legacy =
SSE when penalty applicable.",
-        "Counter": "0,1,2,3",
-        "CounterHTOff": "0,1,2,3,4,5,6,7",
         "Errata": "BDM30",
         "EventCode": "0xC1",
         "EventName": "OTHER_ASSISTS.AVX_TO_SSE",
@@ -178,8 +142,6 @@
     },
     {
         "BriefDescription": "Number of transitions from SSE to AVX-256 whe=
n penalty applicable.",
-        "Counter": "0,1,2,3",
-        "CounterHTOff": "0,1,2,3,4,5,6,7",
         "Errata": "BDM30",
         "EventCode": "0xC1",
         "EventName": "OTHER_ASSISTS.SSE_TO_AVX",
@@ -189,8 +151,6 @@
     },
     {
         "BriefDescription": "Micro-op dispatches cancelled due to insuffic=
ient SIMD physical register file read ports",
-        "Counter": "0,1,2,3",
-        "CounterHTOff": "0,1,2,3",
         "EventCode": "0xA0",
         "EventName": "UOP_DISPATCHES_CANCELLED.SIMD_PRF",
         "PublicDescription": "This event counts the number of micro-operat=
ions cancelled after they were dispatched from the scheduler to the executi=
on units when the total number of physical register read ports across all d=
ispatch ports exceeds the read bandwidth of the physical register file.  Th=
e SIMD_PRF subevent applies to the following instructions: VDPPS, DPPS, VPC=
MPESTRI, PCMPESTRI, VPCMPESTRM, PCMPESTRM, VFMADD*, VFMADDSUB*, VFMSUB*, VM=
SUBADD*, VFNMADD*, VFNMSUB*.  See the Broadwell Optimization Guide for more=
 information.",
diff --git a/tools/perf/pmu-events/arch/x86/broadwellx/frontend.json b/tool=
s/perf/pmu-events/arch/x86/broadwellx/frontend.json
index 37ce8034b2ed..d0f6678609ae 100644
--- a/tools/perf/pmu-events/arch/x86/broadwellx/frontend.json
+++ b/tools/perf/pmu-events/arch/x86/broadwellx/frontend.json
@@ -1,8 +1,6 @@
 [
     {
         "BriefDescription": "Counts the total number when the front end is=
 resteered, mainly when the BPU cannot provide a correct prediction and thi=
s is corrected by other branch handling mechanisms at the front end.",
-        "Counter": "0,1,2,3",
-        "CounterHTOff": "0,1,2,3,4,5,6,7",
         "EventCode": "0xe6",
         "EventName": "BACLEARS.ANY",
         "SampleAfterValue": "100003",
@@ -10,8 +8,6 @@
     },
     {
         "BriefDescription": "Decode Stream Buffer (DSB)-to-MITE switch tru=
e penalty cycles.",
-        "Counter": "0,1,2,3",
-        "CounterHTOff": "0,1,2,3,4,5,6,7",
         "EventCode": "0xAB",
         "EventName": "DSB2MITE_SWITCHES.PENALTY_CYCLES",
         "PublicDescription": "This event counts Decode Stream Buffer (DSB)=
-to-MITE switch true penalty cycles. These cycles do not include uops route=
d through because of the switch itself, for example, when Instruction Decod=
e Queue (IDQ) pre-allocation is unavailable, or Instruction Decode Queue (I=
DQ) is full. SBD-to-MITE switch true penalty cycles happen after the merge =
mux (MM) receives Decode Stream Buffer (DSB) Sync-indication until receivin=
g the first MITE uop. \nMM is placed before Instruction Decode Queue (IDQ) =
to merge uops being fed from the MITE and Decode Stream Buffer (DSB) paths.=
 Decode Stream Buffer (DSB) inserts the Sync-indication whenever a Decode S=
tream Buffer (DSB)-to-MITE switch occurs.\nPenalty: A Decode Stream Buffer =
(DSB) hit followed by a Decode Stream Buffer (DSB) miss can cost up to six =
cycles in which no uops are delivered to the IDQ. Most often, such switches=
 from the Decode Stream Buffer (DSB) to the legacy pipeline cost 02 cycles.=
",
@@ -20,8 +16,6 @@
     },
     {
         "BriefDescription": "Number of Instruction Cache, Streaming Buffer=
 and Victim Cache Reads. both cacheable and noncacheable, including UC fetc=
hes",
-        "Counter": "0,1,2,3",
-        "CounterHTOff": "0,1,2,3,4,5,6,7",
         "EventCode": "0x80",
         "EventName": "ICACHE.HIT",
         "PublicDescription": "This event counts the number of both cacheab=
le and noncacheable Instruction Cache, Streaming Buffer and Victim Cache Re=
ads including UC fetches.",
@@ -30,8 +24,6 @@
     },
     {
         "BriefDescription": "Cycles where a code fetch is stalled due to L=
1 instruction-cache miss.",
-        "Counter": "0,1,2,3",
-        "CounterHTOff": "0,1,2,3,4,5,6,7",
         "EventCode": "0x80",
         "EventName": "ICACHE.IFDATA_STALL",
         "PublicDescription": "This event counts cycles during which the de=
mand fetch waits for data (wfdM104H) from L2 or iSB (opportunistic hit).",
@@ -40,8 +32,6 @@
     },
     {
         "BriefDescription": "Number of Instruction Cache, Streaming Buffer=
 and Victim Cache Misses. Includes Uncacheable accesses.",
-        "Counter": "0,1,2,3",
-        "CounterHTOff": "0,1,2,3,4,5,6,7",
         "EventCode": "0x80",
         "EventName": "ICACHE.MISSES",
         "PublicDescription": "This event counts the number of instruction =
cache, streaming buffer and victim cache misses. Counting includes UC acces=
ses.",
@@ -50,8 +40,6 @@
     },
     {
         "BriefDescription": "Cycles Decode Stream Buffer (DSB) is deliveri=
ng 4 Uops",
-        "Counter": "0,1,2,3",
-        "CounterHTOff": "0,1,2,3,4,5,6,7",
         "CounterMask": "4",
         "EventCode": "0x79",
         "EventName": "IDQ.ALL_DSB_CYCLES_4_UOPS",
@@ -61,8 +49,6 @@
     },
     {
         "BriefDescription": "Cycles Decode Stream Buffer (DSB) is deliveri=
ng any Uop",
-        "Counter": "0,1,2,3",
-        "CounterHTOff": "0,1,2,3,4,5,6,7",
         "CounterMask": "1",
         "EventCode": "0x79",
         "EventName": "IDQ.ALL_DSB_CYCLES_ANY_UOPS",
@@ -72,8 +58,6 @@
     },
     {
         "BriefDescription": "Cycles MITE is delivering 4 Uops",
-        "Counter": "0,1,2,3",
-        "CounterHTOff": "0,1,2,3,4,5,6,7",
         "CounterMask": "4",
         "EventCode": "0x79",
         "EventName": "IDQ.ALL_MITE_CYCLES_4_UOPS",
@@ -83,8 +67,6 @@
     },
     {
         "BriefDescription": "Cycles MITE is delivering any Uop",
-        "Counter": "0,1,2,3",
-        "CounterHTOff": "0,1,2,3,4,5,6,7",
         "CounterMask": "1",
         "EventCode": "0x79",
         "EventName": "IDQ.ALL_MITE_CYCLES_ANY_UOPS",
@@ -94,8 +76,6 @@
     },
     {
         "BriefDescription": "Cycles when uops are being delivered to Instr=
uction Decode Queue (IDQ) from Decode Stream Buffer (DSB) path",
-        "Counter": "0,1,2,3",
-        "CounterHTOff": "0,1,2,3,4,5,6,7",
         "CounterMask": "1",
         "EventCode": "0x79",
         "EventName": "IDQ.DSB_CYCLES",
@@ -105,8 +85,6 @@
     },
     {
         "BriefDescription": "Uops delivered to Instruction Decode Queue (I=
DQ) from the Decode Stream Buffer (DSB) path",
-        "Counter": "0,1,2,3",
-        "CounterHTOff": "0,1,2,3,4,5,6,7",
         "EventCode": "0x79",
         "EventName": "IDQ.DSB_UOPS",
         "PublicDescription": "This event counts the number of uops deliver=
ed to Instruction Decode Queue (IDQ) from the Decode Stream Buffer (DSB) pa=
th. Counting includes uops that may bypass the IDQ.",
@@ -115,8 +93,6 @@
     },
     {
         "BriefDescription": "Instruction Decode Queue (IDQ) empty cycles",
-        "Counter": "0,1,2,3",
-        "CounterHTOff": "0,1,2,3",
         "EventCode": "0x79",
         "EventName": "IDQ.EMPTY",
         "PublicDescription": "This counts the number of cycles that the in=
struction decoder queue is empty and can indicate that the application may =
be bound in the front end.  It does not determine whether there are uops be=
ing delivered to the Alloc stage since uops can be delivered by bypass skip=
ping the Instruction Decode Queue (IDQ) when it is empty.",
@@ -125,8 +101,6 @@
     },
     {
         "BriefDescription": "Uops delivered to Instruction Decode Queue (I=
DQ) from MITE path",
-        "Counter": "0,1,2,3",
-        "CounterHTOff": "0,1,2,3,4,5,6,7",
         "EventCode": "0x79",
         "EventName": "IDQ.MITE_ALL_UOPS",
         "PublicDescription": "This event counts the number of uops deliver=
ed to Instruction Decode Queue (IDQ) from the MITE path. Counting includes =
uops that may bypass the IDQ. This also means that uops are not being deliv=
ered from the Decode Stream Buffer (DSB).",
@@ -135,8 +109,6 @@
     },
     {
         "BriefDescription": "Cycles when uops are being delivered to Instr=
uction Decode Queue (IDQ) from MITE path",
-        "Counter": "0,1,2,3",
-        "CounterHTOff": "0,1,2,3,4,5,6,7",
         "CounterMask": "1",
         "EventCode": "0x79",
         "EventName": "IDQ.MITE_CYCLES",
@@ -146,8 +118,6 @@
     },
     {
         "BriefDescription": "Uops delivered to Instruction Decode Queue (I=
DQ) from MITE path",
-        "Counter": "0,1,2,3",
-        "CounterHTOff": "0,1,2,3,4,5,6,7",
         "EventCode": "0x79",
         "EventName": "IDQ.MITE_UOPS",
         "PublicDescription": "This event counts the number of uops deliver=
ed to Instruction Decode Queue (IDQ) from the MITE path. Counting includes =
uops that may bypass the IDQ. This also means that uops are not being deliv=
ered from the Decode Stream Buffer (DSB).",
@@ -156,8 +126,6 @@
     },
     {
         "BriefDescription": "Cycles when uops are being delivered to Instr=
uction Decode Queue (IDQ) while Microcode Sequenser (MS) is busy",
-        "Counter": "0,1,2,3",
-        "CounterHTOff": "0,1,2,3,4,5,6,7",
         "CounterMask": "1",
         "EventCode": "0x79",
         "EventName": "IDQ.MS_CYCLES",
@@ -167,8 +135,6 @@
     },
     {
         "BriefDescription": "Cycles when uops initiated by Decode Stream B=
uffer (DSB) are being delivered to Instruction Decode Queue (IDQ) while Mic=
rocode Sequenser (MS) is busy",
-        "Counter": "0,1,2,3",
-        "CounterHTOff": "0,1,2,3,4,5,6,7",
         "CounterMask": "1",
         "EventCode": "0x79",
         "EventName": "IDQ.MS_DSB_CYCLES",
@@ -178,8 +144,6 @@
     },
     {
         "BriefDescription": "Deliveries to Instruction Decode Queue (IDQ) =
initiated by Decode Stream Buffer (DSB) while Microcode Sequenser (MS) is b=
usy",
-        "Counter": "0,1,2,3",
-        "CounterHTOff": "0,1,2,3,4,5,6,7",
         "CounterMask": "1",
         "EdgeDetect": "1",
         "EventCode": "0x79",
@@ -190,8 +154,6 @@
     },
     {
         "BriefDescription": "Uops initiated by Decode Stream Buffer (DSB) =
that are being delivered to Instruction Decode Queue (IDQ) while Microcode =
Sequenser (MS) is busy",
-        "Counter": "0,1,2,3",
-        "CounterHTOff": "0,1,2,3,4,5,6,7",
         "EventCode": "0x79",
         "EventName": "IDQ.MS_DSB_UOPS",
         "PublicDescription": "This event counts the number of uops initiat=
ed by Decode Stream Buffer (DSB) that are being delivered to Instruction De=
code Queue (IDQ) while the Microcode Sequencer (MS) is busy. Counting inclu=
des uops that may bypass the IDQ.",
@@ -200,8 +162,6 @@
     },
     {
         "BriefDescription": "Uops initiated by MITE and delivered to Instr=
uction Decode Queue (IDQ) while Microcode Sequenser (MS) is busy",
-        "Counter": "0,1,2,3",
-        "CounterHTOff": "0,1,2,3,4,5,6,7",
         "EventCode": "0x79",
         "EventName": "IDQ.MS_MITE_UOPS",
         "PublicDescription": "This event counts the number of uops initiat=
ed by MITE and delivered to Instruction Decode Queue (IDQ) while the Microc=
ode Sequenser (MS) is busy. Counting includes uops that may bypass the IDQ.=
",
@@ -210,8 +170,6 @@
     },
     {
         "BriefDescription": "Number of switches from DSB (Decode Stream Bu=
ffer) or MITE (legacy decode pipeline) to the Microcode Sequencer.",
-        "Counter": "0,1,2,3",
-        "CounterHTOff": "0,1,2,3,4,5,6,7",
         "CounterMask": "1",
         "EdgeDetect": "1",
         "EventCode": "0x79",
@@ -221,8 +179,6 @@
     },
     {
         "BriefDescription": "Uops delivered to Instruction Decode Queue (I=
DQ) while Microcode Sequenser (MS) is busy",
-        "Counter": "0,1,2,3",
-        "CounterHTOff": "0,1,2,3,4,5,6,7",
         "EventCode": "0x79",
         "EventName": "IDQ.MS_UOPS",
         "PublicDescription": "This event counts the total number of uops d=
elivered to Instruction Decode Queue (IDQ) while the Microcode Sequenser (M=
S) is busy. Counting includes uops that may bypass the IDQ. Uops maybe init=
iated by Decode Stream Buffer (DSB) or MITE.",
@@ -231,8 +187,6 @@
     },
     {
         "BriefDescription": "Uops not delivered to Resource Allocation Tab=
le (RAT) per thread when backend of the machine is not stalled",
-        "Counter": "0,1,2,3",
-        "CounterHTOff": "0,1,2,3",
         "EventCode": "0x9C",
         "EventName": "IDQ_UOPS_NOT_DELIVERED.CORE",
         "PublicDescription": "This event counts the number of uops not del=
ivered to Resource Allocation Table (RAT) per thread adding 4  x when Resou=
rce Allocation Table (RAT) is not stalled and Instruction Decode Queue (IDQ=
) delivers x uops to Resource Allocation Table (RAT) (where x belongs to {0=
,1,2,3}). Counting does not cover cases when:\n a. IDQ-Resource Allocation =
Table (RAT) pipe serves the other thread;\n b. Resource Allocation Table (R=
AT) is stalled for the thread (including uop drops and clear BE conditions)=
; \n c. Instruction Decode Queue (IDQ) delivers four uops.",
@@ -241,8 +195,6 @@
     },
     {
         "BriefDescription": "Cycles per thread when 4 or more uops are not=
 delivered to Resource Allocation Table (RAT) when backend of the machine i=
s not stalled",
-        "Counter": "0,1,2,3",
-        "CounterHTOff": "0,1,2,3",
         "CounterMask": "4",
         "EventCode": "0x9C",
         "EventName": "IDQ_UOPS_NOT_DELIVERED.CYCLES_0_UOPS_DELIV.CORE",
@@ -252,8 +204,6 @@
     },
     {
         "BriefDescription": "Counts cycles FE delivered 4 uops or Resource=
 Allocation Table (RAT) was stalling FE.",
-        "Counter": "0,1,2,3",
-        "CounterHTOff": "0,1,2,3",
         "CounterMask": "1",
         "EventCode": "0x9C",
         "EventName": "IDQ_UOPS_NOT_DELIVERED.CYCLES_FE_WAS_OK",
@@ -263,8 +213,6 @@
     },
     {
         "BriefDescription": "Cycles per thread when 3 or more uops are not=
 delivered to Resource Allocation Table (RAT) when backend of the machine i=
s not stalled",
-        "Counter": "0,1,2,3",
-        "CounterHTOff": "0,1,2,3",
         "CounterMask": "3",
         "EventCode": "0x9C",
         "EventName": "IDQ_UOPS_NOT_DELIVERED.CYCLES_LE_1_UOP_DELIV.CORE",
@@ -274,8 +222,6 @@
     },
     {
         "BriefDescription": "Cycles with less than 2 uops delivered by the=
 front end.",
-        "Counter": "0,1,2,3",
-        "CounterHTOff": "0,1,2,3",
         "CounterMask": "2",
         "EventCode": "0x9C",
         "EventName": "IDQ_UOPS_NOT_DELIVERED.CYCLES_LE_2_UOP_DELIV.CORE",
@@ -284,8 +230,6 @@
     },
     {
         "BriefDescription": "Cycles with less than 3 uops delivered by the=
 front end.",
-        "Counter": "0,1,2,3",
-        "CounterHTOff": "0,1,2,3",
         "CounterMask": "1",
         "EventCode": "0x9C",
         "EventName": "IDQ_UOPS_NOT_DELIVERED.CYCLES_LE_3_UOP_DELIV.CORE",
diff --git a/tools/perf/pmu-events/arch/x86/broadwellx/memory.json b/tools/=
perf/pmu-events/arch/x86/broadwellx/memory.json
index 545f61f691b9..a7449e5b68dc 100644
--- a/tools/perf/pmu-events/arch/x86/broadwellx/memory.json
+++ b/tools/perf/pmu-events/arch/x86/broadwellx/memory.json
@@ -1,8 +1,6 @@
 [
     {
         "BriefDescription": "Number of times HLE abort was triggered",
-        "Counter": "0,1,2,3",
-        "CounterHTOff": "0,1,2,3,4,5,6,7",
         "EventCode": "0xc8",
         "EventName": "HLE_RETIRED.ABORTED",
         "PEBS": "1",
@@ -12,8 +10,6 @@
     },
     {
         "BriefDescription": "Number of times an HLE execution aborted due =
to various memory events (e.g., read/write capacity and conflicts).",
-        "Counter": "0,1,2,3",
-        "CounterHTOff": "0,1,2,3,4,5,6,7",
         "EventCode": "0xc8",
         "EventName": "HLE_RETIRED.ABORTED_MISC1",
         "PublicDescription": "Number of times an HLE abort was attributed =
to a Memory condition (See TSX_Memory event for additional details).",
@@ -22,8 +18,6 @@
     },
     {
         "BriefDescription": "Number of times an HLE execution aborted due =
to uncommon conditions",
-        "Counter": "0,1,2,3",
-        "CounterHTOff": "0,1,2,3,4,5,6,7",
         "EventCode": "0xc8",
         "EventName": "HLE_RETIRED.ABORTED_MISC2",
         "PublicDescription": "Number of times the TSX watchdog signaled an=
 HLE abort.",
@@ -32,8 +26,6 @@
     },
     {
         "BriefDescription": "Number of times an HLE execution aborted due =
to HLE-unfriendly instructions",
-        "Counter": "0,1,2,3",
-        "CounterHTOff": "0,1,2,3,4,5,6,7",
         "EventCode": "0xc8",
         "EventName": "HLE_RETIRED.ABORTED_MISC3",
         "PublicDescription": "Number of times a disallowed operation cause=
d an HLE abort.",
@@ -42,8 +34,6 @@
     },
     {
         "BriefDescription": "Number of times an HLE execution aborted due =
to incompatible memory type",
-        "Counter": "0,1,2,3",
-        "CounterHTOff": "0,1,2,3,4,5,6,7",
         "EventCode": "0xc8",
         "EventName": "HLE_RETIRED.ABORTED_MISC4",
         "PublicDescription": "Number of times HLE caused a fault.",
@@ -52,8 +42,6 @@
     },
     {
         "BriefDescription": "Number of times an HLE execution aborted due =
to none of the previous 4 categories (e.g. interrupts)",
-        "Counter": "0,1,2,3",
-        "CounterHTOff": "0,1,2,3,4,5,6,7",
         "EventCode": "0xc8",
         "EventName": "HLE_RETIRED.ABORTED_MISC5",
         "PublicDescription": "Number of times HLE aborted and was not due =
to the abort conditions in subevents 3-6.",
@@ -62,8 +50,6 @@
     },
     {
         "BriefDescription": "Number of times HLE commit succeeded",
-        "Counter": "0,1,2,3",
-        "CounterHTOff": "0,1,2,3,4,5,6,7",
         "EventCode": "0xc8",
         "EventName": "HLE_RETIRED.COMMIT",
         "PublicDescription": "Number of times HLE commit succeeded.",
@@ -72,8 +58,6 @@
     },
     {
         "BriefDescription": "Number of times we entered an HLE region; doe=
s not count nested transactions",
-        "Counter": "0,1,2,3",
-        "CounterHTOff": "0,1,2,3,4,5,6,7",
         "EventCode": "0xc8",
         "EventName": "HLE_RETIRED.START",
         "PublicDescription": "Number of times we entered an HLE region\n d=
oes not count nested transactions.",
@@ -82,8 +66,6 @@
     },
     {
         "BriefDescription": "Counts the number of machine clears due to me=
mory order conflicts.",
-        "Counter": "0,1,2,3",
-        "CounterHTOff": "0,1,2,3,4,5,6,7",
         "EventCode": "0xC3",
         "EventName": "MACHINE_CLEARS.MEMORY_ORDERING",
         "PublicDescription": "This event counts the number of memory order=
ing Machine Clears detected. Memory Ordering Machine Clears can result from=
 one of the following:\n1. memory disambiguation,\n2. external snoop, or\n3=
. cross SMT-HW-thread snoop (stores) hitting load buffer.",
@@ -92,8 +74,6 @@
     },
     {
         "BriefDescription": "Randomly selected loads with latency value be=
ing above 128",
-        "Counter": "3",
-        "CounterHTOff": "3",
         "Data_LA": "1",
         "Errata": "BDM100, BDM35",
         "EventCode": "0xcd",
@@ -103,13 +83,10 @@
         "PEBS": "2",
         "PublicDescription": "Counts randomly selected loads with latency =
value being above 128.",
         "SampleAfterValue": "1009",
-        "TakenAlone": "1",
         "UMask": "0x1"
     },
     {
         "BriefDescription": "Randomly selected loads with latency value be=
ing above 16",
-        "Counter": "3",
-        "CounterHTOff": "3",
         "Data_LA": "1",
         "Errata": "BDM100, BDM35",
         "EventCode": "0xcd",
@@ -119,13 +96,10 @@
         "PEBS": "2",
         "PublicDescription": "Counts randomly selected loads with latency =
value being above 16.",
         "SampleAfterValue": "20011",
-        "TakenAlone": "1",
         "UMask": "0x1"
     },
     {
         "BriefDescription": "Randomly selected loads with latency value be=
ing above 256",
-        "Counter": "3",
-        "CounterHTOff": "3",
         "Data_LA": "1",
         "Errata": "BDM100, BDM35",
         "EventCode": "0xcd",
@@ -135,13 +109,10 @@
         "PEBS": "2",
         "PublicDescription": "Counts randomly selected loads with latency =
value being above 256.",
         "SampleAfterValue": "503",
-        "TakenAlone": "1",
         "UMask": "0x1"
     },
     {
         "BriefDescription": "Randomly selected loads with latency value be=
ing above 32",
-        "Counter": "3",
-        "CounterHTOff": "3",
         "Data_LA": "1",
         "Errata": "BDM100, BDM35",
         "EventCode": "0xcd",
@@ -151,13 +122,10 @@
         "PEBS": "2",
         "PublicDescription": "Counts randomly selected loads with latency =
value being above 32.",
         "SampleAfterValue": "100007",
-        "TakenAlone": "1",
         "UMask": "0x1"
     },
     {
         "BriefDescription": "Randomly selected loads with latency value be=
ing above 4",
-        "Counter": "3",
-        "CounterHTOff": "3",
         "Data_LA": "1",
         "Errata": "BDM100, BDM35",
         "EventCode": "0xcd",
@@ -167,13 +135,10 @@
         "PEBS": "2",
         "PublicDescription": "Counts randomly selected loads with latency =
value being above four.",
         "SampleAfterValue": "100003",
-        "TakenAlone": "1",
         "UMask": "0x1"
     },
     {
         "BriefDescription": "Randomly selected loads with latency value be=
ing above 512",
-        "Counter": "3",
-        "CounterHTOff": "3",
         "Data_LA": "1",
         "Errata": "BDM100, BDM35",
         "EventCode": "0xcd",
@@ -183,13 +148,10 @@
         "PEBS": "2",
         "PublicDescription": "Counts randomly selected loads with latency =
value being above 512.",
         "SampleAfterValue": "101",
-        "TakenAlone": "1",
         "UMask": "0x1"
     },
     {
         "BriefDescription": "Randomly selected loads with latency value be=
ing above 64",
-        "Counter": "3",
-        "CounterHTOff": "3",
         "Data_LA": "1",
         "Errata": "BDM100, BDM35",
         "EventCode": "0xcd",
@@ -199,13 +161,10 @@
         "PEBS": "2",
         "PublicDescription": "Counts randomly selected loads with latency =
value being above 64.",
         "SampleAfterValue": "2003",
-        "TakenAlone": "1",
         "UMask": "0x1"
     },
     {
         "BriefDescription": "Randomly selected loads with latency value be=
ing above 8",
-        "Counter": "3",
-        "CounterHTOff": "3",
         "Data_LA": "1",
         "Errata": "BDM100, BDM35",
         "EventCode": "0xcd",
@@ -215,13 +174,10 @@
         "PEBS": "2",
         "PublicDescription": "Counts randomly selected loads with latency =
value being above eight.",
         "SampleAfterValue": "50021",
-        "TakenAlone": "1",
         "UMask": "0x1"
     },
     {
         "BriefDescription": "Speculative cache line split load uops dispat=
ched to L1 cache",
-        "Counter": "0,1,2,3",
-        "CounterHTOff": "0,1,2,3,4,5,6,7",
         "EventCode": "0x05",
         "EventName": "MISALIGN_MEM_REF.LOADS",
         "PublicDescription": "This event counts speculative cache-line spl=
it load uops dispatched to the L1 cache.",
@@ -230,8 +186,6 @@
     },
     {
         "BriefDescription": "Speculative cache line split STA uops dispatc=
hed to L1 cache",
-        "Counter": "0,1,2,3",
-        "CounterHTOff": "0,1,2,3,4,5,6,7",
         "EventCode": "0x05",
         "EventName": "MISALIGN_MEM_REF.STORES",
         "PublicDescription": "This event counts speculative cache line spl=
it store-address (STA) uops dispatched to the L1 cache.",
@@ -240,236 +194,177 @@
     },
     {
         "BriefDescription": "Counts all demand & prefetch code reads miss =
in the L3",
-        "Counter": "0,1,2,3",
-        "CounterHTOff": "0,1,2,3",
         "EventCode": "0xB7, 0xBB",
         "EventName": "OFFCORE_RESPONSE.ALL_CODE_RD.LLC_MISS.ANY_RESPONSE",
         "MSRIndex": "0x1a6,0x1a7",
         "MSRValue": "0x3FBFC00244",
-        "Offcore": "1",
         "SampleAfterValue": "100003",
         "UMask": "0x1"
     },
     {
         "BriefDescription": "Counts all demand & prefetch code reads miss =
the L3 and the data is returned from local dram",
-        "Counter": "0,1,2,3",
-        "CounterHTOff": "0,1,2,3",
         "EventCode": "0xB7, 0xBB",
         "EventName": "OFFCORE_RESPONSE.ALL_CODE_RD.LLC_MISS.LOCAL_DRAM",
         "MSRIndex": "0x1a6,0x1a7",
         "MSRValue": "0x604000244",
-        "Offcore": "1",
         "SampleAfterValue": "100003",
         "UMask": "0x1"
     },
     {
         "BriefDescription": "Counts all demand & prefetch data reads miss =
in the L3",
-        "Counter": "0,1,2,3",
-        "CounterHTOff": "0,1,2,3",
         "EventCode": "0xB7, 0xBB",
         "EventName": "OFFCORE_RESPONSE.ALL_DATA_RD.LLC_MISS.ANY_RESPONSE",
         "MSRIndex": "0x1a6,0x1a7",
         "MSRValue": "0x3FBFC00091",
-        "Offcore": "1",
         "SampleAfterValue": "100003",
         "UMask": "0x1"
     },
     {
         "BriefDescription": "Counts all demand & prefetch data reads miss =
the L3 and the data is returned from local dram",
-        "Counter": "0,1,2,3",
-        "CounterHTOff": "0,1,2,3",
         "EventCode": "0xB7, 0xBB",
         "EventName": "OFFCORE_RESPONSE.ALL_DATA_RD.LLC_MISS.LOCAL_DRAM",
         "MSRIndex": "0x1a6,0x1a7",
         "MSRValue": "0x604000091",
-        "Offcore": "1",
         "SampleAfterValue": "100003",
         "UMask": "0x1"
     },
     {
         "BriefDescription": "Counts all demand & prefetch data reads miss =
the L3 and the data is returned from remote dram",
-        "Counter": "0,1,2,3",
-        "CounterHTOff": "0,1,2,3",
         "EventCode": "0xB7, 0xBB",
         "EventName": "OFFCORE_RESPONSE.ALL_DATA_RD.LLC_MISS.REMOTE_DRAM",
         "MSRIndex": "0x1a6,0x1a7",
         "MSRValue": "0x63BC00091",
-        "Offcore": "1",
         "SampleAfterValue": "100003",
         "UMask": "0x1"
     },
     {
         "BriefDescription": "Counts all demand & prefetch data reads miss =
the L3 and the modified data is transferred from remote cache",
-        "Counter": "0,1,2,3",
-        "CounterHTOff": "0,1,2,3",
         "EventCode": "0xB7, 0xBB",
         "EventName": "OFFCORE_RESPONSE.ALL_DATA_RD.LLC_MISS.REMOTE_HITM",
         "MSRIndex": "0x1a6,0x1a7",
         "MSRValue": "0x103FC00091",
-        "Offcore": "1",
         "SampleAfterValue": "100003",
         "UMask": "0x1"
     },
     {
         "BriefDescription": "Counts all demand & prefetch data reads miss =
the L3 and clean or shared data is transferred from remote cache",
-        "Counter": "0,1,2,3",
-        "CounterHTOff": "0,1,2,3",
         "EventCode": "0xB7, 0xBB",
         "EventName": "OFFCORE_RESPONSE.ALL_DATA_RD.LLC_MISS.REMOTE_HIT_FOR=
WARD",
         "MSRIndex": "0x1a6,0x1a7",
         "MSRValue": "0x87FC00091",
-        "Offcore": "1",
         "SampleAfterValue": "100003",
         "UMask": "0x1"
     },
     {
         "BriefDescription": "Counts all data/code/rfo reads (demand & pref=
etch) miss in the L3",
-        "Counter": "0,1,2,3",
-        "CounterHTOff": "0,1,2,3",
         "EventCode": "0xB7, 0xBB",
         "EventName": "OFFCORE_RESPONSE.ALL_READS.LLC_MISS.ANY_RESPONSE",
         "MSRIndex": "0x1a6,0x1a7",
         "MSRValue": "0x3FBFC007F7",
-        "Offcore": "1",
         "SampleAfterValue": "100003",
         "UMask": "0x1"
     },
     {
         "BriefDescription": "Counts all data/code/rfo reads (demand & pref=
etch) miss the L3 and the data is returned from local dram",
-        "Counter": "0,1,2,3",
-        "CounterHTOff": "0,1,2,3",
         "EventCode": "0xB7, 0xBB",
         "EventName": "OFFCORE_RESPONSE.ALL_READS.LLC_MISS.LOCAL_DRAM",
         "MSRIndex": "0x1a6,0x1a7",
         "MSRValue": "0x6040007F7",
-        "Offcore": "1",
         "SampleAfterValue": "100003",
         "UMask": "0x1"
     },
     {
         "BriefDescription": "Counts all data/code/rfo reads (demand & pref=
etch) miss the L3 and the data is returned from remote dram",
-        "Counter": "0,1,2,3",
-        "CounterHTOff": "0,1,2,3",
         "EventCode": "0xB7, 0xBB",
         "EventName": "OFFCORE_RESPONSE.ALL_READS.LLC_MISS.REMOTE_DRAM",
         "MSRIndex": "0x1a6,0x1a7",
         "MSRValue": "0x63BC007F7",
-        "Offcore": "1",
         "SampleAfterValue": "100003",
         "UMask": "0x1"
     },
     {
         "BriefDescription": "Counts all data/code/rfo reads (demand & pref=
etch) miss the L3 and the modified data is transferred from remote cache",
-        "Counter": "0,1,2,3",
-        "CounterHTOff": "0,1,2,3",
         "EventCode": "0xB7, 0xBB",
         "EventName": "OFFCORE_RESPONSE.ALL_READS.LLC_MISS.REMOTE_HITM",
         "MSRIndex": "0x1a6,0x1a7",
         "MSRValue": "0x103FC007F7",
-        "Offcore": "1",
         "SampleAfterValue": "100003",
         "UMask": "0x1"
     },
     {
         "BriefDescription": "Counts all data/code/rfo reads (demand & pref=
etch) miss the L3 and clean or shared data is transferred from remote cache=
",
-        "Counter": "0,1,2,3",
-        "CounterHTOff": "0,1,2,3",
         "EventCode": "0xB7, 0xBB",
         "EventName": "OFFCORE_RESPONSE.ALL_READS.LLC_MISS.REMOTE_HIT_FORWA=
RD",
         "MSRIndex": "0x1a6,0x1a7",
         "MSRValue": "0x87FC007F7",
-        "Offcore": "1",
         "SampleAfterValue": "100003",
         "UMask": "0x1"
     },
     {
         "BriefDescription": "Counts all requests miss in the L3",
-        "Counter": "0,1,2,3",
-        "CounterHTOff": "0,1,2,3",
         "EventCode": "0xB7, 0xBB",
         "EventName": "OFFCORE_RESPONSE.ALL_REQUESTS.LLC_MISS.ANY_RESPONSE"=
,
         "MSRIndex": "0x1a6,0x1a7",
         "MSRValue": "0x3FBFC08FFF",
-        "Offcore": "1",
         "SampleAfterValue": "100003",
         "UMask": "0x1"
     },
     {
         "BriefDescription": "Counts all demand & prefetch RFOs miss in the=
 L3",
-        "Counter": "0,1,2,3",
-        "CounterHTOff": "0,1,2,3",
         "EventCode": "0xB7, 0xBB",
         "EventName": "OFFCORE_RESPONSE.ALL_RFO.LLC_MISS.ANY_RESPONSE",
         "MSRIndex": "0x1a6,0x1a7",
         "MSRValue": "0x3FBFC00122",
-        "Offcore": "1",
         "SampleAfterValue": "100003",
         "UMask": "0x1"
     },
     {
         "BriefDescription": "Counts all demand & prefetch RFOs miss the L3=
 and the data is returned from local dram",
-        "Counter": "0,1,2,3",
-        "CounterHTOff": "0,1,2,3",
         "EventCode": "0xB7, 0xBB",
         "EventName": "OFFCORE_RESPONSE.ALL_RFO.LLC_MISS.LOCAL_DRAM",
         "MSRIndex": "0x1a6,0x1a7",
         "MSRValue": "0x604000122",
-        "Offcore": "1",
         "SampleAfterValue": "100003",
         "UMask": "0x1"
     },
     {
         "BriefDescription": "Counts all demand data writes (RFOs) miss in =
the L3",
-        "Counter": "0,1,2,3",
-        "CounterHTOff": "0,1,2,3",
         "EventCode": "0xB7, 0xBB",
         "EventName": "OFFCORE_RESPONSE.DEMAND_RFO.LLC_MISS.ANY_RESPONSE",
         "MSRIndex": "0x1a6,0x1a7",
         "MSRValue": "0x3FBFC00002",
-        "Offcore": "1",
         "SampleAfterValue": "100003",
         "UMask": "0x1"
     },
     {
         "BriefDescription": "Counts all demand data writes (RFOs) miss the=
 L3 and the modified data is transferred from remote cache",
-        "Counter": "0,1,2,3",
-        "CounterHTOff": "0,1,2,3",
         "EventCode": "0xB7, 0xBB",
         "EventName": "OFFCORE_RESPONSE.DEMAND_RFO.LLC_MISS.REMOTE_HITM",
         "MSRIndex": "0x1a6,0x1a7",
         "MSRValue": "0x103FC00002",
-        "Offcore": "1",
         "SampleAfterValue": "100003",
         "UMask": "0x1"
     },
     {
         "BriefDescription": "Counts prefetch (that bring data to LLC only)=
 code reads miss in the L3",
-        "Counter": "0,1,2,3",
-        "CounterHTOff": "0,1,2,3",
         "EventCode": "0xB7, 0xBB",
         "EventName": "OFFCORE_RESPONSE.PF_LLC_CODE_RD.LLC_MISS.ANY_RESPONS=
E",
         "MSRIndex": "0x1a6,0x1a7",
         "MSRValue": "0x3FBFC00200",
-        "Offcore": "1",
         "SampleAfterValue": "100003",
         "UMask": "0x1"
     },
     {
         "BriefDescription": "Counts all prefetch (that bring data to LLC o=
nly) RFOs miss in the L3",
-        "Counter": "0,1,2,3",
-        "CounterHTOff": "0,1,2,3",
         "EventCode": "0xB7, 0xBB",
         "EventName": "OFFCORE_RESPONSE.PF_LLC_RFO.LLC_MISS.ANY_RESPONSE",
         "MSRIndex": "0x1a6,0x1a7",
         "MSRValue": "0x3FBFC00100",
-        "Offcore": "1",
         "SampleAfterValue": "100003",
         "UMask": "0x1"
     },
     {
         "BriefDescription": "Number of times RTM abort was triggered",
-        "Counter": "0,1,2,3",
-        "CounterHTOff": "0,1,2,3",
         "EventCode": "0xc9",
         "EventName": "RTM_RETIRED.ABORTED",
         "PEBS": "1",
@@ -479,8 +374,6 @@
     },
     {
         "BriefDescription": "Number of times an RTM execution aborted due =
to various memory events (e.g. read/write capacity and conflicts)",
-        "Counter": "0,1,2,3",
-        "CounterHTOff": "0,1,2,3",
         "EventCode": "0xc9",
         "EventName": "RTM_RETIRED.ABORTED_MISC1",
         "PublicDescription": "Number of times an RTM abort was attributed =
to a Memory condition (See TSX_Memory event for additional details).",
@@ -489,8 +382,6 @@
     },
     {
         "BriefDescription": "Number of times an RTM execution aborted due =
to various memory events (e.g., read/write capacity and conflicts).",
-        "Counter": "0,1,2,3",
-        "CounterHTOff": "0,1,2,3",
         "EventCode": "0xc9",
         "EventName": "RTM_RETIRED.ABORTED_MISC2",
         "PublicDescription": "Number of times the TSX watchdog signaled an=
 RTM abort.",
@@ -499,8 +390,6 @@
     },
     {
         "BriefDescription": "Number of times an RTM execution aborted due =
to HLE-unfriendly instructions",
-        "Counter": "0,1,2,3",
-        "CounterHTOff": "0,1,2,3",
         "EventCode": "0xc9",
         "EventName": "RTM_RETIRED.ABORTED_MISC3",
         "PublicDescription": "Number of times a disallowed operation cause=
d an RTM abort.",
@@ -509,8 +398,6 @@
     },
     {
         "BriefDescription": "Number of times an RTM execution aborted due =
to incompatible memory type",
-        "Counter": "0,1,2,3",
-        "CounterHTOff": "0,1,2,3",
         "EventCode": "0xc9",
         "EventName": "RTM_RETIRED.ABORTED_MISC4",
         "PublicDescription": "Number of times a RTM caused a fault.",
@@ -519,8 +406,6 @@
     },
     {
         "BriefDescription": "Number of times an RTM execution aborted due =
to none of the previous 4 categories (e.g. interrupt)",
-        "Counter": "0,1,2,3",
-        "CounterHTOff": "0,1,2,3",
         "EventCode": "0xc9",
         "EventName": "RTM_RETIRED.ABORTED_MISC5",
         "PublicDescription": "Number of times RTM aborted and was not due =
to the abort conditions in subevents 3-6.",
@@ -529,8 +414,6 @@
     },
     {
         "BriefDescription": "Number of times RTM commit succeeded",
-        "Counter": "0,1,2,3",
-        "CounterHTOff": "0,1,2,3",
         "EventCode": "0xc9",
         "EventName": "RTM_RETIRED.COMMIT",
         "PublicDescription": "Number of times RTM commit succeeded.",
@@ -539,8 +422,6 @@
     },
     {
         "BriefDescription": "Number of times we entered an RTM region; doe=
s not count nested transactions",
-        "Counter": "0,1,2,3",
-        "CounterHTOff": "0,1,2,3",
         "EventCode": "0xc9",
         "EventName": "RTM_RETIRED.START",
         "PublicDescription": "Number of times we entered an RTM region\n d=
oes not count nested transactions.",
@@ -549,8 +430,6 @@
     },
     {
         "BriefDescription": "Counts the number of times a class of instruc=
tions that may cause a transactional abort was executed. Since this is the =
count of execution, it may not always cause a transactional abort.",
-        "Counter": "0,1,2,3",
-        "CounterHTOff": "0,1,2,3,4,5,6,7",
         "EventCode": "0x5d",
         "EventName": "TX_EXEC.MISC1",
         "SampleAfterValue": "2000003",
@@ -558,8 +437,6 @@
     },
     {
         "BriefDescription": "Counts the number of times a class of instruc=
tions (e.g., vzeroupper) that may cause a transactional abort was executed =
inside a transactional region",
-        "Counter": "0,1,2,3",
-        "CounterHTOff": "0,1,2,3,4,5,6,7",
         "EventCode": "0x5d",
         "EventName": "TX_EXEC.MISC2",
         "PublicDescription": "Unfriendly TSX abort triggered by  a vzeroup=
per instruction.",
@@ -568,8 +445,6 @@
     },
     {
         "BriefDescription": "Counts the number of times an instruction exe=
cution caused the transactional nest count supported to be exceeded",
-        "Counter": "0,1,2,3",
-        "CounterHTOff": "0,1,2,3,4,5,6,7",
         "EventCode": "0x5d",
         "EventName": "TX_EXEC.MISC3",
         "PublicDescription": "Unfriendly TSX abort triggered by a nest cou=
nt that is too deep.",
@@ -578,8 +453,6 @@
     },
     {
         "BriefDescription": "Counts the number of times a XBEGIN instructi=
on was executed inside an HLE transactional region.",
-        "Counter": "0,1,2,3",
-        "CounterHTOff": "0,1,2,3,4,5,6,7",
         "EventCode": "0x5d",
         "EventName": "TX_EXEC.MISC4",
         "PublicDescription": "RTM region detected inside HLE.",
@@ -588,8 +461,6 @@
     },
     {
         "BriefDescription": "Counts the number of times an HLE XACQUIRE in=
struction was executed inside an RTM transactional region.",
-        "Counter": "0,1,2,3",
-        "CounterHTOff": "0,1,2,3,4,5,6,7",
         "EventCode": "0x5d",
         "EventName": "TX_EXEC.MISC5",
         "SampleAfterValue": "2000003",
@@ -597,8 +468,6 @@
     },
     {
         "BriefDescription": "Number of times a TSX Abort was triggered due=
 to an evicted line caused by a transaction overflow",
-        "Counter": "0,1,2,3",
-        "CounterHTOff": "0,1,2,3,4,5,6,7",
         "EventCode": "0x54",
         "EventName": "TX_MEM.ABORT_CAPACITY_WRITE",
         "PublicDescription": "Number of times a TSX Abort was triggered du=
e to an evicted line caused by a transaction overflow.",
@@ -607,8 +476,6 @@
     },
     {
         "BriefDescription": "Number of times a TSX line had a cache confli=
ct",
-        "Counter": "0,1,2,3",
-        "CounterHTOff": "0,1,2,3,4,5,6,7",
         "EventCode": "0x54",
         "EventName": "TX_MEM.ABORT_CONFLICT",
         "PublicDescription": "Number of times a TSX line had a cache confl=
ict.",
@@ -617,8 +484,6 @@
     },
     {
         "BriefDescription": "Number of times a TSX Abort was triggered due=
 to release/commit but data and address mismatch",
-        "Counter": "0,1,2,3",
-        "CounterHTOff": "0,1,2,3,4,5,6,7",
         "EventCode": "0x54",
         "EventName": "TX_MEM.ABORT_HLE_ELISION_BUFFER_MISMATCH",
         "PublicDescription": "Number of times a TSX Abort was triggered du=
e to release/commit but data and address mismatch.",
@@ -627,8 +492,6 @@
     },
     {
         "BriefDescription": "Number of times a TSX Abort was triggered due=
 to commit but Lock Buffer not empty",
-        "Counter": "0,1,2,3",
-        "CounterHTOff": "0,1,2,3,4,5,6,7",
         "EventCode": "0x54",
         "EventName": "TX_MEM.ABORT_HLE_ELISION_BUFFER_NOT_EMPTY",
         "PublicDescription": "Number of times a TSX Abort was triggered du=
e to commit but Lock Buffer not empty.",
@@ -637,8 +500,6 @@
     },
     {
         "BriefDescription": "Number of times a TSX Abort was triggered due=
 to attempting an unsupported alignment from Lock Buffer",
-        "Counter": "0,1,2,3",
-        "CounterHTOff": "0,1,2,3,4,5,6,7",
         "EventCode": "0x54",
         "EventName": "TX_MEM.ABORT_HLE_ELISION_BUFFER_UNSUPPORTED_ALIGNMEN=
T",
         "PublicDescription": "Number of times a TSX Abort was triggered du=
e to attempting an unsupported alignment from Lock Buffer.",
@@ -647,8 +508,6 @@
     },
     {
         "BriefDescription": "Number of times a TSX Abort was triggered due=
 to a non-release/commit store to lock",
-        "Counter": "0,1,2,3",
-        "CounterHTOff": "0,1,2,3,4,5,6,7",
         "EventCode": "0x54",
         "EventName": "TX_MEM.ABORT_HLE_STORE_TO_ELIDED_LOCK",
         "PublicDescription": "Number of times a TSX Abort was triggered du=
e to a non-release/commit store to lock.",
@@ -657,8 +516,6 @@
     },
     {
         "BriefDescription": "Number of times we could not allocate Lock Bu=
ffer",
-        "Counter": "0,1,2,3",
-        "CounterHTOff": "0,1,2,3,4,5,6,7",
         "EventCode": "0x54",
         "EventName": "TX_MEM.HLE_ELISION_BUFFER_FULL",
         "PublicDescription": "Number of times we could not allocate Lock B=
uffer.",
diff --git a/tools/perf/pmu-events/arch/x86/broadwellx/other.json b/tools/p=
erf/pmu-events/arch/x86/broadwellx/other.json
index 917d145d5227..1c2a5b001949 100644
--- a/tools/perf/pmu-events/arch/x86/broadwellx/other.json
+++ b/tools/perf/pmu-events/arch/x86/broadwellx/other.json
@@ -1,8 +1,6 @@
 [
     {
         "BriefDescription": "Unhalted core cycles when the thread is in ri=
ng 0",
-        "Counter": "0,1,2,3",
-        "CounterHTOff": "0,1,2,3,4,5,6,7",
         "EventCode": "0x5C",
         "EventName": "CPL_CYCLES.RING0",
         "PublicDescription": "This event counts the unhalted core cycles d=
uring which the thread is in the ring 0 privileged mode.",
@@ -11,8 +9,6 @@
     },
     {
         "BriefDescription": "Number of intervals between processor halts w=
hile thread is in ring 0",
-        "Counter": "0,1,2,3",
-        "CounterHTOff": "0,1,2,3,4,5,6,7",
         "CounterMask": "1",
         "EdgeDetect": "1",
         "EventCode": "0x5C",
@@ -23,8 +19,6 @@
     },
     {
         "BriefDescription": "Unhalted core cycles when thread is in rings =
1, 2, or 3",
-        "Counter": "0,1,2,3",
-        "CounterHTOff": "0,1,2,3,4,5,6,7",
         "EventCode": "0x5C",
         "EventName": "CPL_CYCLES.RING123",
         "PublicDescription": "This event counts unhalted core cycles durin=
g which the thread is in rings 1, 2, or 3.",
@@ -33,8 +27,6 @@
     },
     {
         "BriefDescription": "Cycles when L1 and L2 are locked due to UC or=
 split lock",
-        "Counter": "0,1,2,3",
-        "CounterHTOff": "0,1,2,3,4,5,6,7",
         "EventCode": "0x63",
         "EventName": "LOCK_CYCLES.SPLIT_LOCK_UC_LOCK_DURATION",
         "PublicDescription": "This event counts cycles in which the L1 and=
 L2 are locked due to a UC lock or split lock. A lock is asserted in case o=
f locked memory access, due to noncacheable memory, locked operation that s=
pans two cache lines, or a page walk from the noncacheable page table. L1D =
and L2 locks have a very high performance penalty and it is highly recommen=
ded to avoid such access.",
diff --git a/tools/perf/pmu-events/arch/x86/broadwellx/pipeline.json b/tool=
s/perf/pmu-events/arch/x86/broadwellx/pipeline.json
index f0f30081d683..75233316640b 100644
--- a/tools/perf/pmu-events/arch/x86/broadwellx/pipeline.json
+++ b/tools/perf/pmu-events/arch/x86/broadwellx/pipeline.json
@@ -1,8 +1,6 @@
 [
     {
         "BriefDescription": "Cycles when divider is busy executing divide =
operations",
-        "Counter": "0,1,2,3",
-        "CounterHTOff": "0,1,2,3,4,5,6,7",
         "EventCode": "0x14",
         "EventName": "ARITH.FPU_DIV_ACTIVE",
         "PublicDescription": "This event counts the number of the divide o=
perations executed. Uses edge-detect and a cmask value of 1 on ARITH.FPU_DI=
V_ACTIVE to get the number of the divide operations executed.",
@@ -11,8 +9,6 @@
     },
     {
         "BriefDescription": "Speculative and retired  branches",
-        "Counter": "0,1,2,3",
-        "CounterHTOff": "0,1,2,3,4,5,6,7",
         "EventCode": "0x88",
         "EventName": "BR_INST_EXEC.ALL_BRANCHES",
         "PublicDescription": "This event counts both taken and not taken s=
peculative and retired branch instructions.",
@@ -21,8 +17,6 @@
     },
     {
         "BriefDescription": "Speculative and retired macro-conditional bra=
nches",
-        "Counter": "0,1,2,3",
-        "CounterHTOff": "0,1,2,3,4,5,6,7",
         "EventCode": "0x88",
         "EventName": "BR_INST_EXEC.ALL_CONDITIONAL",
         "PublicDescription": "This event counts both taken and not taken s=
peculative and retired macro-conditional branch instructions.",
@@ -31,8 +25,6 @@
     },
     {
         "BriefDescription": "Speculative and retired macro-unconditional b=
ranches excluding calls and indirects",
-        "Counter": "0,1,2,3",
-        "CounterHTOff": "0,1,2,3,4,5,6,7",
         "EventCode": "0x88",
         "EventName": "BR_INST_EXEC.ALL_DIRECT_JMP",
         "PublicDescription": "This event counts both taken and not taken s=
peculative and retired macro-unconditional branch instructions, excluding c=
alls and indirects.",
@@ -41,8 +33,6 @@
     },
     {
         "BriefDescription": "Speculative and retired direct near calls",
-        "Counter": "0,1,2,3",
-        "CounterHTOff": "0,1,2,3,4,5,6,7",
         "EventCode": "0x88",
         "EventName": "BR_INST_EXEC.ALL_DIRECT_NEAR_CALL",
         "PublicDescription": "This event counts both taken and not taken s=
peculative and retired direct near calls.",
@@ -51,8 +41,6 @@
     },
     {
         "BriefDescription": "Speculative and retired indirect branches exc=
luding calls and returns",
-        "Counter": "0,1,2,3",
-        "CounterHTOff": "0,1,2,3,4,5,6,7",
         "EventCode": "0x88",
         "EventName": "BR_INST_EXEC.ALL_INDIRECT_JUMP_NON_CALL_RET",
         "PublicDescription": "This event counts both taken and not taken s=
peculative and retired indirect branches excluding calls and return branche=
s.",
@@ -61,8 +49,6 @@
     },
     {
         "BriefDescription": "Speculative and retired indirect return branc=
hes.",
-        "Counter": "0,1,2,3",
-        "CounterHTOff": "0,1,2,3,4,5,6,7",
         "EventCode": "0x88",
         "EventName": "BR_INST_EXEC.ALL_INDIRECT_NEAR_RETURN",
         "PublicDescription": "This event counts both taken and not taken s=
peculative and retired indirect branches that have a return mnemonic.",
@@ -71,8 +57,6 @@
     },
     {
         "BriefDescription": "Not taken macro-conditional branches",
-        "Counter": "0,1,2,3",
-        "CounterHTOff": "0,1,2,3,4,5,6,7",
         "EventCode": "0x88",
         "EventName": "BR_INST_EXEC.NONTAKEN_CONDITIONAL",
         "PublicDescription": "This event counts not taken macro-conditiona=
l branch instructions.",
@@ -81,8 +65,6 @@
     },
     {
         "BriefDescription": "Taken speculative and retired macro-condition=
al branches",
-        "Counter": "0,1,2,3",
-        "CounterHTOff": "0,1,2,3,4,5,6,7",
         "EventCode": "0x88",
         "EventName": "BR_INST_EXEC.TAKEN_CONDITIONAL",
         "PublicDescription": "This event counts taken speculative and reti=
red macro-conditional branch instructions.",
@@ -91,8 +73,6 @@
     },
     {
         "BriefDescription": "Taken speculative and retired macro-condition=
al branch instructions excluding calls and indirects",
-        "Counter": "0,1,2,3",
-        "CounterHTOff": "0,1,2,3,4,5,6,7",
         "EventCode": "0x88",
         "EventName": "BR_INST_EXEC.TAKEN_DIRECT_JUMP",
         "PublicDescription": "This event counts taken speculative and reti=
red macro-conditional branch instructions excluding calls and indirect bran=
ches.",
@@ -101,8 +81,6 @@
     },
     {
         "BriefDescription": "Taken speculative and retired direct near cal=
ls",
-        "Counter": "0,1,2,3",
-        "CounterHTOff": "0,1,2,3,4,5,6,7",
         "EventCode": "0x88",
         "EventName": "BR_INST_EXEC.TAKEN_DIRECT_NEAR_CALL",
         "PublicDescription": "This event counts taken speculative and reti=
red direct near calls.",
@@ -111,8 +89,6 @@
     },
     {
         "BriefDescription": "Taken speculative and retired indirect branch=
es excluding calls and returns",
-        "Counter": "0,1,2,3",
-        "CounterHTOff": "0,1,2,3,4,5,6,7",
         "EventCode": "0x88",
         "EventName": "BR_INST_EXEC.TAKEN_INDIRECT_JUMP_NON_CALL_RET",
         "PublicDescription": "This event counts taken speculative and reti=
red indirect branches excluding calls and return branches.",
@@ -121,8 +97,6 @@
     },
     {
         "BriefDescription": "Taken speculative and retired indirect calls"=
,
-        "Counter": "0,1,2,3",
-        "CounterHTOff": "0,1,2,3,4,5,6,7",
         "EventCode": "0x88",
         "EventName": "BR_INST_EXEC.TAKEN_INDIRECT_NEAR_CALL",
         "PublicDescription": "This event counts taken speculative and reti=
red indirect calls including both register and memory indirect.",
@@ -131,8 +105,6 @@
     },
     {
         "BriefDescription": "Taken speculative and retired indirect branch=
es with return mnemonic",
-        "Counter": "0,1,2,3",
-        "CounterHTOff": "0,1,2,3,4,5,6,7",
         "EventCode": "0x88",
         "EventName": "BR_INST_EXEC.TAKEN_INDIRECT_NEAR_RETURN",
         "PublicDescription": "This event counts taken speculative and reti=
red indirect branches that have a return mnemonic.",
@@ -141,8 +113,6 @@
     },
     {
         "BriefDescription": "All (macro) branch instructions retired.",
-        "Counter": "0,1,2,3",
-        "CounterHTOff": "0,1,2,3,4,5,6,7",
         "EventCode": "0xC4",
         "EventName": "BR_INST_RETIRED.ALL_BRANCHES",
         "PublicDescription": "This event counts all (macro) branch instruc=
tions retired.",
@@ -150,8 +120,6 @@
     },
     {
         "BriefDescription": "All (macro) branch instructions retired. (Pre=
cise Event - PEBS)",
-        "Counter": "0,1,2,3",
-        "CounterHTOff": "0,1,2,3",
         "Errata": "BDW98",
         "EventCode": "0xC4",
         "EventName": "BR_INST_RETIRED.ALL_BRANCHES_PEBS",
@@ -162,8 +130,6 @@
     },
     {
         "BriefDescription": "Conditional branch instructions retired.",
-        "Counter": "0,1,2,3",
-        "CounterHTOff": "0,1,2,3,4,5,6,7",
         "EventCode": "0xC4",
         "EventName": "BR_INST_RETIRED.CONDITIONAL",
         "PEBS": "1",
@@ -173,8 +139,6 @@
     },
     {
         "BriefDescription": "Far branch instructions retired.",
-        "Counter": "0,1,2,3",
-        "CounterHTOff": "0,1,2,3,4,5,6,7",
         "Errata": "BDW98",
         "EventCode": "0xC4",
         "EventName": "BR_INST_RETIRED.FAR_BRANCH",
@@ -184,8 +148,6 @@
     },
     {
         "BriefDescription": "Direct and indirect near call instructions re=
tired.",
-        "Counter": "0,1,2,3",
-        "CounterHTOff": "0,1,2,3,4,5,6,7",
         "EventCode": "0xC4",
         "EventName": "BR_INST_RETIRED.NEAR_CALL",
         "PEBS": "1",
@@ -195,8 +157,6 @@
     },
     {
         "BriefDescription": "Direct and indirect macro near call instructi=
ons retired (captured in ring 3).",
-        "Counter": "0,1,2,3",
-        "CounterHTOff": "0,1,2,3,4,5,6,7",
         "EventCode": "0xC4",
         "EventName": "BR_INST_RETIRED.NEAR_CALL_R3",
         "PEBS": "1",
@@ -206,8 +166,6 @@
     },
     {
         "BriefDescription": "Return instructions retired.",
-        "Counter": "0,1,2,3",
-        "CounterHTOff": "0,1,2,3,4,5,6,7",
         "EventCode": "0xC4",
         "EventName": "BR_INST_RETIRED.NEAR_RETURN",
         "PEBS": "1",
@@ -217,8 +175,6 @@
     },
     {
         "BriefDescription": "Taken branch instructions retired.",
-        "Counter": "0,1,2,3",
-        "CounterHTOff": "0,1,2,3,4,5,6,7",
         "EventCode": "0xC4",
         "EventName": "BR_INST_RETIRED.NEAR_TAKEN",
         "PEBS": "1",
@@ -228,8 +184,6 @@
     },
     {
         "BriefDescription": "Not taken branch instructions retired.",
-        "Counter": "0,1,2,3",
-        "CounterHTOff": "0,1,2,3,4,5,6,7",
         "EventCode": "0xC4",
         "EventName": "BR_INST_RETIRED.NOT_TAKEN",
         "PublicDescription": "This event counts not taken branch instructi=
ons retired.",
@@ -238,8 +192,6 @@
     },
     {
         "BriefDescription": "Speculative and retired mispredicted macro co=
nditional branches",
-        "Counter": "0,1,2,3",
-        "CounterHTOff": "0,1,2,3,4,5,6,7",
         "EventCode": "0x89",
         "EventName": "BR_MISP_EXEC.ALL_BRANCHES",
         "PublicDescription": "This event counts both taken and not taken s=
peculative and retired mispredicted branch instructions.",
@@ -248,8 +200,6 @@
     },
     {
         "BriefDescription": "Speculative and retired mispredicted macro co=
nditional branches",
-        "Counter": "0,1,2,3",
-        "CounterHTOff": "0,1,2,3,4,5,6,7",
         "EventCode": "0x89",
         "EventName": "BR_MISP_EXEC.ALL_CONDITIONAL",
         "PublicDescription": "This event counts both taken and not taken s=
peculative and retired mispredicted macro conditional branch instructions."=
,
@@ -258,8 +208,6 @@
     },
     {
         "BriefDescription": "Mispredicted indirect branches excluding call=
s and returns",
-        "Counter": "0,1,2,3",
-        "CounterHTOff": "0,1,2,3,4,5,6,7",
         "EventCode": "0x89",
         "EventName": "BR_MISP_EXEC.ALL_INDIRECT_JUMP_NON_CALL_RET",
         "PublicDescription": "This event counts both taken and not taken m=
ispredicted indirect branches excluding calls and returns.",
@@ -268,8 +216,6 @@
     },
     {
         "BriefDescription": "Not taken speculative and retired mispredicte=
d macro conditional branches",
-        "Counter": "0,1,2,3",
-        "CounterHTOff": "0,1,2,3,4,5,6,7",
         "EventCode": "0x89",
         "EventName": "BR_MISP_EXEC.NONTAKEN_CONDITIONAL",
         "PublicDescription": "This event counts not taken speculative and =
retired mispredicted macro conditional branch instructions.",
@@ -278,8 +224,6 @@
     },
     {
         "BriefDescription": "Taken speculative and retired mispredicted ma=
cro conditional branches",
-        "Counter": "0,1,2,3",
-        "CounterHTOff": "0,1,2,3,4,5,6,7",
         "EventCode": "0x89",
         "EventName": "BR_MISP_EXEC.TAKEN_CONDITIONAL",
         "PublicDescription": "This event counts taken speculative and reti=
red mispredicted macro conditional branch instructions.",
@@ -288,8 +232,6 @@
     },
     {
         "BriefDescription": "Taken speculative and retired mispredicted in=
direct branches excluding calls and returns",
-        "Counter": "0,1,2,3",
-        "CounterHTOff": "0,1,2,3,4,5,6,7",
         "EventCode": "0x89",
         "EventName": "BR_MISP_EXEC.TAKEN_INDIRECT_JUMP_NON_CALL_RET",
         "PublicDescription": "This event counts taken speculative and reti=
red mispredicted indirect branches excluding calls and returns.",
@@ -298,8 +240,6 @@
     },
     {
         "BriefDescription": "Taken speculative and retired mispredicted in=
direct calls.",
-        "Counter": "0,1,2,3",
-        "CounterHTOff": "0,1,2,3,4,5,6,7",
         "EventCode": "0x89",
         "EventName": "BR_MISP_EXEC.TAKEN_INDIRECT_NEAR_CALL",
         "SampleAfterValue": "200003",
@@ -307,8 +247,6 @@
     },
     {
         "BriefDescription": "Taken speculative and retired mispredicted in=
direct branches with return mnemonic",
-        "Counter": "0,1,2,3",
-        "CounterHTOff": "0,1,2,3,4,5,6,7",
         "EventCode": "0x89",
         "EventName": "BR_MISP_EXEC.TAKEN_RETURN_NEAR",
         "PublicDescription": "This event counts taken speculative and reti=
red mispredicted indirect branches that have a return mnemonic.",
@@ -317,8 +255,6 @@
     },
     {
         "BriefDescription": "All mispredicted macro branch instructions re=
tired.",
-        "Counter": "0,1,2,3",
-        "CounterHTOff": "0,1,2,3,4,5,6,7",
         "EventCode": "0xC5",
         "EventName": "BR_MISP_RETIRED.ALL_BRANCHES",
         "PublicDescription": "This event counts all mispredicted macro bra=
nch instructions retired.",
@@ -326,8 +262,6 @@
     },
     {
         "BriefDescription": "Mispredicted macro branch instructions retire=
d. (Precise Event - PEBS)",
-        "Counter": "0,1,2,3",
-        "CounterHTOff": "0,1,2,3",
         "EventCode": "0xC5",
         "EventName": "BR_MISP_RETIRED.ALL_BRANCHES_PEBS",
         "PEBS": "2",
@@ -337,8 +271,6 @@
     },
     {
         "BriefDescription": "Mispredicted conditional branch instructions =
retired.",
-        "Counter": "0,1,2,3",
-        "CounterHTOff": "0,1,2,3,4,5,6,7",
         "EventCode": "0xC5",
         "EventName": "BR_MISP_RETIRED.CONDITIONAL",
         "PEBS": "1",
@@ -348,8 +280,6 @@
     },
     {
         "BriefDescription": "number of near branch instructions retired th=
at were mispredicted and taken.",
-        "Counter": "0,1,2,3",
-        "CounterHTOff": "0,1,2,3,4,5,6,7",
         "EventCode": "0xC5",
         "EventName": "BR_MISP_RETIRED.NEAR_TAKEN",
         "PEBS": "1",
@@ -359,8 +289,6 @@
     },
     {
         "BriefDescription": "This event counts the number of mispredicted =
ret instructions retired. Non PEBS",
-        "Counter": "0,1,2,3",
-        "CounterHTOff": "0,1,2,3,4,5,6,7",
         "EventCode": "0xC5",
         "EventName": "BR_MISP_RETIRED.RET",
         "PEBS": "1",
@@ -370,8 +298,6 @@
     },
     {
         "BriefDescription": "Count XClk pulses when this thread is unhalte=
d and the other thread is halted.",
-        "Counter": "0,1,2,3",
-        "CounterHTOff": "0,1,2,3",
         "EventCode": "0x3c",
         "EventName": "CPU_CLK_THREAD_UNHALTED.ONE_THREAD_ACTIVE",
         "SampleAfterValue": "100003",
@@ -379,8 +305,6 @@
     },
     {
         "BriefDescription": "Reference cycles when the thread is unhalted =
(counts at 100 MHz rate)",
-        "Counter": "0,1,2,3",
-        "CounterHTOff": "0,1,2,3,4,5,6,7",
         "EventCode": "0x3C",
         "EventName": "CPU_CLK_THREAD_UNHALTED.REF_XCLK",
         "PublicDescription": "This is a fixed-frequency event programmed t=
o general counters. It counts when the core is unhalted at 100 Mhz.",
@@ -390,8 +314,6 @@
     {
         "AnyThread": "1",
         "BriefDescription": "Reference cycles when the at least one thread=
 on the physical core is unhalted (counts at 100 MHz rate).",
-        "Counter": "0,1,2,3",
-        "CounterHTOff": "0,1,2,3,4,5,6,7",
         "EventCode": "0x3C",
         "EventName": "CPU_CLK_THREAD_UNHALTED.REF_XCLK_ANY",
         "SampleAfterValue": "100003",
@@ -399,8 +321,6 @@
     },
     {
         "BriefDescription": "Count XClk pulses when this thread is unhalte=
d and the other thread is halted.",
-        "Counter": "0,1,2,3",
-        "CounterHTOff": "0,1,2,3,4,5,6,7",
         "EventCode": "0x3C",
         "EventName": "CPU_CLK_UNHALTED.ONE_THREAD_ACTIVE",
         "SampleAfterValue": "100003",
@@ -408,8 +328,6 @@
     },
     {
         "BriefDescription": "Reference cycles when the core is not in halt=
 state.",
-        "Counter": "Fixed counter 2",
-        "CounterHTOff": "Fixed counter 2",
         "EventName": "CPU_CLK_UNHALTED.REF_TSC",
         "PublicDescription": "This event counts the number of reference cy=
cles when the core is not in a halt state. The core enters the halt state w=
hen it is running the HLT instruction or the MWAIT instruction. This event =
is not affected by core frequency changes (for example, P states, TM2 trans=
itions) but has the same incrementing frequency as the time stamp counter. =
This event can approximate elapsed time while the core was not in a halt st=
ate. This event has a constant ratio with the CPU_CLK_UNHALTED.REF_XCLK eve=
nt. It is counted on a dedicated fixed counter, leaving the four (eight whe=
n Hyperthreading is disabled) programmable counters available for other eve=
nts. \nNote: On all current platforms this event stops counting during 'thr=
ottling (TM)' states duty off periods the processor is 'halted'.  This even=
t is clocked by base clock (100 Mhz) on Sandy Bridge. The counter update is=
 done at a lower clock rate then the core clock the overflow status bit for=
 this counter may appear 'sticky'.  After the counter has overflowed and so=
ftware clears the overflow status bit and resets the counter to less than M=
AX. The reset value to the counter is not clocked immediately so the overfl=
ow status bit will flip 'high (1)' and generate another PMI (if enabled) af=
ter which the reset value gets clocked into the counter. Therefore, softwar=
e will get the interrupt, read the overflow status bit '1 for bit 34 while =
the counter value is less than MAX. Software should ignore this case.",
         "SampleAfterValue": "2000003",
@@ -417,8 +335,6 @@
     },
     {
         "BriefDescription": "Reference cycles when the thread is unhalted =
(counts at 100 MHz rate)",
-        "Counter": "0,1,2,3",
-        "CounterHTOff": "0,1,2,3,4,5,6,7",
         "EventCode": "0x3C",
         "EventName": "CPU_CLK_UNHALTED.REF_XCLK",
         "PublicDescription": "Reference cycles when the thread is unhalted=
 (counts at 100 MHz rate).",
@@ -428,8 +344,6 @@
     {
         "AnyThread": "1",
         "BriefDescription": "Reference cycles when the at least one thread=
 on the physical core is unhalted (counts at 100 MHz rate).",
-        "Counter": "0,1,2,3",
-        "CounterHTOff": "0,1,2,3,4,5,6,7",
         "EventCode": "0x3C",
         "EventName": "CPU_CLK_UNHALTED.REF_XCLK_ANY",
         "SampleAfterValue": "100003",
@@ -437,8 +351,6 @@
     },
     {
         "BriefDescription": "Core cycles when the thread is not in halt st=
ate",
-        "Counter": "Fixed counter 1",
-        "CounterHTOff": "Fixed counter 1",
         "EventName": "CPU_CLK_UNHALTED.THREAD",
         "PublicDescription": "This event counts the number of core cycles =
while the thread is not in a halt state. The thread enters the halt state w=
hen it is running the HLT instruction. This event is a component in many ke=
y event ratios. The core frequency may change from time to time due to tran=
sitions associated with Enhanced Intel SpeedStep Technology or TM2. For thi=
s reason this event may have a changing ratio with regards to time. When th=
e core frequency is constant, this event can approximate elapsed time while=
 the core was not in the halt state. It is counted on a dedicated fixed cou=
nter, leaving the four (eight when Hyperthreading is disabled) programmable=
 counters available for other events.",
         "SampleAfterValue": "2000003",
@@ -447,16 +359,12 @@
     {
         "AnyThread": "1",
         "BriefDescription": "Core cycles when at least one thread on the p=
hysical core is not in halt state.",
-        "Counter": "Fixed counter 1",
-        "CounterHTOff": "Fixed counter 1",
         "EventName": "CPU_CLK_UNHALTED.THREAD_ANY",
         "SampleAfterValue": "2000003",
         "UMask": "0x2"
     },
     {
         "BriefDescription": "Thread cycles when thread is not in halt stat=
e",
-        "Counter": "0,1,2,3",
-        "CounterHTOff": "0,1,2,3,4,5,6,7",
         "EventCode": "0x3C",
         "EventName": "CPU_CLK_UNHALTED.THREAD_P",
         "PublicDescription": "This is an architectural event that counts t=
he number of thread cycles while the thread is not in a halt state. The thr=
ead enters the halt state when it is running the HLT instruction. The core =
frequency may change from time to time due to power or thermal throttling. =
For this reason, this event may have a changing ratio with regards to wall =
clock time.",
@@ -465,16 +373,12 @@
     {
         "AnyThread": "1",
         "BriefDescription": "Core cycles when at least one thread on the p=
hysical core is not in halt state.",
-        "Counter": "0,1,2,3",
-        "CounterHTOff": "0,1,2,3,4,5,6,7",
         "EventCode": "0x3C",
         "EventName": "CPU_CLK_UNHALTED.THREAD_P_ANY",
         "SampleAfterValue": "2000003"
     },
     {
         "BriefDescription": "Cycles while L1 cache miss demand load is out=
standing.",
-        "Counter": "2",
-        "CounterHTOff": "2",
         "CounterMask": "8",
         "EventCode": "0xA3",
         "EventName": "CYCLE_ACTIVITY.CYCLES_L1D_MISS",
@@ -483,8 +387,6 @@
     },
     {
         "BriefDescription": "Cycles while L1 cache miss demand load is out=
standing.",
-        "Counter": "2",
-        "CounterHTOff": "2",
         "CounterMask": "8",
         "EventCode": "0xA3",
         "EventName": "CYCLE_ACTIVITY.CYCLES_L1D_PENDING",
@@ -494,8 +396,6 @@
     },
     {
         "BriefDescription": "Cycles while L2 cache miss demand load is out=
standing.",
-        "Counter": "0,1,2,3",
-        "CounterHTOff": "0,1,2,3,4,5,6,7",
         "CounterMask": "1",
         "EventCode": "0xA3",
         "EventName": "CYCLE_ACTIVITY.CYCLES_L2_MISS",
@@ -504,8 +404,6 @@
     },
     {
         "BriefDescription": "Cycles while L2 cache miss demand load is out=
standing.",
-        "Counter": "0,1,2,3",
-        "CounterHTOff": "0,1,2,3,4,5,6,7",
         "CounterMask": "1",
         "EventCode": "0xA3",
         "EventName": "CYCLE_ACTIVITY.CYCLES_L2_PENDING",
@@ -515,8 +413,6 @@
     },
     {
         "BriefDescription": "Cycles while memory subsystem has an outstand=
ing load.",
-        "Counter": "0,1,2,3",
-        "CounterHTOff": "0,1,2,3,4,5,6,7",
         "CounterMask": "2",
         "EventCode": "0xA3",
         "EventName": "CYCLE_ACTIVITY.CYCLES_LDM_PENDING",
@@ -526,8 +422,6 @@
     },
     {
         "BriefDescription": "Cycles while memory subsystem has an outstand=
ing load.",
-        "Counter": "0,1,2,3",
-        "CounterHTOff": "0,1,2,3",
         "CounterMask": "2",
         "EventCode": "0xA3",
         "EventName": "CYCLE_ACTIVITY.CYCLES_MEM_ANY",
@@ -536,8 +430,6 @@
     },
     {
         "BriefDescription": "This event increments by 1 for every cycle wh=
ere there was no execute for this thread.",
-        "Counter": "0,1,2,3",
-        "CounterHTOff": "0,1,2,3",
         "CounterMask": "4",
         "EventCode": "0xA3",
         "EventName": "CYCLE_ACTIVITY.CYCLES_NO_EXECUTE",
@@ -547,8 +439,6 @@
     },
     {
         "BriefDescription": "Execution stalls while L1 cache miss demand l=
oad is outstanding.",
-        "Counter": "2",
-        "CounterHTOff": "2",
         "CounterMask": "12",
         "EventCode": "0xA3",
         "EventName": "CYCLE_ACTIVITY.STALLS_L1D_MISS",
@@ -557,8 +447,6 @@
     },
     {
         "BriefDescription": "Execution stalls while L1 cache miss demand l=
oad is outstanding.",
-        "Counter": "2",
-        "CounterHTOff": "2",
         "CounterMask": "12",
         "EventCode": "0xA3",
         "EventName": "CYCLE_ACTIVITY.STALLS_L1D_PENDING",
@@ -568,8 +456,6 @@
     },
     {
         "BriefDescription": "Execution stalls while L2 cache miss demand l=
oad is outstanding.",
-        "Counter": "0,1,2,3",
-        "CounterHTOff": "0,1,2,3,4,5,6,7",
         "CounterMask": "5",
         "EventCode": "0xA3",
         "EventName": "CYCLE_ACTIVITY.STALLS_L2_MISS",
@@ -578,8 +464,6 @@
     },
     {
         "BriefDescription": "Execution stalls while L2 cache miss demand l=
oad is outstanding.",
-        "Counter": "0,1,2,3",
-        "CounterHTOff": "0,1,2,3",
         "CounterMask": "5",
         "EventCode": "0xA3",
         "EventName": "CYCLE_ACTIVITY.STALLS_L2_PENDING",
@@ -589,8 +473,6 @@
     },
     {
         "BriefDescription": "Execution stalls while memory subsystem has a=
n outstanding load.",
-        "Counter": "0,1,2,3",
-        "CounterHTOff": "0,1,2,3",
         "CounterMask": "6",
         "EventCode": "0xA3",
         "EventName": "CYCLE_ACTIVITY.STALLS_LDM_PENDING",
@@ -600,8 +482,6 @@
     },
     {
         "BriefDescription": "Execution stalls while memory subsystem has a=
n outstanding load.",
-        "Counter": "0,1,2,3",
-        "CounterHTOff": "0,1,2,3,4,5,6,7",
         "CounterMask": "6",
         "EventCode": "0xA3",
         "EventName": "CYCLE_ACTIVITY.STALLS_MEM_ANY",
@@ -610,8 +490,6 @@
     },
     {
         "BriefDescription": "Total execution stalls.",
-        "Counter": "0,1,2,3",
-        "CounterHTOff": "0,1,2,3,4,5,6,7",
         "CounterMask": "4",
         "EventCode": "0xA3",
         "EventName": "CYCLE_ACTIVITY.STALLS_TOTAL",
@@ -620,8 +498,6 @@
     },
     {
         "BriefDescription": "Stalls caused by changing prefix length of th=
e instruction.",
-        "Counter": "0,1,2,3",
-        "CounterHTOff": "0,1,2,3,4,5,6,7",
         "EventCode": "0x87",
         "EventName": "ILD_STALL.LCP",
         "PublicDescription": "This event counts stalls occured due to chan=
ging prefix length (66, 67 or REX.W when they change the length of the deco=
ded instruction). Occurrences counting is proportional to the number of pre=
fixes in a 16B-line. This may result in the following penalties: three-cycl=
e penalty for each LCP in a 16-byte chunk.",
@@ -630,8 +506,6 @@
     },
     {
         "BriefDescription": "Instructions retired from execution.",
-        "Counter": "Fixed counter 0",
-        "CounterHTOff": "Fixed counter 0",
         "EventName": "INST_RETIRED.ANY",
         "PublicDescription": "This event counts the number of instructions=
 retired from execution. For instructions that consist of multiple micro-op=
s, this event counts the retirement of the last micro-op of the instruction=
. Counting continues during hardware interrupts, traps, and inside interrup=
t handlers. \nNotes: INST_RETIRED.ANY is counted by a designated fixed coun=
ter, leaving the four (eight when Hyperthreading is disabled) programmable =
counters available for other events. INST_RETIRED.ANY_P is counted by a pro=
grammable counter and it is an architectural performance event. \nCounting:=
 Faulting executions of GETSEC/VM entry/VM Exit/MWait will not count as ret=
ired instructions.",
         "SampleAfterValue": "2000003",
@@ -639,8 +513,6 @@
     },
     {
         "BriefDescription": "Number of instructions retired. General Count=
er   - architectural event",
-        "Counter": "0,1,2,3",
-        "CounterHTOff": "0,1,2,3,4,5,6,7",
         "Errata": "BDM61",
         "EventCode": "0xC0",
         "EventName": "INST_RETIRED.ANY_P",
@@ -649,8 +521,6 @@
     },
     {
         "BriefDescription": "Precise instruction retired event with HW to =
reduce effect of PEBS shadow in IP distribution",
-        "Counter": "1",
-        "CounterHTOff": "1",
         "Errata": "BDM11, BDM55",
         "EventCode": "0xC0",
         "EventName": "INST_RETIRED.PREC_DIST",
@@ -661,8 +531,6 @@
     },
     {
         "BriefDescription": "FP operations  retired. X87 FP operations tha=
t have no exceptions:",
-        "Counter": "0,1,2,3",
-        "CounterHTOff": "0,1,2,3,4,5,6,7",
         "EventCode": "0xC0",
         "EventName": "INST_RETIRED.X87",
         "PublicDescription": "This event counts FP operations retired. For=
 X87 FP operations that have no exceptions counting also includes flows tha=
t have several X87, or flows that use X87 uops in the exception handling.",
@@ -671,8 +539,6 @@
     },
     {
         "BriefDescription": "Cycles when Resource Allocation Table (RAT) e=
xternal stall is sent to Instruction Decode Queue (IDQ) for the thread",
-        "Counter": "0,1,2,3",
-        "CounterHTOff": "0,1,2,3,4,5,6,7",
         "EventCode": "0x0D",
         "EventName": "INT_MISC.RAT_STALL_CYCLES",
         "PublicDescription": "This event counts the number of cycles durin=
g which Resource Allocation Table (RAT) external stall is sent to Instructi=
on Decode Queue (IDQ) for the current thread. This also includes the cycles=
 during which the Allocator is serving another thread.",
@@ -681,8 +547,6 @@
     },
     {
         "BriefDescription": "Core cycles the allocator was stalled due to =
recovery from earlier clear event for this thread (e.g. misprediction or me=
mory nuke)",
-        "Counter": "0,1,2,3",
-        "CounterHTOff": "0,1,2,3,4,5,6,7",
         "CounterMask": "1",
         "EventCode": "0x0D",
         "EventName": "INT_MISC.RECOVERY_CYCLES",
@@ -693,8 +557,6 @@
     {
         "AnyThread": "1",
         "BriefDescription": "Core cycles the allocator was stalled due to =
recovery from earlier clear event for any thread running on the physical co=
re (e.g. misprediction or memory nuke).",
-        "Counter": "0,1,2,3",
-        "CounterHTOff": "0,1,2,3,4,5,6,7",
         "CounterMask": "1",
         "EventCode": "0x0D",
         "EventName": "INT_MISC.RECOVERY_CYCLES_ANY",
@@ -703,8 +565,6 @@
     },
     {
         "BriefDescription": "This event counts the number of times that sp=
lit load operations are temporarily blocked because all resources for handl=
ing the split accesses are in use.",
-        "Counter": "0,1,2,3",
-        "CounterHTOff": "0,1,2,3,4,5,6,7",
         "EventCode": "0x03",
         "EventName": "LD_BLOCKS.NO_SR",
         "SampleAfterValue": "100003",
@@ -712,8 +572,6 @@
     },
     {
         "BriefDescription": "Cases when loads get true Block-on-Store bloc=
king code preventing store forwarding",
-        "Counter": "0,1,2,3",
-        "CounterHTOff": "0,1,2,3,4,5,6,7",
         "EventCode": "0x03",
         "EventName": "LD_BLOCKS.STORE_FORWARD",
         "PublicDescription": "This event counts how many times the load op=
eration got the true Block-on-Store blocking code preventing store forwardi=
ng. This includes cases when:\n - preceding store conflicts with the load (=
incomplete overlap);\n - store forwarding is impossible due to u-arch limit=
ations;\n - preceding lock RMW operations are not forwarded;\n - store has =
the no-forward bit set (uncacheable/page-split/masked stores);\n - all-bloc=
king stores are used (mostly, fences and port I/O);\nand others.\nThe most =
common case is a load blocked due to its address range overlapping with a p=
receding smaller uncompleted store. Note: This event does not take into acc=
ount cases of out-of-SW-control (for example, SbTailHit), unknown physical =
STA, and cases of blocking loads on store due to being non-WB memory type o=
r a lock. These cases are covered by other events.\nSee the table of not su=
pported store forwards in the Optimization Guide.",
@@ -722,8 +580,6 @@
     },
     {
         "BriefDescription": "False dependencies in MOB due to partial comp=
are",
-        "Counter": "0,1,2,3",
-        "CounterHTOff": "0,1,2,3,4,5,6,7",
         "EventCode": "0x07",
         "EventName": "LD_BLOCKS_PARTIAL.ADDRESS_ALIAS",
         "PublicDescription": "This event counts false dependencies in MOB =
when the partial comparison upon loose net check and dependency was resolve=
d by the Enhanced Loose net mechanism. This may not result in high performa=
nce penalties. Loose net checks can fail when loads and stores are 4k alias=
ed.",
@@ -732,8 +588,6 @@
     },
     {
         "BriefDescription": "Not software-prefetch load dispatches that hi=
t FB allocated for hardware prefetch",
-        "Counter": "0,1,2,3",
-        "CounterHTOff": "0,1,2,3,4,5,6,7",
         "EventCode": "0x4C",
         "EventName": "LOAD_HIT_PRE.HW_PF",
         "PublicDescription": "This event counts all not software-prefetch =
load dispatches that hit the fill buffer (FB) allocated for the hardware pr=
efetch.",
@@ -742,8 +596,6 @@
     },
     {
         "BriefDescription": "Not software-prefetch load dispatches that hi=
t FB allocated for software prefetch",
-        "Counter": "0,1,2,3",
-        "CounterHTOff": "0,1,2,3,4,5,6,7",
         "EventCode": "0x4c",
         "EventName": "LOAD_HIT_PRE.SW_PF",
         "PublicDescription": "This event counts all not software-prefetch =
load dispatches that hit the fill buffer (FB) allocated for the software pr=
efetch. It can also be incremented by some lock instructions. So it should =
only be used with profiling so that the locks can be excluded by asm inspec=
tion of the nearby instructions.",
@@ -752,8 +604,6 @@
     },
     {
         "BriefDescription": "Cycles 4 Uops delivered by the LSD, but didn'=
t come from the decoder.",
-        "Counter": "0,1,2,3",
-        "CounterHTOff": "0,1,2,3,4,5,6,7",
         "CounterMask": "4",
         "EventCode": "0xA8",
         "EventName": "LSD.CYCLES_4_UOPS",
@@ -762,8 +612,6 @@
     },
     {
         "BriefDescription": "Cycles Uops delivered by the LSD, but didn't =
come from the decoder.",
-        "Counter": "0,1,2,3",
-        "CounterHTOff": "0,1,2,3,4,5,6,7",
         "CounterMask": "1",
         "EventCode": "0xA8",
         "EventName": "LSD.CYCLES_ACTIVE",
@@ -772,8 +620,6 @@
     },
     {
         "BriefDescription": "Number of Uops delivered by the LSD.",
-        "Counter": "0,1,2,3",
-        "CounterHTOff": "0,1,2,3,4,5,6,7",
         "EventCode": "0xA8",
         "EventName": "LSD.UOPS",
         "SampleAfterValue": "2000003",
@@ -781,8 +627,6 @@
     },
     {
         "BriefDescription": "Number of machine clears (nukes) of any type.=
",
-        "Counter": "0,1,2,3",
-        "CounterHTOff": "0,1,2,3,4,5,6,7",
         "CounterMask": "1",
         "EdgeDetect": "1",
         "EventCode": "0xC3",
@@ -792,8 +636,6 @@
     },
     {
         "BriefDescription": "Cycles there was a Nuke. Account for both thr=
ead-specific and All Thread Nukes.",
-        "Counter": "0,1,2,3",
-        "CounterHTOff": "0,1,2,3,4,5,6,7",
         "EventCode": "0xC3",
         "EventName": "MACHINE_CLEARS.CYCLES",
         "PublicDescription": "This event counts both thread-specific (TS) =
and all-thread (AT) nukes.",
@@ -802,8 +644,6 @@
     },
     {
         "BriefDescription": "This event counts the number of executed Inte=
l AVX masked load operations that refer to an illegal address range with th=
e mask bits set to 0.",
-        "Counter": "0,1,2,3",
-        "CounterHTOff": "0,1,2,3,4,5,6,7",
         "EventCode": "0xC3",
         "EventName": "MACHINE_CLEARS.MASKMOV",
         "PublicDescription": "Maskmov false fault - counts number of time =
ucode passes through Maskmov flow due to instruction's mask being 0 while t=
he flow was completed without raising a fault.",
@@ -812,8 +652,6 @@
     },
     {
         "BriefDescription": "Self-modifying code (SMC) detected.",
-        "Counter": "0,1,2,3",
-        "CounterHTOff": "0,1,2,3,4,5,6,7",
         "EventCode": "0xC3",
         "EventName": "MACHINE_CLEARS.SMC",
         "PublicDescription": "This event counts self-modifying code (SMC) =
detected, which causes a machine clear.",
@@ -822,8 +660,6 @@
     },
     {
         "BriefDescription": "Number of integer Move Elimination candidate =
uops that were eliminated.",
-        "Counter": "0,1,2,3",
-        "CounterHTOff": "0,1,2,3,4,5,6,7",
         "EventCode": "0x58",
         "EventName": "MOVE_ELIMINATION.INT_ELIMINATED",
         "SampleAfterValue": "1000003",
@@ -831,8 +667,6 @@
     },
     {
         "BriefDescription": "Number of integer Move Elimination candidate =
uops that were not eliminated.",
-        "Counter": "0,1,2,3",
-        "CounterHTOff": "0,1,2,3,4,5,6,7",
         "EventCode": "0x58",
         "EventName": "MOVE_ELIMINATION.INT_NOT_ELIMINATED",
         "SampleAfterValue": "1000003",
@@ -840,8 +674,6 @@
     },
     {
         "BriefDescription": "Number of times any microcode assist is invok=
ed by HW upon uop writeback.",
-        "Counter": "0,1,2,3",
-        "CounterHTOff": "0,1,2,3,4,5,6,7",
         "EventCode": "0xC1",
         "EventName": "OTHER_ASSISTS.ANY_WB_ASSIST",
         "SampleAfterValue": "100003",
@@ -849,8 +681,6 @@
     },
     {
         "BriefDescription": "Resource-related stall cycles",
-        "Counter": "0,1,2,3",
-        "CounterHTOff": "0,1,2,3,4,5,6,7",
         "EventCode": "0xa2",
         "EventName": "RESOURCE_STALLS.ANY",
         "PublicDescription": "This event counts resource-related stall cyc=
les.",
@@ -859,8 +689,6 @@
     },
     {
         "BriefDescription": "Cycles stalled due to re-order buffer full.",
-        "Counter": "0,1,2,3",
-        "CounterHTOff": "0,1,2,3,4,5,6,7",
         "EventCode": "0xA2",
         "EventName": "RESOURCE_STALLS.ROB",
         "PublicDescription": "This event counts ROB full stall cycles. Thi=
s counts cycles that the pipeline backend blocked uop delivery from the fro=
nt end.",
@@ -869,8 +697,6 @@
     },
     {
         "BriefDescription": "Cycles stalled due to no eligible RS entry av=
ailable.",
-        "Counter": "0,1,2,3",
-        "CounterHTOff": "0,1,2,3,4,5,6,7",
         "EventCode": "0xA2",
         "EventName": "RESOURCE_STALLS.RS",
         "PublicDescription": "This event counts stall cycles caused by abs=
ence of eligible entries in the reservation station (RS). This may result f=
rom RS overflow, or from RS deallocation because of the RS array Write Port=
 allocation scheme (each RS entry has two write ports instead of four. As a=
 result, empty entries could not be used, although RS is not really full). =
This counts cycles that the pipeline backend blocked uop delivery from the =
front end.",
@@ -879,8 +705,6 @@
     },
     {
         "BriefDescription": "Cycles stalled due to no store buffers availa=
ble. (not including draining form sync).",
-        "Counter": "0,1,2,3",
-        "CounterHTOff": "0,1,2,3,4,5,6,7",
         "EventCode": "0xA2",
         "EventName": "RESOURCE_STALLS.SB",
         "PublicDescription": "This event counts stall cycles caused by the=
 store buffer (SB) overflow (excluding draining from synch). This counts cy=
cles that the pipeline backend blocked uop delivery from the front end.",
@@ -889,8 +713,6 @@
     },
     {
         "BriefDescription": "Count cases of saving new LBR",
-        "Counter": "0,1,2,3",
-        "CounterHTOff": "0,1,2,3,4,5,6,7",
         "EventCode": "0xCC",
         "EventName": "ROB_MISC_EVENTS.LBR_INSERTS",
         "PublicDescription": "This event counts cases of saving new LBR re=
cords by hardware. This assumes proper enabling of LBRs and takes into acco=
unt LBR filtering done by the LBR_SELECT register.",
@@ -899,8 +721,6 @@
     },
     {
         "BriefDescription": "Cycles when Reservation Station (RS) is empty=
 for the thread",
-        "Counter": "0,1,2,3",
-        "CounterHTOff": "0,1,2,3,4,5,6,7",
         "EventCode": "0x5E",
         "EventName": "RS_EVENTS.EMPTY_CYCLES",
         "PublicDescription": "This event counts cycles during which the re=
servation station (RS) is empty for the thread.\nNote: In ST-mode, not acti=
ve thread should drive 0. This is usually caused by severely costly branch =
mispredictions, or allocator/FE issues.",
@@ -909,8 +729,6 @@
     },
     {
         "BriefDescription": "Counts end of periods where the Reservation S=
tation (RS) was empty. Could be useful to precisely locate Frontend Latency=
 Bound issues.",
-        "Counter": "0,1,2,3",
-        "CounterHTOff": "0,1,2,3,4,5,6,7",
         "CounterMask": "1",
         "EdgeDetect": "1",
         "EventCode": "0x5E",
@@ -921,8 +739,6 @@
     },
     {
         "BriefDescription": "Cycles per thread when uops are executed in p=
ort 0",
-        "Counter": "0,1,2,3",
-        "CounterHTOff": "0,1,2,3,4,5,6,7",
         "EventCode": "0xA1",
         "EventName": "UOPS_DISPATCHED_PORT.PORT_0",
         "PublicDescription": "This event counts, on the per-thread basis, =
cycles during which uops are dispatched from the Reservation Station (RS) t=
o port 0.",
@@ -931,8 +747,6 @@
     },
     {
         "BriefDescription": "Cycles per thread when uops are executed in p=
ort 1",
-        "Counter": "0,1,2,3",
-        "CounterHTOff": "0,1,2,3,4,5,6,7",
         "EventCode": "0xA1",
         "EventName": "UOPS_DISPATCHED_PORT.PORT_1",
         "PublicDescription": "This event counts, on the per-thread basis, =
cycles during which uops are dispatched from the Reservation Station (RS) t=
o port 1.",
@@ -941,8 +755,6 @@
     },
     {
         "BriefDescription": "Cycles per thread when uops are executed in p=
ort 2",
-        "Counter": "0,1,2,3",
-        "CounterHTOff": "0,1,2,3,4,5,6,7",
         "EventCode": "0xA1",
         "EventName": "UOPS_DISPATCHED_PORT.PORT_2",
         "PublicDescription": "This event counts, on the per-thread basis, =
cycles during which uops are dispatched from the Reservation Station (RS) t=
o port 2.",
@@ -951,8 +763,6 @@
     },
     {
         "BriefDescription": "Cycles per thread when uops are executed in p=
ort 3",
-        "Counter": "0,1,2,3",
-        "CounterHTOff": "0,1,2,3,4,5,6,7",
         "EventCode": "0xA1",
         "EventName": "UOPS_DISPATCHED_PORT.PORT_3",
         "PublicDescription": "This event counts, on the per-thread basis, =
cycles during which uops are dispatched from the Reservation Station (RS) t=
o port 3.",
@@ -961,8 +771,6 @@
     },
     {
         "BriefDescription": "Cycles per thread when uops are executed in p=
ort 4",
-        "Counter": "0,1,2,3",
-        "CounterHTOff": "0,1,2,3,4,5,6,7",
         "EventCode": "0xA1",
         "EventName": "UOPS_DISPATCHED_PORT.PORT_4",
         "PublicDescription": "This event counts, on the per-thread basis, =
cycles during which uops are dispatched from the Reservation Station (RS) t=
o port 4.",
@@ -971,8 +779,6 @@
     },
     {
         "BriefDescription": "Cycles per thread when uops are executed in p=
ort 5",
-        "Counter": "0,1,2,3",
-        "CounterHTOff": "0,1,2,3,4,5,6,7",
         "EventCode": "0xA1",
         "EventName": "UOPS_DISPATCHED_PORT.PORT_5",
         "PublicDescription": "This event counts, on the per-thread basis, =
cycles during which uops are dispatched from the Reservation Station (RS) t=
o port 5.",
@@ -981,8 +787,6 @@
     },
     {
         "BriefDescription": "Cycles per thread when uops are executed in p=
ort 6",
-        "Counter": "0,1,2,3",
-        "CounterHTOff": "0,1,2,3,4,5,6,7",
         "EventCode": "0xA1",
         "EventName": "UOPS_DISPATCHED_PORT.PORT_6",
         "PublicDescription": "This event counts, on the per-thread basis, =
cycles during which uops are dispatched from the Reservation Station (RS) t=
o port 6.",
@@ -991,8 +795,6 @@
     },
     {
         "BriefDescription": "Cycles per thread when uops are executed in p=
ort 7",
-        "Counter": "0,1,2,3",
-        "CounterHTOff": "0,1,2,3,4,5,6,7",
         "EventCode": "0xA1",
         "EventName": "UOPS_DISPATCHED_PORT.PORT_7",
         "PublicDescription": "This event counts, on the per-thread basis, =
cycles during which uops are dispatched from the Reservation Station (RS) t=
o port 7.",
@@ -1001,8 +803,6 @@
     },
     {
         "BriefDescription": "Number of uops executed on the core.",
-        "Counter": "0,1,2,3",
-        "CounterHTOff": "0,1,2,3,4,5,6,7",
         "EventCode": "0xB1",
         "EventName": "UOPS_EXECUTED.CORE",
         "PublicDescription": "Number of uops executed from any thread.",
@@ -1011,8 +811,6 @@
     },
     {
         "BriefDescription": "Cycles at least 1 micro-op is executed from a=
ny thread on physical core.",
-        "Counter": "0,1,2,3",
-        "CounterHTOff": "0,1,2,3,4,5,6,7",
         "CounterMask": "1",
         "EventCode": "0xb1",
         "EventName": "UOPS_EXECUTED.CORE_CYCLES_GE_1",
@@ -1021,8 +819,6 @@
     },
     {
         "BriefDescription": "Cycles at least 2 micro-op is executed from a=
ny thread on physical core.",
-        "Counter": "0,1,2,3",
-        "CounterHTOff": "0,1,2,3,4,5,6,7",
         "CounterMask": "2",
         "EventCode": "0xb1",
         "EventName": "UOPS_EXECUTED.CORE_CYCLES_GE_2",
@@ -1031,8 +827,6 @@
     },
     {
         "BriefDescription": "Cycles at least 3 micro-op is executed from a=
ny thread on physical core.",
-        "Counter": "0,1,2,3",
-        "CounterHTOff": "0,1,2,3,4,5,6,7",
         "CounterMask": "3",
         "EventCode": "0xb1",
         "EventName": "UOPS_EXECUTED.CORE_CYCLES_GE_3",
@@ -1041,8 +835,6 @@
     },
     {
         "BriefDescription": "Cycles at least 4 micro-op is executed from a=
ny thread on physical core.",
-        "Counter": "0,1,2,3",
-        "CounterHTOff": "0,1,2,3,4,5,6,7",
         "CounterMask": "4",
         "EventCode": "0xb1",
         "EventName": "UOPS_EXECUTED.CORE_CYCLES_GE_4",
@@ -1051,8 +843,6 @@
     },
     {
         "BriefDescription": "Cycles with no micro-ops executed from any th=
read on physical core.",
-        "Counter": "0,1,2,3",
-        "CounterHTOff": "0,1,2,3,4,5,6,7",
         "EventCode": "0xb1",
         "EventName": "UOPS_EXECUTED.CORE_CYCLES_NONE",
         "Invert": "1",
@@ -1061,8 +851,6 @@
     },
     {
         "BriefDescription": "Cycles where at least 1 uop was executed per-=
thread.",
-        "Counter": "0,1,2,3",
-        "CounterHTOff": "0,1,2,3",
         "CounterMask": "1",
         "EventCode": "0xB1",
         "EventName": "UOPS_EXECUTED.CYCLES_GE_1_UOP_EXEC",
@@ -1071,8 +859,6 @@
     },
     {
         "BriefDescription": "Cycles where at least 2 uops were executed pe=
r-thread.",
-        "Counter": "0,1,2,3",
-        "CounterHTOff": "0,1,2,3",
         "CounterMask": "2",
         "EventCode": "0xB1",
         "EventName": "UOPS_EXECUTED.CYCLES_GE_2_UOPS_EXEC",
@@ -1081,8 +867,6 @@
     },
     {
         "BriefDescription": "Cycles where at least 3 uops were executed pe=
r-thread.",
-        "Counter": "0,1,2,3",
-        "CounterHTOff": "0,1,2,3",
         "CounterMask": "3",
         "EventCode": "0xB1",
         "EventName": "UOPS_EXECUTED.CYCLES_GE_3_UOPS_EXEC",
@@ -1091,8 +875,6 @@
     },
     {
         "BriefDescription": "Cycles where at least 4 uops were executed pe=
r-thread.",
-        "Counter": "0,1,2,3",
-        "CounterHTOff": "0,1,2,3",
         "CounterMask": "4",
         "EventCode": "0xB1",
         "EventName": "UOPS_EXECUTED.CYCLES_GE_4_UOPS_EXEC",
@@ -1101,8 +883,6 @@
     },
     {
         "BriefDescription": "Counts number of cycles no uops were dispatch=
ed to be executed on this thread.",
-        "Counter": "0,1,2,3",
-        "CounterHTOff": "0,1,2,3",
         "CounterMask": "1",
         "EventCode": "0xB1",
         "EventName": "UOPS_EXECUTED.STALL_CYCLES",
@@ -1113,8 +893,6 @@
     },
     {
         "BriefDescription": "Counts the number of uops to be executed per-=
thread each cycle.",
-        "Counter": "0,1,2,3",
-        "CounterHTOff": "0,1,2,3,4,5,6,7",
         "EventCode": "0xB1",
         "EventName": "UOPS_EXECUTED.THREAD",
         "PublicDescription": "Number of uops to be executed per-thread eac=
h cycle.",
@@ -1123,8 +901,6 @@
     },
     {
         "BriefDescription": "Cycles per thread when uops are executed in p=
ort 0",
-        "Counter": "0,1,2,3",
-        "CounterHTOff": "0,1,2,3,4,5,6,7",
         "EventCode": "0xA1",
         "EventName": "UOPS_EXECUTED_PORT.PORT_0",
         "PublicDescription": "This event counts, on the per-thread basis, =
cycles during which uops are dispatched from the Reservation Station (RS) t=
o port 0.",
@@ -1134,8 +910,6 @@
     {
         "AnyThread": "1",
         "BriefDescription": "Cycles per core when uops are exectuted in po=
rt 0.",
-        "Counter": "0,1,2,3",
-        "CounterHTOff": "0,1,2,3,4,5,6,7",
         "EventCode": "0xA1",
         "EventName": "UOPS_EXECUTED_PORT.PORT_0_CORE",
         "SampleAfterValue": "2000003",
@@ -1143,8 +917,6 @@
     },
     {
         "BriefDescription": "Cycles per thread when uops are executed in p=
ort 1",
-        "Counter": "0,1,2,3",
-        "CounterHTOff": "0,1,2,3,4,5,6,7",
         "EventCode": "0xA1",
         "EventName": "UOPS_EXECUTED_PORT.PORT_1",
         "PublicDescription": "This event counts, on the per-thread basis, =
cycles during which uops are dispatched from the Reservation Station (RS) t=
o port 1.",
@@ -1154,8 +926,6 @@
     {
         "AnyThread": "1",
         "BriefDescription": "Cycles per core when uops are exectuted in po=
rt 1.",
-        "Counter": "0,1,2,3",
-        "CounterHTOff": "0,1,2,3,4,5,6,7",
         "EventCode": "0xA1",
         "EventName": "UOPS_EXECUTED_PORT.PORT_1_CORE",
         "SampleAfterValue": "2000003",
@@ -1163,8 +933,6 @@
     },
     {
         "BriefDescription": "Cycles per thread when uops are executed in p=
ort 2",
-        "Counter": "0,1,2,3",
-        "CounterHTOff": "0,1,2,3,4,5,6,7",
         "EventCode": "0xA1",
         "EventName": "UOPS_EXECUTED_PORT.PORT_2",
         "PublicDescription": "This event counts, on the per-thread basis, =
cycles during which uops are dispatched from the Reservation Station (RS) t=
o port 2.",
@@ -1174,8 +942,6 @@
     {
         "AnyThread": "1",
         "BriefDescription": "Cycles per core when uops are dispatched to p=
ort 2.",
-        "Counter": "0,1,2,3",
-        "CounterHTOff": "0,1,2,3,4,5,6,7",
         "EventCode": "0xA1",
         "EventName": "UOPS_EXECUTED_PORT.PORT_2_CORE",
         "SampleAfterValue": "2000003",
@@ -1183,8 +949,6 @@
     },
     {
         "BriefDescription": "Cycles per thread when uops are executed in p=
ort 3",
-        "Counter": "0,1,2,3",
-        "CounterHTOff": "0,1,2,3,4,5,6,7",
         "EventCode": "0xA1",
         "EventName": "UOPS_EXECUTED_PORT.PORT_3",
         "PublicDescription": "This event counts, on the per-thread basis, =
cycles during which uops are dispatched from the Reservation Station (RS) t=
o port 3.",
@@ -1194,8 +958,6 @@
     {
         "AnyThread": "1",
         "BriefDescription": "Cycles per core when uops are dispatched to p=
ort 3.",
-        "Counter": "0,1,2,3",
-        "CounterHTOff": "0,1,2,3,4,5,6,7",
         "EventCode": "0xA1",
         "EventName": "UOPS_EXECUTED_PORT.PORT_3_CORE",
         "SampleAfterValue": "2000003",
@@ -1203,8 +965,6 @@
     },
     {
         "BriefDescription": "Cycles per thread when uops are executed in p=
ort 4",
-        "Counter": "0,1,2,3",
-        "CounterHTOff": "0,1,2,3,4,5,6,7",
         "EventCode": "0xA1",
         "EventName": "UOPS_EXECUTED_PORT.PORT_4",
         "PublicDescription": "This event counts, on the per-thread basis, =
cycles during which uops are dispatched from the Reservation Station (RS) t=
o port 4.",
@@ -1214,8 +974,6 @@
     {
         "AnyThread": "1",
         "BriefDescription": "Cycles per core when uops are exectuted in po=
rt 4.",
-        "Counter": "0,1,2,3",
-        "CounterHTOff": "0,1,2,3,4,5,6,7",
         "EventCode": "0xA1",
         "EventName": "UOPS_EXECUTED_PORT.PORT_4_CORE",
         "SampleAfterValue": "2000003",
@@ -1223,8 +981,6 @@
     },
     {
         "BriefDescription": "Cycles per thread when uops are executed in p=
ort 5",
-        "Counter": "0,1,2,3",
-        "CounterHTOff": "0,1,2,3,4,5,6,7",
         "EventCode": "0xA1",
         "EventName": "UOPS_EXECUTED_PORT.PORT_5",
         "PublicDescription": "This event counts, on the per-thread basis, =
cycles during which uops are dispatched from the Reservation Station (RS) t=
o port 5.",
@@ -1234,8 +990,6 @@
     {
         "AnyThread": "1",
         "BriefDescription": "Cycles per core when uops are exectuted in po=
rt 5.",
-        "Counter": "0,1,2,3",
-        "CounterHTOff": "0,1,2,3,4,5,6,7",
         "EventCode": "0xA1",
         "EventName": "UOPS_EXECUTED_PORT.PORT_5_CORE",
         "SampleAfterValue": "2000003",
@@ -1243,8 +997,6 @@
     },
     {
         "BriefDescription": "Cycles per thread when uops are executed in p=
ort 6",
-        "Counter": "0,1,2,3",
-        "CounterHTOff": "0,1,2,3,4,5,6,7",
         "EventCode": "0xA1",
         "EventName": "UOPS_EXECUTED_PORT.PORT_6",
         "PublicDescription": "This event counts, on the per-thread basis, =
cycles during which uops are dispatched from the Reservation Station (RS) t=
o port 6.",
@@ -1254,8 +1006,6 @@
     {
         "AnyThread": "1",
         "BriefDescription": "Cycles per core when uops are exectuted in po=
rt 6.",
-        "Counter": "0,1,2,3",
-        "CounterHTOff": "0,1,2,3,4,5,6,7",
         "EventCode": "0xA1",
         "EventName": "UOPS_EXECUTED_PORT.PORT_6_CORE",
         "SampleAfterValue": "2000003",
@@ -1263,8 +1013,6 @@
     },
     {
         "BriefDescription": "Cycles per thread when uops are executed in p=
ort 7",
-        "Counter": "0,1,2,3",
-        "CounterHTOff": "0,1,2,3,4,5,6,7",
         "EventCode": "0xA1",
         "EventName": "UOPS_EXECUTED_PORT.PORT_7",
         "PublicDescription": "This event counts, on the per-thread basis, =
cycles during which uops are dispatched from the Reservation Station (RS) t=
o port 7.",
@@ -1274,8 +1022,6 @@
     {
         "AnyThread": "1",
         "BriefDescription": "Cycles per core when uops are dispatched to p=
ort 7.",
-        "Counter": "0,1,2,3",
-        "CounterHTOff": "0,1,2,3,4,5,6,7",
         "EventCode": "0xA1",
         "EventName": "UOPS_EXECUTED_PORT.PORT_7_CORE",
         "SampleAfterValue": "2000003",
@@ -1283,8 +1029,6 @@
     },
     {
         "BriefDescription": "Uops that Resource Allocation Table (RAT) iss=
ues to Reservation Station (RS)",
-        "Counter": "0,1,2,3",
-        "CounterHTOff": "0,1,2,3,4,5,6,7",
         "EventCode": "0x0E",
         "EventName": "UOPS_ISSUED.ANY",
         "PublicDescription": "This event counts the number of Uops issued =
by the Resource Allocation Table (RAT) to the reservation station (RS).",
@@ -1293,8 +1037,6 @@
     },
     {
         "BriefDescription": "Number of flags-merge uops being allocated. S=
uch uops considered perf sensitive; added by GSR u-arch.",
-        "Counter": "0,1,2,3",
-        "CounterHTOff": "0,1,2,3,4,5,6,7",
         "EventCode": "0x0E",
         "EventName": "UOPS_ISSUED.FLAGS_MERGE",
         "PublicDescription": "Number of flags-merge uops being allocated. =
Such uops considered perf sensitive\n added by GSR u-arch.",
@@ -1303,8 +1045,6 @@
     },
     {
         "BriefDescription": "Number of Multiply packed/scalar single preci=
sion uops allocated.",
-        "Counter": "0,1,2,3",
-        "CounterHTOff": "0,1,2,3,4,5,6,7",
         "EventCode": "0x0E",
         "EventName": "UOPS_ISSUED.SINGLE_MUL",
         "SampleAfterValue": "2000003",
@@ -1312,8 +1052,6 @@
     },
     {
         "BriefDescription": "Number of slow LEA uops being allocated. A uo=
p is generally considered SlowLea if it has 3 sources (e.g. 2 sources + imm=
ediate) regardless if as a result of LEA instruction or not.",
-        "Counter": "0,1,2,3",
-        "CounterHTOff": "0,1,2,3,4,5,6,7",
         "EventCode": "0x0E",
         "EventName": "UOPS_ISSUED.SLOW_LEA",
         "SampleAfterValue": "2000003",
@@ -1321,8 +1059,6 @@
     },
     {
         "BriefDescription": "Cycles when Resource Allocation Table (RAT) d=
oes not issue Uops to Reservation Station (RS) for the thread",
-        "Counter": "0,1,2,3",
-        "CounterHTOff": "0,1,2,3",
         "CounterMask": "1",
         "EventCode": "0x0E",
         "EventName": "UOPS_ISSUED.STALL_CYCLES",
@@ -1333,8 +1069,6 @@
     },
     {
         "BriefDescription": "Actually retired uops.",
-        "Counter": "0,1,2,3",
-        "CounterHTOff": "0,1,2,3,4,5,6,7",
         "EventCode": "0xC2",
         "EventName": "UOPS_RETIRED.ALL",
         "PEBS": "1",
@@ -1344,8 +1078,6 @@
     },
     {
         "BriefDescription": "Retirement slots used.",
-        "Counter": "0,1,2,3",
-        "CounterHTOff": "0,1,2,3,4,5,6,7",
         "EventCode": "0xC2",
         "EventName": "UOPS_RETIRED.RETIRE_SLOTS",
         "PEBS": "1",
@@ -1355,8 +1087,6 @@
     },
     {
         "BriefDescription": "Cycles without actually retired uops.",
-        "Counter": "0,1,2,3",
-        "CounterHTOff": "0,1,2,3",
         "CounterMask": "1",
         "EventCode": "0xC2",
         "EventName": "UOPS_RETIRED.STALL_CYCLES",
@@ -1367,8 +1097,6 @@
     },
     {
         "BriefDescription": "Cycles with less than 10 actually retired uop=
s.",
-        "Counter": "0,1,2,3",
-        "CounterHTOff": "0,1,2,3",
         "CounterMask": "16",
         "EventCode": "0xC2",
         "EventName": "UOPS_RETIRED.TOTAL_CYCLES",
diff --git a/tools/perf/pmu-events/arch/x86/broadwellx/uncore-cache.json b/=
tools/perf/pmu-events/arch/x86/broadwellx/uncore-cache.json
index 449fa723d0aa..746954775437 100644
--- a/tools/perf/pmu-events/arch/x86/broadwellx/uncore-cache.json
+++ b/tools/perf/pmu-events/arch/x86/broadwellx/uncore-cache.json
@@ -1,789 +1,1100 @@
 [
     {
-        "BriefDescription": "Bounce Control",
-        "Counter": "0,1,2,3",
-        "EventCode": "0xA",
-        "EventName": "UNC_C_BOUNCE_CONTROL",
+        "BriefDescription": "LLC prefetch misses for code reads. Derived f=
rom unc_c_tor_inserts.miss_opcode",
+        "EventCode": "0x35",
+        "EventName": "LLC_MISSES.CODE_LLC_PREFETCH",
+        "Filter": "filter_opc=3D0x191",
         "PerPkg": "1",
+        "PublicDescription": "Counts the number of entries successfully in=
serted into the TOR that match  qualifications specified by the subevent.  =
There are a number of subevent 'filters' but only a subset of the subevent =
combinations are valid.  Subevents that require an opcode or NID match requ=
ire the Cn_MSR_PMON_BOX_FILTER.{opc, nid} field to be set.  If, for example=
, one wanted to count DRD Local Misses, one should select MISS_OPC_MATCH an=
d set Cn_MSR_PMON_BOX_FILTER.opc  to DRD (0x182).; Miss transactions insert=
ed into the TOR that match an opcode.",
+        "ScaleUnit": "64Bytes",
+        "UMask": "0x3",
         "Unit": "CBO"
     },
     {
-        "BriefDescription": "Uncore Clocks",
-        "Counter": "0,1,2,3",
-        "EventName": "UNC_C_CLOCKTICKS",
+        "BriefDescription": "LLC prefetch misses for data reads. Derived f=
rom unc_c_tor_inserts.miss_opcode",
+        "EventCode": "0x35",
+        "EventName": "LLC_MISSES.DATA_LLC_PREFETCH",
+        "Filter": "filter_opc=3D0x192",
         "PerPkg": "1",
+        "PublicDescription": "Counts the number of entries successfully in=
serted into the TOR that match  qualifications specified by the subevent.  =
There are a number of subevent 'filters' but only a subset of the subevent =
combinations are valid.  Subevents that require an opcode or NID match requ=
ire the Cn_MSR_PMON_BOX_FILTER.{opc, nid} field to be set.  If, for example=
, one wanted to count DRD Local Misses, one should select MISS_OPC_MATCH an=
d set Cn_MSR_PMON_BOX_FILTER.opc  to DRD (0x182).; Miss transactions insert=
ed into the TOR that match an opcode.",
+        "ScaleUnit": "64Bytes",
+        "UMask": "0x3",
         "Unit": "CBO"
     },
     {
-        "BriefDescription": "Counter 0 Occupancy",
-        "Counter": "0,1,2,3",
-        "EventCode": "0x1F",
-        "EventName": "UNC_C_COUNTER0_OCCUPANCY",
+        "BriefDescription": "LLC misses - demand and prefetch data reads -=
 excludes LLC prefetches. Derived from unc_c_tor_inserts.miss_opcode",
+        "EventCode": "0x35",
+        "EventName": "LLC_MISSES.DATA_READ",
+        "Filter": "filter_opc=3D0x182",
         "PerPkg": "1",
+        "PublicDescription": "Counts the number of entries successfully in=
serted into the TOR that match  qualifications specified by the subevent.  =
There are a number of subevent 'filters' but only a subset of the subevent =
combinations are valid.  Subevents that require an opcode or NID match requ=
ire the Cn_MSR_PMON_BOX_FILTER.{opc, nid} field to be set.  If, for example=
, one wanted to count DRD Local Misses, one should select MISS_OPC_MATCH an=
d set Cn_MSR_PMON_BOX_FILTER.opc  to DRD (0x182).; Miss transactions insert=
ed into the TOR that match an opcode.",
+        "ScaleUnit": "64Bytes",
+        "UMask": "0x3",
         "Unit": "CBO"
     },
     {
-        "BriefDescription": "FaST wire asserted",
-        "Counter": "0,1",
-        "EventCode": "0x9",
-        "EventName": "UNC_C_FAST_ASSERTED",
+        "BriefDescription": "MMIO reads. Derived from unc_c_tor_inserts.mi=
ss_opcode",
+        "EventCode": "0x35",
+        "EventName": "LLC_MISSES.MMIO_READ",
+        "Filter": "filter_opc=3D0x187,filter_nc=3D1",
         "PerPkg": "1",
+        "PublicDescription": "Counts the number of entries successfully in=
serted into the TOR that match  qualifications specified by the subevent.  =
There are a number of subevent 'filters' but only a subset of the subevent =
combinations are valid.  Subevents that require an opcode or NID match requ=
ire the Cn_MSR_PMON_BOX_FILTER.{opc, nid} field to be set.  If, for example=
, one wanted to count DRD Local Misses, one should select MISS_OPC_MATCH an=
d set Cn_MSR_PMON_BOX_FILTER.opc  to DRD (0x182).; Miss transactions insert=
ed into the TOR that match an opcode.",
+        "ScaleUnit": "64Bytes",
+        "UMask": "0x3",
         "Unit": "CBO"
     },
     {
-        "BriefDescription": "Cache Lookups; Data Read Request",
-        "Counter": "0,1,2,3",
-        "EventCode": "0x34",
-        "EventName": "UNC_C_LLC_LOOKUP.DATA_READ",
+        "BriefDescription": "MMIO writes. Derived from unc_c_tor_inserts.m=
iss_opcode",
+        "EventCode": "0x35",
+        "EventName": "LLC_MISSES.MMIO_WRITE",
+        "Filter": "filter_opc=3D0x18f,filter_nc=3D1",
         "PerPkg": "1",
+        "PublicDescription": "Counts the number of entries successfully in=
serted into the TOR that match  qualifications specified by the subevent.  =
There are a number of subevent 'filters' but only a subset of the subevent =
combinations are valid.  Subevents that require an opcode or NID match requ=
ire the Cn_MSR_PMON_BOX_FILTER.{opc, nid} field to be set.  If, for example=
, one wanted to count DRD Local Misses, one should select MISS_OPC_MATCH an=
d set Cn_MSR_PMON_BOX_FILTER.opc  to DRD (0x182).; Miss transactions insert=
ed into the TOR that match an opcode.",
+        "ScaleUnit": "64Bytes",
         "UMask": "0x3",
         "Unit": "CBO"
     },
     {
-        "BriefDescription": "Cache Lookups; Write Requests",
-        "Counter": "0,1,2,3",
-        "EventCode": "0x34",
-        "EventName": "UNC_C_LLC_LOOKUP.WRITE",
+        "BriefDescription": "PCIe write misses (full cache line). Derived =
from unc_c_tor_inserts.miss_opcode",
+        "EventCode": "0x35",
+        "EventName": "LLC_MISSES.PCIE_NON_SNOOP_WRITE",
+        "Filter": "filter_opc=3D0x1c8,filter_tid=3D0x3e",
         "PerPkg": "1",
-        "UMask": "0x5",
+        "PublicDescription": "Counts the number of entries successfully in=
serted into the TOR that match  qualifications specified by the subevent.  =
There are a number of subevent 'filters' but only a subset of the subevent =
combinations are valid.  Subevents that require an opcode or NID match requ=
ire the Cn_MSR_PMON_BOX_FILTER.{opc, nid} field to be set.  If, for example=
, one wanted to count DRD Local Misses, one should select MISS_OPC_MATCH an=
d set Cn_MSR_PMON_BOX_FILTER.opc  to DRD (0x182).; Miss transactions insert=
ed into the TOR that match an opcode.",
+        "ScaleUnit": "64Bytes",
+        "UMask": "0x3",
         "Unit": "CBO"
     },
     {
-        "BriefDescription": "Cache Lookups; External Snoop Request",
-        "Counter": "0,1,2,3",
-        "EventCode": "0x34",
-        "EventName": "UNC_C_LLC_LOOKUP.REMOTE_SNOOP",
+        "BriefDescription": "LLC misses for PCIe read current. Derived fro=
m unc_c_tor_inserts.miss_opcode",
+        "EventCode": "0x35",
+        "EventName": "LLC_MISSES.PCIE_READ",
+        "Filter": "filter_opc=3D0x19e",
         "PerPkg": "1",
-        "UMask": "0x9",
+        "PublicDescription": "Counts the number of entries successfully in=
serted into the TOR that match  qualifications specified by the subevent.  =
There are a number of subevent 'filters' but only a subset of the subevent =
combinations are valid.  Subevents that require an opcode or NID match requ=
ire the Cn_MSR_PMON_BOX_FILTER.{opc, nid} field to be set.  If, for example=
, one wanted to count DRD Local Misses, one should select MISS_OPC_MATCH an=
d set Cn_MSR_PMON_BOX_FILTER.opc  to DRD (0x182).; Miss transactions insert=
ed into the TOR that match an opcode.",
+        "ScaleUnit": "64Bytes",
+        "UMask": "0x3",
         "Unit": "CBO"
     },
     {
-        "BriefDescription": "All LLC Misses (code+ data rd + data wr - inc=
luding demand and prefetch)",
-        "Counter": "0,1,2,3",
-        "EventCode": "0x34",
-        "EventName": "UNC_C_LLC_LOOKUP.ANY",
-        "Filter": "filter_state=3D0x1",
+        "BriefDescription": "ItoM write misses (as part of fast string mem=
cpy stores) + PCIe full line writes. Derived from unc_c_tor_inserts.miss_op=
code",
+        "EventCode": "0x35",
+        "EventName": "LLC_MISSES.PCIE_WRITE",
+        "Filter": "filter_opc=3D0x1c8",
         "PerPkg": "1",
+        "PublicDescription": "Counts the number of entries successfully in=
serted into the TOR that match  qualifications specified by the subevent.  =
There are a number of subevent 'filters' but only a subset of the subevent =
combinations are valid.  Subevents that require an opcode or NID match requ=
ire the Cn_MSR_PMON_BOX_FILTER.{opc, nid} field to be set.  If, for example=
, one wanted to count DRD Local Misses, one should select MISS_OPC_MATCH an=
d set Cn_MSR_PMON_BOX_FILTER.opc  to DRD (0x182).; Miss transactions insert=
ed into the TOR that match an opcode.",
         "ScaleUnit": "64Bytes",
-        "UMask": "0x11",
+        "UMask": "0x3",
         "Unit": "CBO"
     },
     {
-        "BriefDescription": "Cache Lookups; Lookups that Match NID",
-        "Counter": "0,1,2,3",
-        "EventCode": "0x34",
-        "EventName": "UNC_C_LLC_LOOKUP.NID",
+        "BriefDescription": "LLC prefetch misses for RFO. Derived from unc=
_c_tor_inserts.miss_opcode",
+        "EventCode": "0x35",
+        "EventName": "LLC_MISSES.RFO_LLC_PREFETCH",
+        "Filter": "filter_opc=3D0x190",
         "PerPkg": "1",
-        "UMask": "0x41",
+        "PublicDescription": "Counts the number of entries successfully in=
serted into the TOR that match  qualifications specified by the subevent.  =
There are a number of subevent 'filters' but only a subset of the subevent =
combinations are valid.  Subevents that require an opcode or NID match requ=
ire the Cn_MSR_PMON_BOX_FILTER.{opc, nid} field to be set.  If, for example=
, one wanted to count DRD Local Misses, one should select MISS_OPC_MATCH an=
d set Cn_MSR_PMON_BOX_FILTER.opc  to DRD (0x182).; Miss transactions insert=
ed into the TOR that match an opcode.",
+        "ScaleUnit": "64Bytes",
+        "UMask": "0x3",
         "Unit": "CBO"
     },
     {
-        "BriefDescription": "Cache Lookups; Any Read Request",
-        "Counter": "0,1,2,3",
-        "EventCode": "0x34",
-        "EventName": "UNC_C_LLC_LOOKUP.READ",
+        "BriefDescription": "LLC misses - Uncacheable reads (from cpu) . D=
erived from unc_c_tor_inserts.miss_opcode",
+        "EventCode": "0x35",
+        "EventName": "LLC_MISSES.UNCACHEABLE",
+        "Filter": "filter_opc=3D0x187",
         "PerPkg": "1",
-        "UMask": "0x21",
+        "PublicDescription": "Counts the number of entries successfully in=
serted into the TOR that match  qualifications specified by the subevent.  =
There are a number of subevent 'filters' but only a subset of the subevent =
combinations are valid.  Subevents that require an opcode or NID match requ=
ire the Cn_MSR_PMON_BOX_FILTER.{opc, nid} field to be set.  If, for example=
, one wanted to count DRD Local Misses, one should select MISS_OPC_MATCH an=
d set Cn_MSR_PMON_BOX_FILTER.opc  to DRD (0x182).; Miss transactions insert=
ed into the TOR that match an opcode.",
+        "ScaleUnit": "64Bytes",
+        "UMask": "0x3",
         "Unit": "CBO"
     },
     {
-        "BriefDescription": "M line evictions from LLC (writebacks to memo=
ry)",
-        "Counter": "0,1,2,3",
-        "EventCode": "0x37",
-        "EventName": "UNC_C_LLC_VICTIMS.M_STATE",
+        "BriefDescription": "L2 demand and L2 prefetch code references to =
LLC. Derived from unc_c_tor_inserts.opcode",
+        "EventCode": "0x35",
+        "EventName": "LLC_REFERENCES.CODE_LLC_PREFETCH",
+        "Filter": "filter_opc=3D0x181",
         "PerPkg": "1",
+        "PublicDescription": "Counts the number of entries successfully in=
serted into the TOR that match  qualifications specified by the subevent.  =
There are a number of subevent 'filters' but only a subset of the subevent =
combinations are valid.  Subevents that require an opcode or NID match requ=
ire the Cn_MSR_PMON_BOX_FILTER.{opc, nid} field to be set.  If, for example=
, one wanted to count DRD Local Misses, one should select MISS_OPC_MATCH an=
d set Cn_MSR_PMON_BOX_FILTER.opc  to DRD (0x182).; Transactions inserted in=
to the TOR that match an opcode (matched by Cn_MSR_PMON_BOX_FILTER.opc)",
         "ScaleUnit": "64Bytes",
         "UMask": "0x1",
         "Unit": "CBO"
     },
     {
-        "BriefDescription": "Lines Victimized; Lines in E state",
-        "Counter": "0,1,2,3",
-        "EventCode": "0x37",
-        "EventName": "UNC_C_LLC_VICTIMS.E_STATE",
+        "BriefDescription": "PCIe writes (partial cache line). Derived fro=
m unc_c_tor_inserts.opcode",
+        "EventCode": "0x35",
+        "EventName": "LLC_REFERENCES.PCIE_NS_PARTIAL_WRITE",
+        "Filter": "filter_opc=3D0x180,filter_tid=3D0x3e",
         "PerPkg": "1",
-        "UMask": "0x2",
+        "PublicDescription": "Counts the number of entries successfully in=
serted into the TOR that match  qualifications specified by the subevent.  =
There are a number of subevent 'filters' but only a subset of the subevent =
combinations are valid.  Subevents that require an opcode or NID match requ=
ire the Cn_MSR_PMON_BOX_FILTER.{opc, nid} field to be set.  If, for example=
, one wanted to count DRD Local Misses, one should select MISS_OPC_MATCH an=
d set Cn_MSR_PMON_BOX_FILTER.opc  to DRD (0x182).; Transactions inserted in=
to the TOR that match an opcode (matched by Cn_MSR_PMON_BOX_FILTER.opc)",
+        "UMask": "0x1",
         "Unit": "CBO"
     },
     {
-        "BriefDescription": "Lines Victimized; Lines in S State",
-        "Counter": "0,1,2,3",
-        "EventCode": "0x37",
-        "EventName": "UNC_C_LLC_VICTIMS.I_STATE",
+        "BriefDescription": "PCIe read current. Derived from unc_c_tor_ins=
erts.opcode",
+        "EventCode": "0x35",
+        "EventName": "LLC_REFERENCES.PCIE_READ",
+        "Filter": "filter_opc=3D0x19e",
         "PerPkg": "1",
-        "UMask": "0x4",
+        "PublicDescription": "Counts the number of entries successfully in=
serted into the TOR that match  qualifications specified by the subevent.  =
There are a number of subevent 'filters' but only a subset of the subevent =
combinations are valid.  Subevents that require an opcode or NID match requ=
ire the Cn_MSR_PMON_BOX_FILTER.{opc, nid} field to be set.  If, for example=
, one wanted to count DRD Local Misses, one should select MISS_OPC_MATCH an=
d set Cn_MSR_PMON_BOX_FILTER.opc  to DRD (0x182).; Transactions inserted in=
to the TOR that match an opcode (matched by Cn_MSR_PMON_BOX_FILTER.opc)",
+        "ScaleUnit": "64Bytes",
+        "UMask": "0x1",
         "Unit": "CBO"
     },
     {
-        "BriefDescription": "Lines Victimized",
-        "Counter": "0,1,2,3",
-        "EventCode": "0x37",
-        "EventName": "UNC_C_LLC_VICTIMS.F_STATE",
+        "BriefDescription": "PCIe write references (full cache line). Deri=
ved from unc_c_tor_inserts.opcode",
+        "EventCode": "0x35",
+        "EventName": "LLC_REFERENCES.PCIE_WRITE",
+        "Filter": "filter_opc=3D0x1c8,filter_tid=3D0x3e",
         "PerPkg": "1",
-        "UMask": "0x8",
+        "PublicDescription": "Counts the number of entries successfully in=
serted into the TOR that match  qualifications specified by the subevent.  =
There are a number of subevent 'filters' but only a subset of the subevent =
combinations are valid.  Subevents that require an opcode or NID match requ=
ire the Cn_MSR_PMON_BOX_FILTER.{opc, nid} field to be set.  If, for example=
, one wanted to count DRD Local Misses, one should select MISS_OPC_MATCH an=
d set Cn_MSR_PMON_BOX_FILTER.opc  to DRD (0x182).; Transactions inserted in=
to the TOR that match an opcode (matched by Cn_MSR_PMON_BOX_FILTER.opc)",
+        "ScaleUnit": "64Bytes",
+        "UMask": "0x1",
         "Unit": "CBO"
     },
     {
-        "BriefDescription": "Lines Victimized; Victimized Lines that Match=
 NID",
-        "Counter": "0,1,2,3",
-        "EventCode": "0x37",
-        "EventName": "UNC_C_LLC_VICTIMS.NID",
+        "BriefDescription": "Streaming stores (full cache line). Derived f=
rom unc_c_tor_inserts.opcode",
+        "EventCode": "0x35",
+        "EventName": "LLC_REFERENCES.STREAMING_FULL",
+        "Filter": "filter_opc=3D0x18c",
         "PerPkg": "1",
-        "UMask": "0x40",
+        "PublicDescription": "Counts the number of entries successfully in=
serted into the TOR that match  qualifications specified by the subevent.  =
There are a number of subevent 'filters' but only a subset of the subevent =
combinations are valid.  Subevents that require an opcode or NID match requ=
ire the Cn_MSR_PMON_BOX_FILTER.{opc, nid} field to be set.  If, for example=
, one wanted to count DRD Local Misses, one should select MISS_OPC_MATCH an=
d set Cn_MSR_PMON_BOX_FILTER.opc  to DRD (0x182).; Transactions inserted in=
to the TOR that match an opcode (matched by Cn_MSR_PMON_BOX_FILTER.opc)",
+        "ScaleUnit": "64Bytes",
+        "UMask": "0x1",
         "Unit": "CBO"
     },
     {
-        "BriefDescription": "Lines Victimized",
-        "Counter": "0,1,2,3",
-        "EventCode": "0x37",
-        "EventName": "UNC_C_LLC_VICTIMS.MISS",
+        "BriefDescription": "Streaming stores (partial cache line). Derive=
d from unc_c_tor_inserts.opcode",
+        "EventCode": "0x35",
+        "EventName": "LLC_REFERENCES.STREAMING_PARTIAL",
+        "Filter": "filter_opc=3D0x18d",
         "PerPkg": "1",
-        "UMask": "0x10",
+        "PublicDescription": "Counts the number of entries successfully in=
serted into the TOR that match  qualifications specified by the subevent.  =
There are a number of subevent 'filters' but only a subset of the subevent =
combinations are valid.  Subevents that require an opcode or NID match requ=
ire the Cn_MSR_PMON_BOX_FILTER.{opc, nid} field to be set.  If, for example=
, one wanted to count DRD Local Misses, one should select MISS_OPC_MATCH an=
d set Cn_MSR_PMON_BOX_FILTER.opc  to DRD (0x182).; Transactions inserted in=
to the TOR that match an opcode (matched by Cn_MSR_PMON_BOX_FILTER.opc)",
+        "ScaleUnit": "64Bytes",
+        "UMask": "0x1",
         "Unit": "CBO"
     },
     {
-        "BriefDescription": "Cbo Misc; Silent Snoop Eviction",
-        "Counter": "0,1,2,3",
-        "EventCode": "0x39",
-        "EventName": "UNC_C_MISC.RSPI_WAS_FSE",
+        "BriefDescription": "Bounce Control",
+        "EventCode": "0xA",
+        "EventName": "UNC_C_BOUNCE_CONTROL",
         "PerPkg": "1",
-        "UMask": "0x1",
+        "PublicDescription": "UNC_C_BOUNCE_CONTROL",
         "Unit": "CBO"
     },
     {
-        "BriefDescription": "Cbo Misc; Write Combining Aliasing",
-        "Counter": "0,1,2,3",
-        "EventCode": "0x39",
-        "EventName": "UNC_C_MISC.WC_ALIASING",
+        "BriefDescription": "Uncore Clocks",
+        "EventName": "UNC_C_CLOCKTICKS",
         "PerPkg": "1",
-        "UMask": "0x2",
+        "PublicDescription": "UNC_C_CLOCKTICKS",
         "Unit": "CBO"
     },
     {
-        "BriefDescription": "Cbo Misc",
-        "Counter": "0,1,2,3",
-        "EventCode": "0x39",
-        "EventName": "UNC_C_MISC.STARTED",
+        "BriefDescription": "Counter 0 Occupancy",
+        "EventCode": "0x1F",
+        "EventName": "UNC_C_COUNTER0_OCCUPANCY",
         "PerPkg": "1",
-        "UMask": "0x4",
+        "PublicDescription": "Since occupancy counts can only be captured =
in the Cbo's 0 counter, this event allows a user to capture occupancy relat=
ed information by filtering the Cb0 occupancy count captured in Counter 0. =
  The filtering available is found in the control register - threshold, inv=
ert and edge detect.   E.g. setting threshold to 1 can effectively monitor =
how many cycles the monitored queue has an entry.",
         "Unit": "CBO"
     },
     {
-        "BriefDescription": "Cbo Misc; RFO HitS",
-        "Counter": "0,1,2,3",
-        "EventCode": "0x39",
-        "EventName": "UNC_C_MISC.RFO_HIT_S",
+        "BriefDescription": "FaST wire asserted",
+        "EventCode": "0x9",
+        "EventName": "UNC_C_FAST_ASSERTED",
         "PerPkg": "1",
-        "UMask": "0x8",
+        "PublicDescription": "Counts the number of cycles either the local=
 distress or incoming distress signals are asserted.  Incoming distress inc=
ludes both up and dn.",
         "Unit": "CBO"
     },
     {
-        "BriefDescription": "Cbo Misc; Clean Victim with raw CV=3D0",
-        "Counter": "0,1,2,3",
-        "EventCode": "0x39",
-        "EventName": "UNC_C_MISC.CVZERO_PREFETCH_VICTIM",
+        "BriefDescription": "All LLC Misses (code+ data rd + data wr - inc=
luding demand and prefetch)",
+        "EventCode": "0x34",
+        "EventName": "UNC_C_LLC_LOOKUP.ANY",
+        "Filter": "filter_state=3D0x1",
         "PerPkg": "1",
-        "UMask": "0x10",
+        "PublicDescription": "Counts the number of times the LLC was acces=
sed - this includes code, data, prefetches and hints coming from L2.  This =
has numerous filters available.  Note the non-standard filtering equation. =
 This event will count requests that lookup the cache multiple times with m=
ultiple increments.  One must ALWAYS set umask bit 0 and select a state or =
states to match.  Otherwise, the event will count nothing.   CBoGlCtrl[22:1=
8] bits correspond to [FMESI] state.; Filters for any transaction originati=
ng from the IPQ or IRQ.  This does not include lookups originating from the=
 ISMQ.",
+        "ScaleUnit": "64Bytes",
+        "UMask": "0x11",
         "Unit": "CBO"
     },
     {
-        "BriefDescription": "Cbo Misc; DRd hitting non-M with raw CV=3D0",
-        "Counter": "0,1,2,3",
-        "EventCode": "0x39",
-        "EventName": "UNC_C_MISC.CVZERO_PREFETCH_MISS",
+        "BriefDescription": "Cache Lookups; Data Read Request",
+        "EventCode": "0x34",
+        "EventName": "UNC_C_LLC_LOOKUP.DATA_READ",
         "PerPkg": "1",
-        "UMask": "0x20",
+        "PublicDescription": "Counts the number of times the LLC was acces=
sed - this includes code, data, prefetches and hints coming from L2.  This =
has numerous filters available.  Note the non-standard filtering equation. =
 This event will count requests that lookup the cache multiple times with m=
ultiple increments.  One must ALWAYS set umask bit 0 and select a state or =
states to match.  Otherwise, the event will count nothing.   CBoGlCtrl[22:1=
8] bits correspond to [FMESI] state.; Read transactions",
+        "UMask": "0x3",
         "Unit": "CBO"
     },
     {
-        "BriefDescription": "AD Ring In Use; Up and Even",
-        "Counter": "0,1,2,3",
-        "EventCode": "0x1B",
-        "EventName": "UNC_C_RING_AD_USED.UP_EVEN",
+        "BriefDescription": "Cache Lookups; Lookups that Match NID",
+        "EventCode": "0x34",
+        "EventName": "UNC_C_LLC_LOOKUP.NID",
         "PerPkg": "1",
-        "UMask": "0x1",
+        "PublicDescription": "Counts the number of times the LLC was acces=
sed - this includes code, data, prefetches and hints coming from L2.  This =
has numerous filters available.  Note the non-standard filtering equation. =
 This event will count requests that lookup the cache multiple times with m=
ultiple increments.  One must ALWAYS set umask bit 0 and select a state or =
states to match.  Otherwise, the event will count nothing.   CBoGlCtrl[22:1=
8] bits correspond to [FMESI] state.; Qualify one of the other subevents by=
 the Target NID.  The NID is programmed in Cn_MSR_PMON_BOX_FILTER.nid.   In=
 conjunction with STATE =3D I, it is possible to monitor misses to specific=
 NIDs in the system.",
+        "UMask": "0x41",
         "Unit": "CBO"
     },
     {
-        "BriefDescription": "AD Ring In Use; Up and Odd",
-        "Counter": "0,1,2,3",
-        "EventCode": "0x1B",
-        "EventName": "UNC_C_RING_AD_USED.UP_ODD",
+        "BriefDescription": "Cache Lookups; Any Read Request",
+        "EventCode": "0x34",
+        "EventName": "UNC_C_LLC_LOOKUP.READ",
         "PerPkg": "1",
-        "UMask": "0x2",
+        "PublicDescription": "Counts the number of times the LLC was acces=
sed - this includes code, data, prefetches and hints coming from L2.  This =
has numerous filters available.  Note the non-standard filtering equation. =
 This event will count requests that lookup the cache multiple times with m=
ultiple increments.  One must ALWAYS set umask bit 0 and select a state or =
states to match.  Otherwise, the event will count nothing.   CBoGlCtrl[22:1=
8] bits correspond to [FMESI] state.; Read transactions",
+        "UMask": "0x21",
         "Unit": "CBO"
     },
     {
-        "BriefDescription": "AD Ring In Use; Down and Even",
-        "Counter": "0,1,2,3",
-        "EventCode": "0x1B",
-        "EventName": "UNC_C_RING_AD_USED.DOWN_EVEN",
+        "BriefDescription": "Cache Lookups; External Snoop Request",
+        "EventCode": "0x34",
+        "EventName": "UNC_C_LLC_LOOKUP.REMOTE_SNOOP",
         "PerPkg": "1",
-        "UMask": "0x4",
+        "PublicDescription": "Counts the number of times the LLC was acces=
sed - this includes code, data, prefetches and hints coming from L2.  This =
has numerous filters available.  Note the non-standard filtering equation. =
 This event will count requests that lookup the cache multiple times with m=
ultiple increments.  One must ALWAYS set umask bit 0 and select a state or =
states to match.  Otherwise, the event will count nothing.   CBoGlCtrl[22:1=
8] bits correspond to [FMESI] state.; Filters for only snoop requests comin=
g from the remote socket(s) through the IPQ.",
+        "UMask": "0x9",
         "Unit": "CBO"
     },
     {
-        "BriefDescription": "AD Ring In Use; Down and Odd",
-        "Counter": "0,1,2,3",
-        "EventCode": "0x1B",
-        "EventName": "UNC_C_RING_AD_USED.DOWN_ODD",
+        "BriefDescription": "Cache Lookups; Write Requests",
+        "EventCode": "0x34",
+        "EventName": "UNC_C_LLC_LOOKUP.WRITE",
         "PerPkg": "1",
-        "UMask": "0x8",
+        "PublicDescription": "Counts the number of times the LLC was acces=
sed - this includes code, data, prefetches and hints coming from L2.  This =
has numerous filters available.  Note the non-standard filtering equation. =
 This event will count requests that lookup the cache multiple times with m=
ultiple increments.  One must ALWAYS set umask bit 0 and select a state or =
states to match.  Otherwise, the event will count nothing.   CBoGlCtrl[22:1=
8] bits correspond to [FMESI] state.; Writeback transactions from L2 to the=
 LLC  This includes all write transactions -- both Cachable and UC.",
+        "UMask": "0x5",
         "Unit": "CBO"
     },
     {
-        "BriefDescription": "AD Ring In Use; Up",
-        "Counter": "0,1,2,3",
-        "EventCode": "0x1B",
-        "EventName": "UNC_C_RING_AD_USED.UP",
+        "BriefDescription": "Lines Victimized; Lines in E state",
+        "EventCode": "0x37",
+        "EventName": "UNC_C_LLC_VICTIMS.E_STATE",
         "PerPkg": "1",
-        "UMask": "0x3",
+        "PublicDescription": "Counts the number of lines that were victimi=
zed on a fill.  This can be filtered by the state that the line was in.",
+        "UMask": "0x2",
         "Unit": "CBO"
     },
     {
-        "BriefDescription": "AD Ring In Use; Down",
-        "Counter": "0,1,2,3",
-        "EventCode": "0x1B",
-        "EventName": "UNC_C_RING_AD_USED.DOWN",
+        "BriefDescription": "Lines Victimized",
+        "EventCode": "0x37",
+        "EventName": "UNC_C_LLC_VICTIMS.F_STATE",
         "PerPkg": "1",
-        "UMask": "0xC",
+        "PublicDescription": "Counts the number of lines that were victimi=
zed on a fill.  This can be filtered by the state that the line was in.",
+        "UMask": "0x8",
         "Unit": "CBO"
     },
     {
-        "BriefDescription": "AD Ring In Use; All",
-        "Counter": "0,1,2,3",
-        "EventCode": "0x1B",
-        "EventName": "UNC_C_RING_AD_USED.ALL",
+        "BriefDescription": "Lines Victimized; Lines in S State",
+        "EventCode": "0x37",
+        "EventName": "UNC_C_LLC_VICTIMS.I_STATE",
         "PerPkg": "1",
-        "UMask": "0xF",
+        "PublicDescription": "Counts the number of lines that were victimi=
zed on a fill.  This can be filtered by the state that the line was in.",
+        "UMask": "0x4",
         "Unit": "CBO"
     },
     {
-        "BriefDescription": "AK Ring In Use; Up and Even",
-        "Counter": "0,1,2,3",
-        "EventCode": "0x1C",
-        "EventName": "UNC_C_RING_AK_USED.UP_EVEN",
+        "BriefDescription": "Lines Victimized",
+        "EventCode": "0x37",
+        "EventName": "UNC_C_LLC_VICTIMS.MISS",
         "PerPkg": "1",
-        "UMask": "0x1",
+        "PublicDescription": "Counts the number of lines that were victimi=
zed on a fill.  This can be filtered by the state that the line was in.",
+        "UMask": "0x10",
         "Unit": "CBO"
     },
     {
-        "BriefDescription": "AK Ring In Use; Up and Odd",
-        "Counter": "0,1,2,3",
-        "EventCode": "0x1C",
-        "EventName": "UNC_C_RING_AK_USED.UP_ODD",
+        "BriefDescription": "M line evictions from LLC (writebacks to memo=
ry)",
+        "EventCode": "0x37",
+        "EventName": "UNC_C_LLC_VICTIMS.M_STATE",
+        "PerPkg": "1",
+        "PublicDescription": "Counts the number of lines that were victimi=
zed on a fill.  This can be filtered by the state that the line was in.",
+        "ScaleUnit": "64Bytes",
+        "UMask": "0x1",
+        "Unit": "CBO"
+    },
+    {
+        "BriefDescription": "Lines Victimized; Victimized Lines that Match=
 NID",
+        "EventCode": "0x37",
+        "EventName": "UNC_C_LLC_VICTIMS.NID",
+        "PerPkg": "1",
+        "PublicDescription": "Counts the number of lines that were victimi=
zed on a fill.  This can be filtered by the state that the line was in.; Qu=
alify one of the other subevents by the Target NID.  The NID is programmed =
in Cn_MSR_PMON_BOX_FILTER.nid.   In conjunction with STATE =3D I, it is pos=
sible to monitor misses to specific NIDs in the system.",
+        "UMask": "0x40",
+        "Unit": "CBO"
+    },
+    {
+        "BriefDescription": "Cbo Misc; DRd hitting non-M with raw CV=3D0",
+        "EventCode": "0x39",
+        "EventName": "UNC_C_MISC.CVZERO_PREFETCH_MISS",
+        "PerPkg": "1",
+        "PublicDescription": "Miscellaneous events in the Cbo.",
+        "UMask": "0x20",
+        "Unit": "CBO"
+    },
+    {
+        "BriefDescription": "Cbo Misc; Clean Victim with raw CV=3D0",
+        "EventCode": "0x39",
+        "EventName": "UNC_C_MISC.CVZERO_PREFETCH_VICTIM",
+        "PerPkg": "1",
+        "PublicDescription": "Miscellaneous events in the Cbo.",
+        "UMask": "0x10",
+        "Unit": "CBO"
+    },
+    {
+        "BriefDescription": "Cbo Misc; RFO HitS",
+        "EventCode": "0x39",
+        "EventName": "UNC_C_MISC.RFO_HIT_S",
+        "PerPkg": "1",
+        "PublicDescription": "Miscellaneous events in the Cbo.; Number of =
times that an RFO hit in S state.  This is useful for determining if it mig=
ht be good for a workload to use RspIWB instead of RspSWB.",
+        "UMask": "0x8",
+        "Unit": "CBO"
+    },
+    {
+        "BriefDescription": "Cbo Misc; Silent Snoop Eviction",
+        "EventCode": "0x39",
+        "EventName": "UNC_C_MISC.RSPI_WAS_FSE",
+        "PerPkg": "1",
+        "PublicDescription": "Miscellaneous events in the Cbo.; Counts the=
 number of times when a Snoop hit in FSE states and triggered a silent evic=
tion.  This is useful because this information is lost in the PRE encodings=
.",
+        "UMask": "0x1",
+        "Unit": "CBO"
+    },
+    {
+        "BriefDescription": "Cbo Misc",
+        "EventCode": "0x39",
+        "EventName": "UNC_C_MISC.STARTED",
+        "PerPkg": "1",
+        "PublicDescription": "Miscellaneous events in the Cbo.",
+        "UMask": "0x4",
+        "Unit": "CBO"
+    },
+    {
+        "BriefDescription": "Cbo Misc; Write Combining Aliasing",
+        "EventCode": "0x39",
+        "EventName": "UNC_C_MISC.WC_ALIASING",
+        "PerPkg": "1",
+        "PublicDescription": "Miscellaneous events in the Cbo.; Counts the=
 number of times that a USWC write (WCIL(F)) transaction hit in the LLC in =
M state, triggering a WBMtoI followed by the USWC write.  This occurs when =
there is WC aliasing.",
+        "UMask": "0x2",
+        "Unit": "CBO"
+    },
+    {
+        "BriefDescription": "LRU Queue; LRU Age 0",
+        "EventCode": "0x3C",
+        "EventName": "UNC_C_QLRU.AGE0",
+        "PerPkg": "1",
+        "PublicDescription": "How often age was set to 0",
+        "UMask": "0x1",
+        "Unit": "CBO"
+    },
+    {
+        "BriefDescription": "LRU Queue; LRU Age 1",
+        "EventCode": "0x3C",
+        "EventName": "UNC_C_QLRU.AGE1",
+        "PerPkg": "1",
+        "PublicDescription": "How often age was set to 1",
+        "UMask": "0x2",
+        "Unit": "CBO"
+    },
+    {
+        "BriefDescription": "LRU Queue; LRU Age 2",
+        "EventCode": "0x3C",
+        "EventName": "UNC_C_QLRU.AGE2",
+        "PerPkg": "1",
+        "PublicDescription": "How often age was set to 2",
+        "UMask": "0x4",
+        "Unit": "CBO"
+    },
+    {
+        "BriefDescription": "LRU Queue; LRU Age 3",
+        "EventCode": "0x3C",
+        "EventName": "UNC_C_QLRU.AGE3",
+        "PerPkg": "1",
+        "PublicDescription": "How often age was set to 3",
+        "UMask": "0x8",
+        "Unit": "CBO"
+    },
+    {
+        "BriefDescription": "LRU Queue; LRU Bits Decremented",
+        "EventCode": "0x3C",
+        "EventName": "UNC_C_QLRU.LRU_DECREMENT",
+        "PerPkg": "1",
+        "PublicDescription": "How often all LRU bits were decremented by 1=
",
+        "UMask": "0x10",
+        "Unit": "CBO"
+    },
+    {
+        "BriefDescription": "LRU Queue; Non-0 Aged Victim",
+        "EventCode": "0x3C",
+        "EventName": "UNC_C_QLRU.VICTIM_NON_ZERO",
+        "PerPkg": "1",
+        "PublicDescription": "How often we picked a victim that had a non-=
zero age",
+        "UMask": "0x20",
+        "Unit": "CBO"
+    },
+    {
+        "BriefDescription": "AD Ring In Use; All",
+        "EventCode": "0x1B",
+        "EventName": "UNC_C_RING_AD_USED.ALL",
+        "PerPkg": "1",
+        "PublicDescription": "Counts the number of cycles that the AD ring=
 is being used at this ring stop.  This includes when packets are passing b=
y and when packets are being sunk, but does not include when packets are be=
ing sent from the ring stop.  We really have two rings in BDX -- a clockwis=
e ring and a counter-clockwise ring.  On the left side of the ring, the UP =
direction is on the clockwise ring and DN is on the counter-clockwise ring.=
  On the right side of the ring, this is reversed.  The first half of the C=
Bos are on the left side of the ring, and the 2nd half are on the right sid=
e of the ring.  In other words (for example), in a 4c part, Cbo 0 UP AD is =
NOT the same ring as CBo 2 UP AD because they are on opposite sides of the =
ring.",
+        "UMask": "0xf",
+        "Unit": "CBO"
+    },
+    {
+        "BriefDescription": "AD Ring In Use; Down",
+        "EventCode": "0x1B",
+        "EventName": "UNC_C_RING_AD_USED.DOWN",
+        "PerPkg": "1",
+        "PublicDescription": "Counts the number of cycles that the AD ring=
 is being used at this ring stop.  This includes when packets are passing b=
y and when packets are being sunk, but does not include when packets are be=
ing sent from the ring stop.  We really have two rings in BDX-- a clockwise=
 ring and a counter-clockwise ring.  On the left side of the ring, the UP d=
irection is on the clockwise ring and DN is on the counter-clockwise ring. =
 On the right side of the ring, this is reversed.  The first half of the CB=
os are on the left side of the ring, and the 2nd half are on the right side=
 of the ring.  In other words (for example), in a 4c part, Cbo 0 UP AD is N=
OT the same ring as CBo 2 UP AD because they are on opposite sides of the r=
ing.",
+        "UMask": "0xc",
+        "Unit": "CBO"
+    },
+    {
+        "BriefDescription": "AD Ring In Use; Down and Even",
+        "EventCode": "0x1B",
+        "EventName": "UNC_C_RING_AD_USED.DOWN_EVEN",
+        "PerPkg": "1",
+        "PublicDescription": "Counts the number of cycles that the AD ring=
 is being used at this ring stop.  This includes when packets are passing b=
y and when packets are being sunk, but does not include when packets are be=
ing sent from the ring stop.  We really have two rings in BDX -- a clockwis=
e ring and a counter-clockwise ring.  On the left side of the ring, the UP =
direction is on the clockwise ring and DN is on the counter-clockwise ring.=
  On the right side of the ring, this is reversed.  The first half of the C=
Bos are on the left side of the ring, and the 2nd half are on the right sid=
e of the ring.  In other words (for example), in a 4c part, Cbo 0 UP AD is =
NOT the same ring as CBo 2 UP AD because they are on opposite sides of the =
ring.; Filters for the Down and Even ring polarity.",
+        "UMask": "0x4",
+        "Unit": "CBO"
+    },
+    {
+        "BriefDescription": "AD Ring In Use; Down and Odd",
+        "EventCode": "0x1B",
+        "EventName": "UNC_C_RING_AD_USED.DOWN_ODD",
+        "PerPkg": "1",
+        "PublicDescription": "Counts the number of cycles that the AD ring=
 is being used at this ring stop.  This includes when packets are passing b=
y and when packets are being sunk, but does not include when packets are be=
ing sent from the ring stop.  We really have two rings in BDX -- a clockwis=
e ring and a counter-clockwise ring.  On the left side of the ring, the UP =
direction is on the clockwise ring and DN is on the counter-clockwise ring.=
  On the right side of the ring, this is reversed.  The first half of the C=
Bos are on the left side of the ring, and the 2nd half are on the right sid=
e of the ring.  In other words (for example), in a 4c part, Cbo 0 UP AD is =
NOT the same ring as CBo 2 UP AD because they are on opposite sides of the =
ring.; Filters for the Down and Odd ring polarity.",
+        "UMask": "0x8",
+        "Unit": "CBO"
+    },
+    {
+        "BriefDescription": "AD Ring In Use; Up",
+        "EventCode": "0x1B",
+        "EventName": "UNC_C_RING_AD_USED.UP",
+        "PerPkg": "1",
+        "PublicDescription": "Counts the number of cycles that the AD ring=
 is being used at this ring stop.  This includes when packets are passing b=
y and when packets are being sunk, but does not include when packets are be=
ing sent from the ring stop.  We really have two rings in BDX -- a clockwis=
e ring and a counter-clockwise ring.  On the left side of the ring, the UP =
direction is on the clockwise ring and DN is on the counter-clockwise ring.=
  On the right side of the ring, this is reversed.  The first half of the C=
Bos are on the left side of the ring, and the 2nd half are on the right sid=
e of the ring.  In other words (for example), in a 4c part, Cbo 0 UP AD is =
NOT the same ring as CBo 2 UP AD because they are on opposite sides of the =
ring.",
+        "UMask": "0x3",
+        "Unit": "CBO"
+    },
+    {
+        "BriefDescription": "AD Ring In Use; Up and Even",
+        "EventCode": "0x1B",
+        "EventName": "UNC_C_RING_AD_USED.UP_EVEN",
+        "PerPkg": "1",
+        "PublicDescription": "Counts the number of cycles that the AD ring=
 is being used at this ring stop.  This includes when packets are passing b=
y and when packets are being sunk, but does not include when packets are be=
ing sent from the ring stop.  We really have two rings in BDX -- a clockwis=
e ring and a counter-clockwise ring.  On the left side of the ring, the UP =
direction is on the clockwise ring and DN is on the counter-clockwise ring.=
  On the right side of the ring, this is reversed.  The first half of the C=
Bos are on the left side of the ring, and the 2nd half are on the right sid=
e of the ring.  In other words (for example), in a 4c part, Cbo 0 UP AD is =
NOT the same ring as CBo 2 UP AD because they are on opposite sides of the =
ring.; Filters for the Up and Even ring polarity.",
+        "UMask": "0x1",
+        "Unit": "CBO"
+    },
+    {
+        "BriefDescription": "AD Ring In Use; Up and Odd",
+        "EventCode": "0x1B",
+        "EventName": "UNC_C_RING_AD_USED.UP_ODD",
         "PerPkg": "1",
+        "PublicDescription": "Counts the number of cycles that the AD ring=
 is being used at this ring stop.  This includes when packets are passing b=
y and when packets are being sunk, but does not include when packets are be=
ing sent from the ring stop.  We really have two rings in BDX -- a clockwis=
e ring and a counter-clockwise ring.  On the left side of the ring, the UP =
direction is on the clockwise ring and DN is on the counter-clockwise ring.=
  On the right side of the ring, this is reversed.  The first half of the C=
Bos are on the left side of the ring, and the 2nd half are on the right sid=
e of the ring.  In other words (for example), in a 4c part, Cbo 0 UP AD is =
NOT the same ring as CBo 2 UP AD because they are on opposite sides of the =
ring.; Filters for the Up and Odd ring polarity.",
         "UMask": "0x2",
         "Unit": "CBO"
     },
+    {
+        "BriefDescription": "AK Ring In Use; All",
+        "EventCode": "0x1C",
+        "EventName": "UNC_C_RING_AK_USED.ALL",
+        "PerPkg": "1",
+        "PublicDescription": "Counts the number of cycles that the AK ring=
 is being used at this ring stop.  This includes when packets are passing b=
y and when packets are being sunk, but does not include when packets are be=
ing sent from the ring stop.We really have two rings in BDX -- a clockwise =
ring and a counter-clockwise ring.  On the left side of the ring, the UP di=
rection is on the clockwise ring and DN is on the counter-clockwise ring.  =
On the right side of the ring, this is reversed.  The first half of the CBo=
s are on the left side of the ring, and the 2nd half are on the right side =
of the ring.  In other words (for example), in a 4c part, Cbo 0 UP AD is NO=
T the same ring as CBo 2 UP AD because they are on opposite sides of the ri=
ng.",
+        "UMask": "0xf",
+        "Unit": "CBO"
+    },
+    {
+        "BriefDescription": "AK Ring In Use; Down",
+        "EventCode": "0x1C",
+        "EventName": "UNC_C_RING_AK_USED.DOWN",
+        "PerPkg": "1",
+        "PublicDescription": "Counts the number of cycles that the AK ring=
 is being used at this ring stop.  This includes when packets are passing b=
y and when packets are being sunk, but does not include when packets are be=
ing sent from the ring stop.We really have two rings in HSX -- a clockwise =
ring and a counter-clockwise ring.  On the left side of the ring, the UP di=
rection is on the clockwise ring and DN is on the counter-clockwise ring.  =
On the right side of the ring, this is reversed.  The first half of the CBo=
s are on the left side of the ring, and the 2nd half are on the right side =
of the ring.  In other words (for example), in a 4c part, Cbo 0 UP AD is NO=
T the same ring as CBo 2 UP AD because they are on opposite sides of the ri=
ng.",
+        "UMask": "0xc",
+        "Unit": "CBO"
+    },
     {
         "BriefDescription": "AK Ring In Use; Down and Even",
-        "Counter": "0,1,2,3",
         "EventCode": "0x1C",
         "EventName": "UNC_C_RING_AK_USED.DOWN_EVEN",
         "PerPkg": "1",
+        "PublicDescription": "Counts the number of cycles that the AK ring=
 is being used at this ring stop.  This includes when packets are passing b=
y and when packets are being sunk, but does not include when packets are be=
ing sent from the ring stop.We really have two rings in BDX -- a clockwise =
ring and a counter-clockwise ring.  On the left side of the ring, the UP di=
rection is on the clockwise ring and DN is on the counter-clockwise ring.  =
On the right side of the ring, this is reversed.  The first half of the CBo=
s are on the left side of the ring, and the 2nd half are on the right side =
of the ring.  In other words (for example), in a 4c part, Cbo 0 UP AD is NO=
T the same ring as CBo 2 UP AD because they are on opposite sides of the ri=
ng.; Filters for the Down and Even ring polarity.",
         "UMask": "0x4",
         "Unit": "CBO"
     },
     {
         "BriefDescription": "AK Ring In Use; Down and Odd",
-        "Counter": "0,1,2,3",
         "EventCode": "0x1C",
         "EventName": "UNC_C_RING_AK_USED.DOWN_ODD",
         "PerPkg": "1",
+        "PublicDescription": "Counts the number of cycles that the AK ring=
 is being used at this ring stop.  This includes when packets are passing b=
y and when packets are being sunk, but does not include when packets are be=
ing sent from the ring stop.We really have two rings in BDX -- a clockwise =
ring and a counter-clockwise ring.  On the left side of the ring, the UP di=
rection is on the clockwise ring and DN is on the counter-clockwise ring.  =
On the right side of the ring, this is reversed.  The first half of the CBo=
s are on the left side of the ring, and the 2nd half are on the right side =
of the ring.  In other words (for example), in a 4c part, Cbo 0 UP AD is NO=
T the same ring as CBo 2 UP AD because they are on opposite sides of the ri=
ng.; Filters for the Down and Odd ring polarity.",
         "UMask": "0x8",
         "Unit": "CBO"
     },
     {
         "BriefDescription": "AK Ring In Use; Up",
-        "Counter": "0,1,2,3",
         "EventCode": "0x1C",
         "EventName": "UNC_C_RING_AK_USED.UP",
         "PerPkg": "1",
+        "PublicDescription": "Counts the number of cycles that the AK ring=
 is being used at this ring stop.  This includes when packets are passing b=
y and when packets are being sunk, but does not include when packets are be=
ing sent from the ring stop.We really have two rings in HSX -- a clockwise =
ring and a counter-clockwise ring.  On the left side of the ring, the UP di=
rection is on the clockwise ring and DN is on the counter-clockwise ring.  =
On the right side of the ring, this is reversed.  The first half of the CBo=
s are on the left side of the ring, and the 2nd half are on the right side =
of the ring.  In other words (for example), in a 4c part, Cbo 0 UP AD is NO=
T the same ring as CBo 2 UP AD because they are on opposite sides of the ri=
ng.",
         "UMask": "0x3",
         "Unit": "CBO"
     },
     {
-        "BriefDescription": "AK Ring In Use; Down",
-        "Counter": "0,1,2,3",
+        "BriefDescription": "AK Ring In Use; Up and Even",
         "EventCode": "0x1C",
-        "EventName": "UNC_C_RING_AK_USED.DOWN",
+        "EventName": "UNC_C_RING_AK_USED.UP_EVEN",
         "PerPkg": "1",
-        "UMask": "0xC",
+        "PublicDescription": "Counts the number of cycles that the AK ring=
 is being used at this ring stop.  This includes when packets are passing b=
y and when packets are being sunk, but does not include when packets are be=
ing sent from the ring stop.We really have two rings in BDX -- a clockwise =
ring and a counter-clockwise ring.  On the left side of the ring, the UP di=
rection is on the clockwise ring and DN is on the counter-clockwise ring.  =
On the right side of the ring, this is reversed.  The first half of the CBo=
s are on the left side of the ring, and the 2nd half are on the right side =
of the ring.  In other words (for example), in a 4c part, Cbo 0 UP AD is NO=
T the same ring as CBo 2 UP AD because they are on opposite sides of the ri=
ng.; Filters for the Up and Even ring polarity.",
+        "UMask": "0x1",
         "Unit": "CBO"
     },
     {
-        "BriefDescription": "AK Ring In Use; All",
-        "Counter": "0,1,2,3",
+        "BriefDescription": "AK Ring In Use; Up and Odd",
         "EventCode": "0x1C",
-        "EventName": "UNC_C_RING_AK_USED.ALL",
+        "EventName": "UNC_C_RING_AK_USED.UP_ODD",
         "PerPkg": "1",
-        "UMask": "0xF",
+        "PublicDescription": "Counts the number of cycles that the AK ring=
 is being used at this ring stop.  This includes when packets are passing b=
y and when packets are being sunk, but does not include when packets are be=
ing sent from the ring stop.We really have two rings in BDX -- a clockwise =
ring and a counter-clockwise ring.  On the left side of the ring, the UP di=
rection is on the clockwise ring and DN is on the counter-clockwise ring.  =
On the right side of the ring, this is reversed.  The first half of the CBo=
s are on the left side of the ring, and the 2nd half are on the right side =
of the ring.  In other words (for example), in a 4c part, Cbo 0 UP AD is NO=
T the same ring as CBo 2 UP AD because they are on opposite sides of the ri=
ng.; Filters for the Up and Odd ring polarity.",
+        "UMask": "0x2",
         "Unit": "CBO"
     },
     {
-        "BriefDescription": "BL Ring in Use; Up and Even",
-        "Counter": "0,1,2,3",
+        "BriefDescription": "BL Ring in Use; Down",
         "EventCode": "0x1D",
-        "EventName": "UNC_C_RING_BL_USED.UP_EVEN",
+        "EventName": "UNC_C_RING_BL_USED.ALL",
         "PerPkg": "1",
-        "UMask": "0x1",
+        "PublicDescription": "Counts the number of cycles that the BL ring=
 is being used at this ring stop.  This includes when packets are passing b=
y and when packets are being sunk, but does not include when packets are be=
ing sent from the ring stop.We really have two rings in BDX -- a clockwise =
ring and a counter-clockwise ring.  On the left side of the ring, the UP di=
rection is on the clockwise ring and DN is on the counter-clockwise ring.  =
On the right side of the ring, this is reversed.  The first half of the CBo=
s are on the left side of the ring, and the 2nd half are on the right side =
of the ring.  In other words (for example), in a 4c part, Cbo 0 UP AD is NO=
T the same ring as CBo 2 UP AD because they are on opposite sides of the ri=
ng.",
+        "UMask": "0xf",
         "Unit": "CBO"
     },
     {
-        "BriefDescription": "BL Ring in Use; Up and Odd",
-        "Counter": "0,1,2,3",
+        "BriefDescription": "BL Ring in Use; Down",
         "EventCode": "0x1D",
-        "EventName": "UNC_C_RING_BL_USED.UP_ODD",
+        "EventName": "UNC_C_RING_BL_USED.DOWN",
         "PerPkg": "1",
-        "UMask": "0x2",
+        "PublicDescription": "Counts the number of cycles that the BL ring=
 is being used at this ring stop.  This includes when packets are passing b=
y and when packets are being sunk, but does not include when packets are be=
ing sent from the ring stop.We really have two rings in HSX -- a clockwise =
ring and a counter-clockwise ring.  On the left side of the ring, the UP di=
rection is on the clockwise ring and DN is on the counter-clockwise ring.  =
On the right side of the ring, this is reversed.  The first half of the CBo=
s are on the left side of the ring, and the 2nd half are on the right side =
of the ring.  In other words (for example), in a 4c part, Cbo 0 UP AD is NO=
T the same ring as CBo 2 UP AD because they are on opposite sides of the ri=
ng.",
+        "UMask": "0xc",
         "Unit": "CBO"
     },
     {
         "BriefDescription": "BL Ring in Use; Down and Even",
-        "Counter": "0,1,2,3",
         "EventCode": "0x1D",
         "EventName": "UNC_C_RING_BL_USED.DOWN_EVEN",
         "PerPkg": "1",
+        "PublicDescription": "Counts the number of cycles that the BL ring=
 is being used at this ring stop.  This includes when packets are passing b=
y and when packets are being sunk, but does not include when packets are be=
ing sent from the ring stop.We really have two rings in BDX -- a clockwise =
ring and a counter-clockwise ring.  On the left side of the ring, the UP di=
rection is on the clockwise ring and DN is on the counter-clockwise ring.  =
On the right side of the ring, this is reversed.  The first half of the CBo=
s are on the left side of the ring, and the 2nd half are on the right side =
of the ring.  In other words (for example), in a 4c part, Cbo 0 UP AD is NO=
T the same ring as CBo 2 UP AD because they are on opposite sides of the ri=
ng.; Filters for the Down and Even ring polarity.",
         "UMask": "0x4",
         "Unit": "CBO"
     },
     {
         "BriefDescription": "BL Ring in Use; Down and Odd",
-        "Counter": "0,1,2,3",
         "EventCode": "0x1D",
         "EventName": "UNC_C_RING_BL_USED.DOWN_ODD",
         "PerPkg": "1",
+        "PublicDescription": "Counts the number of cycles that the BL ring=
 is being used at this ring stop.  This includes when packets are passing b=
y and when packets are being sunk, but does not include when packets are be=
ing sent from the ring stop.We really have two rings in BDX -- a clockwise =
ring and a counter-clockwise ring.  On the left side of the ring, the UP di=
rection is on the clockwise ring and DN is on the counter-clockwise ring.  =
On the right side of the ring, this is reversed.  The first half of the CBo=
s are on the left side of the ring, and the 2nd half are on the right side =
of the ring.  In other words (for example), in a 4c part, Cbo 0 UP AD is NO=
T the same ring as CBo 2 UP AD because they are on opposite sides of the ri=
ng.; Filters for the Down and Odd ring polarity.",
         "UMask": "0x8",
         "Unit": "CBO"
     },
     {
         "BriefDescription": "BL Ring in Use; Up",
-        "Counter": "0,1,2,3",
         "EventCode": "0x1D",
         "EventName": "UNC_C_RING_BL_USED.UP",
         "PerPkg": "1",
+        "PublicDescription": "Counts the number of cycles that the BL ring=
 is being used at this ring stop.  This includes when packets are passing b=
y and when packets are being sunk, but does not include when packets are be=
ing sent from the ring stop.We really have two rings in HSX -- a clockwise =
ring and a counter-clockwise ring.  On the left side of the ring, the UP di=
rection is on the clockwise ring and DN is on the counter-clockwise ring.  =
On the right side of the ring, this is reversed.  The first half of the CBo=
s are on the left side of the ring, and the 2nd half are on the right side =
of the ring.  In other words (for example), in a 4c part, Cbo 0 UP AD is NO=
T the same ring as CBo 2 UP AD because they are on opposite sides of the ri=
ng.",
         "UMask": "0x3",
         "Unit": "CBO"
     },
     {
-        "BriefDescription": "BL Ring in Use; Down",
-        "Counter": "0,1,2,3",
+        "BriefDescription": "BL Ring in Use; Up and Even",
         "EventCode": "0x1D",
-        "EventName": "UNC_C_RING_BL_USED.DOWN",
+        "EventName": "UNC_C_RING_BL_USED.UP_EVEN",
         "PerPkg": "1",
-        "UMask": "0xC",
+        "PublicDescription": "Counts the number of cycles that the BL ring=
 is being used at this ring stop.  This includes when packets are passing b=
y and when packets are being sunk, but does not include when packets are be=
ing sent from the ring stop.We really have two rings in BDX -- a clockwise =
ring and a counter-clockwise ring.  On the left side of the ring, the UP di=
rection is on the clockwise ring and DN is on the counter-clockwise ring.  =
On the right side of the ring, this is reversed.  The first half of the CBo=
s are on the left side of the ring, and the 2nd half are on the right side =
of the ring.  In other words (for example), in a 4c part, Cbo 0 UP AD is NO=
T the same ring as CBo 2 UP AD because they are on opposite sides of the ri=
ng.; Filters for the Up and Even ring polarity.",
+        "UMask": "0x1",
         "Unit": "CBO"
     },
     {
-        "BriefDescription": "BL Ring in Use; Down",
-        "Counter": "0,1,2,3",
+        "BriefDescription": "BL Ring in Use; Up and Odd",
         "EventCode": "0x1D",
-        "EventName": "UNC_C_RING_BL_USED.ALL",
+        "EventName": "UNC_C_RING_BL_USED.UP_ODD",
         "PerPkg": "1",
-        "UMask": "0xF",
+        "PublicDescription": "Counts the number of cycles that the BL ring=
 is being used at this ring stop.  This includes when packets are passing b=
y and when packets are being sunk, but does not include when packets are be=
ing sent from the ring stop.We really have two rings in BDX -- a clockwise =
ring and a counter-clockwise ring.  On the left side of the ring, the UP di=
rection is on the clockwise ring and DN is on the counter-clockwise ring.  =
On the right side of the ring, this is reversed.  The first half of the CBo=
s are on the left side of the ring, and the 2nd half are on the right side =
of the ring.  In other words (for example), in a 4c part, Cbo 0 UP AD is NO=
T the same ring as CBo 2 UP AD because they are on opposite sides of the ri=
ng.; Filters for the Up and Odd ring polarity.",
+        "UMask": "0x2",
         "Unit": "CBO"
     },
     {
         "BriefDescription": "Number of LLC responses that bounced on the R=
ing.; AD",
-        "Counter": "0,1,2,3",
         "EventCode": "0x5",
         "EventName": "UNC_C_RING_BOUNCES.AD",
         "PerPkg": "1",
+        "PublicDescription": "UNC_C_RING_BOUNCES.AD",
         "UMask": "0x1",
         "Unit": "CBO"
     },
     {
         "BriefDescription": "Number of LLC responses that bounced on the R=
ing.; AK",
-        "Counter": "0,1,2,3",
         "EventCode": "0x5",
         "EventName": "UNC_C_RING_BOUNCES.AK",
         "PerPkg": "1",
+        "PublicDescription": "UNC_C_RING_BOUNCES.AK",
         "UMask": "0x2",
         "Unit": "CBO"
     },
     {
         "BriefDescription": "Number of LLC responses that bounced on the R=
ing.; BL",
-        "Counter": "0,1,2,3",
         "EventCode": "0x5",
         "EventName": "UNC_C_RING_BOUNCES.BL",
         "PerPkg": "1",
+        "PublicDescription": "UNC_C_RING_BOUNCES.BL",
         "UMask": "0x4",
         "Unit": "CBO"
     },
     {
-        "BriefDescription": "Number of LLC responses that bounced on the R=
ing.; Snoops of processor's cache",
-        "Counter": "0,1,2,3",
+        "BriefDescription": "Number of LLC responses that bounced on the R=
ing.; Snoops of processor's cache.",
         "EventCode": "0x5",
         "EventName": "UNC_C_RING_BOUNCES.IV",
         "PerPkg": "1",
+        "PublicDescription": "UNC_C_RING_BOUNCES.IV",
         "UMask": "0x10",
         "Unit": "CBO"
     },
     {
         "BriefDescription": "BL Ring in Use; Any",
-        "Counter": "0,1,2,3",
         "EventCode": "0x1E",
         "EventName": "UNC_C_RING_IV_USED.ANY",
         "PerPkg": "1",
-        "UMask": "0xF",
+        "PublicDescription": "Counts the number of cycles that the IV ring=
 is being used at this ring stop.  This includes when packets are passing b=
y and when packets are being sunk, but does not include when packets are be=
ing sent from the ring stop.  There is only 1 IV ring in BDX  Therefore, if=
 one wants to monitor the Even ring, they should select both UP_EVEN and DN=
_EVEN.  To monitor the Odd ring, they should select both UP_ODD and DN_ODD.=
; Filters any polarity",
+        "UMask": "0xf",
         "Unit": "CBO"
     },
     {
         "BriefDescription": "BL Ring in Use; Any",
-        "Counter": "0,1,2,3",
         "EventCode": "0x1E",
-        "EventName": "UNC_C_RING_IV_USED.UP",
+        "EventName": "UNC_C_RING_IV_USED.DN",
         "PerPkg": "1",
-        "UMask": "0x3",
+        "PublicDescription": "Counts the number of cycles that the IV ring=
 is being used at this ring stop.  This includes when packets are passing b=
y and when packets are being sunk, but does not include when packets are be=
ing sent from the ring stop.  There is only 1 IV ring in BDX  Therefore, if=
 one wants to monitor the Even ring, they should select both UP_EVEN and DN=
_EVEN.  To monitor the Odd ring, they should select both UP_ODD and DN_ODD.=
; Filters any polarity",
+        "UMask": "0xc",
         "Unit": "CBO"
     },
     {
         "BriefDescription": "BL Ring in Use; Down",
-        "Counter": "0,1,2,3",
         "EventCode": "0x1E",
         "EventName": "UNC_C_RING_IV_USED.DOWN",
         "PerPkg": "1",
-        "UMask": "0xCC",
+        "PublicDescription": "Counts the number of cycles that the IV ring=
 is being used at this ring stop.  This includes when packets are passing b=
y and when packets are being sunk, but does not include when packets are be=
ing sent from the ring stop.  There is only 1 IV ring in BDX  Therefore, if=
 one wants to monitor the Even ring, they should select both UP_EVEN and DN=
_EVEN.  To monitor the Odd ring, they should select both UP_ODD and DN_ODD.=
; Filters for Down polarity",
+        "UMask": "0xcc",
         "Unit": "CBO"
     },
     {
         "BriefDescription": "BL Ring in Use; Any",
-        "Counter": "0,1,2,3",
         "EventCode": "0x1E",
-        "EventName": "UNC_C_RING_IV_USED.DN",
-        "PerPkg": "1",
-        "UMask": "0xC",
-        "Unit": "CBO"
-    },
-    {
-        "BriefDescription": "Number of cycles the Cbo is actively throttli=
ng traffic onto the Ring in order to limit bounce traffic",
-        "Counter": "0,1,2,3",
-        "EventCode": "0x7",
-        "EventName": "UNC_C_RING_SRC_THRTL",
+        "EventName": "UNC_C_RING_IV_USED.UP",
         "PerPkg": "1",
+        "PublicDescription": "Counts the number of cycles that the IV ring=
 is being used at this ring stop.  This includes when packets are passing b=
y and when packets are being sunk, but does not include when packets are be=
ing sent from the ring stop.  There is only 1 IV ring in BDX  Therefore, if=
 one wants to monitor the Even ring, they should select both UP_EVEN and DN=
_EVEN.  To monitor the Odd ring, they should select both UP_ODD and DN_ODD.=
; Filters any polarity",
+        "UMask": "0x3",
         "Unit": "CBO"
     },
     {
-        "BriefDescription": "Ingress Arbiter Blocking Cycles; IPQ",
-        "Counter": "0,1,2,3",
-        "EventCode": "0x12",
-        "EventName": "UNC_C_RxR_EXT_STARVED.IRQ",
+        "BriefDescription": "AD",
+        "EventCode": "0x6",
+        "EventName": "UNC_C_RING_SINK_STARVED.AD",
         "PerPkg": "1",
+        "PublicDescription": "UNC_C_RING_SINK_STARVED.AD",
         "UMask": "0x1",
         "Unit": "CBO"
     },
     {
-        "BriefDescription": "Ingress Arbiter Blocking Cycles; IRQ",
-        "Counter": "0,1,2,3",
-        "EventCode": "0x12",
-        "EventName": "UNC_C_RxR_EXT_STARVED.IPQ",
+        "BriefDescription": "AK",
+        "EventCode": "0x6",
+        "EventName": "UNC_C_RING_SINK_STARVED.AK",
         "PerPkg": "1",
+        "PublicDescription": "UNC_C_RING_SINK_STARVED.AK",
         "UMask": "0x2",
         "Unit": "CBO"
     },
     {
-        "BriefDescription": "Ingress Arbiter Blocking Cycles; PRQ",
-        "Counter": "0,1,2,3",
-        "EventCode": "0x12",
-        "EventName": "UNC_C_RxR_EXT_STARVED.PRQ",
+        "BriefDescription": "BL",
+        "EventCode": "0x6",
+        "EventName": "UNC_C_RING_SINK_STARVED.BL",
         "PerPkg": "1",
+        "PublicDescription": "UNC_C_RING_SINK_STARVED.BL",
         "UMask": "0x4",
         "Unit": "CBO"
     },
     {
-        "BriefDescription": "Ingress Arbiter Blocking Cycles; ISMQ_BID",
-        "Counter": "0,1,2,3",
-        "EventCode": "0x12",
-        "EventName": "UNC_C_RxR_EXT_STARVED.ISMQ_BIDS",
+        "BriefDescription": "IV",
+        "EventCode": "0x6",
+        "EventName": "UNC_C_RING_SINK_STARVED.IV",
         "PerPkg": "1",
+        "PublicDescription": "UNC_C_RING_SINK_STARVED.IV",
         "UMask": "0x8",
         "Unit": "CBO"
     },
     {
-        "BriefDescription": "Ingress Allocations; IRQ",
-        "Counter": "0,1,2,3",
-        "EventCode": "0x13",
-        "EventName": "UNC_C_RxR_INSERTS.IRQ",
+        "BriefDescription": "Number of cycles the Cbo is actively throttli=
ng traffic onto the Ring in order to limit bounce traffic.",
+        "EventCode": "0x7",
+        "EventName": "UNC_C_RING_SRC_THRTL",
         "PerPkg": "1",
-        "UMask": "0x1",
+        "PublicDescription": "UNC_C_RING_SRC_THRTL",
         "Unit": "CBO"
     },
     {
-        "BriefDescription": "Ingress Allocations; IRQ Rejected",
-        "Counter": "0,1,2,3",
-        "EventCode": "0x13",
-        "EventName": "UNC_C_RxR_INSERTS.IRQ_REJ",
-        "PerPkg": "1",
-        "UMask": "0x2",
+        "BriefDescription": "Ingress Arbiter Blocking Cycles; IRQ",
+        "EventCode": "0x12",
+        "EventName": "UNC_C_RxR_EXT_STARVED.IPQ",
+        "PerPkg": "1",
+        "PublicDescription": "Counts cycles in external starvation.  This =
occurs when one of the ingress queues is being starved by the other queues.=
; IPQ is externally startved and therefore we are blocking the IRQ.",
+        "UMask": "0x2",
+        "Unit": "CBO"
+    },
+    {
+        "BriefDescription": "Ingress Arbiter Blocking Cycles; IPQ",
+        "EventCode": "0x12",
+        "EventName": "UNC_C_RxR_EXT_STARVED.IRQ",
+        "PerPkg": "1",
+        "PublicDescription": "Counts cycles in external starvation.  This =
occurs when one of the ingress queues is being starved by the other queues.=
; IRQ is externally starved and therefore we are blocking the IPQ.",
+        "UMask": "0x1",
+        "Unit": "CBO"
+    },
+    {
+        "BriefDescription": "Ingress Arbiter Blocking Cycles; ISMQ_BID",
+        "EventCode": "0x12",
+        "EventName": "UNC_C_RxR_EXT_STARVED.ISMQ_BIDS",
+        "PerPkg": "1",
+        "PublicDescription": "Counts cycles in external starvation.  This =
occurs when one of the ingress queues is being starved by the other queues.=
; Number of times that the ISMQ Bid.",
+        "UMask": "0x8",
+        "Unit": "CBO"
+    },
+    {
+        "BriefDescription": "Ingress Arbiter Blocking Cycles; PRQ",
+        "EventCode": "0x12",
+        "EventName": "UNC_C_RxR_EXT_STARVED.PRQ",
+        "PerPkg": "1",
+        "PublicDescription": "Counts cycles in external starvation.  This =
occurs when one of the ingress queues is being starved by the other queues.=
",
+        "UMask": "0x4",
         "Unit": "CBO"
     },
     {
         "BriefDescription": "Ingress Allocations; IPQ",
-        "Counter": "0,1,2,3",
         "EventCode": "0x13",
         "EventName": "UNC_C_RxR_INSERTS.IPQ",
         "PerPkg": "1",
+        "PublicDescription": "Counts number of allocations per cycle into =
the specified Ingress queue.",
         "UMask": "0x4",
         "Unit": "CBO"
     },
+    {
+        "BriefDescription": "Ingress Allocations; IRQ",
+        "EventCode": "0x13",
+        "EventName": "UNC_C_RxR_INSERTS.IRQ",
+        "PerPkg": "1",
+        "PublicDescription": "Counts number of allocations per cycle into =
the specified Ingress queue.",
+        "UMask": "0x1",
+        "Unit": "CBO"
+    },
+    {
+        "BriefDescription": "Ingress Allocations; IRQ Rejected",
+        "EventCode": "0x13",
+        "EventName": "UNC_C_RxR_INSERTS.IRQ_REJ",
+        "PerPkg": "1",
+        "PublicDescription": "Counts number of allocations per cycle into =
the specified Ingress queue.",
+        "UMask": "0x2",
+        "Unit": "CBO"
+    },
     {
         "BriefDescription": "Ingress Allocations; PRQ",
-        "Counter": "0,1,2,3",
         "EventCode": "0x13",
         "EventName": "UNC_C_RxR_INSERTS.PRQ",
         "PerPkg": "1",
+        "PublicDescription": "Counts number of allocations per cycle into =
the specified Ingress queue.",
         "UMask": "0x10",
         "Unit": "CBO"
     },
     {
         "BriefDescription": "Ingress Allocations; PRQ",
-        "Counter": "0,1,2,3",
         "EventCode": "0x13",
         "EventName": "UNC_C_RxR_INSERTS.PRQ_REJ",
         "PerPkg": "1",
+        "PublicDescription": "Counts number of allocations per cycle into =
the specified Ingress queue.",
         "UMask": "0x20",
         "Unit": "CBO"
     },
     {
-        "BriefDescription": "Probe Queue Retries; Any Reject",
-        "Counter": "0,1,2,3",
-        "EventCode": "0x31",
-        "EventName": "UNC_C_RxR_IPQ_RETRY.ANY",
+        "BriefDescription": "Ingress Internal Starvation Cycles; IPQ",
+        "EventCode": "0x14",
+        "EventName": "UNC_C_RxR_INT_STARVED.IPQ",
+        "PerPkg": "1",
+        "PublicDescription": "Counts cycles in internal starvation.  This =
occurs when one (or more) of the entries in the ingress queue are being sta=
rved out by other entries in that queue.; Cycles with the IPQ in Internal S=
tarvation.",
+        "UMask": "0x4",
+        "Unit": "CBO"
+    },
+    {
+        "BriefDescription": "Ingress Internal Starvation Cycles; IRQ",
+        "EventCode": "0x14",
+        "EventName": "UNC_C_RxR_INT_STARVED.IRQ",
         "PerPkg": "1",
+        "PublicDescription": "Counts cycles in internal starvation.  This =
occurs when one (or more) of the entries in the ingress queue are being sta=
rved out by other entries in that queue.; Cycles with the IRQ in Internal S=
tarvation.",
         "UMask": "0x1",
         "Unit": "CBO"
     },
     {
-        "BriefDescription": "Probe Queue Retries; No Egress Credits",
-        "Counter": "0,1,2,3",
-        "EventCode": "0x31",
-        "EventName": "UNC_C_RxR_IPQ_RETRY.FULL",
+        "BriefDescription": "Ingress Internal Starvation Cycles; ISMQ",
+        "EventCode": "0x14",
+        "EventName": "UNC_C_RxR_INT_STARVED.ISMQ",
         "PerPkg": "1",
-        "UMask": "0x2",
+        "PublicDescription": "Counts cycles in internal starvation.  This =
occurs when one (or more) of the entries in the ingress queue are being sta=
rved out by other entries in that queue.; Cycles with the ISMQ in Internal =
Starvation.",
+        "UMask": "0x8",
+        "Unit": "CBO"
+    },
+    {
+        "BriefDescription": "Ingress Internal Starvation Cycles; PRQ",
+        "EventCode": "0x14",
+        "EventName": "UNC_C_RxR_INT_STARVED.PRQ",
+        "PerPkg": "1",
+        "PublicDescription": "Counts cycles in internal starvation.  This =
occurs when one (or more) of the entries in the ingress queue are being sta=
rved out by other entries in that queue.",
+        "UMask": "0x10",
         "Unit": "CBO"
     },
     {
         "BriefDescription": "Probe Queue Retries; Address Conflict",
-        "Counter": "0,1,2,3",
         "EventCode": "0x31",
         "EventName": "UNC_C_RxR_IPQ_RETRY.ADDR_CONFLICT",
         "PerPkg": "1",
+        "PublicDescription": "Number of times a snoop (probe) request had =
to retry.  Filters exist to cover some of the common cases retries.; Counts=
 the number of times that a request form the IPQ was retried because of a T=
OR reject from an address conflicts.  Address conflicts out of the IPQ shou=
ld be rare.  They will generally only occur if two different sockets are se=
nding requests to the same address at the same time.  This is a true confli=
ct case, unlike the IPQ Address Conflict which is commonly caused by prefet=
ching characteristics.",
         "UMask": "0x4",
         "Unit": "CBO"
     },
+    {
+        "BriefDescription": "Probe Queue Retries; Any Reject",
+        "EventCode": "0x31",
+        "EventName": "UNC_C_RxR_IPQ_RETRY.ANY",
+        "PerPkg": "1",
+        "PublicDescription": "Number of times a snoop (probe) request had =
to retry.  Filters exist to cover some of the common cases retries.; Counts=
 the number of times that a request form the IPQ was retried because of a T=
OR reject.  TOR rejects from the IPQ can be caused by the Egress being full=
 or Address Conflicts.",
+        "UMask": "0x1",
+        "Unit": "CBO"
+    },
+    {
+        "BriefDescription": "Probe Queue Retries; No Egress Credits",
+        "EventCode": "0x31",
+        "EventName": "UNC_C_RxR_IPQ_RETRY.FULL",
+        "PerPkg": "1",
+        "PublicDescription": "Number of times a snoop (probe) request had =
to retry.  Filters exist to cover some of the common cases retries.; Counts=
 the number of times that a request form the IPQ was retried because of a T=
OR reject from the Egress being full.  IPQ requests make use of the AD Egre=
ss for regular responses, the BL egress to forward data, and the AK egress =
to return credits.",
+        "UMask": "0x2",
+        "Unit": "CBO"
+    },
     {
         "BriefDescription": "Probe Queue Retries; No QPI Credits",
-        "Counter": "0,1,2,3",
         "EventCode": "0x31",
         "EventName": "UNC_C_RxR_IPQ_RETRY.QPI_CREDITS",
         "PerPkg": "1",
+        "PublicDescription": "Number of times a snoop (probe) request had =
to retry.  Filters exist to cover some of the common cases retries.",
         "UMask": "0x10",
         "Unit": "CBO"
     },
     {
         "BriefDescription": "Probe Queue Retries; No AD Sbo Credits",
-        "Counter": "0,1,2,3",
         "EventCode": "0x28",
         "EventName": "UNC_C_RxR_IPQ_RETRY2.AD_SBO",
         "PerPkg": "1",
+        "PublicDescription": "Number of times a snoop (probe) request had =
to retry.  Filters exist to cover some of the common cases retries.; Counts=
 the number of times that a request from the IPQ was retried because of it =
lacked credits to send an AD packet to the Sbo.",
         "UMask": "0x1",
         "Unit": "CBO"
     },
     {
         "BriefDescription": "Probe Queue Retries; Target Node Filter",
-        "Counter": "0,1,2,3",
         "EventCode": "0x28",
         "EventName": "UNC_C_RxR_IPQ_RETRY2.TARGET",
         "PerPkg": "1",
+        "PublicDescription": "Number of times a snoop (probe) request had =
to retry.  Filters exist to cover some of the common cases retries.; Counts=
 the number of times that a request from the IPQ was retried filtered by th=
e Target NodeID as specified in the Cbox's Filter register.",
         "UMask": "0x40",
         "Unit": "CBO"
     },
+    {
+        "BriefDescription": "Ingress Request Queue Rejects; Address Confli=
ct",
+        "EventCode": "0x32",
+        "EventName": "UNC_C_RxR_IRQ_RETRY.ADDR_CONFLICT",
+        "PerPkg": "1",
+        "PublicDescription": "Counts the number of times that a request fr=
om the IRQ was retried because of an address match in the TOR.  In order to=
 maintain coherency, requests to the same address are not allowed to pass e=
ach other up in the Cbo.  Therefore, if there is an outstanding request to =
a given address, one cannot issue another request to that address until it =
is complete.  This comes up most commonly with prefetches.  Outstanding pre=
fetches occasionally will not complete their memory fetch and a demand requ=
est to the same address will then sit in the IRQ and get retried until the =
prefetch fills the data into the LLC.  Therefore, it will not be uncommon t=
o see this case in high bandwidth streaming workloads when the LLC Prefetch=
er in the core is enabled.",
+        "UMask": "0x4",
+        "Unit": "CBO"
+    },
     {
         "BriefDescription": "Ingress Request Queue Rejects; Any Reject",
-        "Counter": "0,1,2,3",
         "EventCode": "0x32",
         "EventName": "UNC_C_RxR_IRQ_RETRY.ANY",
         "PerPkg": "1",
+        "PublicDescription": "Counts the number of IRQ retries that occur.=
  Requests from the IRQ are retried if they are rejected from the TOR pipel=
ine for a variety of reasons.  Some of the most common reasons include if t=
he Egress is full, there are no RTIDs, or there is a Physical Address match=
 to another outstanding request.",
         "UMask": "0x1",
         "Unit": "CBO"
     },
     {
         "BriefDescription": "Ingress Request Queue Rejects; No Egress Cred=
its",
-        "Counter": "0,1,2,3",
         "EventCode": "0x32",
         "EventName": "UNC_C_RxR_IRQ_RETRY.FULL",
         "PerPkg": "1",
+        "PublicDescription": "Counts the number of times that a request fr=
om the IRQ was retried because it failed to acquire an entry in the Egress.=
  The egress is the buffer that queues up for allocating onto the ring.  IR=
Q requests can make use of all four rings and all four Egresses.  If any of=
 the queues that a given request needs to make use of are full, the request=
 will be retried.",
         "UMask": "0x2",
         "Unit": "CBO"
     },
     {
-        "BriefDescription": "Ingress Request Queue Rejects; Address Confli=
ct",
-        "Counter": "0,1,2,3",
+        "BriefDescription": "Ingress Request Queue Rejects; No IIO Credits=
",
         "EventCode": "0x32",
-        "EventName": "UNC_C_RxR_IRQ_RETRY.ADDR_CONFLICT",
+        "EventName": "UNC_C_RxR_IRQ_RETRY.IIO_CREDITS",
         "PerPkg": "1",
-        "UMask": "0x4",
+        "PublicDescription": "Number of times a request attempted to acqui=
re the NCS/NCB credit for sending messages on BL to the IIO.  There is a si=
ngle credit in each CBo that is shared between the NCS and NCB message clas=
ses for sending transactions on the BL ring (such as read data) to the IIO.=
",
+        "UMask": "0x20",
         "Unit": "CBO"
     },
     {
-        "BriefDescription": "Ingress Request Queue Rejects; No RTIDs",
-        "Counter": "0,1,2,3",
+        "BriefDescription": "Ingress Request Queue Rejects",
         "EventCode": "0x32",
-        "EventName": "UNC_C_RxR_IRQ_RETRY.RTID",
+        "EventName": "UNC_C_RxR_IRQ_RETRY.NID",
         "PerPkg": "1",
-        "UMask": "0x8",
+        "PublicDescription": "Qualify one of the other subevents by a give=
n RTID destination NID.  The NID is programmed in Cn_MSR_PMON_BOX_FILTER1.n=
id.",
+        "UMask": "0x40",
         "Unit": "CBO"
     },
     {
         "BriefDescription": "Ingress Request Queue Rejects; No QPI Credits=
",
-        "Counter": "0,1,2,3",
         "EventCode": "0x32",
         "EventName": "UNC_C_RxR_IRQ_RETRY.QPI_CREDITS",
         "PerPkg": "1",
+        "PublicDescription": "Number of requests rejects because of lack o=
f QPI Ingress credits.  These credits are required in order to send transac=
tions to the QPI agent.  Please see the QPI_IGR_CREDITS events for more inf=
ormation.",
         "UMask": "0x10",
         "Unit": "CBO"
     },
     {
-        "BriefDescription": "Ingress Request Queue Rejects; No IIO Credits=
",
-        "Counter": "0,1,2,3",
-        "EventCode": "0x32",
-        "EventName": "UNC_C_RxR_IRQ_RETRY.IIO_CREDITS",
-        "PerPkg": "1",
-        "UMask": "0x20",
-        "Unit": "CBO"
-    },
-    {
-        "BriefDescription": "Ingress Request Queue Rejects",
-        "Counter": "0,1,2,3",
+        "BriefDescription": "Ingress Request Queue Rejects; No RTIDs",
         "EventCode": "0x32",
-        "EventName": "UNC_C_RxR_IRQ_RETRY.NID",
+        "EventName": "UNC_C_RxR_IRQ_RETRY.RTID",
         "PerPkg": "1",
-        "UMask": "0x40",
+        "PublicDescription": "Counts the number of times that requests fro=
m the IRQ were retried because there were no RTIDs available.  RTIDs are re=
quired after a request misses the LLC and needs to send snoops and/or reque=
sts to memory.  If there are no RTIDs available, requests will queue up in =
the IRQ and retry until one becomes available.  Note that there are multipl=
e RTID pools for the different sockets.  There may be cases where the local=
 RTIDs are all used, but requests destined for remote memory can still acqu=
ire an RTID because there are remote RTIDs available.  This event does not =
provide any filtering for this case.",
+        "UMask": "0x8",
         "Unit": "CBO"
     },
     {
         "BriefDescription": "Ingress Request Queue Rejects; No AD Sbo Cred=
its",
-        "Counter": "0,1,2,3",
         "EventCode": "0x29",
         "EventName": "UNC_C_RxR_IRQ_RETRY2.AD_SBO",
         "PerPkg": "1",
+        "PublicDescription": "Counts the number of times that a request fr=
om the IPQ was retried because of it lacked credits to send an AD packet to=
 the Sbo.",
         "UMask": "0x1",
         "Unit": "CBO"
     },
     {
         "BriefDescription": "Ingress Request Queue Rejects; No BL Sbo Cred=
its",
-        "Counter": "0,1,2,3",
         "EventCode": "0x29",
         "EventName": "UNC_C_RxR_IRQ_RETRY2.BL_SBO",
         "PerPkg": "1",
+        "PublicDescription": "Counts the number of times that a request fr=
om the IPQ was retried because of it lacked credits to send an BL packet to=
 the Sbo.",
         "UMask": "0x2",
         "Unit": "CBO"
     },
     {
         "BriefDescription": "Ingress Request Queue Rejects; Target Node Fi=
lter",
-        "Counter": "0,1,2,3",
         "EventCode": "0x29",
         "EventName": "UNC_C_RxR_IRQ_RETRY2.TARGET",
         "PerPkg": "1",
+        "PublicDescription": "Counts the number of times that a request fr=
om the IPQ was retried filtered by the Target NodeID as specified in the Cb=
ox's Filter register.",
         "UMask": "0x40",
         "Unit": "CBO"
     },
     {
         "BriefDescription": "ISMQ Retries; Any Reject",
-        "Counter": "0,1,2,3",
         "EventCode": "0x33",
         "EventName": "UNC_C_RxR_ISMQ_RETRY.ANY",
         "PerPkg": "1",
+        "PublicDescription": "Number of times a transaction flowing throug=
h the ISMQ had to retry.  Transaction pass through the ISMQ as responses fo=
r requests that already exist in the Cbo.  Some examples include: when data=
 is returned or when snoop responses come back from the cores.; Counts the =
total number of times that a request from the ISMQ retried because of a TOR=
 reject.  ISMQ requests generally will not need to retry (or at least ISMQ =
retries are less common than IRQ retries).  ISMQ requests will retry if the=
y are not able to acquire a needed Egress credit to get onto the ring, or f=
or cache evictions that need to acquire an RTID.  Most ISMQ requests alread=
y have an RTID, so eviction retries will be less common here.",
         "UMask": "0x1",
         "Unit": "CBO"
     },
     {
         "BriefDescription": "ISMQ Retries; No Egress Credits",
-        "Counter": "0,1,2,3",
         "EventCode": "0x33",
         "EventName": "UNC_C_RxR_ISMQ_RETRY.FULL",
         "PerPkg": "1",
+        "PublicDescription": "Number of times a transaction flowing throug=
h the ISMQ had to retry.  Transaction pass through the ISMQ as responses fo=
r requests that already exist in the Cbo.  Some examples include: when data=
 is returned or when snoop responses come back from the cores.; Counts the =
number of times that a request from the ISMQ retried because of a TOR rejec=
t caused by a lack of Egress credits. The egress is the buffer that queues =
up for allocating onto the ring.  If any of the Egress queues that a given =
request needs to make use of are full, the request will be retried.",
         "UMask": "0x2",
         "Unit": "CBO"
     },
     {
-        "BriefDescription": "ISMQ Retries; No RTIDs",
-        "Counter": "0,1,2,3",
+        "BriefDescription": "ISMQ Retries; No IIO Credits",
         "EventCode": "0x33",
-        "EventName": "UNC_C_RxR_ISMQ_RETRY.RTID",
+        "EventName": "UNC_C_RxR_ISMQ_RETRY.IIO_CREDITS",
         "PerPkg": "1",
-        "UMask": "0x8",
+        "PublicDescription": "Number of times a transaction flowing throug=
h the ISMQ had to retry.  Transaction pass through the ISMQ as responses fo=
r requests that already exist in the Cbo.  Some examples include: when data=
 is returned or when snoop responses come back from the cores.; Number of t=
imes a request attempted to acquire the NCS/NCB credit for sending messages=
 on BL to the IIO.  There is a single credit in each CBo that is shared bet=
ween the NCS and NCB message classes for sending transactions on the BL rin=
g (such as read data) to the IIO.",
+        "UMask": "0x20",
         "Unit": "CBO"
     },
     {
-        "BriefDescription": "ISMQ Retries; No QPI Credits",
-        "Counter": "0,1,2,3",
+        "BriefDescription": "ISMQ Retries",
         "EventCode": "0x33",
-        "EventName": "UNC_C_RxR_ISMQ_RETRY.QPI_CREDITS",
+        "EventName": "UNC_C_RxR_ISMQ_RETRY.NID",
         "PerPkg": "1",
-        "UMask": "0x10",
+        "PublicDescription": "Number of times a transaction flowing throug=
h the ISMQ had to retry.  Transaction pass through the ISMQ as responses fo=
r requests that already exist in the Cbo.  Some examples include: when data=
 is returned or when snoop responses come back from the cores.; Qualify one=
 of the other subevents by a given RTID destination NID.  The NID is progra=
mmed in Cn_MSR_PMON_BOX_FILTER1.nid.",
+        "UMask": "0x40",
         "Unit": "CBO"
     },
     {
-        "BriefDescription": "ISMQ Retries; No IIO Credits",
-        "Counter": "0,1,2,3",
+        "BriefDescription": "ISMQ Retries; No QPI Credits",
         "EventCode": "0x33",
-        "EventName": "UNC_C_RxR_ISMQ_RETRY.IIO_CREDITS",
+        "EventName": "UNC_C_RxR_ISMQ_RETRY.QPI_CREDITS",
         "PerPkg": "1",
-        "UMask": "0x20",
+        "PublicDescription": "Number of times a transaction flowing throug=
h the ISMQ had to retry.  Transaction pass through the ISMQ as responses fo=
r requests that already exist in the Cbo.  Some examples include: when data=
 is returned or when snoop responses come back from the cores.",
+        "UMask": "0x10",
         "Unit": "CBO"
     },
     {
-        "BriefDescription": "ISMQ Retries",
-        "Counter": "0,1,2,3",
+        "BriefDescription": "ISMQ Retries; No RTIDs",
         "EventCode": "0x33",
-        "EventName": "UNC_C_RxR_ISMQ_RETRY.WB_CREDITS",
+        "EventName": "UNC_C_RxR_ISMQ_RETRY.RTID",
         "PerPkg": "1",
-        "UMask": "0x80",
+        "PublicDescription": "Number of times a transaction flowing throug=
h the ISMQ had to retry.  Transaction pass through the ISMQ as responses fo=
r requests that already exist in the Cbo.  Some examples include: when data=
 is returned or when snoop responses come back from the cores.; Counts the =
number of times that a request from the ISMQ retried because of a TOR rejec=
t caused by no RTIDs.  M-state cache evictions are serviced through the ISM=
Q, and must acquire an RTID in order to write back to memory.  If no RTIDs =
are available, they will be retried.",
+        "UMask": "0x8",
         "Unit": "CBO"
     },
     {
         "BriefDescription": "ISMQ Retries",
-        "Counter": "0,1,2,3",
         "EventCode": "0x33",
-        "EventName": "UNC_C_RxR_ISMQ_RETRY.NID",
+        "EventName": "UNC_C_RxR_ISMQ_RETRY.WB_CREDITS",
         "PerPkg": "1",
-        "UMask": "0x40",
+        "PublicDescription": "Number of times a transaction flowing throug=
h the ISMQ had to retry.  Transaction pass through the ISMQ as responses fo=
r requests that already exist in the Cbo.  Some examples include: when data=
 is returned or when snoop responses come back from the cores.; Qualify one=
 of the other subevents by a given RTID destination NID.  The NID is progra=
mmed in Cn_MSR_PMON_BOX_FILTER1.nid.",
+        "UMask": "0x80",
         "Unit": "CBO"
     },
     {
         "BriefDescription": "ISMQ Request Queue Rejects; No AD Sbo Credits=
",
-        "Counter": "0,1,2,3",
         "EventCode": "0x2A",
         "EventName": "UNC_C_RxR_ISMQ_RETRY2.AD_SBO",
         "PerPkg": "1",
+        "PublicDescription": "Counts the number of times that a request fr=
om the ISMQ was retried because of it lacked credits to send an AD packet t=
o the Sbo.",
         "UMask": "0x1",
         "Unit": "CBO"
     },
     {
         "BriefDescription": "ISMQ Request Queue Rejects; No BL Sbo Credits=
",
-        "Counter": "0,1,2,3",
         "EventCode": "0x2A",
         "EventName": "UNC_C_RxR_ISMQ_RETRY2.BL_SBO",
         "PerPkg": "1",
+        "PublicDescription": "Counts the number of times that a request fr=
om the ISMQ was retried because of it lacked credits to send an BL packet t=
o the Sbo.",
         "UMask": "0x2",
         "Unit": "CBO"
     },
     {
         "BriefDescription": "ISMQ Request Queue Rejects; Target Node Filte=
r",
-        "Counter": "0,1,2,3",
         "EventCode": "0x2A",
         "EventName": "UNC_C_RxR_ISMQ_RETRY2.TARGET",
         "PerPkg": "1",
+        "PublicDescription": "Counts the number of times that a request fr=
om the ISMQ was retried filtered by the Target NodeID as specified in the C=
box's Filter register.",
         "UMask": "0x40",
         "Unit": "CBO"
     },
+    {
+        "BriefDescription": "Ingress Occupancy; IPQ",
+        "EventCode": "0x11",
+        "EventName": "UNC_C_RxR_OCCUPANCY.IPQ",
+        "PerPkg": "1",
+        "PublicDescription": "Counts number of entries in the specified In=
gress queue in each cycle.",
+        "UMask": "0x4",
+        "Unit": "CBO"
+    },
     {
         "BriefDescription": "Ingress Occupancy; IRQ",
         "EventCode": "0x11",
         "EventName": "UNC_C_RxR_OCCUPANCY.IRQ",
         "PerPkg": "1",
+        "PublicDescription": "Counts number of entries in the specified In=
gress queue in each cycle.",
         "UMask": "0x1",
         "Unit": "CBO"
     },
@@ -792,40 +1103,34 @@
         "EventCode": "0x11",
         "EventName": "UNC_C_RxR_OCCUPANCY.IRQ_REJ",
         "PerPkg": "1",
+        "PublicDescription": "Counts number of entries in the specified In=
gress queue in each cycle.",
         "UMask": "0x2",
         "Unit": "CBO"
     },
-    {
-        "BriefDescription": "Ingress Occupancy; IPQ",
-        "EventCode": "0x11",
-        "EventName": "UNC_C_RxR_OCCUPANCY.IPQ",
-        "PerPkg": "1",
-        "UMask": "0x4",
-        "Unit": "CBO"
-    },
     {
         "BriefDescription": "Ingress Occupancy; PRQ Rejects",
         "EventCode": "0x11",
         "EventName": "UNC_C_RxR_OCCUPANCY.PRQ_REJ",
         "PerPkg": "1",
+        "PublicDescription": "Counts number of entries in the specified In=
gress queue in each cycle.",
         "UMask": "0x20",
         "Unit": "CBO"
     },
     {
         "BriefDescription": "SBo Credits Acquired; For AD Ring",
-        "Counter": "0,1,2,3",
         "EventCode": "0x3D",
         "EventName": "UNC_C_SBO_CREDITS_ACQUIRED.AD",
         "PerPkg": "1",
+        "PublicDescription": "Number of Sbo credits acquired in a given cy=
cle, per ring.  Each Cbo is assigned an Sbo it can communicate with.",
         "UMask": "0x1",
         "Unit": "CBO"
     },
     {
         "BriefDescription": "SBo Credits Acquired; For BL Ring",
-        "Counter": "0,1,2,3",
         "EventCode": "0x3D",
         "EventName": "UNC_C_SBO_CREDITS_ACQUIRED.BL",
         "PerPkg": "1",
+        "PublicDescription": "Number of Sbo credits acquired in a given cy=
cle, per ring.  Each Cbo is assigned an Sbo it can communicate with.",
         "UMask": "0x2",
         "Unit": "CBO"
     },
@@ -834,6 +1139,7 @@
         "EventCode": "0x3E",
         "EventName": "UNC_C_SBO_CREDIT_OCCUPANCY.AD",
         "PerPkg": "1",
+        "PublicDescription": "Number of Sbo credits in use in a given cycl=
e, per ring.  Each Cbo is assigned an Sbo it can communicate with.",
         "UMask": "0x1",
         "Unit": "CBO"
     },
@@ -842,411 +1148,288 @@
         "EventCode": "0x3E",
         "EventName": "UNC_C_SBO_CREDIT_OCCUPANCY.BL",
         "PerPkg": "1",
+        "PublicDescription": "Number of Sbo credits in use in a given cycl=
e, per ring.  Each Cbo is assigned an Sbo it can communicate with.",
         "UMask": "0x2",
         "Unit": "CBO"
     },
     {
-        "BriefDescription": "TOR Inserts; Opcode Match",
-        "Counter": "0,1,2,3",
+        "BriefDescription": "TOR Inserts; All",
         "EventCode": "0x35",
-        "EventName": "UNC_C_TOR_INSERTS.OPCODE",
+        "EventName": "UNC_C_TOR_INSERTS.ALL",
         "PerPkg": "1",
-        "UMask": "0x1",
+        "PublicDescription": "Counts the number of entries successfully in=
serted into the TOR that match  qualifications specified by the subevent.  =
There are a number of subevent 'filters' but only a subset of the subevent =
combinations are valid.  Subevents that require an opcode or NID match requ=
ire the Cn_MSR_PMON_BOX_FILTER.{opc, nid} field to be set.  If, for example=
, one wanted to count DRD Local Misses, one should select MISS_OPC_MATCH an=
d set Cn_MSR_PMON_BOX_FILTER.opc  to DRD (0x182).; All transactions inserte=
d into the TOR.    This includes requests that reside in the TOR for a shor=
t time, such as LLC Hits that do not need to snoop cores or requests that g=
et rejected and have to be retried through one of the ingress queues.  The =
TOR is more commonly a bottleneck in skews with smaller core counts, where =
the ratio of RTIDs to TOR entries is larger.  Note that there are reserved =
TOR entries for various request types, so it is possible that a given reque=
st type be blocked with an occupancy that is less than 20.  Also note that =
generally requests will not be able to arbitrate into the TOR pipeline if t=
here are no available TOR slots.",
+        "UMask": "0x8",
         "Unit": "CBO"
     },
     {
-        "BriefDescription": "PCIe writes (partial cache line). Derived fro=
m unc_c_tor_inserts.opcode",
-        "Counter": "0,1,2,3",
+        "BriefDescription": "TOR Inserts; Evictions",
         "EventCode": "0x35",
-        "EventName": "LLC_REFERENCES.PCIE_NS_PARTIAL_WRITE",
-        "Filter": "filter_opc=3D0x180,filter_tid=3D0x3e",
+        "EventName": "UNC_C_TOR_INSERTS.EVICTION",
         "PerPkg": "1",
-        "UMask": "0x1",
+        "PublicDescription": "Counts the number of entries successfully in=
serted into the TOR that match  qualifications specified by the subevent.  =
There are a number of subevent 'filters' but only a subset of the subevent =
combinations are valid.  Subevents that require an opcode or NID match requ=
ire the Cn_MSR_PMON_BOX_FILTER.{opc, nid} field to be set.  If, for example=
, one wanted to count DRD Local Misses, one should select MISS_OPC_MATCH an=
d set Cn_MSR_PMON_BOX_FILTER.opc  to DRD (0x182).; Eviction transactions in=
serted into the TOR.  Evictions can be quick, such as when the line is in t=
he F, S, or E states and no core valid bits are set.  They can also be long=
er if either CV bits are set (so the cores need to be snooped) and/or if th=
ere is a HitM (in which case it is necessary to write the request out to me=
mory).",
+        "UMask": "0x4",
         "Unit": "CBO"
     },
     {
-        "BriefDescription": "L2 demand and L2 prefetch code references to =
LLC. Derived from unc_c_tor_inserts.opcode",
-        "Counter": "0,1,2,3",
+        "BriefDescription": "TOR Inserts; Local Memory",
         "EventCode": "0x35",
-        "EventName": "LLC_REFERENCES.CODE_LLC_PREFETCH",
-        "Filter": "filter_opc=3D0x181",
+        "EventName": "UNC_C_TOR_INSERTS.LOCAL",
         "PerPkg": "1",
-        "ScaleUnit": "64Bytes",
-        "UMask": "0x1",
+        "PublicDescription": "Counts the number of entries successfully in=
serted into the TOR that match  qualifications specified by the subevent.  =
There are a number of subevent 'filters' but only a subset of the subevent =
combinations are valid.  Subevents that require an opcode or NID match requ=
ire the Cn_MSR_PMON_BOX_FILTER.{opc, nid} field to be set.  If, for example=
, one wanted to count DRD Local Misses, one should select MISS_OPC_MATCH an=
d set Cn_MSR_PMON_BOX_FILTER.opc  to DRD (0x182).; All transactions inserte=
d into the TOR that are satisifed by locally HOMed memory.",
+        "UMask": "0x28",
         "Unit": "CBO"
     },
     {
-        "BriefDescription": "Streaming stores (full cache line). Derived f=
rom unc_c_tor_inserts.opcode",
-        "Counter": "0,1,2,3",
+        "BriefDescription": "TOR Inserts; Local Memory - Opcode Matched",
         "EventCode": "0x35",
-        "EventName": "LLC_REFERENCES.STREAMING_FULL",
-        "Filter": "filter_opc=3D0x18c",
+        "EventName": "UNC_C_TOR_INSERTS.LOCAL_OPCODE",
         "PerPkg": "1",
-        "ScaleUnit": "64Bytes",
-        "UMask": "0x1",
+        "PublicDescription": "Counts the number of entries successfully in=
serted into the TOR that match  qualifications specified by the subevent.  =
There are a number of subevent 'filters' but only a subset of the subevent =
combinations are valid.  Subevents that require an opcode or NID match requ=
ire the Cn_MSR_PMON_BOX_FILTER.{opc, nid} field to be set.  If, for example=
, one wanted to count DRD Local Misses, one should select MISS_OPC_MATCH an=
d set Cn_MSR_PMON_BOX_FILTER.opc  to DRD (0x182).; All transactions, satisi=
fed by an opcode,  inserted into the TOR that are satisifed by locally HOMe=
d memory.",
+        "UMask": "0x21",
         "Unit": "CBO"
     },
     {
-        "BriefDescription": "Streaming stores (partial cache line). Derive=
d from unc_c_tor_inserts.opcode",
-        "Counter": "0,1,2,3",
+        "BriefDescription": "TOR Inserts; Misses to Local Memory",
         "EventCode": "0x35",
-        "EventName": "LLC_REFERENCES.STREAMING_PARTIAL",
-        "Filter": "filter_opc=3D0x18d",
+        "EventName": "UNC_C_TOR_INSERTS.MISS_LOCAL",
         "PerPkg": "1",
-        "ScaleUnit": "64Bytes",
-        "UMask": "0x1",
+        "PublicDescription": "Counts the number of entries successfully in=
serted into the TOR that match  qualifications specified by the subevent.  =
There are a number of subevent 'filters' but only a subset of the subevent =
combinations are valid.  Subevents that require an opcode or NID match requ=
ire the Cn_MSR_PMON_BOX_FILTER.{opc, nid} field to be set.  If, for example=
, one wanted to count DRD Local Misses, one should select MISS_OPC_MATCH an=
d set Cn_MSR_PMON_BOX_FILTER.opc  to DRD (0x182).; Miss transactions insert=
ed into the TOR that are satisifed by locally HOMed memory.",
+        "UMask": "0x2a",
         "Unit": "CBO"
     },
     {
-        "BriefDescription": "PCIe read current. Derived from unc_c_tor_ins=
erts.opcode",
-        "Counter": "0,1,2,3",
+        "BriefDescription": "TOR Inserts; Misses to Local Memory - Opcode =
Matched",
         "EventCode": "0x35",
-        "EventName": "LLC_REFERENCES.PCIE_READ",
-        "Filter": "filter_opc=3D0x19e",
+        "EventName": "UNC_C_TOR_INSERTS.MISS_LOCAL_OPCODE",
         "PerPkg": "1",
-        "ScaleUnit": "64Bytes",
-        "UMask": "0x1",
+        "PublicDescription": "Counts the number of entries successfully in=
serted into the TOR that match  qualifications specified by the subevent.  =
There are a number of subevent 'filters' but only a subset of the subevent =
combinations are valid.  Subevents that require an opcode or NID match requ=
ire the Cn_MSR_PMON_BOX_FILTER.{opc, nid} field to be set.  If, for example=
, one wanted to count DRD Local Misses, one should select MISS_OPC_MATCH an=
d set Cn_MSR_PMON_BOX_FILTER.opc  to DRD (0x182).; Miss transactions, satis=
ifed by an opcode, inserted into the TOR that are satisifed by locally HOMe=
d memory.",
+        "UMask": "0x23",
         "Unit": "CBO"
     },
     {
-        "BriefDescription": "PCIe write references (full cache line). Deri=
ved from unc_c_tor_inserts.opcode",
-        "Counter": "0,1,2,3",
+        "BriefDescription": "TOR Inserts; Miss Opcode Match",
         "EventCode": "0x35",
-        "EventName": "LLC_REFERENCES.PCIE_WRITE",
-        "Filter": "filter_opc=3D0x1c8,filter_tid=3D0x3e",
+        "EventName": "UNC_C_TOR_INSERTS.MISS_OPCODE",
         "PerPkg": "1",
-        "ScaleUnit": "64Bytes",
-        "UMask": "0x1",
+        "PublicDescription": "Counts the number of entries successfully in=
serted into the TOR that match  qualifications specified by the subevent.  =
There are a number of subevent 'filters' but only a subset of the subevent =
combinations are valid.  Subevents that require an opcode or NID match requ=
ire the Cn_MSR_PMON_BOX_FILTER.{opc, nid} field to be set.  If, for example=
, one wanted to count DRD Local Misses, one should select MISS_OPC_MATCH an=
d set Cn_MSR_PMON_BOX_FILTER.opc  to DRD (0x182).; Miss transactions insert=
ed into the TOR that match an opcode.",
+        "UMask": "0x3",
         "Unit": "CBO"
     },
     {
-        "BriefDescription": "TOR Inserts; Evictions",
-        "Counter": "0,1,2,3",
+        "BriefDescription": "TOR Inserts; Misses to Remote Memory",
         "EventCode": "0x35",
-        "EventName": "UNC_C_TOR_INSERTS.EVICTION",
+        "EventName": "UNC_C_TOR_INSERTS.MISS_REMOTE",
         "PerPkg": "1",
-        "UMask": "0x4",
+        "PublicDescription": "Counts the number of entries successfully in=
serted into the TOR that match  qualifications specified by the subevent.  =
There are a number of subevent 'filters' but only a subset of the subevent =
combinations are valid.  Subevents that require an opcode or NID match requ=
ire the Cn_MSR_PMON_BOX_FILTER.{opc, nid} field to be set.  If, for example=
, one wanted to count DRD Local Misses, one should select MISS_OPC_MATCH an=
d set Cn_MSR_PMON_BOX_FILTER.opc  to DRD (0x182).; Miss transactions insert=
ed into the TOR that are satisifed by remote caches or remote memory.",
+        "UMask": "0x8a",
         "Unit": "CBO"
     },
     {
-        "BriefDescription": "TOR Inserts; All",
-        "Counter": "0,1,2,3",
+        "BriefDescription": "TOR Inserts; Misses to Remote Memory - Opcode=
 Matched",
         "EventCode": "0x35",
-        "EventName": "UNC_C_TOR_INSERTS.ALL",
+        "EventName": "UNC_C_TOR_INSERTS.MISS_REMOTE_OPCODE",
         "PerPkg": "1",
-        "UMask": "0x8",
+        "PublicDescription": "Counts the number of entries successfully in=
serted into the TOR that match  qualifications specified by the subevent.  =
There are a number of subevent 'filters' but only a subset of the subevent =
combinations are valid.  Subevents that require an opcode or NID match requ=
ire the Cn_MSR_PMON_BOX_FILTER.{opc, nid} field to be set.  If, for example=
, one wanted to count DRD Local Misses, one should select MISS_OPC_MATCH an=
d set Cn_MSR_PMON_BOX_FILTER.opc  to DRD (0x182).; Miss transactions, satis=
ifed by an opcode,  inserted into the TOR that are satisifed by remote cach=
es or remote memory.",
+        "UMask": "0x83",
         "Unit": "CBO"
     },
     {
-        "BriefDescription": "TOR Inserts; Writebacks",
-        "Counter": "0,1,2,3",
+        "BriefDescription": "TOR Inserts; NID Matched",
         "EventCode": "0x35",
-        "EventName": "UNC_C_TOR_INSERTS.WB",
+        "EventName": "UNC_C_TOR_INSERTS.NID_ALL",
         "PerPkg": "1",
-        "UMask": "0x10",
+        "PublicDescription": "Counts the number of entries successfully in=
serted into the TOR that match  qualifications specified by the subevent.  =
There are a number of subevent 'filters' but only a subset of the subevent =
combinations are valid.  Subevents that require an opcode or NID match requ=
ire the Cn_MSR_PMON_BOX_FILTER.{opc, nid} field to be set.  If, for example=
, one wanted to count DRD Local Misses, one should select MISS_OPC_MATCH an=
d set Cn_MSR_PMON_BOX_FILTER.opc  to DRD (0x182).; All NID matched (matches=
 an RTID destination) transactions inserted into the TOR.  The NID is progr=
ammed in Cn_MSR_PMON_BOX_FILTER.nid.  In conjunction with STATE =3D I, it i=
s possible to monitor misses to specific NIDs in the system.",
+        "UMask": "0x48",
         "Unit": "CBO"
     },
     {
-        "BriefDescription": "TOR Inserts; Miss Opcode Match",
-        "Counter": "0,1,2,3",
+        "BriefDescription": "TOR Inserts; NID Matched Evictions",
         "EventCode": "0x35",
-        "EventName": "UNC_C_TOR_INSERTS.MISS_OPCODE",
+        "EventName": "UNC_C_TOR_INSERTS.NID_EVICTION",
         "PerPkg": "1",
-        "UMask": "0x3",
+        "PublicDescription": "Counts the number of entries successfully in=
serted into the TOR that match  qualifications specified by the subevent.  =
There are a number of subevent 'filters' but only a subset of the subevent =
combinations are valid.  Subevents that require an opcode or NID match requ=
ire the Cn_MSR_PMON_BOX_FILTER.{opc, nid} field to be set.  If, for example=
, one wanted to count DRD Local Misses, one should select MISS_OPC_MATCH an=
d set Cn_MSR_PMON_BOX_FILTER.opc  to DRD (0x182).; NID matched eviction tra=
nsactions inserted into the TOR.",
+        "UMask": "0x44",
         "Unit": "CBO"
     },
     {
-        "BriefDescription": "LLC misses - demand and prefetch data reads -=
 excludes LLC prefetches. Derived from unc_c_tor_inserts.miss_opcode",
-        "Counter": "0,1,2,3",
+        "BriefDescription": "TOR Inserts; NID Matched Miss All",
         "EventCode": "0x35",
-        "EventName": "LLC_MISSES.DATA_READ",
-        "Filter": "filter_opc=3D0x182",
+        "EventName": "UNC_C_TOR_INSERTS.NID_MISS_ALL",
         "PerPkg": "1",
-        "ScaleUnit": "64Bytes",
-        "UMask": "0x3",
+        "PublicDescription": "Counts the number of entries successfully in=
serted into the TOR that match  qualifications specified by the subevent.  =
There are a number of subevent 'filters' but only a subset of the subevent =
combinations are valid.  Subevents that require an opcode or NID match requ=
ire the Cn_MSR_PMON_BOX_FILTER.{opc, nid} field to be set.  If, for example=
, one wanted to count DRD Local Misses, one should select MISS_OPC_MATCH an=
d set Cn_MSR_PMON_BOX_FILTER.opc  to DRD (0x182).; All NID matched miss req=
uests that were inserted into the TOR.",
+        "UMask": "0x4a",
         "Unit": "CBO"
     },
     {
-        "BriefDescription": "LLC misses - Uncacheable reads (from cpu) . D=
erived from unc_c_tor_inserts.miss_opcode",
-        "Counter": "0,1,2,3",
+        "BriefDescription": "TOR Inserts; NID and Opcode Matched Miss",
         "EventCode": "0x35",
-        "EventName": "LLC_MISSES.UNCACHEABLE",
-        "Filter": "filter_opc=3D0x187",
+        "EventName": "UNC_C_TOR_INSERTS.NID_MISS_OPCODE",
         "PerPkg": "1",
-        "ScaleUnit": "64Bytes",
-        "UMask": "0x3",
-        "Unit": "CBO"
-    },
-    {
-        "BriefDescription": "MMIO reads. Derived from unc_c_tor_inserts.mi=
ss_opcode",
-        "Counter": "0,1,2,3",
-        "EventCode": "0x35",
-        "EventName": "LLC_MISSES.MMIO_READ",
-        "Filter": "filter_opc=3D0x187,filter_nc=3D1",
-        "PerPkg": "1",
-        "ScaleUnit": "64Bytes",
-        "UMask": "0x3",
-        "Unit": "CBO"
-    },
-    {
-        "BriefDescription": "MMIO writes. Derived from unc_c_tor_inserts.m=
iss_opcode",
-        "Counter": "0,1,2,3",
-        "EventCode": "0x35",
-        "EventName": "LLC_MISSES.MMIO_WRITE",
-        "Filter": "filter_opc=3D0x18f,filter_nc=3D1",
-        "PerPkg": "1",
-        "ScaleUnit": "64Bytes",
-        "UMask": "0x3",
-        "Unit": "CBO"
-    },
-    {
-        "BriefDescription": "LLC prefetch misses for RFO. Derived from unc=
_c_tor_inserts.miss_opcode",
-        "Counter": "0,1,2,3",
-        "EventCode": "0x35",
-        "EventName": "LLC_MISSES.RFO_LLC_PREFETCH",
-        "Filter": "filter_opc=3D0x190",
-        "PerPkg": "1",
-        "ScaleUnit": "64Bytes",
-        "UMask": "0x3",
-        "Unit": "CBO"
-    },
-    {
-        "BriefDescription": "LLC prefetch misses for code reads. Derived f=
rom unc_c_tor_inserts.miss_opcode",
-        "Counter": "0,1,2,3",
-        "EventCode": "0x35",
-        "EventName": "LLC_MISSES.CODE_LLC_PREFETCH",
-        "Filter": "filter_opc=3D0x191",
-        "PerPkg": "1",
-        "ScaleUnit": "64Bytes",
-        "UMask": "0x3",
-        "Unit": "CBO"
-    },
-    {
-        "BriefDescription": "LLC prefetch misses for data reads. Derived f=
rom unc_c_tor_inserts.miss_opcode",
-        "Counter": "0,1,2,3",
-        "EventCode": "0x35",
-        "EventName": "LLC_MISSES.DATA_LLC_PREFETCH",
-        "Filter": "filter_opc=3D0x192",
-        "PerPkg": "1",
-        "ScaleUnit": "64Bytes",
-        "UMask": "0x3",
-        "Unit": "CBO"
-    },
-    {
-        "BriefDescription": "LLC misses for PCIe read current. Derived fro=
m unc_c_tor_inserts.miss_opcode",
-        "Counter": "0,1,2,3",
-        "EventCode": "0x35",
-        "EventName": "LLC_MISSES.PCIE_READ",
-        "Filter": "filter_opc=3D0x19e",
-        "PerPkg": "1",
-        "ScaleUnit": "64Bytes",
-        "UMask": "0x3",
-        "Unit": "CBO"
-    },
-    {
-        "BriefDescription": "ItoM write misses (as part of fast string mem=
cpy stores) + PCIe full line writes. Derived from unc_c_tor_inserts.miss_op=
code",
-        "Counter": "0,1,2,3",
-        "EventCode": "0x35",
-        "EventName": "LLC_MISSES.PCIE_WRITE",
-        "Filter": "filter_opc=3D0x1c8",
-        "PerPkg": "1",
-        "ScaleUnit": "64Bytes",
-        "UMask": "0x3",
-        "Unit": "CBO"
-    },
-    {
-        "BriefDescription": "PCIe write misses (full cache line). Derived =
from unc_c_tor_inserts.miss_opcode",
-        "Counter": "0,1,2,3",
-        "EventCode": "0x35",
-        "EventName": "LLC_MISSES.PCIE_NON_SNOOP_WRITE",
-        "Filter": "filter_opc=3D0x1c8,filter_tid=3D0x3e",
-        "PerPkg": "1",
-        "ScaleUnit": "64Bytes",
-        "UMask": "0x3",
+        "PublicDescription": "Counts the number of entries successfully in=
serted into the TOR that match  qualifications specified by the subevent.  =
There are a number of subevent 'filters' but only a subset of the subevent =
combinations are valid.  Subevents that require an opcode or NID match requ=
ire the Cn_MSR_PMON_BOX_FILTER.{opc, nid} field to be set.  If, for example=
, one wanted to count DRD Local Misses, one should select MISS_OPC_MATCH an=
d set Cn_MSR_PMON_BOX_FILTER.opc  to DRD (0x182).; Miss transactions insert=
ed into the TOR that match a NID and an opcode.",
+        "UMask": "0x43",
         "Unit": "CBO"
     },
     {
         "BriefDescription": "TOR Inserts; NID and Opcode Matched",
-        "Counter": "0,1,2,3",
         "EventCode": "0x35",
         "EventName": "UNC_C_TOR_INSERTS.NID_OPCODE",
         "PerPkg": "1",
+        "PublicDescription": "Counts the number of entries successfully in=
serted into the TOR that match  qualifications specified by the subevent.  =
There are a number of subevent 'filters' but only a subset of the subevent =
combinations are valid.  Subevents that require an opcode or NID match requ=
ire the Cn_MSR_PMON_BOX_FILTER.{opc, nid} field to be set.  If, for example=
, one wanted to count DRD Local Misses, one should select MISS_OPC_MATCH an=
d set Cn_MSR_PMON_BOX_FILTER.opc  to DRD (0x182).; Transactions inserted in=
to the TOR that match a NID and an opcode.",
         "UMask": "0x41",
         "Unit": "CBO"
     },
-    {
-        "BriefDescription": "TOR Inserts; NID Matched Evictions",
-        "Counter": "0,1,2,3",
-        "EventCode": "0x35",
-        "EventName": "UNC_C_TOR_INSERTS.NID_EVICTION",
-        "PerPkg": "1",
-        "UMask": "0x44",
-        "Unit": "CBO"
-    },
-    {
-        "BriefDescription": "TOR Inserts; NID Matched",
-        "Counter": "0,1,2,3",
-        "EventCode": "0x35",
-        "EventName": "UNC_C_TOR_INSERTS.NID_ALL",
-        "PerPkg": "1",
-        "UMask": "0x48",
-        "Unit": "CBO"
-    },
     {
         "BriefDescription": "TOR Inserts; NID Matched Writebacks",
-        "Counter": "0,1,2,3",
         "EventCode": "0x35",
         "EventName": "UNC_C_TOR_INSERTS.NID_WB",
         "PerPkg": "1",
+        "PublicDescription": "Counts the number of entries successfully in=
serted into the TOR that match  qualifications specified by the subevent.  =
There are a number of subevent 'filters' but only a subset of the subevent =
combinations are valid.  Subevents that require an opcode or NID match requ=
ire the Cn_MSR_PMON_BOX_FILTER.{opc, nid} field to be set.  If, for example=
, one wanted to count DRD Local Misses, one should select MISS_OPC_MATCH an=
d set Cn_MSR_PMON_BOX_FILTER.opc  to DRD (0x182).; NID matched write transa=
ctions inserted into the TOR.",
         "UMask": "0x50",
         "Unit": "CBO"
     },
     {
-        "BriefDescription": "TOR Inserts; NID and Opcode Matched Miss",
-        "Counter": "0,1,2,3",
+        "BriefDescription": "TOR Inserts; Opcode Match",
         "EventCode": "0x35",
-        "EventName": "UNC_C_TOR_INSERTS.NID_MISS_OPCODE",
+        "EventName": "UNC_C_TOR_INSERTS.OPCODE",
         "PerPkg": "1",
-        "UMask": "0x43",
+        "PublicDescription": "Counts the number of entries successfully in=
serted into the TOR that match  qualifications specified by the subevent.  =
There are a number of subevent 'filters' but only a subset of the subevent =
combinations are valid.  Subevents that require an opcode or NID match requ=
ire the Cn_MSR_PMON_BOX_FILTER.{opc, nid} field to be set.  If, for example=
, one wanted to count DRD Local Misses, one should select MISS_OPC_MATCH an=
d set Cn_MSR_PMON_BOX_FILTER.opc  to DRD (0x182).; Transactions inserted in=
to the TOR that match an opcode (matched by Cn_MSR_PMON_BOX_FILTER.opc)",
+        "UMask": "0x1",
         "Unit": "CBO"
     },
     {
-        "BriefDescription": "TOR Inserts; NID Matched Miss All",
-        "Counter": "0,1,2,3",
+        "BriefDescription": "TOR Inserts; Remote Memory",
         "EventCode": "0x35",
-        "EventName": "UNC_C_TOR_INSERTS.NID_MISS_ALL",
+        "EventName": "UNC_C_TOR_INSERTS.REMOTE",
         "PerPkg": "1",
-        "UMask": "0x4A",
+        "PublicDescription": "Counts the number of entries successfully in=
serted into the TOR that match  qualifications specified by the subevent.  =
There are a number of subevent 'filters' but only a subset of the subevent =
combinations are valid.  Subevents that require an opcode or NID match requ=
ire the Cn_MSR_PMON_BOX_FILTER.{opc, nid} field to be set.  If, for example=
, one wanted to count DRD Local Misses, one should select MISS_OPC_MATCH an=
d set Cn_MSR_PMON_BOX_FILTER.opc  to DRD (0x182).; All transactions inserte=
d into the TOR that are satisifed by remote caches or remote memory.",
+        "UMask": "0x88",
         "Unit": "CBO"
     },
     {
-        "BriefDescription": "TOR Inserts; Misses to Local Memory",
-        "Counter": "0,1,2,3",
+        "BriefDescription": "TOR Inserts; Remote Memory - Opcode Matched",
         "EventCode": "0x35",
-        "EventName": "UNC_C_TOR_INSERTS.MISS_LOCAL",
+        "EventName": "UNC_C_TOR_INSERTS.REMOTE_OPCODE",
         "PerPkg": "1",
-        "UMask": "0x2A",
+        "PublicDescription": "Counts the number of entries successfully in=
serted into the TOR that match  qualifications specified by the subevent.  =
There are a number of subevent 'filters' but only a subset of the subevent =
combinations are valid.  Subevents that require an opcode or NID match requ=
ire the Cn_MSR_PMON_BOX_FILTER.{opc, nid} field to be set.  If, for example=
, one wanted to count DRD Local Misses, one should select MISS_OPC_MATCH an=
d set Cn_MSR_PMON_BOX_FILTER.opc  to DRD (0x182).; All transactions, satisi=
fed by an opcode,  inserted into the TOR that are satisifed by remote cache=
s or remote memory.",
+        "UMask": "0x81",
         "Unit": "CBO"
     },
     {
-        "BriefDescription": "TOR Inserts; Misses to Remote Memory",
-        "Counter": "0,1,2,3",
+        "BriefDescription": "TOR Inserts; Writebacks",
         "EventCode": "0x35",
-        "EventName": "UNC_C_TOR_INSERTS.MISS_REMOTE",
+        "EventName": "UNC_C_TOR_INSERTS.WB",
         "PerPkg": "1",
-        "UMask": "0x8A",
+        "PublicDescription": "Counts the number of entries successfully in=
serted into the TOR that match  qualifications specified by the subevent.  =
There are a number of subevent 'filters' but only a subset of the subevent =
combinations are valid.  Subevents that require an opcode or NID match requ=
ire the Cn_MSR_PMON_BOX_FILTER.{opc, nid} field to be set.  If, for example=
, one wanted to count DRD Local Misses, one should select MISS_OPC_MATCH an=
d set Cn_MSR_PMON_BOX_FILTER.opc  to DRD (0x182).; Write transactions inser=
ted into the TOR.   This does not include RFO, but actual operations that c=
ontain data being sent from the core.",
+        "UMask": "0x10",
         "Unit": "CBO"
     },
     {
-        "BriefDescription": "TOR Inserts; Local Memory",
-        "Counter": "0,1,2,3",
-        "EventCode": "0x35",
-        "EventName": "UNC_C_TOR_INSERTS.LOCAL",
+        "BriefDescription": "TOR Occupancy; Any",
+        "EventCode": "0x36",
+        "EventName": "UNC_C_TOR_OCCUPANCY.ALL",
         "PerPkg": "1",
-        "UMask": "0x28",
+        "PublicDescription": "For each cycle, this event accumulates the n=
umber of valid entries in the TOR that match qualifications specified by th=
e subevent.   There are a number of subevent 'filters' but only a subset of=
 the subevent combinations are valid.  Subevents that require an opcode or =
NID match require the Cn_MSR_PMON_BOX_FILTER.{opc, nid} field to be set.  I=
f, for example, one wanted to count DRD Local Misses, one should select MIS=
S_OPC_MATCH and set Cn_MSR_PMON_BOX_FILTER.opc to DRD (0x182); All valid TO=
R entries.  This includes requests that reside in the TOR for a short time,=
 such as LLC Hits that do not need to snoop cores or requests that get reje=
cted and have to be retried through one of the ingress queues.  The TOR is =
more commonly a bottleneck in skews with smaller core counts, where the rat=
io of RTIDs to TOR entries is larger.  Note that there are reserved TOR ent=
ries for various request types, so it is possible that a given request type=
 be blocked with an occupancy that is less than 20.  Also note that general=
ly requests will not be able to arbitrate into the TOR pipeline if there ar=
e no available TOR slots.",
+        "UMask": "0x8",
         "Unit": "CBO"
     },
     {
-        "BriefDescription": "TOR Inserts; Remote Memory",
-        "Counter": "0,1,2,3",
-        "EventCode": "0x35",
-        "EventName": "UNC_C_TOR_INSERTS.REMOTE",
+        "BriefDescription": "TOR Occupancy; Evictions",
+        "EventCode": "0x36",
+        "EventName": "UNC_C_TOR_OCCUPANCY.EVICTION",
         "PerPkg": "1",
-        "UMask": "0x88",
+        "PublicDescription": "For each cycle, this event accumulates the n=
umber of valid entries in the TOR that match qualifications specified by th=
e subevent.   There are a number of subevent 'filters' but only a subset of=
 the subevent combinations are valid.  Subevents that require an opcode or =
NID match require the Cn_MSR_PMON_BOX_FILTER.{opc, nid} field to be set.  I=
f, for example, one wanted to count DRD Local Misses, one should select MIS=
S_OPC_MATCH and set Cn_MSR_PMON_BOX_FILTER.opc to DRD (0x182); Number of ou=
tstanding eviction transactions in the TOR.  Evictions can be quick, such a=
s when the line is in the F, S, or E states and no core valid bits are set.=
  They can also be longer if either CV bits are set (so the cores need to b=
e snooped) and/or if there is a HitM (in which case it is necessary to writ=
e the request out to memory).",
+        "UMask": "0x4",
         "Unit": "CBO"
     },
     {
-        "BriefDescription": "TOR Inserts; Misses to Local Memory - Opcode =
Matched",
-        "Counter": "0,1,2,3",
-        "EventCode": "0x35",
-        "EventName": "UNC_C_TOR_INSERTS.MISS_LOCAL_OPCODE",
+        "BriefDescription": "Occupancy counter for LLC data reads (demand =
and L2 prefetch). Derived from unc_c_tor_occupancy.miss_opcode",
+        "EventCode": "0x36",
+        "EventName": "UNC_C_TOR_OCCUPANCY.LLC_DATA_READ",
+        "Filter": "filter_opc=3D0x182",
         "PerPkg": "1",
-        "UMask": "0x23",
+        "PublicDescription": "For each cycle, this event accumulates the n=
umber of valid entries in the TOR that match qualifications specified by th=
e subevent.   There are a number of subevent 'filters' but only a subset of=
 the subevent combinations are valid.  Subevents that require an opcode or =
NID match require the Cn_MSR_PMON_BOX_FILTER.{opc, nid} field to be set.  I=
f, for example, one wanted to count DRD Local Misses, one should select MIS=
S_OPC_MATCH and set Cn_MSR_PMON_BOX_FILTER.opc to DRD (0x182); TOR entries =
for miss transactions that match an opcode. This generally means that the r=
equest was sent to memory or MMIO.",
+        "UMask": "0x3",
         "Unit": "CBO"
     },
     {
-        "BriefDescription": "TOR Inserts; Misses to Remote Memory - Opcode=
 Matched",
-        "Counter": "0,1,2,3",
-        "EventCode": "0x35",
-        "EventName": "UNC_C_TOR_INSERTS.MISS_REMOTE_OPCODE",
+        "BriefDescription": "TOR Occupancy",
+        "EventCode": "0x36",
+        "EventName": "UNC_C_TOR_OCCUPANCY.LOCAL",
         "PerPkg": "1",
-        "UMask": "0x83",
+        "PublicDescription": "For each cycle, this event accumulates the n=
umber of valid entries in the TOR that match qualifications specified by th=
e subevent.   There are a number of subevent 'filters' but only a subset of=
 the subevent combinations are valid.  Subevents that require an opcode or =
NID match require the Cn_MSR_PMON_BOX_FILTER.{opc, nid} field to be set.  I=
f, for example, one wanted to count DRD Local Misses, one should select MIS=
S_OPC_MATCH and set Cn_MSR_PMON_BOX_FILTER.opc to DRD (0x182)",
+        "UMask": "0x28",
         "Unit": "CBO"
     },
     {
-        "BriefDescription": "TOR Inserts; Local Memory - Opcode Matched",
-        "Counter": "0,1,2,3",
-        "EventCode": "0x35",
-        "EventName": "UNC_C_TOR_INSERTS.LOCAL_OPCODE",
+        "BriefDescription": "TOR Occupancy; Local Memory - Opcode Matched"=
,
+        "EventCode": "0x36",
+        "EventName": "UNC_C_TOR_OCCUPANCY.LOCAL_OPCODE",
         "PerPkg": "1",
+        "PublicDescription": "For each cycle, this event accumulates the n=
umber of valid entries in the TOR that match qualifications specified by th=
e subevent.   There are a number of subevent 'filters' but only a subset of=
 the subevent combinations are valid.  Subevents that require an opcode or =
NID match require the Cn_MSR_PMON_BOX_FILTER.{opc, nid} field to be set.  I=
f, for example, one wanted to count DRD Local Misses, one should select MIS=
S_OPC_MATCH and set Cn_MSR_PMON_BOX_FILTER.opc to DRD (0x182); Number of ou=
tstanding  transactions, satisifed by an opcode,  in the TOR that are satis=
ifed by locally HOMed memory.",
         "UMask": "0x21",
         "Unit": "CBO"
     },
     {
-        "BriefDescription": "TOR Inserts; Remote Memory - Opcode Matched",
-        "Counter": "0,1,2,3",
-        "EventCode": "0x35",
-        "EventName": "UNC_C_TOR_INSERTS.REMOTE_OPCODE",
-        "PerPkg": "1",
-        "UMask": "0x81",
-        "Unit": "CBO"
-    },
-    {
-        "BriefDescription": "TOR Occupancy; Opcode Match",
+        "BriefDescription": "TOR Occupancy; Miss All",
         "EventCode": "0x36",
-        "EventName": "UNC_C_TOR_OCCUPANCY.OPCODE",
+        "EventName": "UNC_C_TOR_OCCUPANCY.MISS_ALL",
         "PerPkg": "1",
-        "UMask": "0x1",
+        "PublicDescription": "For each cycle, this event accumulates the n=
umber of valid entries in the TOR that match qualifications specified by th=
e subevent.   There are a number of subevent 'filters' but only a subset of=
 the subevent combinations are valid.  Subevents that require an opcode or =
NID match require the Cn_MSR_PMON_BOX_FILTER.{opc, nid} field to be set.  I=
f, for example, one wanted to count DRD Local Misses, one should select MIS=
S_OPC_MATCH and set Cn_MSR_PMON_BOX_FILTER.opc to DRD (0x182); Number of ou=
tstanding miss requests in the TOR.  'Miss' means the allocation requires a=
n RTID.  This generally means that the request was sent to memory or MMIO."=
,
+        "UMask": "0xa",
         "Unit": "CBO"
     },
     {
-        "BriefDescription": "TOR Occupancy; Evictions",
+        "BriefDescription": "TOR Occupancy",
         "EventCode": "0x36",
-        "EventName": "UNC_C_TOR_OCCUPANCY.EVICTION",
+        "EventName": "UNC_C_TOR_OCCUPANCY.MISS_LOCAL",
         "PerPkg": "1",
-        "UMask": "0x4",
+        "PublicDescription": "For each cycle, this event accumulates the n=
umber of valid entries in the TOR that match qualifications specified by th=
e subevent.   There are a number of subevent 'filters' but only a subset of=
 the subevent combinations are valid.  Subevents that require an opcode or =
NID match require the Cn_MSR_PMON_BOX_FILTER.{opc, nid} field to be set.  I=
f, for example, one wanted to count DRD Local Misses, one should select MIS=
S_OPC_MATCH and set Cn_MSR_PMON_BOX_FILTER.opc to DRD (0x182)",
+        "UMask": "0x2a",
         "Unit": "CBO"
     },
     {
-        "BriefDescription": "TOR Occupancy; Any",
+        "BriefDescription": "TOR Occupancy; Misses to Local Memory - Opcod=
e Matched",
         "EventCode": "0x36",
-        "EventName": "UNC_C_TOR_OCCUPANCY.ALL",
+        "EventName": "UNC_C_TOR_OCCUPANCY.MISS_LOCAL_OPCODE",
         "PerPkg": "1",
-        "UMask": "0x8",
+        "PublicDescription": "For each cycle, this event accumulates the n=
umber of valid entries in the TOR that match qualifications specified by th=
e subevent.   There are a number of subevent 'filters' but only a subset of=
 the subevent combinations are valid.  Subevents that require an opcode or =
NID match require the Cn_MSR_PMON_BOX_FILTER.{opc, nid} field to be set.  I=
f, for example, one wanted to count DRD Local Misses, one should select MIS=
S_OPC_MATCH and set Cn_MSR_PMON_BOX_FILTER.opc to DRD (0x182); Number of ou=
tstanding Miss transactions, satisifed by an opcode, in the TOR that are sa=
tisifed by locally HOMed memory.",
+        "UMask": "0x23",
         "Unit": "CBO"
     },
     {
-        "BriefDescription": "Occupancy counter for LLC data reads (demand =
and L2 prefetch). Derived from unc_c_tor_occupancy.miss_opcode",
+        "BriefDescription": "TOR Occupancy; Miss Opcode Match",
         "EventCode": "0x36",
-        "EventName": "UNC_C_TOR_OCCUPANCY.LLC_DATA_READ",
-        "Filter": "filter_opc=3D0x182",
+        "EventName": "UNC_C_TOR_OCCUPANCY.MISS_OPCODE",
         "PerPkg": "1",
+        "PublicDescription": "For each cycle, this event accumulates the n=
umber of valid entries in the TOR that match qualifications specified by th=
e subevent.   There are a number of subevent 'filters' but only a subset of=
 the subevent combinations are valid.  Subevents that require an opcode or =
NID match require the Cn_MSR_PMON_BOX_FILTER.{opc, nid} field to be set.  I=
f, for example, one wanted to count DRD Local Misses, one should select MIS=
S_OPC_MATCH and set Cn_MSR_PMON_BOX_FILTER.opc to DRD (0x182); TOR entries =
for miss transactions that match an opcode. This generally means that the r=
equest was sent to memory or MMIO.",
         "UMask": "0x3",
         "Unit": "CBO"
     },
     {
-        "BriefDescription": "Occupancy counter for LLC data reads (demand =
and L2 prefetch)",
+        "BriefDescription": "TOR Occupancy",
         "EventCode": "0x36",
-        "EventName": "UNC_C_TOR_OCCUPANCY.MISS_OPCODE",
-        "Filter": "filter_opc=3D0x182",
+        "EventName": "UNC_C_TOR_OCCUPANCY.MISS_REMOTE",
         "PerPkg": "1",
-        "UMask": "0x3",
+        "PublicDescription": "For each cycle, this event accumulates the n=
umber of valid entries in the TOR that match qualifications specified by th=
e subevent.   There are a number of subevent 'filters' but only a subset of=
 the subevent combinations are valid.  Subevents that require an opcode or =
NID match require the Cn_MSR_PMON_BOX_FILTER.{opc, nid} field to be set.  I=
f, for example, one wanted to count DRD Local Misses, one should select MIS=
S_OPC_MATCH and set Cn_MSR_PMON_BOX_FILTER.opc to DRD (0x182)",
+        "UMask": "0x8a",
         "Unit": "CBO"
     },
     {
-        "BriefDescription": "TOR Occupancy; Miss All",
+        "BriefDescription": "TOR Occupancy; Misses to Remote Memory - Opco=
de Matched",
         "EventCode": "0x36",
-        "EventName": "UNC_C_TOR_OCCUPANCY.MISS_ALL",
+        "EventName": "UNC_C_TOR_OCCUPANCY.MISS_REMOTE_OPCODE",
         "PerPkg": "1",
-        "UMask": "0xA",
+        "PublicDescription": "For each cycle, this event accumulates the n=
umber of valid entries in the TOR that match qualifications specified by th=
e subevent.   There are a number of subevent 'filters' but only a subset of=
 the subevent combinations are valid.  Subevents that require an opcode or =
NID match require the Cn_MSR_PMON_BOX_FILTER.{opc, nid} field to be set.  I=
f, for example, one wanted to count DRD Local Misses, one should select MIS=
S_OPC_MATCH and set Cn_MSR_PMON_BOX_FILTER.opc to DRD (0x182); Number of ou=
tstanding Miss transactions, satisifed by an opcode, in the TOR that are sa=
tisifed by remote caches or remote memory.",
+        "UMask": "0x83",
         "Unit": "CBO"
     },
     {
-        "BriefDescription": "TOR Occupancy; NID and Opcode Matched",
+        "BriefDescription": "TOR Occupancy; NID Matched",
         "EventCode": "0x36",
-        "EventName": "UNC_C_TOR_OCCUPANCY.NID_OPCODE",
+        "EventName": "UNC_C_TOR_OCCUPANCY.NID_ALL",
         "PerPkg": "1",
-        "UMask": "0x41",
+        "PublicDescription": "For each cycle, this event accumulates the n=
umber of valid entries in the TOR that match qualifications specified by th=
e subevent.   There are a number of subevent 'filters' but only a subset of=
 the subevent combinations are valid.  Subevents that require an opcode or =
NID match require the Cn_MSR_PMON_BOX_FILTER.{opc, nid} field to be set.  I=
f, for example, one wanted to count DRD Local Misses, one should select MIS=
S_OPC_MATCH and set Cn_MSR_PMON_BOX_FILTER.opc to DRD (0x182); Number of NI=
D matched outstanding requests in the TOR.  The NID is programmed in Cn_MSR=
_PMON_BOX_FILTER.nid.In conjunction with STATE =3D I, it is possible to mon=
itor misses to specific NIDs in the system.",
+        "UMask": "0x48",
         "Unit": "CBO"
     },
     {
@@ -1254,15 +1437,17 @@
         "EventCode": "0x36",
         "EventName": "UNC_C_TOR_OCCUPANCY.NID_EVICTION",
         "PerPkg": "1",
+        "PublicDescription": "For each cycle, this event accumulates the n=
umber of valid entries in the TOR that match qualifications specified by th=
e subevent.   There are a number of subevent 'filters' but only a subset of=
 the subevent combinations are valid.  Subevents that require an opcode or =
NID match require the Cn_MSR_PMON_BOX_FILTER.{opc, nid} field to be set.  I=
f, for example, one wanted to count DRD Local Misses, one should select MIS=
S_OPC_MATCH and set Cn_MSR_PMON_BOX_FILTER.opc to DRD (0x182); Number of ou=
tstanding NID matched eviction transactions in the TOR .",
         "UMask": "0x44",
         "Unit": "CBO"
     },
     {
         "BriefDescription": "TOR Occupancy; NID Matched",
         "EventCode": "0x36",
-        "EventName": "UNC_C_TOR_OCCUPANCY.NID_ALL",
+        "EventName": "UNC_C_TOR_OCCUPANCY.NID_MISS_ALL",
         "PerPkg": "1",
-        "UMask": "0x48",
+        "PublicDescription": "For each cycle, this event accumulates the n=
umber of valid entries in the TOR that match qualifications specified by th=
e subevent.   There are a number of subevent 'filters' but only a subset of=
 the subevent combinations are valid.  Subevents that require an opcode or =
NID match require the Cn_MSR_PMON_BOX_FILTER.{opc, nid} field to be set.  I=
f, for example, one wanted to count DRD Local Misses, one should select MIS=
S_OPC_MATCH and set Cn_MSR_PMON_BOX_FILTER.opc to DRD (0x182); Number of ou=
tstanding Miss requests in the TOR that match a NID.",
+        "UMask": "0x4a",
         "Unit": "CBO"
     },
     {
@@ -1270,39 +1455,35 @@
         "EventCode": "0x36",
         "EventName": "UNC_C_TOR_OCCUPANCY.NID_MISS_OPCODE",
         "PerPkg": "1",
+        "PublicDescription": "For each cycle, this event accumulates the n=
umber of valid entries in the TOR that match qualifications specified by th=
e subevent.   There are a number of subevent 'filters' but only a subset of=
 the subevent combinations are valid.  Subevents that require an opcode or =
NID match require the Cn_MSR_PMON_BOX_FILTER.{opc, nid} field to be set.  I=
f, for example, one wanted to count DRD Local Misses, one should select MIS=
S_OPC_MATCH and set Cn_MSR_PMON_BOX_FILTER.opc to DRD (0x182); Number of ou=
tstanding Miss requests in the TOR that match a NID and an opcode.",
         "UMask": "0x43",
         "Unit": "CBO"
     },
     {
-        "BriefDescription": "TOR Occupancy; NID Matched",
-        "EventCode": "0x36",
-        "EventName": "UNC_C_TOR_OCCUPANCY.NID_MISS_ALL",
-        "PerPkg": "1",
-        "UMask": "0x4A",
-        "Unit": "CBO"
-    },
-    {
-        "BriefDescription": "TOR Occupancy",
+        "BriefDescription": "TOR Occupancy; NID and Opcode Matched",
         "EventCode": "0x36",
-        "EventName": "UNC_C_TOR_OCCUPANCY.MISS_LOCAL",
+        "EventName": "UNC_C_TOR_OCCUPANCY.NID_OPCODE",
         "PerPkg": "1",
-        "UMask": "0x2A",
+        "PublicDescription": "For each cycle, this event accumulates the n=
umber of valid entries in the TOR that match qualifications specified by th=
e subevent.   There are a number of subevent 'filters' but only a subset of=
 the subevent combinations are valid.  Subevents that require an opcode or =
NID match require the Cn_MSR_PMON_BOX_FILTER.{opc, nid} field to be set.  I=
f, for example, one wanted to count DRD Local Misses, one should select MIS=
S_OPC_MATCH and set Cn_MSR_PMON_BOX_FILTER.opc to DRD (0x182); TOR entries =
that match a NID and an opcode.",
+        "UMask": "0x41",
         "Unit": "CBO"
     },
     {
-        "BriefDescription": "TOR Occupancy",
+        "BriefDescription": "TOR Occupancy; NID Matched Writebacks",
         "EventCode": "0x36",
-        "EventName": "UNC_C_TOR_OCCUPANCY.MISS_REMOTE",
+        "EventName": "UNC_C_TOR_OCCUPANCY.NID_WB",
         "PerPkg": "1",
-        "UMask": "0x8A",
+        "PublicDescription": "For each cycle, this event accumulates the n=
umber of valid entries in the TOR that match qualifications specified by th=
e subevent.   There are a number of subevent 'filters' but only a subset of=
 the subevent combinations are valid.  Subevents that require an opcode or =
NID match require the Cn_MSR_PMON_BOX_FILTER.{opc, nid} field to be set.  I=
f, for example, one wanted to count DRD Local Misses, one should select MIS=
S_OPC_MATCH and set Cn_MSR_PMON_BOX_FILTER.opc to DRD (0x182); NID matched =
write transactions int the TOR.",
+        "UMask": "0x50",
         "Unit": "CBO"
     },
     {
-        "BriefDescription": "TOR Occupancy",
+        "BriefDescription": "TOR Occupancy; Opcode Match",
         "EventCode": "0x36",
-        "EventName": "UNC_C_TOR_OCCUPANCY.LOCAL",
+        "EventName": "UNC_C_TOR_OCCUPANCY.OPCODE",
         "PerPkg": "1",
-        "UMask": "0x28",
+        "PublicDescription": "For each cycle, this event accumulates the n=
umber of valid entries in the TOR that match qualifications specified by th=
e subevent.   There are a number of subevent 'filters' but only a subset of=
 the subevent combinations are valid.  Subevents that require an opcode or =
NID match require the Cn_MSR_PMON_BOX_FILTER.{opc, nid} field to be set.  I=
f, for example, one wanted to count DRD Local Misses, one should select MIS=
S_OPC_MATCH and set Cn_MSR_PMON_BOX_FILTER.opc to DRD (0x182); TOR entries =
that match an opcode (matched by Cn_MSR_PMON_BOX_FILTER.opc).",
+        "UMask": "0x1",
         "Unit": "CBO"
     },
     {
@@ -1310,38 +1491,16 @@
         "EventCode": "0x36",
         "EventName": "UNC_C_TOR_OCCUPANCY.REMOTE",
         "PerPkg": "1",
+        "PublicDescription": "For each cycle, this event accumulates the n=
umber of valid entries in the TOR that match qualifications specified by th=
e subevent.   There are a number of subevent 'filters' but only a subset of=
 the subevent combinations are valid.  Subevents that require an opcode or =
NID match require the Cn_MSR_PMON_BOX_FILTER.{opc, nid} field to be set.  I=
f, for example, one wanted to count DRD Local Misses, one should select MIS=
S_OPC_MATCH and set Cn_MSR_PMON_BOX_FILTER.opc to DRD (0x182)",
         "UMask": "0x88",
         "Unit": "CBO"
     },
-    {
-        "BriefDescription": "TOR Occupancy; Misses to Local Memory - Opcod=
e Matched",
-        "EventCode": "0x36",
-        "EventName": "UNC_C_TOR_OCCUPANCY.MISS_LOCAL_OPCODE",
-        "PerPkg": "1",
-        "UMask": "0x23",
-        "Unit": "CBO"
-    },
-    {
-        "BriefDescription": "TOR Occupancy; Misses to Remote Memory - Opco=
de Matched",
-        "EventCode": "0x36",
-        "EventName": "UNC_C_TOR_OCCUPANCY.MISS_REMOTE_OPCODE",
-        "PerPkg": "1",
-        "UMask": "0x83",
-        "Unit": "CBO"
-    },
-    {
-        "BriefDescription": "TOR Occupancy; Local Memory - Opcode Matched"=
,
-        "EventCode": "0x36",
-        "EventName": "UNC_C_TOR_OCCUPANCY.LOCAL_OPCODE",
-        "PerPkg": "1",
-        "UMask": "0x21",
-        "Unit": "CBO"
-    },
     {
         "BriefDescription": "TOR Occupancy; Remote Memory - Opcode Matched=
",
         "EventCode": "0x36",
         "EventName": "UNC_C_TOR_OCCUPANCY.REMOTE_OPCODE",
         "PerPkg": "1",
+        "PublicDescription": "For each cycle, this event accumulates the n=
umber of valid entries in the TOR that match qualifications specified by th=
e subevent.   There are a number of subevent 'filters' but only a subset of=
 the subevent combinations are valid.  Subevents that require an opcode or =
NID match require the Cn_MSR_PMON_BOX_FILTER.{opc, nid} field to be set.  I=
f, for example, one wanted to count DRD Local Misses, one should select MIS=
S_OPC_MATCH and set Cn_MSR_PMON_BOX_FILTER.opc to DRD (0x182); Number of ou=
tstanding  transactions, satisifed by an opcode,  in the TOR that are satis=
ifed by remote caches or remote memory.",
         "UMask": "0x81",
         "Unit": "CBO"
     },
@@ -1350,2297 +1509,2110 @@
         "EventCode": "0x36",
         "EventName": "UNC_C_TOR_OCCUPANCY.WB",
         "PerPkg": "1",
+        "PublicDescription": "For each cycle, this event accumulates the n=
umber of valid entries in the TOR that match qualifications specified by th=
e subevent.   There are a number of subevent 'filters' but only a subset of=
 the subevent combinations are valid.  Subevents that require an opcode or =
NID match require the Cn_MSR_PMON_BOX_FILTER.{opc, nid} field to be set.  I=
f, for example, one wanted to count DRD Local Misses, one should select MIS=
S_OPC_MATCH and set Cn_MSR_PMON_BOX_FILTER.opc to DRD (0x182); Write transa=
ctions in the TOR.   This does not include RFO, but actual operations that =
contain data being sent from the core.",
         "UMask": "0x10",
         "Unit": "CBO"
     },
-    {
-        "BriefDescription": "TOR Occupancy; NID Matched Writebacks",
-        "EventCode": "0x36",
-        "EventName": "UNC_C_TOR_OCCUPANCY.NID_WB",
-        "PerPkg": "1",
-        "UMask": "0x50",
-        "Unit": "CBO"
-    },
     {
         "BriefDescription": "Onto AD Ring",
-        "Counter": "0,1,2,3",
         "EventCode": "0x4",
         "EventName": "UNC_C_TxR_ADS_USED.AD",
         "PerPkg": "1",
+        "PublicDescription": "UNC_C_TxR_ADS_USED.AD",
         "UMask": "0x1",
         "Unit": "CBO"
     },
     {
         "BriefDescription": "Onto AK Ring",
-        "Counter": "0,1,2,3",
         "EventCode": "0x4",
         "EventName": "UNC_C_TxR_ADS_USED.AK",
         "PerPkg": "1",
+        "PublicDescription": "UNC_C_TxR_ADS_USED.AK",
         "UMask": "0x2",
         "Unit": "CBO"
     },
     {
         "BriefDescription": "Onto BL Ring",
-        "Counter": "0,1,2,3",
         "EventCode": "0x4",
         "EventName": "UNC_C_TxR_ADS_USED.BL",
         "PerPkg": "1",
+        "PublicDescription": "UNC_C_TxR_ADS_USED.BL",
         "UMask": "0x4",
         "Unit": "CBO"
     },
     {
         "BriefDescription": "Egress Allocations; AD - Cachebo",
-        "Counter": "0,1,2,3",
         "EventCode": "0x2",
         "EventName": "UNC_C_TxR_INSERTS.AD_CACHE",
         "PerPkg": "1",
+        "PublicDescription": "Number of allocations into the Cbo Egress.  =
The Egress is used to queue up requests destined for the ring.; Ring transa=
ctions from the Cachebo destined for the AD ring.  Some example include out=
bound requests, snoop requests, and snoop responses.",
         "UMask": "0x1",
         "Unit": "CBO"
     },
-    {
-        "BriefDescription": "Egress Allocations; AK - Cachebo",
-        "Counter": "0,1,2,3",
-        "EventCode": "0x2",
-        "EventName": "UNC_C_TxR_INSERTS.AK_CACHE",
-        "PerPkg": "1",
-        "UMask": "0x2",
-        "Unit": "CBO"
-    },
-    {
-        "BriefDescription": "Egress Allocations; BL - Cacheno",
-        "Counter": "0,1,2,3",
-        "EventCode": "0x2",
-        "EventName": "UNC_C_TxR_INSERTS.BL_CACHE",
-        "PerPkg": "1",
-        "UMask": "0x4",
-        "Unit": "CBO"
-    },
-    {
-        "BriefDescription": "Egress Allocations; IV - Cachebo",
-        "Counter": "0,1,2,3",
-        "EventCode": "0x2",
-        "EventName": "UNC_C_TxR_INSERTS.IV_CACHE",
-        "PerPkg": "1",
-        "UMask": "0x8",
-        "Unit": "CBO"
-    },
     {
         "BriefDescription": "Egress Allocations; AD - Corebo",
-        "Counter": "0,1,2,3",
         "EventCode": "0x2",
         "EventName": "UNC_C_TxR_INSERTS.AD_CORE",
         "PerPkg": "1",
+        "PublicDescription": "Number of allocations into the Cbo Egress.  =
The Egress is used to queue up requests destined for the ring.; Ring transa=
ctions from the Corebo destined for the AD ring.  This is commonly used for=
 outbound requests.",
         "UMask": "0x10",
         "Unit": "CBO"
     },
     {
-        "BriefDescription": "Egress Allocations; AK - Corebo",
-        "Counter": "0,1,2,3",
-        "EventCode": "0x2",
-        "EventName": "UNC_C_TxR_INSERTS.AK_CORE",
-        "PerPkg": "1",
-        "UMask": "0x20",
-        "Unit": "CBO"
-    },
-    {
-        "BriefDescription": "Egress Allocations; BL - Corebo",
-        "Counter": "0,1,2,3",
+        "BriefDescription": "Egress Allocations; AK - Cachebo",
         "EventCode": "0x2",
-        "EventName": "UNC_C_TxR_INSERTS.BL_CORE",
-        "PerPkg": "1",
-        "UMask": "0x40",
-        "Unit": "CBO"
-    },
-    {
-        "BriefDescription": "LRU Queue; LRU Age 0",
-        "Counter": "0,1,2,3",
-        "EventCode": "0x3C",
-        "EventName": "UNC_C_QLRU.AGE0",
-        "PerPkg": "1",
-        "UMask": "0x1",
-        "Unit": "CBO"
-    },
-    {
-        "BriefDescription": "LRU Queue; LRU Age 1",
-        "Counter": "0,1,2,3",
-        "EventCode": "0x3C",
-        "EventName": "UNC_C_QLRU.AGE1",
+        "EventName": "UNC_C_TxR_INSERTS.AK_CACHE",
         "PerPkg": "1",
+        "PublicDescription": "Number of allocations into the Cbo Egress.  =
The Egress is used to queue up requests destined for the ring.; Ring transa=
ctions from the Cachebo destined for the AK ring.  This is commonly used fo=
r credit returns and GO responses.",
         "UMask": "0x2",
         "Unit": "CBO"
     },
     {
-        "BriefDescription": "LRU Queue; LRU Age 2",
-        "Counter": "0,1,2,3",
-        "EventCode": "0x3C",
-        "EventName": "UNC_C_QLRU.AGE2",
-        "PerPkg": "1",
-        "UMask": "0x4",
-        "Unit": "CBO"
-    },
-    {
-        "BriefDescription": "LRU Queue; LRU Age 3",
-        "Counter": "0,1,2,3",
-        "EventCode": "0x3C",
-        "EventName": "UNC_C_QLRU.AGE3",
-        "PerPkg": "1",
-        "UMask": "0x8",
-        "Unit": "CBO"
-    },
-    {
-        "BriefDescription": "LRU Queue; LRU Bits Decremented",
-        "Counter": "0,1,2,3",
-        "EventCode": "0x3C",
-        "EventName": "UNC_C_QLRU.LRU_DECREMENT",
-        "PerPkg": "1",
-        "UMask": "0x10",
-        "Unit": "CBO"
-    },
-    {
-        "BriefDescription": "LRU Queue; Non-0 Aged Victim",
-        "Counter": "0,1,2,3",
-        "EventCode": "0x3C",
-        "EventName": "UNC_C_QLRU.VICTIM_NON_ZERO",
+        "BriefDescription": "Egress Allocations; AK - Corebo",
+        "EventCode": "0x2",
+        "EventName": "UNC_C_TxR_INSERTS.AK_CORE",
         "PerPkg": "1",
+        "PublicDescription": "Number of allocations into the Cbo Egress.  =
The Egress is used to queue up requests destined for the ring.; Ring transa=
ctions from the Corebo destined for the AK ring.  This is commonly used for=
 snoop responses coming from the core and destined for a Cachebo.",
         "UMask": "0x20",
         "Unit": "CBO"
     },
     {
-        "BriefDescription": "AD",
-        "Counter": "0,1,2,3",
-        "EventCode": "0x6",
-        "EventName": "UNC_C_RING_SINK_STARVED.AD",
-        "PerPkg": "1",
-        "UMask": "0x1",
-        "Unit": "CBO"
-    },
-    {
-        "BriefDescription": "AK",
-        "Counter": "0,1,2,3",
-        "EventCode": "0x6",
-        "EventName": "UNC_C_RING_SINK_STARVED.AK",
-        "PerPkg": "1",
-        "UMask": "0x2",
-        "Unit": "CBO"
-    },
-    {
-        "BriefDescription": "IV",
-        "Counter": "0,1,2,3",
-        "EventCode": "0x6",
-        "EventName": "UNC_C_RING_SINK_STARVED.IV",
-        "PerPkg": "1",
-        "UMask": "0x8",
-        "Unit": "CBO"
-    },
-    {
-        "BriefDescription": "BL",
-        "Counter": "0,1,2,3",
-        "EventCode": "0x6",
-        "EventName": "UNC_C_RING_SINK_STARVED.BL",
+        "BriefDescription": "Egress Allocations; BL - Cacheno",
+        "EventCode": "0x2",
+        "EventName": "UNC_C_TxR_INSERTS.BL_CACHE",
         "PerPkg": "1",
+        "PublicDescription": "Number of allocations into the Cbo Egress.  =
The Egress is used to queue up requests destined for the ring.; Ring transa=
ctions from the Cachebo destined for the BL ring.  This is commonly used to=
 send data from the cache to various destinations.",
         "UMask": "0x4",
         "Unit": "CBO"
     },
     {
-        "BriefDescription": "Ingress Internal Starvation Cycles; IRQ",
-        "Counter": "0,1,2,3",
-        "EventCode": "0x14",
-        "EventName": "UNC_C_RxR_INT_STARVED.IRQ",
-        "PerPkg": "1",
-        "UMask": "0x1",
-        "Unit": "CBO"
-    },
-    {
-        "BriefDescription": "Ingress Internal Starvation Cycles; IPQ",
-        "Counter": "0,1,2,3",
-        "EventCode": "0x14",
-        "EventName": "UNC_C_RxR_INT_STARVED.IPQ",
+        "BriefDescription": "Egress Allocations; BL - Corebo",
+        "EventCode": "0x2",
+        "EventName": "UNC_C_TxR_INSERTS.BL_CORE",
         "PerPkg": "1",
-        "UMask": "0x4",
+        "PublicDescription": "Number of allocations into the Cbo Egress.  =
The Egress is used to queue up requests destined for the ring.; Ring transa=
ctions from the Corebo destined for the BL ring.  This is commonly used for=
 transferring writeback data to the cache.",
+        "UMask": "0x40",
         "Unit": "CBO"
     },
     {
-        "BriefDescription": "Ingress Internal Starvation Cycles; ISMQ",
-        "Counter": "0,1,2,3",
-        "EventCode": "0x14",
-        "EventName": "UNC_C_RxR_INT_STARVED.ISMQ",
+        "BriefDescription": "Egress Allocations; IV - Cachebo",
+        "EventCode": "0x2",
+        "EventName": "UNC_C_TxR_INSERTS.IV_CACHE",
         "PerPkg": "1",
+        "PublicDescription": "Number of allocations into the Cbo Egress.  =
The Egress is used to queue up requests destined for the ring.; Ring transa=
ctions from the Cachebo destined for the IV ring.  This is commonly used fo=
r snoops to the cores.",
         "UMask": "0x8",
         "Unit": "CBO"
     },
     {
-        "BriefDescription": "Ingress Internal Starvation Cycles; PRQ",
-        "Counter": "0,1,2,3",
-        "EventCode": "0x14",
-        "EventName": "UNC_C_RxR_INT_STARVED.PRQ",
+        "BriefDescription": "Injection Starvation; Onto AD Ring (to core)"=
,
+        "EventCode": "0x3",
+        "EventName": "UNC_C_TxR_STARVED.AD_CORE",
         "PerPkg": "1",
+        "PublicDescription": "Counts injection starvation.  This starvatio=
n is triggered when the Egress cannot send a transaction onto the ring for =
a long period of time.; cycles that the core AD egress spent in starvation"=
,
         "UMask": "0x10",
         "Unit": "CBO"
     },
     {
         "BriefDescription": "Injection Starvation; Onto AK Ring",
-        "Counter": "0,1,2,3",
         "EventCode": "0x3",
         "EventName": "UNC_C_TxR_STARVED.AK_BOTH",
         "PerPkg": "1",
+        "PublicDescription": "Counts injection starvation.  This starvatio=
n is triggered when the Egress cannot send a transaction onto the ring for =
a long period of time.; cycles that both AK egresses spent in starvation",
         "UMask": "0x2",
         "Unit": "CBO"
     },
     {
         "BriefDescription": "Injection Starvation; Onto BL Ring",
-        "Counter": "0,1,2,3",
         "EventCode": "0x3",
         "EventName": "UNC_C_TxR_STARVED.BL_BOTH",
         "PerPkg": "1",
+        "PublicDescription": "Counts injection starvation.  This starvatio=
n is triggered when the Egress cannot send a transaction onto the ring for =
a long period of time.; cycles that both BL egresses spent in starvation",
         "UMask": "0x4",
         "Unit": "CBO"
     },
     {
         "BriefDescription": "Injection Starvation; Onto IV Ring",
-        "Counter": "0,1,2,3",
         "EventCode": "0x3",
         "EventName": "UNC_C_TxR_STARVED.IV",
         "PerPkg": "1",
+        "PublicDescription": "Counts injection starvation.  This starvatio=
n is triggered when the Egress cannot send a transaction onto the ring for =
a long period of time.; cycles that the cachebo IV egress spent in starvati=
on",
         "UMask": "0x8",
         "Unit": "CBO"
     },
-    {
-        "BriefDescription": "Injection Starvation; Onto AD Ring (to core)"=
,
-        "Counter": "0,1,2,3",
-        "EventCode": "0x3",
-        "EventName": "UNC_C_TxR_STARVED.AD_CORE",
-        "PerPkg": "1",
-        "UMask": "0x10",
-        "Unit": "CBO"
-    },
-    {
-        "BriefDescription": "QPI Address/Opcode Match; Address & Opcode Ma=
tch",
-        "Counter": "0,1,2,3",
-        "EventCode": "0x20",
-        "EventName": "UNC_H_ADDR_OPC_MATCH.FILT",
-        "PerPkg": "1",
-        "UMask": "0x3",
-        "Unit": "HA"
-    },
-    {
-        "BriefDescription": "QPI Address/Opcode Match; Address",
-        "Counter": "0,1,2,3",
-        "EventCode": "0x20",
-        "EventName": "UNC_H_ADDR_OPC_MATCH.ADDR",
-        "PerPkg": "1",
-        "UMask": "0x1",
-        "Unit": "HA"
-    },
-    {
-        "BriefDescription": "QPI Address/Opcode Match; Opcode",
-        "Counter": "0,1,2,3",
-        "EventCode": "0x20",
-        "EventName": "UNC_H_ADDR_OPC_MATCH.OPC",
-        "PerPkg": "1",
-        "UMask": "0x2",
-        "Unit": "HA"
-    },
-    {
-        "BriefDescription": "QPI Address/Opcode Match; AD Opcodes",
-        "Counter": "0,1,2,3",
-        "EventCode": "0x20",
-        "EventName": "UNC_H_ADDR_OPC_MATCH.AD",
-        "PerPkg": "1",
-        "UMask": "0x4",
-        "Unit": "HA"
-    },
-    {
-        "BriefDescription": "QPI Address/Opcode Match; BL Opcodes",
-        "Counter": "0,1,2,3",
-        "EventCode": "0x20",
-        "EventName": "UNC_H_ADDR_OPC_MATCH.BL",
-        "PerPkg": "1",
-        "UMask": "0x8",
-        "Unit": "HA"
-    },
-    {
-        "BriefDescription": "QPI Address/Opcode Match; AK Opcodes",
-        "Counter": "0,1,2,3",
-        "EventCode": "0x20",
-        "EventName": "UNC_H_ADDR_OPC_MATCH.AK",
-        "PerPkg": "1",
-        "UMask": "0x10",
-        "Unit": "HA"
-    },
     {
         "BriefDescription": "BT Cycles Not Empty",
-        "Counter": "0,1,2,3",
         "EventCode": "0x42",
-        "EventName": "UNC_H_BT_CYCLES_NE",
-        "PerPkg": "1",
-        "Unit": "HA"
-    },
-    {
-        "BriefDescription": "HA to iMC Bypass; Taken",
-        "Counter": "0,1,2,3",
-        "EventCode": "0x14",
-        "EventName": "UNC_H_BYPASS_IMC.TAKEN",
-        "PerPkg": "1",
-        "UMask": "0x1",
-        "Unit": "HA"
-    },
-    {
-        "BriefDescription": "HA to iMC Bypass; Not Taken",
-        "Counter": "0,1,2,3",
-        "EventCode": "0x14",
-        "EventName": "UNC_H_BYPASS_IMC.NOT_TAKEN",
-        "PerPkg": "1",
-        "UMask": "0x2",
-        "Unit": "HA"
-    },
-    {
-        "BriefDescription": "uclks",
-        "Counter": "0,1,2,3",
-        "EventName": "UNC_H_CLOCKTICKS",
-        "PerPkg": "1",
-        "Unit": "HA"
-    },
-    {
-        "BriefDescription": "Direct2Core Messages Sent",
-        "Counter": "0,1,2,3",
-        "EventCode": "0x11",
-        "EventName": "UNC_H_DIRECT2CORE_COUNT",
-        "PerPkg": "1",
-        "Unit": "HA"
-    },
-    {
-        "BriefDescription": "Cycles when Direct2Core was Disabled",
-        "Counter": "0,1,2,3",
-        "EventCode": "0x12",
-        "EventName": "UNC_H_DIRECT2CORE_CYCLES_DISABLED",
-        "PerPkg": "1",
-        "Unit": "HA"
-    },
-    {
-        "BriefDescription": "Number of Reads that had Direct2Core Overridd=
en",
-        "Counter": "0,1,2,3",
-        "EventCode": "0x13",
-        "EventName": "UNC_H_DIRECT2CORE_TXN_OVERRIDE",
-        "PerPkg": "1",
-        "Unit": "HA"
-    },
-    {
-        "BriefDescription": "Directory Lat Opt Return",
-        "Counter": "0,1,2,3",
-        "EventCode": "0x41",
-        "EventName": "UNC_H_DIRECTORY_LAT_OPT",
-        "PerPkg": "1",
-        "Unit": "HA"
-    },
-    {
-        "BriefDescription": "Directory Lookups; Snoop Needed",
-        "Counter": "0,1,2,3",
-        "EventCode": "0xC",
-        "EventName": "UNC_H_DIRECTORY_LOOKUP.SNP",
-        "PerPkg": "1",
-        "UMask": "0x1",
-        "Unit": "HA"
-    },
-    {
-        "BriefDescription": "Directory Lookups; Snoop Not Needed",
-        "Counter": "0,1,2,3",
-        "EventCode": "0xC",
-        "EventName": "UNC_H_DIRECTORY_LOOKUP.NO_SNP",
-        "PerPkg": "1",
-        "UMask": "0x2",
-        "Unit": "HA"
-    },
-    {
-        "BriefDescription": "Directory Updates; Directory Set",
-        "Counter": "0,1,2,3",
-        "EventCode": "0xD",
-        "EventName": "UNC_H_DIRECTORY_UPDATE.SET",
-        "PerPkg": "1",
-        "UMask": "0x1",
-        "Unit": "HA"
-    },
-    {
-        "BriefDescription": "Directory Updates; Directory Clear",
-        "Counter": "0,1,2,3",
-        "EventCode": "0xD",
-        "EventName": "UNC_H_DIRECTORY_UPDATE.CLEAR",
-        "PerPkg": "1",
-        "UMask": "0x2",
-        "Unit": "HA"
-    },
-    {
-        "BriefDescription": "Directory Updates; Any Directory Update",
-        "Counter": "0,1,2,3",
-        "EventCode": "0xD",
-        "EventName": "UNC_H_DIRECTORY_UPDATE.ANY",
-        "PerPkg": "1",
-        "UMask": "0x3",
-        "Unit": "HA"
-    },
-    {
-        "BriefDescription": "Counts Number of Hits in HitMe Cache; op is R=
dCode, RdData, RdDataMigratory, RdInvOwn, RdCur or InvItoE",
-        "Counter": "0,1,2,3",
-        "EventCode": "0x71",
-        "EventName": "UNC_H_HITME_HIT.READ_OR_INVITOE",
-        "PerPkg": "1",
-        "UMask": "0x1",
-        "Unit": "HA"
-    },
-    {
-        "BriefDescription": "Counts Number of Hits in HitMe Cache; op is W=
bMtoI",
-        "Counter": "0,1,2,3",
-        "EventCode": "0x71",
-        "EventName": "UNC_H_HITME_HIT.WBMTOI",
-        "PerPkg": "1",
-        "UMask": "0x2",
-        "Unit": "HA"
-    },
-    {
-        "BriefDescription": "Counts Number of Hits in HitMe Cache; op is A=
ckCnfltWbI",
-        "Counter": "0,1,2,3",
-        "EventCode": "0x71",
-        "EventName": "UNC_H_HITME_HIT.ACKCNFLTWBI",
-        "PerPkg": "1",
-        "UMask": "0x4",
-        "Unit": "HA"
-    },
-    {
-        "BriefDescription": "Counts Number of Hits in HitMe Cache; op is W=
bMtoE or WbMtoS",
-        "Counter": "0,1,2,3",
-        "EventCode": "0x71",
-        "EventName": "UNC_H_HITME_HIT.WBMTOE_OR_S",
-        "PerPkg": "1",
-        "UMask": "0x8",
-        "Unit": "HA"
-    },
-    {
-        "BriefDescription": "Counts Number of Hits in HitMe Cache; op is R=
spIFwd or RspIFwdWb for a remote request",
-        "Counter": "0,1,2,3",
-        "EventCode": "0x71",
-        "EventName": "UNC_H_HITME_HIT.RSPFWDI_REMOTE",
-        "PerPkg": "1",
-        "UMask": "0x10",
-        "Unit": "HA"
-    },
-    {
-        "BriefDescription": "Counts Number of Hits in HitMe Cache; op is R=
spIFwd or RspIFwdWb for a local request",
-        "Counter": "0,1,2,3",
-        "EventCode": "0x71",
-        "EventName": "UNC_H_HITME_HIT.RSPFWDI_LOCAL",
+        "EventName": "UNC_H_BT_CYCLES_NE",
         "PerPkg": "1",
-        "UMask": "0x20",
+        "PublicDescription": "Cycles the Backup Tracker (BT) is not empty.=
 The BT is the actual HOM tracker in IVT.",
         "Unit": "HA"
     },
     {
-        "BriefDescription": "Counts Number of Hits in HitMe Cache; op is R=
sSFwd or RspSFwdWb",
-        "Counter": "0,1,2,3",
-        "EventCode": "0x71",
-        "EventName": "UNC_H_HITME_HIT.RSPFWDS",
+        "BriefDescription": "BT to HT Not Issued; Incoming Data Hazard",
+        "EventCode": "0x51",
+        "EventName": "UNC_H_BT_TO_HT_NOT_ISSUED.INCOMING_BL_HAZARD",
         "PerPkg": "1",
-        "UMask": "0x40",
+        "PublicDescription": "Counts the number of cycles when the HA does=
 not issue transaction from BT to HT.; Cycles unable to issue from BT due t=
o incoming BL data hazard",
+        "UMask": "0x4",
         "Unit": "HA"
     },
     {
-        "BriefDescription": "Counts Number of Hits in HitMe Cache; op is R=
spI, RspIWb, RspS, RspSWb, RspCnflt or RspCnfltWbI",
-        "Counter": "0,1,2,3",
-        "EventCode": "0x71",
-        "EventName": "UNC_H_HITME_HIT.RSP",
+        "BriefDescription": "BT to HT Not Issued; Incoming Snoop Hazard",
+        "EventCode": "0x51",
+        "EventName": "UNC_H_BT_TO_HT_NOT_ISSUED.INCOMING_SNP_HAZARD",
         "PerPkg": "1",
-        "UMask": "0x80",
+        "PublicDescription": "Counts the number of cycles when the HA does=
 not issue transaction from BT to HT.; Cycles unable to issue from BT due t=
o incoming snoop hazard",
+        "UMask": "0x2",
         "Unit": "HA"
     },
     {
-        "BriefDescription": "Counts Number of Hits in HitMe Cache; Allocat=
ions",
-        "Counter": "0,1,2,3",
-        "EventCode": "0x71",
-        "EventName": "UNC_H_HITME_HIT.ALLOCS",
+        "BriefDescription": "BT to HT Not Issued; Incoming Data Hazard",
+        "EventCode": "0x51",
+        "EventName": "UNC_H_BT_TO_HT_NOT_ISSUED.RSPACKCFLT_HAZARD",
         "PerPkg": "1",
-        "UMask": "0x70",
+        "PublicDescription": "Counts the number of cycles when the HA does=
 not issue transaction from BT to HT.; Cycles unable to issue from BT due t=
o incoming BL data hazard",
+        "UMask": "0x8",
         "Unit": "HA"
     },
     {
-        "BriefDescription": "Counts Number of Hits in HitMe Cache; Allocat=
ions",
-        "Counter": "0,1,2,3",
-        "EventCode": "0x71",
-        "EventName": "UNC_H_HITME_HIT.EVICTS",
+        "BriefDescription": "BT to HT Not Issued; Incoming Data Hazard",
+        "EventCode": "0x51",
+        "EventName": "UNC_H_BT_TO_HT_NOT_ISSUED.WBMDATA_HAZARD",
         "PerPkg": "1",
-        "UMask": "0x42",
+        "PublicDescription": "Counts the number of cycles when the HA does=
 not issue transaction from BT to HT.; Cycles unable to issue from BT due t=
o incoming BL data hazard",
+        "UMask": "0x10",
         "Unit": "HA"
     },
     {
-        "BriefDescription": "Counts Number of Hits in HitMe Cache; Invalid=
ations",
-        "Counter": "0,1,2,3",
-        "EventCode": "0x71",
-        "EventName": "UNC_H_HITME_HIT.INVALS",
+        "BriefDescription": "HA to iMC Bypass; Not Taken",
+        "EventCode": "0x14",
+        "EventName": "UNC_H_BYPASS_IMC.NOT_TAKEN",
         "PerPkg": "1",
-        "UMask": "0x26",
+        "PublicDescription": "Counts the number of times when the HA was a=
ble to bypass was attempted.  This is a latency optimization for situations=
 when there is light loadings on the memory subsystem.  This can be filted =
by when the bypass was taken and when it was not.; Filter for transactions =
that could not take the bypass.",
+        "UMask": "0x2",
         "Unit": "HA"
     },
     {
-        "BriefDescription": "Counts Number of Hits in HitMe Cache; All Req=
uests",
-        "Counter": "0,1,2,3",
-        "EventCode": "0x71",
-        "EventName": "UNC_H_HITME_HIT.ALL",
+        "BriefDescription": "HA to iMC Bypass; Taken",
+        "EventCode": "0x14",
+        "EventName": "UNC_H_BYPASS_IMC.TAKEN",
         "PerPkg": "1",
-        "UMask": "0xFF",
+        "PublicDescription": "Counts the number of times when the HA was a=
ble to bypass was attempted.  This is a latency optimization for situations=
 when there is light loadings on the memory subsystem.  This can be filted =
by when the bypass was taken and when it was not.; Filter for transactions =
that succeeded in taking the bypass.",
+        "UMask": "0x1",
         "Unit": "HA"
     },
     {
-        "BriefDescription": "Counts Number of Hits in HitMe Cache; HOM Req=
uests",
-        "Counter": "0,1,2,3",
-        "EventCode": "0x71",
-        "EventName": "UNC_H_HITME_HIT.HOM",
+        "BriefDescription": "uclks",
+        "EventName": "UNC_H_CLOCKTICKS",
         "PerPkg": "1",
-        "UMask": "0xF",
+        "PublicDescription": "Counts the number of uclks in the HA.  This =
will be slightly different than the count in the Ubox because of enable/fre=
eze delays.  The HA is on the other side of the die from the fixed Ubox ucl=
k counter, so the drift could be somewhat larger than in units that are clo=
ser like the QPI Agent.",
         "Unit": "HA"
     },
     {
-        "BriefDescription": "Accumulates Number of PV bits set on HitMe Ca=
che Hits; op is RdCode, RdData, RdDataMigratory, RdInvOwn, RdCur or InvItoE=
",
-        "Counter": "0,1,2,3",
-        "EventCode": "0x72",
-        "EventName": "UNC_H_HITME_HIT_PV_BITS_SET.READ_OR_INVITOE",
+        "BriefDescription": "Direct2Core Messages Sent",
+        "EventCode": "0x11",
+        "EventName": "UNC_H_DIRECT2CORE_COUNT",
         "PerPkg": "1",
-        "UMask": "0x1",
+        "PublicDescription": "Number of Direct2Core messages sent",
         "Unit": "HA"
     },
     {
-        "BriefDescription": "Accumulates Number of PV bits set on HitMe Ca=
che Hits; op is WbMtoI",
-        "Counter": "0,1,2,3",
-        "EventCode": "0x72",
-        "EventName": "UNC_H_HITME_HIT_PV_BITS_SET.WBMTOI",
+        "BriefDescription": "Cycles when Direct2Core was Disabled",
+        "EventCode": "0x12",
+        "EventName": "UNC_H_DIRECT2CORE_CYCLES_DISABLED",
         "PerPkg": "1",
-        "UMask": "0x2",
+        "PublicDescription": "Number of cycles in which Direct2Core was di=
sabled",
         "Unit": "HA"
     },
     {
-        "BriefDescription": "Accumulates Number of PV bits set on HitMe Ca=
che Hits; op is AckCnfltWbI",
-        "Counter": "0,1,2,3",
-        "EventCode": "0x72",
-        "EventName": "UNC_H_HITME_HIT_PV_BITS_SET.ACKCNFLTWBI",
+        "BriefDescription": "Number of Reads that had Direct2Core Overridd=
en",
+        "EventCode": "0x13",
+        "EventName": "UNC_H_DIRECT2CORE_TXN_OVERRIDE",
         "PerPkg": "1",
-        "UMask": "0x4",
+        "PublicDescription": "Number of Reads where Direct2Core overridden=
",
         "Unit": "HA"
     },
     {
-        "BriefDescription": "Accumulates Number of PV bits set on HitMe Ca=
che Hits; op is WbMtoE or WbMtoS",
-        "Counter": "0,1,2,3",
-        "EventCode": "0x72",
-        "EventName": "UNC_H_HITME_HIT_PV_BITS_SET.WBMTOE_OR_S",
+        "BriefDescription": "Directory Lat Opt Return",
+        "EventCode": "0x41",
+        "EventName": "UNC_H_DIRECTORY_LAT_OPT",
         "PerPkg": "1",
-        "UMask": "0x8",
+        "PublicDescription": "Directory Latency Optimization Data Return P=
ath Taken. When directory mode is enabled and the directory returned for a =
read is Dir=3DI, then data can be returned using a faster path if certain c=
onditions are met (credits, free pipeline, etc).",
         "Unit": "HA"
     },
     {
-        "BriefDescription": "Accumulates Number of PV bits set on HitMe Ca=
che Hits; op is RspIFwd or RspIFwdWb for a remote request",
-        "Counter": "0,1,2,3",
-        "EventCode": "0x72",
-        "EventName": "UNC_H_HITME_HIT_PV_BITS_SET.RSPFWDI_REMOTE",
+        "BriefDescription": "Directory Lookups; Snoop Not Needed",
+        "EventCode": "0xC",
+        "EventName": "UNC_H_DIRECTORY_LOOKUP.NO_SNP",
         "PerPkg": "1",
-        "UMask": "0x10",
+        "PublicDescription": "Counts the number of transactions that looke=
d up the directory.  Can be filtered by requests that had to snoop and thos=
e that did not have to.; Filters for transactions that did not have to send=
 any snoops because the directory bit was clear.",
+        "UMask": "0x2",
         "Unit": "HA"
     },
     {
-        "BriefDescription": "Accumulates Number of PV bits set on HitMe Ca=
che Hits; op is RspIFwd or RspIFwdWb for a local request",
-        "Counter": "0,1,2,3",
-        "EventCode": "0x72",
-        "EventName": "UNC_H_HITME_HIT_PV_BITS_SET.RSPFWDI_LOCAL",
+        "BriefDescription": "Directory Lookups; Snoop Needed",
+        "EventCode": "0xC",
+        "EventName": "UNC_H_DIRECTORY_LOOKUP.SNP",
         "PerPkg": "1",
-        "UMask": "0x20",
+        "PublicDescription": "Counts the number of transactions that looke=
d up the directory.  Can be filtered by requests that had to snoop and thos=
e that did not have to.; Filters for transactions that had to send one or m=
ore snoops because the directory bit was set.",
+        "UMask": "0x1",
         "Unit": "HA"
     },
     {
-        "BriefDescription": "Accumulates Number of PV bits set on HitMe Ca=
che Hits; op is RsSFwd or RspSFwdWb",
-        "Counter": "0,1,2,3",
-        "EventCode": "0x72",
-        "EventName": "UNC_H_HITME_HIT_PV_BITS_SET.RSPFWDS",
+        "BriefDescription": "Directory Updates; Any Directory Update",
+        "EventCode": "0xD",
+        "EventName": "UNC_H_DIRECTORY_UPDATE.ANY",
         "PerPkg": "1",
-        "UMask": "0x40",
+        "PublicDescription": "Counts the number of directory updates that =
were required.  These result in writes to the memory controller.  This can =
be filtered by directory sets and directory clears.",
+        "UMask": "0x3",
         "Unit": "HA"
     },
     {
-        "BriefDescription": "Accumulates Number of PV bits set on HitMe Ca=
che Hits; op is RspI, RspIWb, RspS, RspSWb, RspCnflt or RspCnfltWbI",
-        "Counter": "0,1,2,3",
-        "EventCode": "0x72",
-        "EventName": "UNC_H_HITME_HIT_PV_BITS_SET.RSP",
+        "BriefDescription": "Directory Updates; Directory Clear",
+        "EventCode": "0xD",
+        "EventName": "UNC_H_DIRECTORY_UPDATE.CLEAR",
         "PerPkg": "1",
-        "UMask": "0x80",
+        "PublicDescription": "Counts the number of directory updates that =
were required.  These result in writes to the memory controller.  This can =
be filtered by directory sets and directory clears.; Filter for directory c=
lears.  This occurs when snoops were sent and all returned with RspI.",
+        "UMask": "0x2",
         "Unit": "HA"
     },
     {
-        "BriefDescription": "Accumulates Number of PV bits set on HitMe Ca=
che Hits; All Requests",
-        "Counter": "0,1,2,3",
-        "EventCode": "0x72",
-        "EventName": "UNC_H_HITME_HIT_PV_BITS_SET.ALL",
+        "BriefDescription": "Directory Updates; Directory Set",
+        "EventCode": "0xD",
+        "EventName": "UNC_H_DIRECTORY_UPDATE.SET",
         "PerPkg": "1",
-        "UMask": "0xFF",
+        "PublicDescription": "Counts the number of directory updates that =
were required.  These result in writes to the memory controller.  This can =
be filtered by directory sets and directory clears.; Filter for directory s=
ets.  This occurs when a remote read transaction requests memory, bringing =
it to a remote cache.",
+        "UMask": "0x1",
         "Unit": "HA"
     },
     {
-        "BriefDescription": "Accumulates Number of PV bits set on HitMe Ca=
che Hits; HOM Requests",
-        "Counter": "0,1,2,3",
-        "EventCode": "0x72",
-        "EventName": "UNC_H_HITME_HIT_PV_BITS_SET.HOM",
+        "BriefDescription": "Counts Number of Hits in HitMe Cache; op is A=
ckCnfltWbI",
+        "EventCode": "0x71",
+        "EventName": "UNC_H_HITME_HIT.ACKCNFLTWBI",
         "PerPkg": "1",
-        "UMask": "0xF",
+        "PublicDescription": "UNC_H_HITME_HIT.ACKCNFLTWBI",
+        "UMask": "0x4",
         "Unit": "HA"
     },
     {
-        "BriefDescription": "Counts Number of times HitMe Cache is accesse=
d; op is RdCode, RdData, RdDataMigratory, RdInvOwn, RdCur or InvItoE",
-        "Counter": "0,1,2,3",
-        "EventCode": "0x70",
-        "EventName": "UNC_H_HITME_LOOKUP.READ_OR_INVITOE",
+        "BriefDescription": "Counts Number of Hits in HitMe Cache; All Req=
uests",
+        "EventCode": "0x71",
+        "EventName": "UNC_H_HITME_HIT.ALL",
         "PerPkg": "1",
-        "UMask": "0x1",
+        "PublicDescription": "UNC_H_HITME_HIT.ALL",
+        "UMask": "0xff",
         "Unit": "HA"
     },
     {
-        "BriefDescription": "Counts Number of times HitMe Cache is accesse=
d; op is WbMtoI",
-        "Counter": "0,1,2,3",
-        "EventCode": "0x70",
-        "EventName": "UNC_H_HITME_LOOKUP.WBMTOI",
+        "BriefDescription": "Counts Number of Hits in HitMe Cache; Allocat=
ions",
+        "EventCode": "0x71",
+        "EventName": "UNC_H_HITME_HIT.ALLOCS",
         "PerPkg": "1",
-        "UMask": "0x2",
+        "PublicDescription": "UNC_H_HITME_HIT.ALLOCS",
+        "UMask": "0x70",
         "Unit": "HA"
     },
     {
-        "BriefDescription": "Counts Number of times HitMe Cache is accesse=
d; op is AckCnfltWbI",
-        "Counter": "0,1,2,3",
-        "EventCode": "0x70",
-        "EventName": "UNC_H_HITME_LOOKUP.ACKCNFLTWBI",
+        "BriefDescription": "Counts Number of Hits in HitMe Cache; Allocat=
ions",
+        "EventCode": "0x71",
+        "EventName": "UNC_H_HITME_HIT.EVICTS",
         "PerPkg": "1",
-        "UMask": "0x4",
+        "PublicDescription": "UNC_H_HITME_HIT.EVICTS",
+        "UMask": "0x42",
         "Unit": "HA"
     },
     {
-        "BriefDescription": "Counts Number of times HitMe Cache is accesse=
d; op is WbMtoE or WbMtoS",
-        "Counter": "0,1,2,3",
-        "EventCode": "0x70",
-        "EventName": "UNC_H_HITME_LOOKUP.WBMTOE_OR_S",
+        "BriefDescription": "Counts Number of Hits in HitMe Cache; HOM Req=
uests",
+        "EventCode": "0x71",
+        "EventName": "UNC_H_HITME_HIT.HOM",
         "PerPkg": "1",
-        "UMask": "0x8",
+        "PublicDescription": "UNC_H_HITME_HIT.HOM",
+        "UMask": "0xf",
         "Unit": "HA"
     },
     {
-        "BriefDescription": "Counts Number of times HitMe Cache is accesse=
d; op is RspIFwd or RspIFwdWb for a remote request",
-        "Counter": "0,1,2,3",
-        "EventCode": "0x70",
-        "EventName": "UNC_H_HITME_LOOKUP.RSPFWDI_REMOTE",
+        "BriefDescription": "Counts Number of Hits in HitMe Cache; Invalid=
ations",
+        "EventCode": "0x71",
+        "EventName": "UNC_H_HITME_HIT.INVALS",
         "PerPkg": "1",
-        "UMask": "0x10",
+        "PublicDescription": "UNC_H_HITME_HIT.INVALS",
+        "UMask": "0x26",
         "Unit": "HA"
     },
     {
-        "BriefDescription": "Counts Number of times HitMe Cache is accesse=
d; op is RspIFwd or RspIFwdWb for a local request",
-        "Counter": "0,1,2,3",
-        "EventCode": "0x70",
-        "EventName": "UNC_H_HITME_LOOKUP.RSPFWDI_LOCAL",
+        "BriefDescription": "Counts Number of Hits in HitMe Cache; op is R=
dCode, RdData, RdDataMigratory, RdInvOwn, RdCur or InvItoE",
+        "EventCode": "0x71",
+        "EventName": "UNC_H_HITME_HIT.READ_OR_INVITOE",
         "PerPkg": "1",
-        "UMask": "0x20",
+        "PublicDescription": "UNC_H_HITME_HIT.READ_OR_INVITOE",
+        "UMask": "0x1",
         "Unit": "HA"
     },
     {
-        "BriefDescription": "Counts Number of times HitMe Cache is accesse=
d; op is RsSFwd or RspSFwdWb",
-        "Counter": "0,1,2,3",
-        "EventCode": "0x70",
-        "EventName": "UNC_H_HITME_LOOKUP.RSPFWDS",
+        "BriefDescription": "Counts Number of Hits in HitMe Cache; op is R=
spI, RspIWb, RspS, RspSWb, RspCnflt or RspCnfltWbI",
+        "EventCode": "0x71",
+        "EventName": "UNC_H_HITME_HIT.RSP",
         "PerPkg": "1",
-        "UMask": "0x40",
+        "PublicDescription": "UNC_H_HITME_HIT.RSP",
+        "UMask": "0x80",
         "Unit": "HA"
     },
     {
-        "BriefDescription": "Counts Number of times HitMe Cache is accesse=
d; op is RspI, RspIWb, RspS, RspSWb, RspCnflt or RspCnfltWbI",
-        "Counter": "0,1,2,3",
-        "EventCode": "0x70",
-        "EventName": "UNC_H_HITME_LOOKUP.RSP",
+        "BriefDescription": "Counts Number of Hits in HitMe Cache; op is R=
spIFwd or RspIFwdWb for a local request",
+        "EventCode": "0x71",
+        "EventName": "UNC_H_HITME_HIT.RSPFWDI_LOCAL",
         "PerPkg": "1",
-        "UMask": "0x80",
+        "PublicDescription": "UNC_H_HITME_HIT.RSPFWDI_LOCAL",
+        "UMask": "0x20",
         "Unit": "HA"
     },
     {
-        "BriefDescription": "Counts Number of times HitMe Cache is accesse=
d; Allocations",
-        "Counter": "0,1,2,3",
-        "EventCode": "0x70",
-        "EventName": "UNC_H_HITME_LOOKUP.ALLOCS",
+        "BriefDescription": "Counts Number of Hits in HitMe Cache; op is R=
spIFwd or RspIFwdWb for a remote request",
+        "EventCode": "0x71",
+        "EventName": "UNC_H_HITME_HIT.RSPFWDI_REMOTE",
         "PerPkg": "1",
-        "UMask": "0x70",
+        "PublicDescription": "UNC_H_HITME_HIT.RSPFWDI_REMOTE",
+        "UMask": "0x10",
         "Unit": "HA"
     },
     {
-        "BriefDescription": "Counts Number of times HitMe Cache is accesse=
d; Invalidations",
-        "Counter": "0,1,2,3",
-        "EventCode": "0x70",
-        "EventName": "UNC_H_HITME_LOOKUP.INVALS",
+        "BriefDescription": "Counts Number of Hits in HitMe Cache; op is R=
sSFwd or RspSFwdWb",
+        "EventCode": "0x71",
+        "EventName": "UNC_H_HITME_HIT.RSPFWDS",
         "PerPkg": "1",
-        "UMask": "0x26",
+        "PublicDescription": "UNC_H_HITME_HIT.RSPFWDS",
+        "UMask": "0x40",
         "Unit": "HA"
     },
     {
-        "BriefDescription": "Counts Number of times HitMe Cache is accesse=
d; All Requests",
-        "Counter": "0,1,2,3",
-        "EventCode": "0x70",
-        "EventName": "UNC_H_HITME_LOOKUP.ALL",
+        "BriefDescription": "Counts Number of Hits in HitMe Cache; op is W=
bMtoE or WbMtoS",
+        "EventCode": "0x71",
+        "EventName": "UNC_H_HITME_HIT.WBMTOE_OR_S",
         "PerPkg": "1",
-        "UMask": "0xFF",
+        "PublicDescription": "UNC_H_HITME_HIT.WBMTOE_OR_S",
+        "UMask": "0x8",
         "Unit": "HA"
     },
     {
-        "BriefDescription": "Counts Number of times HitMe Cache is accesse=
d; HOM Requests",
-        "Counter": "0,1,2,3",
-        "EventCode": "0x70",
-        "EventName": "UNC_H_HITME_LOOKUP.HOM",
+        "BriefDescription": "Counts Number of Hits in HitMe Cache; op is W=
bMtoI",
+        "EventCode": "0x71",
+        "EventName": "UNC_H_HITME_HIT.WBMTOI",
         "PerPkg": "1",
-        "UMask": "0xF",
+        "PublicDescription": "UNC_H_HITME_HIT.WBMTOI",
+        "UMask": "0x2",
         "Unit": "HA"
     },
     {
-        "BriefDescription": "Cycles without QPI Ingress Credits; AD to QPI=
 Link 0",
-        "Counter": "0,1,2,3",
-        "EventCode": "0x22",
-        "EventName": "UNC_H_IGR_NO_CREDIT_CYCLES.AD_QPI0",
+        "BriefDescription": "Accumulates Number of PV bits set on HitMe Ca=
che Hits; op is AckCnfltWbI",
+        "EventCode": "0x72",
+        "EventName": "UNC_H_HITME_HIT_PV_BITS_SET.ACKCNFLTWBI",
         "PerPkg": "1",
-        "UMask": "0x1",
+        "PublicDescription": "UNC_H_HITME_HIT_PV_BITS_SET.ACKCNFLTWBI",
+        "UMask": "0x4",
         "Unit": "HA"
     },
     {
-        "BriefDescription": "Cycles without QPI Ingress Credits; AD to QPI=
 Link 1",
-        "Counter": "0,1,2,3",
-        "EventCode": "0x22",
-        "EventName": "UNC_H_IGR_NO_CREDIT_CYCLES.AD_QPI1",
+        "BriefDescription": "Accumulates Number of PV bits set on HitMe Ca=
che Hits; All Requests",
+        "EventCode": "0x72",
+        "EventName": "UNC_H_HITME_HIT_PV_BITS_SET.ALL",
         "PerPkg": "1",
-        "UMask": "0x2",
+        "PublicDescription": "UNC_H_HITME_HIT_PV_BITS_SET.ALL",
+        "UMask": "0xff",
         "Unit": "HA"
     },
     {
-        "BriefDescription": "Cycles without QPI Ingress Credits; BL to QPI=
 Link 0",
-        "Counter": "0,1,2,3",
-        "EventCode": "0x22",
-        "EventName": "UNC_H_IGR_NO_CREDIT_CYCLES.BL_QPI0",
+        "BriefDescription": "Accumulates Number of PV bits set on HitMe Ca=
che Hits; HOM Requests",
+        "EventCode": "0x72",
+        "EventName": "UNC_H_HITME_HIT_PV_BITS_SET.HOM",
         "PerPkg": "1",
-        "UMask": "0x4",
+        "PublicDescription": "UNC_H_HITME_HIT_PV_BITS_SET.HOM",
+        "UMask": "0xf",
         "Unit": "HA"
     },
     {
-        "BriefDescription": "Cycles without QPI Ingress Credits; BL to QPI=
 Link 1",
-        "Counter": "0,1,2,3",
-        "EventCode": "0x22",
-        "EventName": "UNC_H_IGR_NO_CREDIT_CYCLES.BL_QPI1",
+        "BriefDescription": "Accumulates Number of PV bits set on HitMe Ca=
che Hits; op is RdCode, RdData, RdDataMigratory, RdInvOwn, RdCur or InvItoE=
",
+        "EventCode": "0x72",
+        "EventName": "UNC_H_HITME_HIT_PV_BITS_SET.READ_OR_INVITOE",
         "PerPkg": "1",
-        "UMask": "0x8",
+        "PublicDescription": "UNC_H_HITME_HIT_PV_BITS_SET.READ_OR_INVITOE"=
,
+        "UMask": "0x1",
         "Unit": "HA"
     },
     {
-        "BriefDescription": "Cycles without QPI Ingress Credits; BL to QPI=
 Link 0",
-        "Counter": "0,1,2,3",
-        "EventCode": "0x22",
-        "EventName": "UNC_H_IGR_NO_CREDIT_CYCLES.AD_QPI2",
+        "BriefDescription": "Accumulates Number of PV bits set on HitMe Ca=
che Hits; op is RspI, RspIWb, RspS, RspSWb, RspCnflt or RspCnfltWbI",
+        "EventCode": "0x72",
+        "EventName": "UNC_H_HITME_HIT_PV_BITS_SET.RSP",
         "PerPkg": "1",
-        "UMask": "0x10",
+        "PublicDescription": "UNC_H_HITME_HIT_PV_BITS_SET.RSP",
+        "UMask": "0x80",
         "Unit": "HA"
     },
     {
-        "BriefDescription": "Cycles without QPI Ingress Credits; BL to QPI=
 Link 1",
-        "Counter": "0,1,2,3",
-        "EventCode": "0x22",
-        "EventName": "UNC_H_IGR_NO_CREDIT_CYCLES.BL_QPI2",
+        "BriefDescription": "Accumulates Number of PV bits set on HitMe Ca=
che Hits; op is RspIFwd or RspIFwdWb for a local request",
+        "EventCode": "0x72",
+        "EventName": "UNC_H_HITME_HIT_PV_BITS_SET.RSPFWDI_LOCAL",
         "PerPkg": "1",
+        "PublicDescription": "UNC_H_HITME_HIT_PV_BITS_SET.RSPFWDI_LOCAL",
         "UMask": "0x20",
         "Unit": "HA"
     },
     {
-        "BriefDescription": "HA to iMC Normal Priority Reads Issued; Norma=
l Priority",
-        "Counter": "0,1,2,3",
-        "EventCode": "0x17",
-        "EventName": "UNC_H_IMC_READS.NORMAL",
+        "BriefDescription": "Accumulates Number of PV bits set on HitMe Ca=
che Hits; op is RspIFwd or RspIFwdWb for a remote request",
+        "EventCode": "0x72",
+        "EventName": "UNC_H_HITME_HIT_PV_BITS_SET.RSPFWDI_REMOTE",
         "PerPkg": "1",
-        "UMask": "0x1",
+        "PublicDescription": "UNC_H_HITME_HIT_PV_BITS_SET.RSPFWDI_REMOTE",
+        "UMask": "0x10",
         "Unit": "HA"
     },
     {
-        "BriefDescription": "Retry Events",
-        "Counter": "0,1,2,3",
-        "EventCode": "0x1E",
-        "EventName": "UNC_H_IMC_RETRY",
+        "BriefDescription": "Accumulates Number of PV bits set on HitMe Ca=
che Hits; op is RsSFwd or RspSFwdWb",
+        "EventCode": "0x72",
+        "EventName": "UNC_H_HITME_HIT_PV_BITS_SET.RSPFWDS",
         "PerPkg": "1",
+        "PublicDescription": "UNC_H_HITME_HIT_PV_BITS_SET.RSPFWDS",
+        "UMask": "0x40",
         "Unit": "HA"
     },
     {
-        "BriefDescription": "HA to iMC Full Line Writes Issued; Full Line =
Non-ISOCH",
-        "Counter": "0,1,2,3",
-        "EventCode": "0x1A",
-        "EventName": "UNC_H_IMC_WRITES.FULL",
+        "BriefDescription": "Accumulates Number of PV bits set on HitMe Ca=
che Hits; op is WbMtoE or WbMtoS",
+        "EventCode": "0x72",
+        "EventName": "UNC_H_HITME_HIT_PV_BITS_SET.WBMTOE_OR_S",
         "PerPkg": "1",
-        "UMask": "0x1",
+        "PublicDescription": "UNC_H_HITME_HIT_PV_BITS_SET.WBMTOE_OR_S",
+        "UMask": "0x8",
         "Unit": "HA"
     },
     {
-        "BriefDescription": "HA to iMC Full Line Writes Issued; Partial No=
n-ISOCH",
-        "Counter": "0,1,2,3",
-        "EventCode": "0x1A",
-        "EventName": "UNC_H_IMC_WRITES.PARTIAL",
+        "BriefDescription": "Accumulates Number of PV bits set on HitMe Ca=
che Hits; op is WbMtoI",
+        "EventCode": "0x72",
+        "EventName": "UNC_H_HITME_HIT_PV_BITS_SET.WBMTOI",
         "PerPkg": "1",
+        "PublicDescription": "UNC_H_HITME_HIT_PV_BITS_SET.WBMTOI",
         "UMask": "0x2",
         "Unit": "HA"
     },
     {
-        "BriefDescription": "HA to iMC Full Line Writes Issued; ISOCH Full=
 Line",
-        "Counter": "0,1,2,3",
-        "EventCode": "0x1A",
-        "EventName": "UNC_H_IMC_WRITES.FULL_ISOCH",
+        "BriefDescription": "Counts Number of times HitMe Cache is accesse=
d; op is AckCnfltWbI",
+        "EventCode": "0x70",
+        "EventName": "UNC_H_HITME_LOOKUP.ACKCNFLTWBI",
         "PerPkg": "1",
+        "PublicDescription": "UNC_H_HITME_LOOKUP.ACKCNFLTWBI",
         "UMask": "0x4",
         "Unit": "HA"
     },
     {
-        "BriefDescription": "HA to iMC Full Line Writes Issued; ISOCH Part=
ial",
-        "Counter": "0,1,2,3",
-        "EventCode": "0x1A",
-        "EventName": "UNC_H_IMC_WRITES.PARTIAL_ISOCH",
+        "BriefDescription": "Counts Number of times HitMe Cache is accesse=
d; All Requests",
+        "EventCode": "0x70",
+        "EventName": "UNC_H_HITME_LOOKUP.ALL",
         "PerPkg": "1",
-        "UMask": "0x8",
+        "PublicDescription": "UNC_H_HITME_LOOKUP.ALL",
+        "UMask": "0xff",
         "Unit": "HA"
     },
     {
-        "BriefDescription": "HA to iMC Full Line Writes Issued; All Writes=
",
-        "Counter": "0,1,2,3",
-        "EventCode": "0x1A",
-        "EventName": "UNC_H_IMC_WRITES.ALL",
+        "BriefDescription": "Counts Number of times HitMe Cache is accesse=
d; Allocations",
+        "EventCode": "0x70",
+        "EventName": "UNC_H_HITME_LOOKUP.ALLOCS",
         "PerPkg": "1",
-        "UMask": "0xF",
+        "PublicDescription": "UNC_H_HITME_LOOKUP.ALLOCS",
+        "UMask": "0x70",
         "Unit": "HA"
     },
     {
-        "BriefDescription": "OSB Snoop Broadcast; Local Reads",
-        "Counter": "0,1,2,3",
-        "EventCode": "0x53",
-        "EventName": "UNC_H_OSB.READS_LOCAL",
+        "BriefDescription": "Counts Number of times HitMe Cache is accesse=
d; HOM Requests",
+        "EventCode": "0x70",
+        "EventName": "UNC_H_HITME_LOOKUP.HOM",
         "PerPkg": "1",
-        "UMask": "0x2",
+        "PublicDescription": "UNC_H_HITME_LOOKUP.HOM",
+        "UMask": "0xf",
         "Unit": "HA"
     },
     {
-        "BriefDescription": "OSB Snoop Broadcast; Local InvItoE",
-        "Counter": "0,1,2,3",
-        "EventCode": "0x53",
-        "EventName": "UNC_H_OSB.INVITOE_LOCAL",
+        "BriefDescription": "Counts Number of times HitMe Cache is accesse=
d; Invalidations",
+        "EventCode": "0x70",
+        "EventName": "UNC_H_HITME_LOOKUP.INVALS",
         "PerPkg": "1",
-        "UMask": "0x4",
+        "PublicDescription": "UNC_H_HITME_LOOKUP.INVALS",
+        "UMask": "0x26",
         "Unit": "HA"
     },
     {
-        "BriefDescription": "OSB Snoop Broadcast; Remote",
-        "Counter": "0,1,2,3",
-        "EventCode": "0x53",
-        "EventName": "UNC_H_OSB.REMOTE",
+        "BriefDescription": "Counts Number of times HitMe Cache is accesse=
d; op is RdCode, RdData, RdDataMigratory, RdInvOwn, RdCur or InvItoE",
+        "EventCode": "0x70",
+        "EventName": "UNC_H_HITME_LOOKUP.READ_OR_INVITOE",
         "PerPkg": "1",
-        "UMask": "0x8",
+        "PublicDescription": "UNC_H_HITME_LOOKUP.READ_OR_INVITOE",
+        "UMask": "0x1",
         "Unit": "HA"
     },
     {
-        "BriefDescription": "OSB Snoop Broadcast; Cancelled",
-        "Counter": "0,1,2,3",
-        "EventCode": "0x53",
-        "EventName": "UNC_H_OSB.CANCELLED",
+        "BriefDescription": "Counts Number of times HitMe Cache is accesse=
d; op is RspI, RspIWb, RspS, RspSWb, RspCnflt or RspCnfltWbI",
+        "EventCode": "0x70",
+        "EventName": "UNC_H_HITME_LOOKUP.RSP",
         "PerPkg": "1",
-        "UMask": "0x10",
+        "PublicDescription": "UNC_H_HITME_LOOKUP.RSP",
+        "UMask": "0x80",
         "Unit": "HA"
     },
     {
-        "BriefDescription": "OSB Snoop Broadcast; Reads Local -  Useful",
-        "Counter": "0,1,2,3",
-        "EventCode": "0x53",
-        "EventName": "UNC_H_OSB.READS_LOCAL_USEFUL",
+        "BriefDescription": "Counts Number of times HitMe Cache is accesse=
d; op is RspIFwd or RspIFwdWb for a local request",
+        "EventCode": "0x70",
+        "EventName": "UNC_H_HITME_LOOKUP.RSPFWDI_LOCAL",
         "PerPkg": "1",
+        "PublicDescription": "UNC_H_HITME_LOOKUP.RSPFWDI_LOCAL",
         "UMask": "0x20",
         "Unit": "HA"
     },
     {
-        "BriefDescription": "OSB Snoop Broadcast; Remote - Useful",
-        "Counter": "0,1,2,3",
-        "EventCode": "0x53",
-        "EventName": "UNC_H_OSB.REMOTE_USEFUL",
+        "BriefDescription": "Counts Number of times HitMe Cache is accesse=
d; op is RspIFwd or RspIFwdWb for a remote request",
+        "EventCode": "0x70",
+        "EventName": "UNC_H_HITME_LOOKUP.RSPFWDI_REMOTE",
+        "PerPkg": "1",
+        "PublicDescription": "UNC_H_HITME_LOOKUP.RSPFWDI_REMOTE",
+        "UMask": "0x10",
+        "Unit": "HA"
+    },
+    {
+        "BriefDescription": "Counts Number of times HitMe Cache is accesse=
d; op is RsSFwd or RspSFwdWb",
+        "EventCode": "0x70",
+        "EventName": "UNC_H_HITME_LOOKUP.RSPFWDS",
         "PerPkg": "1",
+        "PublicDescription": "UNC_H_HITME_LOOKUP.RSPFWDS",
         "UMask": "0x40",
         "Unit": "HA"
     },
     {
-        "BriefDescription": "OSB Early Data Return; All",
-        "Counter": "0,1,2,3",
-        "EventCode": "0x54",
-        "EventName": "UNC_H_OSB_EDR.ALL",
+        "BriefDescription": "Counts Number of times HitMe Cache is accesse=
d; op is WbMtoE or WbMtoS",
+        "EventCode": "0x70",
+        "EventName": "UNC_H_HITME_LOOKUP.WBMTOE_OR_S",
         "PerPkg": "1",
-        "UMask": "0x1",
+        "PublicDescription": "UNC_H_HITME_LOOKUP.WBMTOE_OR_S",
+        "UMask": "0x8",
         "Unit": "HA"
     },
     {
-        "BriefDescription": "OSB Early Data Return; Reads to Local  I",
-        "Counter": "0,1,2,3",
-        "EventCode": "0x54",
-        "EventName": "UNC_H_OSB_EDR.READS_LOCAL_I",
+        "BriefDescription": "Counts Number of times HitMe Cache is accesse=
d; op is WbMtoI",
+        "EventCode": "0x70",
+        "EventName": "UNC_H_HITME_LOOKUP.WBMTOI",
         "PerPkg": "1",
+        "PublicDescription": "UNC_H_HITME_LOOKUP.WBMTOI",
         "UMask": "0x2",
         "Unit": "HA"
     },
     {
-        "BriefDescription": "OSB Early Data Return; Reads to Remote I",
-        "Counter": "0,1,2,3",
-        "EventCode": "0x54",
-        "EventName": "UNC_H_OSB_EDR.READS_REMOTE_I",
+        "BriefDescription": "Cycles without QPI Ingress Credits; AD to QPI=
 Link 0",
+        "EventCode": "0x22",
+        "EventName": "UNC_H_IGR_NO_CREDIT_CYCLES.AD_QPI0",
         "PerPkg": "1",
-        "UMask": "0x4",
+        "PublicDescription": "Counts the number of cycles when the HA does=
 not have credits to send messages to the QPI Agent.  This can be filtered =
by the different credit pools and the different links.",
+        "UMask": "0x1",
         "Unit": "HA"
     },
     {
-        "BriefDescription": "OSB Early Data Return; Reads to Local S",
-        "Counter": "0,1,2,3",
-        "EventCode": "0x54",
-        "EventName": "UNC_H_OSB_EDR.READS_LOCAL_S",
+        "BriefDescription": "Cycles without QPI Ingress Credits; AD to QPI=
 Link 1",
+        "EventCode": "0x22",
+        "EventName": "UNC_H_IGR_NO_CREDIT_CYCLES.AD_QPI1",
         "PerPkg": "1",
-        "UMask": "0x8",
+        "PublicDescription": "Counts the number of cycles when the HA does=
 not have credits to send messages to the QPI Agent.  This can be filtered =
by the different credit pools and the different links.",
+        "UMask": "0x2",
         "Unit": "HA"
     },
     {
-        "BriefDescription": "OSB Early Data Return; Reads to Remote S",
-        "Counter": "0,1,2,3",
-        "EventCode": "0x54",
-        "EventName": "UNC_H_OSB_EDR.READS_REMOTE_S",
+        "BriefDescription": "Cycles without QPI Ingress Credits; BL to QPI=
 Link 0",
+        "EventCode": "0x22",
+        "EventName": "UNC_H_IGR_NO_CREDIT_CYCLES.AD_QPI2",
         "PerPkg": "1",
+        "PublicDescription": "Counts the number of cycles when the HA does=
 not have credits to send messages to the QPI Agent.  This can be filtered =
by the different credit pools and the different links.",
         "UMask": "0x10",
         "Unit": "HA"
     },
     {
-        "BriefDescription": "Read and Write Requests; Reads",
-        "Counter": "0,1,2,3",
-        "EventCode": "0x1",
-        "EventName": "UNC_H_REQUESTS.READS",
+        "BriefDescription": "Cycles without QPI Ingress Credits; BL to QPI=
 Link 0",
+        "EventCode": "0x22",
+        "EventName": "UNC_H_IGR_NO_CREDIT_CYCLES.BL_QPI0",
         "PerPkg": "1",
-        "UMask": "0x3",
+        "PublicDescription": "Counts the number of cycles when the HA does=
 not have credits to send messages to the QPI Agent.  This can be filtered =
by the different credit pools and the different links.",
+        "UMask": "0x4",
         "Unit": "HA"
     },
     {
-        "BriefDescription": "Read and Write Requests; Writes",
-        "Counter": "0,1,2,3",
-        "EventCode": "0x1",
-        "EventName": "UNC_H_REQUESTS.WRITES",
+        "BriefDescription": "Cycles without QPI Ingress Credits; BL to QPI=
 Link 1",
+        "EventCode": "0x22",
+        "EventName": "UNC_H_IGR_NO_CREDIT_CYCLES.BL_QPI1",
         "PerPkg": "1",
-        "UMask": "0xC",
+        "PublicDescription": "Counts the number of cycles when the HA does=
 not have credits to send messages to the QPI Agent.  This can be filtered =
by the different credit pools and the different links.",
+        "UMask": "0x8",
         "Unit": "HA"
     },
     {
-        "BriefDescription": "Read and Write Requests; Local Reads",
-        "Counter": "0,1,2,3",
-        "EventCode": "0x1",
-        "EventName": "UNC_H_REQUESTS.READS_LOCAL",
+        "BriefDescription": "Cycles without QPI Ingress Credits; BL to QPI=
 Link 1",
+        "EventCode": "0x22",
+        "EventName": "UNC_H_IGR_NO_CREDIT_CYCLES.BL_QPI2",
         "PerPkg": "1",
-        "UMask": "0x1",
+        "PublicDescription": "Counts the number of cycles when the HA does=
 not have credits to send messages to the QPI Agent.  This can be filtered =
by the different credit pools and the different links.",
+        "UMask": "0x20",
         "Unit": "HA"
     },
     {
-        "BriefDescription": "Read and Write Requests; Remote Reads",
-        "Counter": "0,1,2,3",
-        "EventCode": "0x1",
-        "EventName": "UNC_H_REQUESTS.READS_REMOTE",
+        "BriefDescription": "HA to iMC Normal Priority Reads Issued; Norma=
l Priority",
+        "EventCode": "0x17",
+        "EventName": "UNC_H_IMC_READS.NORMAL",
         "PerPkg": "1",
-        "UMask": "0x2",
+        "PublicDescription": "Count of the number of reads issued to any o=
f the memory controller channels.  This can be filtered by the priority of =
the reads.",
+        "UMask": "0x1",
         "Unit": "HA"
     },
     {
-        "BriefDescription": "Read and Write Requests; Local Writes",
-        "Counter": "0,1,2,3",
-        "EventCode": "0x1",
-        "EventName": "UNC_H_REQUESTS.WRITES_LOCAL",
+        "BriefDescription": "Retry Events",
+        "EventCode": "0x1E",
+        "EventName": "UNC_H_IMC_RETRY",
         "PerPkg": "1",
-        "UMask": "0x4",
+        "PublicDescription": "UNC_H_IMC_RETRY",
         "Unit": "HA"
     },
     {
-        "BriefDescription": "Read and Write Requests; Remote Writes",
-        "Counter": "0,1,2,3",
-        "EventCode": "0x1",
-        "EventName": "UNC_H_REQUESTS.WRITES_REMOTE",
+        "BriefDescription": "HA to iMC Full Line Writes Issued; All Writes=
",
+        "EventCode": "0x1A",
+        "EventName": "UNC_H_IMC_WRITES.ALL",
         "PerPkg": "1",
-        "UMask": "0x8",
+        "PublicDescription": "Counts the total number of full line writes =
issued from the HA into the memory controller.  This counts for all four ch=
annels.  It can be filtered by full/partial and ISOCH/non-ISOCH.",
+        "UMask": "0xf",
         "Unit": "HA"
     },
     {
-        "BriefDescription": "Read and Write Requests; Local InvItoEs",
-        "Counter": "0,1,2,3",
-        "EventCode": "0x1",
-        "EventName": "UNC_H_REQUESTS.INVITOE_LOCAL",
+        "BriefDescription": "HA to iMC Full Line Writes Issued; Full Line =
Non-ISOCH",
+        "EventCode": "0x1A",
+        "EventName": "UNC_H_IMC_WRITES.FULL",
         "PerPkg": "1",
-        "UMask": "0x10",
+        "PublicDescription": "Counts the total number of full line writes =
issued from the HA into the memory controller.  This counts for all four ch=
annels.  It can be filtered by full/partial and ISOCH/non-ISOCH.",
+        "UMask": "0x1",
         "Unit": "HA"
     },
     {
-        "BriefDescription": "Read and Write Requests; Remote InvItoEs",
-        "Counter": "0,1,2,3",
-        "EventCode": "0x1",
-        "EventName": "UNC_H_REQUESTS.INVITOE_REMOTE",
+        "BriefDescription": "HA to iMC Full Line Writes Issued; ISOCH Full=
 Line",
+        "EventCode": "0x1A",
+        "EventName": "UNC_H_IMC_WRITES.FULL_ISOCH",
         "PerPkg": "1",
-        "UMask": "0x20",
+        "PublicDescription": "Counts the total number of full line writes =
issued from the HA into the memory controller.  This counts for all four ch=
annels.  It can be filtered by full/partial and ISOCH/non-ISOCH.",
+        "UMask": "0x4",
         "Unit": "HA"
     },
     {
-        "BriefDescription": "HA AD Ring in Use; Clockwise and Even",
-        "Counter": "0,1,2,3",
-        "EventCode": "0x3E",
-        "EventName": "UNC_H_RING_AD_USED.CW_EVEN",
+        "BriefDescription": "HA to iMC Full Line Writes Issued; Partial No=
n-ISOCH",
+        "EventCode": "0x1A",
+        "EventName": "UNC_H_IMC_WRITES.PARTIAL",
         "PerPkg": "1",
-        "UMask": "0x1",
+        "PublicDescription": "Counts the total number of full line writes =
issued from the HA into the memory controller.  This counts for all four ch=
annels.  It can be filtered by full/partial and ISOCH/non-ISOCH.",
+        "UMask": "0x2",
         "Unit": "HA"
     },
     {
-        "BriefDescription": "HA AD Ring in Use; Clockwise and Odd",
-        "Counter": "0,1,2,3",
-        "EventCode": "0x3E",
-        "EventName": "UNC_H_RING_AD_USED.CW_ODD",
+        "BriefDescription": "HA to iMC Full Line Writes Issued; ISOCH Part=
ial",
+        "EventCode": "0x1A",
+        "EventName": "UNC_H_IMC_WRITES.PARTIAL_ISOCH",
         "PerPkg": "1",
-        "UMask": "0x2",
+        "PublicDescription": "Counts the total number of full line writes =
issued from the HA into the memory controller.  This counts for all four ch=
annels.  It can be filtered by full/partial and ISOCH/non-ISOCH.",
+        "UMask": "0x8",
         "Unit": "HA"
     },
     {
-        "BriefDescription": "HA AD Ring in Use; Counterclockwise and Even"=
,
-        "Counter": "0,1,2,3",
-        "EventCode": "0x3E",
-        "EventName": "UNC_H_RING_AD_USED.CCW_EVEN",
+        "BriefDescription": "IOT Backpressure",
+        "EventCode": "0x61",
+        "EventName": "UNC_H_IOT_BACKPRESSURE.HUB",
         "PerPkg": "1",
-        "UMask": "0x4",
+        "PublicDescription": "UNC_H_IOT_BACKPRESSURE.HUB",
+        "UMask": "0x2",
         "Unit": "HA"
     },
     {
-        "BriefDescription": "HA AD Ring in Use; Counterclockwise and Odd",
-        "Counter": "0,1,2,3",
-        "EventCode": "0x3E",
-        "EventName": "UNC_H_RING_AD_USED.CCW_ODD",
+        "BriefDescription": "IOT Backpressure",
+        "EventCode": "0x61",
+        "EventName": "UNC_H_IOT_BACKPRESSURE.SAT",
         "PerPkg": "1",
-        "UMask": "0x8",
+        "PublicDescription": "UNC_H_IOT_BACKPRESSURE.SAT",
+        "UMask": "0x1",
         "Unit": "HA"
     },
     {
-        "BriefDescription": "HA AD Ring in Use; Clockwise",
-        "Counter": "0,1,2,3",
-        "EventCode": "0x3E",
-        "EventName": "UNC_H_RING_AD_USED.CW",
+        "BriefDescription": "IOT Common Trigger Sequencer - Lo",
+        "EventCode": "0x64",
+        "EventName": "UNC_H_IOT_CTS_EAST_LO.CTS0",
         "PerPkg": "1",
-        "UMask": "0x3",
+        "PublicDescription": "Debug Mask/Match Tie-Ins",
+        "UMask": "0x1",
         "Unit": "HA"
     },
     {
-        "BriefDescription": "HA AD Ring in Use; Counterclockwise",
-        "Counter": "0,1,2,3",
-        "EventCode": "0x3E",
-        "EventName": "UNC_H_RING_AD_USED.CCW",
+        "BriefDescription": "IOT Common Trigger Sequencer - Lo",
+        "EventCode": "0x64",
+        "EventName": "UNC_H_IOT_CTS_EAST_LO.CTS1",
         "PerPkg": "1",
-        "UMask": "0xC",
+        "PublicDescription": "Debug Mask/Match Tie-Ins",
+        "UMask": "0x2",
         "Unit": "HA"
     },
     {
-        "BriefDescription": "HA AK Ring in Use; Clockwise and Even",
-        "Counter": "0,1,2,3",
-        "EventCode": "0x3F",
-        "EventName": "UNC_H_RING_AK_USED.CW_EVEN",
+        "BriefDescription": "IOT Common Trigger Sequencer - Hi",
+        "EventCode": "0x65",
+        "EventName": "UNC_H_IOT_CTS_HI.CTS2",
         "PerPkg": "1",
+        "PublicDescription": "Debug Mask/Match Tie-Ins",
         "UMask": "0x1",
         "Unit": "HA"
     },
     {
-        "BriefDescription": "HA AK Ring in Use; Clockwise and Odd",
-        "Counter": "0,1,2,3",
-        "EventCode": "0x3F",
-        "EventName": "UNC_H_RING_AK_USED.CW_ODD",
+        "BriefDescription": "IOT Common Trigger Sequencer - Hi",
+        "EventCode": "0x65",
+        "EventName": "UNC_H_IOT_CTS_HI.CTS3",
         "PerPkg": "1",
+        "PublicDescription": "Debug Mask/Match Tie-Ins",
         "UMask": "0x2",
         "Unit": "HA"
     },
     {
-        "BriefDescription": "HA AK Ring in Use; Counterclockwise and Even"=
,
-        "Counter": "0,1,2,3",
-        "EventCode": "0x3F",
-        "EventName": "UNC_H_RING_AK_USED.CCW_EVEN",
+        "BriefDescription": "IOT Common Trigger Sequencer - Lo",
+        "EventCode": "0x62",
+        "EventName": "UNC_H_IOT_CTS_WEST_LO.CTS0",
         "PerPkg": "1",
-        "UMask": "0x4",
+        "PublicDescription": "Debug Mask/Match Tie-Ins",
+        "UMask": "0x1",
         "Unit": "HA"
     },
     {
-        "BriefDescription": "HA AK Ring in Use; Counterclockwise and Odd",
-        "Counter": "0,1,2,3",
-        "EventCode": "0x3F",
-        "EventName": "UNC_H_RING_AK_USED.CCW_ODD",
+        "BriefDescription": "IOT Common Trigger Sequencer - Lo",
+        "EventCode": "0x62",
+        "EventName": "UNC_H_IOT_CTS_WEST_LO.CTS1",
         "PerPkg": "1",
-        "UMask": "0x8",
+        "PublicDescription": "Debug Mask/Match Tie-Ins",
+        "UMask": "0x2",
         "Unit": "HA"
     },
     {
-        "BriefDescription": "HA AK Ring in Use; Clockwise",
-        "Counter": "0,1,2,3",
-        "EventCode": "0x3F",
-        "EventName": "UNC_H_RING_AK_USED.CW",
+        "BriefDescription": "OSB Snoop Broadcast; Cancelled",
+        "EventCode": "0x53",
+        "EventName": "UNC_H_OSB.CANCELLED",
         "PerPkg": "1",
-        "UMask": "0x3",
+        "PublicDescription": "Count of OSB snoop broadcasts. Counts by 1 p=
er request causing OSB snoops to be broadcast. Does not count all the snoop=
s generated by OSB.; OSB Snoop broadcast cancelled due to D2C or Other. OSB=
 cancel is counted when OSB local read is not allowed even when the transac=
tion in local InItoE. It also counts D2C OSB cancel, but also includes the =
cases were D2C was not set in the first place for the transaction coming fr=
om the ring.",
+        "UMask": "0x10",
         "Unit": "HA"
     },
     {
-        "BriefDescription": "HA AK Ring in Use; Counterclockwise",
-        "Counter": "0,1,2,3",
-        "EventCode": "0x3F",
-        "EventName": "UNC_H_RING_AK_USED.CCW",
+        "BriefDescription": "OSB Snoop Broadcast; Local InvItoE",
+        "EventCode": "0x53",
+        "EventName": "UNC_H_OSB.INVITOE_LOCAL",
         "PerPkg": "1",
-        "UMask": "0xC",
+        "PublicDescription": "Count of OSB snoop broadcasts. Counts by 1 p=
er request causing OSB snoops to be broadcast. Does not count all the snoop=
s generated by OSB.",
+        "UMask": "0x4",
         "Unit": "HA"
     },
     {
-        "BriefDescription": "HA BL Ring in Use; Clockwise and Even",
-        "Counter": "0,1,2,3",
-        "EventCode": "0x40",
-        "EventName": "UNC_H_RING_BL_USED.CW_EVEN",
+        "BriefDescription": "OSB Snoop Broadcast; Local Reads",
+        "EventCode": "0x53",
+        "EventName": "UNC_H_OSB.READS_LOCAL",
         "PerPkg": "1",
-        "UMask": "0x1",
+        "PublicDescription": "Count of OSB snoop broadcasts. Counts by 1 p=
er request causing OSB snoops to be broadcast. Does not count all the snoop=
s generated by OSB.",
+        "UMask": "0x2",
         "Unit": "HA"
     },
     {
-        "BriefDescription": "HA BL Ring in Use; Clockwise and Odd",
-        "Counter": "0,1,2,3",
-        "EventCode": "0x40",
-        "EventName": "UNC_H_RING_BL_USED.CW_ODD",
+        "BriefDescription": "OSB Snoop Broadcast; Reads Local -  Useful",
+        "EventCode": "0x53",
+        "EventName": "UNC_H_OSB.READS_LOCAL_USEFUL",
         "PerPkg": "1",
-        "UMask": "0x2",
+        "PublicDescription": "Count of OSB snoop broadcasts. Counts by 1 p=
er request causing OSB snoops to be broadcast. Does not count all the snoop=
s generated by OSB.",
+        "UMask": "0x20",
         "Unit": "HA"
     },
     {
-        "BriefDescription": "HA BL Ring in Use; Counterclockwise and Even"=
,
-        "Counter": "0,1,2,3",
-        "EventCode": "0x40",
-        "EventName": "UNC_H_RING_BL_USED.CCW_EVEN",
+        "BriefDescription": "OSB Snoop Broadcast; Remote",
+        "EventCode": "0x53",
+        "EventName": "UNC_H_OSB.REMOTE",
         "PerPkg": "1",
-        "UMask": "0x4",
+        "PublicDescription": "Count of OSB snoop broadcasts. Counts by 1 p=
er request causing OSB snoops to be broadcast. Does not count all the snoop=
s generated by OSB.",
+        "UMask": "0x8",
         "Unit": "HA"
     },
     {
-        "BriefDescription": "HA BL Ring in Use; Counterclockwise and Odd",
-        "Counter": "0,1,2,3",
-        "EventCode": "0x40",
-        "EventName": "UNC_H_RING_BL_USED.CCW_ODD",
+        "BriefDescription": "OSB Snoop Broadcast; Remote - Useful",
+        "EventCode": "0x53",
+        "EventName": "UNC_H_OSB.REMOTE_USEFUL",
         "PerPkg": "1",
-        "UMask": "0x8",
+        "PublicDescription": "Count of OSB snoop broadcasts. Counts by 1 p=
er request causing OSB snoops to be broadcast. Does not count all the snoop=
s generated by OSB.",
+        "UMask": "0x40",
         "Unit": "HA"
     },
     {
-        "BriefDescription": "HA BL Ring in Use; Clockwise",
-        "Counter": "0,1,2,3",
-        "EventCode": "0x40",
-        "EventName": "UNC_H_RING_BL_USED.CW",
+        "BriefDescription": "OSB Early Data Return; All",
+        "EventCode": "0x54",
+        "EventName": "UNC_H_OSB_EDR.ALL",
         "PerPkg": "1",
-        "UMask": "0x3",
+        "PublicDescription": "Counts the number of transactions that broad=
cast snoop due to OSB, but found clean data in memory and was able to do ea=
rly data return",
+        "UMask": "0x1",
         "Unit": "HA"
     },
     {
-        "BriefDescription": "HA BL Ring in Use; Counterclockwise",
-        "Counter": "0,1,2,3",
-        "EventCode": "0x40",
-        "EventName": "UNC_H_RING_BL_USED.CCW",
+        "BriefDescription": "OSB Early Data Return; Reads to Local  I",
+        "EventCode": "0x54",
+        "EventName": "UNC_H_OSB_EDR.READS_LOCAL_I",
         "PerPkg": "1",
-        "UMask": "0xC",
+        "PublicDescription": "Counts the number of transactions that broad=
cast snoop due to OSB, but found clean data in memory and was able to do ea=
rly data return",
+        "UMask": "0x2",
         "Unit": "HA"
     },
     {
-        "BriefDescription": "iMC RPQ Credits Empty - Regular; Channel 0",
-        "Counter": "0,1,2,3",
-        "EventCode": "0x15",
-        "EventName": "UNC_H_RPQ_CYCLES_NO_REG_CREDITS.CHN0",
+        "BriefDescription": "OSB Early Data Return; Reads to Local S",
+        "EventCode": "0x54",
+        "EventName": "UNC_H_OSB_EDR.READS_LOCAL_S",
         "PerPkg": "1",
-        "UMask": "0x1",
+        "PublicDescription": "Counts the number of transactions that broad=
cast snoop due to OSB, but found clean data in memory and was able to do ea=
rly data return",
+        "UMask": "0x8",
         "Unit": "HA"
     },
     {
-        "BriefDescription": "iMC RPQ Credits Empty - Regular; Channel 1",
-        "Counter": "0,1,2,3",
-        "EventCode": "0x15",
-        "EventName": "UNC_H_RPQ_CYCLES_NO_REG_CREDITS.CHN1",
+        "BriefDescription": "OSB Early Data Return; Reads to Remote I",
+        "EventCode": "0x54",
+        "EventName": "UNC_H_OSB_EDR.READS_REMOTE_I",
         "PerPkg": "1",
-        "UMask": "0x2",
+        "PublicDescription": "Counts the number of transactions that broad=
cast snoop due to OSB, but found clean data in memory and was able to do ea=
rly data return",
+        "UMask": "0x4",
         "Unit": "HA"
     },
     {
-        "BriefDescription": "iMC RPQ Credits Empty - Regular; Channel 2",
-        "Counter": "0,1,2,3",
-        "EventCode": "0x15",
-        "EventName": "UNC_H_RPQ_CYCLES_NO_REG_CREDITS.CHN2",
+        "BriefDescription": "OSB Early Data Return; Reads to Remote S",
+        "EventCode": "0x54",
+        "EventName": "UNC_H_OSB_EDR.READS_REMOTE_S",
         "PerPkg": "1",
-        "UMask": "0x4",
+        "PublicDescription": "Counts the number of transactions that broad=
cast snoop due to OSB, but found clean data in memory and was able to do ea=
rly data return",
+        "UMask": "0x10",
         "Unit": "HA"
     },
     {
-        "BriefDescription": "iMC RPQ Credits Empty - Regular; Channel 3",
-        "Counter": "0,1,2,3",
-        "EventCode": "0x15",
-        "EventName": "UNC_H_RPQ_CYCLES_NO_REG_CREDITS.CHN3",
+        "BriefDescription": "Read and Write Requests; Local InvItoEs",
+        "EventCode": "0x1",
+        "EventName": "UNC_H_REQUESTS.INVITOE_LOCAL",
         "PerPkg": "1",
-        "UMask": "0x8",
+        "PublicDescription": "Counts the total number of read requests mad=
e into the Home Agent. Reads include all read opcodes (including RFO).  Wri=
tes include all writes (streaming, evictions, HitM, etc).; This filter incl=
udes only InvItoEs coming from the local socket.",
+        "UMask": "0x10",
         "Unit": "HA"
     },
     {
-        "BriefDescription": "SBo0 Credits Acquired; For AD Ring",
-        "Counter": "0,1,2,3",
-        "EventCode": "0x68",
-        "EventName": "UNC_H_SBO0_CREDITS_ACQUIRED.AD",
+        "BriefDescription": "Read and Write Requests; Remote InvItoEs",
+        "EventCode": "0x1",
+        "EventName": "UNC_H_REQUESTS.INVITOE_REMOTE",
         "PerPkg": "1",
-        "UMask": "0x1",
+        "PublicDescription": "Counts the total number of read requests mad=
e into the Home Agent. Reads include all read opcodes (including RFO).  Wri=
tes include all writes (streaming, evictions, HitM, etc).; This filter incl=
udes only InvItoEs coming from remote sockets.",
+        "UMask": "0x20",
         "Unit": "HA"
     },
     {
-        "BriefDescription": "SBo0 Credits Acquired; For BL Ring",
-        "Counter": "0,1,2,3",
-        "EventCode": "0x68",
-        "EventName": "UNC_H_SBO0_CREDITS_ACQUIRED.BL",
+        "BriefDescription": "Read and Write Requests; Reads",
+        "EventCode": "0x1",
+        "EventName": "UNC_H_REQUESTS.READS",
         "PerPkg": "1",
-        "UMask": "0x2",
+        "PublicDescription": "Counts the total number of read requests mad=
e into the Home Agent. Reads include all read opcodes (including RFO).  Wri=
tes include all writes (streaming, evictions, HitM, etc).; Incoming ead req=
uests.  This is a good proxy for LLC Read Misses (including RFOs).",
+        "UMask": "0x3",
         "Unit": "HA"
     },
     {
-        "BriefDescription": "SBo0 Credits Occupancy; For AD Ring",
-        "Counter": "0,1,2,3",
-        "EventCode": "0x6A",
-        "EventName": "UNC_H_SBO0_CREDIT_OCCUPANCY.AD",
+        "BriefDescription": "Read and Write Requests; Local Reads",
+        "EventCode": "0x1",
+        "EventName": "UNC_H_REQUESTS.READS_LOCAL",
         "PerPkg": "1",
+        "PublicDescription": "Counts the total number of read requests mad=
e into the Home Agent. Reads include all read opcodes (including RFO).  Wri=
tes include all writes (streaming, evictions, HitM, etc).; This filter incl=
udes only read requests coming from the local socket.  This is a good proxy=
 for LLC Read Misses (including RFOs) from the local socket.",
         "UMask": "0x1",
         "Unit": "HA"
     },
     {
-        "BriefDescription": "SBo0 Credits Occupancy; For BL Ring",
-        "Counter": "0,1,2,3",
-        "EventCode": "0x6A",
-        "EventName": "UNC_H_SBO0_CREDIT_OCCUPANCY.BL",
+        "BriefDescription": "Read and Write Requests; Remote Reads",
+        "EventCode": "0x1",
+        "EventName": "UNC_H_REQUESTS.READS_REMOTE",
         "PerPkg": "1",
+        "PublicDescription": "Counts the total number of read requests mad=
e into the Home Agent. Reads include all read opcodes (including RFO).  Wri=
tes include all writes (streaming, evictions, HitM, etc).; This filter incl=
udes only read requests coming from the remote socket.  This is a good prox=
y for LLC Read Misses (including RFOs) from the remote socket.",
         "UMask": "0x2",
         "Unit": "HA"
     },
     {
-        "BriefDescription": "SBo1 Credits Acquired; For AD Ring",
-        "Counter": "0,1,2,3",
-        "EventCode": "0x69",
-        "EventName": "UNC_H_SBO1_CREDITS_ACQUIRED.AD",
+        "BriefDescription": "Read and Write Requests; Writes",
+        "EventCode": "0x1",
+        "EventName": "UNC_H_REQUESTS.WRITES",
         "PerPkg": "1",
-        "UMask": "0x1",
+        "PublicDescription": "Counts the total number of read requests mad=
e into the Home Agent. Reads include all read opcodes (including RFO).  Wri=
tes include all writes (streaming, evictions, HitM, etc).; Incoming write r=
equests.",
+        "UMask": "0xc",
         "Unit": "HA"
     },
     {
-        "BriefDescription": "SBo1 Credits Acquired; For BL Ring",
-        "Counter": "0,1,2,3",
-        "EventCode": "0x69",
-        "EventName": "UNC_H_SBO1_CREDITS_ACQUIRED.BL",
+        "BriefDescription": "Read and Write Requests; Local Writes",
+        "EventCode": "0x1",
+        "EventName": "UNC_H_REQUESTS.WRITES_LOCAL",
         "PerPkg": "1",
-        "UMask": "0x2",
+        "PublicDescription": "Counts the total number of read requests mad=
e into the Home Agent. Reads include all read opcodes (including RFO).  Wri=
tes include all writes (streaming, evictions, HitM, etc).; This filter incl=
udes only writes coming from the local socket.",
+        "UMask": "0x4",
         "Unit": "HA"
     },
     {
-        "BriefDescription": "SBo1 Credits Occupancy; For AD Ring",
-        "Counter": "0,1,2,3",
-        "EventCode": "0x6B",
-        "EventName": "UNC_H_SBO1_CREDIT_OCCUPANCY.AD",
+        "BriefDescription": "Read and Write Requests; Remote Writes",
+        "EventCode": "0x1",
+        "EventName": "UNC_H_REQUESTS.WRITES_REMOTE",
         "PerPkg": "1",
-        "UMask": "0x1",
+        "PublicDescription": "Counts the total number of read requests mad=
e into the Home Agent. Reads include all read opcodes (including RFO).  Wri=
tes include all writes (streaming, evictions, HitM, etc).; This filter incl=
udes only writes coming from remote sockets.",
+        "UMask": "0x8",
         "Unit": "HA"
     },
     {
-        "BriefDescription": "SBo1 Credits Occupancy; For BL Ring",
-        "Counter": "0,1,2,3",
-        "EventCode": "0x6B",
-        "EventName": "UNC_H_SBO1_CREDIT_OCCUPANCY.BL",
+        "BriefDescription": "HA AD Ring in Use; Counterclockwise",
+        "EventCode": "0x3E",
+        "EventName": "UNC_H_RING_AD_USED.CCW",
         "PerPkg": "1",
-        "UMask": "0x2",
+        "PublicDescription": "Counts the number of cycles that the AD ring=
 is being used at this ring stop.  This includes when packets are passing b=
y and when packets are being sunk, but does not include when packets are be=
ing sent from the ring stop.",
+        "UMask": "0xc",
         "Unit": "HA"
     },
     {
-        "BriefDescription": "Data beat the Snoop Responses; Local Requests=
",
-        "Counter": "0,1,2,3",
-        "EventCode": "0xA",
-        "EventName": "UNC_H_SNOOPS_RSP_AFTER_DATA.LOCAL",
+        "BriefDescription": "HA AD Ring in Use; Counterclockwise and Even"=
,
+        "EventCode": "0x3E",
+        "EventName": "UNC_H_RING_AD_USED.CCW_EVEN",
         "PerPkg": "1",
-        "UMask": "0x1",
+        "PublicDescription": "Counts the number of cycles that the AD ring=
 is being used at this ring stop.  This includes when packets are passing b=
y and when packets are being sunk, but does not include when packets are be=
ing sent from the ring stop.; Filters for the Counterclockwise and Even rin=
g polarity.",
+        "UMask": "0x4",
         "Unit": "HA"
     },
     {
-        "BriefDescription": "Data beat the Snoop Responses; Remote Request=
s",
-        "Counter": "0,1,2,3",
-        "EventCode": "0xA",
-        "EventName": "UNC_H_SNOOPS_RSP_AFTER_DATA.REMOTE",
+        "BriefDescription": "HA AD Ring in Use; Counterclockwise and Odd",
+        "EventCode": "0x3E",
+        "EventName": "UNC_H_RING_AD_USED.CCW_ODD",
         "PerPkg": "1",
-        "UMask": "0x2",
+        "PublicDescription": "Counts the number of cycles that the AD ring=
 is being used at this ring stop.  This includes when packets are passing b=
y and when packets are being sunk, but does not include when packets are be=
ing sent from the ring stop.; Filters for the Counterclockwise and Odd ring=
 polarity.",
+        "UMask": "0x8",
         "Unit": "HA"
     },
     {
-        "BriefDescription": "Cycles with Snoops Outstanding; Local Request=
s",
-        "Counter": "0,1,2,3",
-        "EventCode": "0x8",
-        "EventName": "UNC_H_SNOOP_CYCLES_NE.LOCAL",
+        "BriefDescription": "HA AD Ring in Use; Clockwise",
+        "EventCode": "0x3E",
+        "EventName": "UNC_H_RING_AD_USED.CW",
+        "PerPkg": "1",
+        "PublicDescription": "Counts the number of cycles that the AD ring=
 is being used at this ring stop.  This includes when packets are passing b=
y and when packets are being sunk, but does not include when packets are be=
ing sent from the ring stop.",
+        "UMask": "0x3",
+        "Unit": "HA"
+    },
+    {
+        "BriefDescription": "HA AD Ring in Use; Clockwise and Even",
+        "EventCode": "0x3E",
+        "EventName": "UNC_H_RING_AD_USED.CW_EVEN",
         "PerPkg": "1",
+        "PublicDescription": "Counts the number of cycles that the AD ring=
 is being used at this ring stop.  This includes when packets are passing b=
y and when packets are being sunk, but does not include when packets are be=
ing sent from the ring stop.; Filters for the Clockwise and Even ring polar=
ity.",
         "UMask": "0x1",
         "Unit": "HA"
     },
     {
-        "BriefDescription": "Cycles with Snoops Outstanding; Remote Reques=
ts",
-        "Counter": "0,1,2,3",
-        "EventCode": "0x8",
-        "EventName": "UNC_H_SNOOP_CYCLES_NE.REMOTE",
+        "BriefDescription": "HA AD Ring in Use; Clockwise and Odd",
+        "EventCode": "0x3E",
+        "EventName": "UNC_H_RING_AD_USED.CW_ODD",
         "PerPkg": "1",
+        "PublicDescription": "Counts the number of cycles that the AD ring=
 is being used at this ring stop.  This includes when packets are passing b=
y and when packets are being sunk, but does not include when packets are be=
ing sent from the ring stop.; Filters for the Clockwise and Odd ring polari=
ty.",
         "UMask": "0x2",
         "Unit": "HA"
     },
     {
-        "BriefDescription": "Cycles with Snoops Outstanding; All Requests"=
,
-        "Counter": "0,1,2,3",
-        "EventCode": "0x8",
-        "EventName": "UNC_H_SNOOP_CYCLES_NE.ALL",
+        "BriefDescription": "HA AK Ring in Use; All",
+        "EventCode": "0x3F",
+        "EventName": "UNC_H_RING_AK_USED.ALL",
         "PerPkg": "1",
-        "UMask": "0x3",
+        "PublicDescription": "Counts the number of cycles that the AK ring=
 is being used at this ring stop.  This includes when packets are passing b=
y and when packets are being sunk, but does not include when packets are be=
ing sent from the ring stop.",
+        "UMask": "0xf",
         "Unit": "HA"
     },
     {
-        "BriefDescription": "Tracker Snoops Outstanding Accumulator; Local=
 Requests",
-        "Counter": "0,1,2,3",
-        "EventCode": "0x9",
-        "EventName": "UNC_H_SNOOP_OCCUPANCY.LOCAL",
+        "BriefDescription": "HA AK Ring in Use; Counterclockwise",
+        "EventCode": "0x3F",
+        "EventName": "UNC_H_RING_AK_USED.CCW",
         "PerPkg": "1",
-        "UMask": "0x1",
+        "PublicDescription": "Counts the number of cycles that the AK ring=
 is being used at this ring stop.  This includes when packets are passing b=
y and when packets are being sunk, but does not include when packets are be=
ing sent from the ring stop.",
+        "UMask": "0xc",
         "Unit": "HA"
     },
     {
-        "BriefDescription": "Tracker Snoops Outstanding Accumulator; Remot=
e Requests",
-        "Counter": "0,1,2,3",
-        "EventCode": "0x9",
-        "EventName": "UNC_H_SNOOP_OCCUPANCY.REMOTE",
+        "BriefDescription": "HA AK Ring in Use; Counterclockwise and Even"=
,
+        "EventCode": "0x3F",
+        "EventName": "UNC_H_RING_AK_USED.CCW_EVEN",
         "PerPkg": "1",
-        "UMask": "0x2",
+        "PublicDescription": "Counts the number of cycles that the AK ring=
 is being used at this ring stop.  This includes when packets are passing b=
y and when packets are being sunk, but does not include when packets are be=
ing sent from the ring stop.; Filters for the Counterclockwise and Even rin=
g polarity.",
+        "UMask": "0x4",
         "Unit": "HA"
     },
     {
-        "BriefDescription": "Snoop Responses Received; RspI",
-        "Counter": "0,1,2,3",
-        "EventCode": "0x21",
-        "EventName": "UNC_H_SNOOP_RESP.RSPI",
+        "BriefDescription": "HA AK Ring in Use; Counterclockwise and Odd",
+        "EventCode": "0x3F",
+        "EventName": "UNC_H_RING_AK_USED.CCW_ODD",
         "PerPkg": "1",
-        "UMask": "0x1",
+        "PublicDescription": "Counts the number of cycles that the AK ring=
 is being used at this ring stop.  This includes when packets are passing b=
y and when packets are being sunk, but does not include when packets are be=
ing sent from the ring stop.; Filters for the Counterclockwise and Odd ring=
 polarity.",
+        "UMask": "0x8",
         "Unit": "HA"
     },
     {
-        "BriefDescription": "Shared line response from remote cache",
-        "Counter": "0,1,2,3",
-        "EventCode": "0x21",
-        "EventName": "UNC_H_SNOOP_RESP.RSPS",
+        "BriefDescription": "HA AK Ring in Use; Clockwise",
+        "EventCode": "0x3F",
+        "EventName": "UNC_H_RING_AK_USED.CW",
         "PerPkg": "1",
-        "ScaleUnit": "64Bytes",
-        "UMask": "0x2",
+        "PublicDescription": "Counts the number of cycles that the AK ring=
 is being used at this ring stop.  This includes when packets are passing b=
y and when packets are being sunk, but does not include when packets are be=
ing sent from the ring stop.",
+        "UMask": "0x3",
         "Unit": "HA"
     },
     {
-        "BriefDescription": "M line forwarded from remote cache with no wr=
iteback to memory",
-        "Counter": "0,1,2,3",
-        "EventCode": "0x21",
-        "EventName": "UNC_H_SNOOP_RESP.RSPIFWD",
+        "BriefDescription": "HA AK Ring in Use; Clockwise and Even",
+        "EventCode": "0x3F",
+        "EventName": "UNC_H_RING_AK_USED.CW_EVEN",
         "PerPkg": "1",
-        "ScaleUnit": "64Bytes",
-        "UMask": "0x4",
+        "PublicDescription": "Counts the number of cycles that the AK ring=
 is being used at this ring stop.  This includes when packets are passing b=
y and when packets are being sunk, but does not include when packets are be=
ing sent from the ring stop.; Filters for the Clockwise and Even ring polar=
ity.",
+        "UMask": "0x1",
         "Unit": "HA"
     },
     {
-        "BriefDescription": "Shared line forwarded from remote cache",
-        "Counter": "0,1,2,3",
-        "EventCode": "0x21",
-        "EventName": "UNC_H_SNOOP_RESP.RSPSFWD",
+        "BriefDescription": "HA AK Ring in Use; Clockwise and Odd",
+        "EventCode": "0x3F",
+        "EventName": "UNC_H_RING_AK_USED.CW_ODD",
         "PerPkg": "1",
-        "ScaleUnit": "64Bytes",
-        "UMask": "0x8",
+        "PublicDescription": "Counts the number of cycles that the AK ring=
 is being used at this ring stop.  This includes when packets are passing b=
y and when packets are being sunk, but does not include when packets are be=
ing sent from the ring stop.; Filters for the Clockwise and Odd ring polari=
ty.",
+        "UMask": "0x2",
         "Unit": "HA"
     },
     {
-        "BriefDescription": "Snoop Responses Received; Rsp*WB",
-        "Counter": "0,1,2,3",
-        "EventCode": "0x21",
-        "EventName": "UNC_H_SNOOP_RESP.RSP_WB",
+        "BriefDescription": "HA BL Ring in Use; All",
+        "EventCode": "0x40",
+        "EventName": "UNC_H_RING_BL_USED.ALL",
         "PerPkg": "1",
-        "UMask": "0x10",
+        "PublicDescription": "Counts the number of cycles that the BL ring=
 is being used at this ring stop.  This includes when packets are passing b=
y and when packets are being sunk, but does not include when packets are be=
ing sent from the ring stop.",
+        "UMask": "0xf",
         "Unit": "HA"
     },
     {
-        "BriefDescription": "M line forwarded from remote cache along with=
 writeback to memory",
-        "Counter": "0,1,2,3",
-        "EventCode": "0x21",
-        "EventName": "UNC_H_SNOOP_RESP.RSP_FWD_WB",
+        "BriefDescription": "HA BL Ring in Use; Counterclockwise",
+        "EventCode": "0x40",
+        "EventName": "UNC_H_RING_BL_USED.CCW",
         "PerPkg": "1",
-        "ScaleUnit": "64Bytes",
-        "UMask": "0x20",
+        "PublicDescription": "Counts the number of cycles that the BL ring=
 is being used at this ring stop.  This includes when packets are passing b=
y and when packets are being sunk, but does not include when packets are be=
ing sent from the ring stop.",
+        "UMask": "0xc",
         "Unit": "HA"
     },
     {
-        "BriefDescription": "Snoop Responses Received; RSPCNFLCT*",
-        "Counter": "0,1,2,3",
-        "EventCode": "0x21",
-        "EventName": "UNC_H_SNOOP_RESP.RSPCNFLCT",
+        "BriefDescription": "HA BL Ring in Use; Counterclockwise and Even"=
,
+        "EventCode": "0x40",
+        "EventName": "UNC_H_RING_BL_USED.CCW_EVEN",
         "PerPkg": "1",
-        "UMask": "0x40",
+        "PublicDescription": "Counts the number of cycles that the BL ring=
 is being used at this ring stop.  This includes when packets are passing b=
y and when packets are being sunk, but does not include when packets are be=
ing sent from the ring stop.; Filters for the Counterclockwise and Even rin=
g polarity.",
+        "UMask": "0x4",
         "Unit": "HA"
     },
     {
-        "BriefDescription": "Snoop Responses Received Local; RspI",
-        "Counter": "0,1,2,3",
-        "EventCode": "0x60",
-        "EventName": "UNC_H_SNP_RESP_RECV_LOCAL.RSPI",
+        "BriefDescription": "HA BL Ring in Use; Counterclockwise and Odd",
+        "EventCode": "0x40",
+        "EventName": "UNC_H_RING_BL_USED.CCW_ODD",
         "PerPkg": "1",
-        "UMask": "0x1",
+        "PublicDescription": "Counts the number of cycles that the BL ring=
 is being used at this ring stop.  This includes when packets are passing b=
y and when packets are being sunk, but does not include when packets are be=
ing sent from the ring stop.; Filters for the Counterclockwise and Odd ring=
 polarity.",
+        "UMask": "0x8",
         "Unit": "HA"
     },
     {
-        "BriefDescription": "Snoop Responses Received Local; RspS",
-        "Counter": "0,1,2,3",
-        "EventCode": "0x60",
-        "EventName": "UNC_H_SNP_RESP_RECV_LOCAL.RSPS",
+        "BriefDescription": "HA BL Ring in Use; Clockwise",
+        "EventCode": "0x40",
+        "EventName": "UNC_H_RING_BL_USED.CW",
         "PerPkg": "1",
-        "UMask": "0x2",
+        "PublicDescription": "Counts the number of cycles that the BL ring=
 is being used at this ring stop.  This includes when packets are passing b=
y and when packets are being sunk, but does not include when packets are be=
ing sent from the ring stop.",
+        "UMask": "0x3",
         "Unit": "HA"
     },
     {
-        "BriefDescription": "Snoop Responses Received Local; RspIFwd",
-        "Counter": "0,1,2,3",
-        "EventCode": "0x60",
-        "EventName": "UNC_H_SNP_RESP_RECV_LOCAL.RSPIFWD",
+        "BriefDescription": "HA BL Ring in Use; Clockwise and Even",
+        "EventCode": "0x40",
+        "EventName": "UNC_H_RING_BL_USED.CW_EVEN",
         "PerPkg": "1",
-        "UMask": "0x4",
+        "PublicDescription": "Counts the number of cycles that the BL ring=
 is being used at this ring stop.  This includes when packets are passing b=
y and when packets are being sunk, but does not include when packets are be=
ing sent from the ring stop.; Filters for the Clockwise and Even ring polar=
ity.",
+        "UMask": "0x1",
         "Unit": "HA"
     },
     {
-        "BriefDescription": "Snoop Responses Received Local; RspSFwd",
-        "Counter": "0,1,2,3",
-        "EventCode": "0x60",
-        "EventName": "UNC_H_SNP_RESP_RECV_LOCAL.RSPSFWD",
+        "BriefDescription": "HA BL Ring in Use; Clockwise and Odd",
+        "EventCode": "0x40",
+        "EventName": "UNC_H_RING_BL_USED.CW_ODD",
         "PerPkg": "1",
-        "UMask": "0x8",
+        "PublicDescription": "Counts the number of cycles that the BL ring=
 is being used at this ring stop.  This includes when packets are passing b=
y and when packets are being sunk, but does not include when packets are be=
ing sent from the ring stop.; Filters for the Clockwise and Odd ring polari=
ty.",
+        "UMask": "0x2",
         "Unit": "HA"
     },
     {
-        "BriefDescription": "Snoop Responses Received Local; Rsp*WB",
-        "Counter": "0,1,2,3",
-        "EventCode": "0x60",
-        "EventName": "UNC_H_SNP_RESP_RECV_LOCAL.RSPxWB",
+        "BriefDescription": "iMC RPQ Credits Empty - Regular; Channel 0",
+        "EventCode": "0x15",
+        "EventName": "UNC_H_RPQ_CYCLES_NO_REG_CREDITS.CHN0",
         "PerPkg": "1",
-        "UMask": "0x10",
+        "PublicDescription": "Counts the number of cycles when there are n=
o regular credits available for posting reads from the HA into the iMC.  In=
 order to send reads into the memory controller, the HA must first acquire =
a credit for the iMC's RPQ (read pending queue).  This queue is broken into=
 regular credits/buffers that are used by general reads, and special reques=
ts such as ISOCH reads.  This count only tracks the regular credits  Common=
 high banwidth workloads should be able to make use of all of the regular b=
uffers, but it will be difficult (and uncommon) to make use of both the reg=
ular and special buffers at the same time.  One can filter based on the mem=
ory controller channel.  One or more channels can be tracked at a given tim=
e.; Filter for memory controller channel 0 only.",
+        "UMask": "0x1",
         "Unit": "HA"
     },
     {
-        "BriefDescription": "Snoop Responses Received Local; Rsp*FWD*WB",
-        "Counter": "0,1,2,3",
-        "EventCode": "0x60",
-        "EventName": "UNC_H_SNP_RESP_RECV_LOCAL.RSPxFWDxWB",
+        "BriefDescription": "iMC RPQ Credits Empty - Regular; Channel 1",
+        "EventCode": "0x15",
+        "EventName": "UNC_H_RPQ_CYCLES_NO_REG_CREDITS.CHN1",
         "PerPkg": "1",
-        "UMask": "0x20",
+        "PublicDescription": "Counts the number of cycles when there are n=
o regular credits available for posting reads from the HA into the iMC.  In=
 order to send reads into the memory controller, the HA must first acquire =
a credit for the iMC's RPQ (read pending queue).  This queue is broken into=
 regular credits/buffers that are used by general reads, and special reques=
ts such as ISOCH reads.  This count only tracks the regular credits  Common=
 high banwidth workloads should be able to make use of all of the regular b=
uffers, but it will be difficult (and uncommon) to make use of both the reg=
ular and special buffers at the same time.  One can filter based on the mem=
ory controller channel.  One or more channels can be tracked at a given tim=
e.; Filter for memory controller channel 1 only.",
+        "UMask": "0x2",
         "Unit": "HA"
     },
     {
-        "BriefDescription": "Snoop Responses Received Local; RspCnflct",
-        "Counter": "0,1,2,3",
-        "EventCode": "0x60",
-        "EventName": "UNC_H_SNP_RESP_RECV_LOCAL.RSPCNFLCT",
+        "BriefDescription": "iMC RPQ Credits Empty - Regular; Channel 2",
+        "EventCode": "0x15",
+        "EventName": "UNC_H_RPQ_CYCLES_NO_REG_CREDITS.CHN2",
         "PerPkg": "1",
-        "UMask": "0x40",
+        "PublicDescription": "Counts the number of cycles when there are n=
o regular credits available for posting reads from the HA into the iMC.  In=
 order to send reads into the memory controller, the HA must first acquire =
a credit for the iMC's RPQ (read pending queue).  This queue is broken into=
 regular credits/buffers that are used by general reads, and special reques=
ts such as ISOCH reads.  This count only tracks the regular credits  Common=
 high banwidth workloads should be able to make use of all of the regular b=
uffers, but it will be difficult (and uncommon) to make use of both the reg=
ular and special buffers at the same time.  One can filter based on the mem=
ory controller channel.  One or more channels can be tracked at a given tim=
e.; Filter for memory controller channel 2 only.",
+        "UMask": "0x4",
         "Unit": "HA"
     },
     {
-        "BriefDescription": "Snoop Responses Received Local; Other",
-        "Counter": "0,1,2,3",
-        "EventCode": "0x60",
-        "EventName": "UNC_H_SNP_RESP_RECV_LOCAL.OTHER",
+        "BriefDescription": "iMC RPQ Credits Empty - Regular; Channel 3",
+        "EventCode": "0x15",
+        "EventName": "UNC_H_RPQ_CYCLES_NO_REG_CREDITS.CHN3",
         "PerPkg": "1",
-        "UMask": "0x80",
+        "PublicDescription": "Counts the number of cycles when there are n=
o regular credits available for posting reads from the HA into the iMC.  In=
 order to send reads into the memory controller, the HA must first acquire =
a credit for the iMC's RPQ (read pending queue).  This queue is broken into=
 regular credits/buffers that are used by general reads, and special reques=
ts such as ISOCH reads.  This count only tracks the regular credits  Common=
 high banwidth workloads should be able to make use of all of the regular b=
uffers, but it will be difficult (and uncommon) to make use of both the reg=
ular and special buffers at the same time.  One can filter based on the mem=
ory controller channel.  One or more channels can be tracked at a given tim=
e.; Filter for memory controller channel 3 only.",
+        "UMask": "0x8",
         "Unit": "HA"
     },
     {
-        "BriefDescription": "Stall on No Sbo Credits; For SBo0, AD Ring",
-        "Counter": "0,1,2,3",
-        "EventCode": "0x6C",
-        "EventName": "UNC_H_STALL_NO_SBO_CREDIT.SBO0_AD",
+        "BriefDescription": "iMC RPQ Credits Empty - Special; Channel 0",
+        "EventCode": "0x16",
+        "EventName": "UNC_H_RPQ_CYCLES_NO_SPEC_CREDITS.CHN0",
         "PerPkg": "1",
+        "PublicDescription": "Counts the number of cycles when there are n=
o special credits available for posting reads from the HA into the iMC.  In=
 order to send reads into the memory controller, the HA must first acquire =
a credit for the iMC's RPQ (read pending queue).  This queue is broken into=
 regular credits/buffers that are used by general reads, and special reques=
ts such as ISOCH reads.  This count only tracks the special credits.  This =
statistic is generally not interesting for general IA workloads, but may be=
 of interest for understanding the characteristics of systems using ISOCH. =
 One can filter based on the memory controller channel.  One or more channe=
ls can be tracked at a given time.; Filter for memory controller channel 0 =
only.",
         "UMask": "0x1",
         "Unit": "HA"
     },
     {
-        "BriefDescription": "Stall on No Sbo Credits; For SBo1, AD Ring",
-        "Counter": "0,1,2,3",
-        "EventCode": "0x6C",
-        "EventName": "UNC_H_STALL_NO_SBO_CREDIT.SBO1_AD",
+        "BriefDescription": "iMC RPQ Credits Empty - Special; Channel 1",
+        "EventCode": "0x16",
+        "EventName": "UNC_H_RPQ_CYCLES_NO_SPEC_CREDITS.CHN1",
         "PerPkg": "1",
+        "PublicDescription": "Counts the number of cycles when there are n=
o special credits available for posting reads from the HA into the iMC.  In=
 order to send reads into the memory controller, the HA must first acquire =
a credit for the iMC's RPQ (read pending queue).  This queue is broken into=
 regular credits/buffers that are used by general reads, and special reques=
ts such as ISOCH reads.  This count only tracks the special credits.  This =
statistic is generally not interesting for general IA workloads, but may be=
 of interest for understanding the characteristics of systems using ISOCH. =
 One can filter based on the memory controller channel.  One or more channe=
ls can be tracked at a given time.; Filter for memory controller channel 1 =
only.",
         "UMask": "0x2",
         "Unit": "HA"
     },
     {
-        "BriefDescription": "Stall on No Sbo Credits; For SBo0, BL Ring",
-        "Counter": "0,1,2,3",
-        "EventCode": "0x6C",
-        "EventName": "UNC_H_STALL_NO_SBO_CREDIT.SBO0_BL",
+        "BriefDescription": "iMC RPQ Credits Empty - Special; Channel 2",
+        "EventCode": "0x16",
+        "EventName": "UNC_H_RPQ_CYCLES_NO_SPEC_CREDITS.CHN2",
         "PerPkg": "1",
+        "PublicDescription": "Counts the number of cycles when there are n=
o special credits available for posting reads from the HA into the iMC.  In=
 order to send reads into the memory controller, the HA must first acquire =
a credit for the iMC's RPQ (read pending queue).  This queue is broken into=
 regular credits/buffers that are used by general reads, and special reques=
ts such as ISOCH reads.  This count only tracks the special credits.  This =
statistic is generally not interesting for general IA workloads, but may be=
 of interest for understanding the characteristics of systems using ISOCH. =
 One can filter based on the memory controller channel.  One or more channe=
ls can be tracked at a given time.; Filter for memory controller channel 2 =
only.",
         "UMask": "0x4",
         "Unit": "HA"
     },
     {
-        "BriefDescription": "Stall on No Sbo Credits; For SBo1, BL Ring",
-        "Counter": "0,1,2,3",
-        "EventCode": "0x6C",
-        "EventName": "UNC_H_STALL_NO_SBO_CREDIT.SBO1_BL",
+        "BriefDescription": "iMC RPQ Credits Empty - Special; Channel 3",
+        "EventCode": "0x16",
+        "EventName": "UNC_H_RPQ_CYCLES_NO_SPEC_CREDITS.CHN3",
         "PerPkg": "1",
+        "PublicDescription": "Counts the number of cycles when there are n=
o special credits available for posting reads from the HA into the iMC.  In=
 order to send reads into the memory controller, the HA must first acquire =
a credit for the iMC's RPQ (read pending queue).  This queue is broken into=
 regular credits/buffers that are used by general reads, and special reques=
ts such as ISOCH reads.  This count only tracks the special credits.  This =
statistic is generally not interesting for general IA workloads, but may be=
 of interest for understanding the characteristics of systems using ISOCH. =
 One can filter based on the memory controller channel.  One or more channe=
ls can be tracked at a given time.; Filter for memory controller channel 3 =
only.",
         "UMask": "0x8",
         "Unit": "HA"
     },
     {
-        "BriefDescription": "HA Requests to a TAD Region - Group 0; TAD Re=
gion 0",
-        "Counter": "0,1,2,3",
-        "EventCode": "0x1B",
-        "EventName": "UNC_H_TAD_REQUESTS_G0.REGION0",
+        "BriefDescription": "SBo0 Credits Acquired; For AD Ring",
+        "EventCode": "0x68",
+        "EventName": "UNC_H_SBO0_CREDITS_ACQUIRED.AD",
         "PerPkg": "1",
+        "PublicDescription": "Number of Sbo 0 credits acquired in a given =
cycle, per ring.",
         "UMask": "0x1",
         "Unit": "HA"
     },
     {
-        "BriefDescription": "HA Requests to a TAD Region - Group 0; TAD Re=
gion 1",
-        "Counter": "0,1,2,3",
-        "EventCode": "0x1B",
-        "EventName": "UNC_H_TAD_REQUESTS_G0.REGION1",
+        "BriefDescription": "SBo0 Credits Acquired; For BL Ring",
+        "EventCode": "0x68",
+        "EventName": "UNC_H_SBO0_CREDITS_ACQUIRED.BL",
         "PerPkg": "1",
+        "PublicDescription": "Number of Sbo 0 credits acquired in a given =
cycle, per ring.",
         "UMask": "0x2",
         "Unit": "HA"
     },
     {
-        "BriefDescription": "HA Requests to a TAD Region - Group 0; TAD Re=
gion 2",
-        "Counter": "0,1,2,3",
-        "EventCode": "0x1B",
-        "EventName": "UNC_H_TAD_REQUESTS_G0.REGION2",
+        "BriefDescription": "SBo0 Credits Occupancy; For AD Ring",
+        "EventCode": "0x6A",
+        "EventName": "UNC_H_SBO0_CREDIT_OCCUPANCY.AD",
         "PerPkg": "1",
-        "UMask": "0x4",
+        "PublicDescription": "Number of Sbo 0 credits in use in a given cy=
cle, per ring.",
+        "UMask": "0x1",
         "Unit": "HA"
     },
     {
-        "BriefDescription": "HA Requests to a TAD Region - Group 0; TAD Re=
gion 3",
-        "Counter": "0,1,2,3",
-        "EventCode": "0x1B",
-        "EventName": "UNC_H_TAD_REQUESTS_G0.REGION3",
+        "BriefDescription": "SBo0 Credits Occupancy; For BL Ring",
+        "EventCode": "0x6A",
+        "EventName": "UNC_H_SBO0_CREDIT_OCCUPANCY.BL",
         "PerPkg": "1",
-        "UMask": "0x8",
+        "PublicDescription": "Number of Sbo 0 credits in use in a given cy=
cle, per ring.",
+        "UMask": "0x2",
         "Unit": "HA"
     },
     {
-        "BriefDescription": "HA Requests to a TAD Region - Group 0; TAD Re=
gion 4",
-        "Counter": "0,1,2,3",
-        "EventCode": "0x1B",
-        "EventName": "UNC_H_TAD_REQUESTS_G0.REGION4",
+        "BriefDescription": "SBo1 Credits Acquired; For AD Ring",
+        "EventCode": "0x69",
+        "EventName": "UNC_H_SBO1_CREDITS_ACQUIRED.AD",
         "PerPkg": "1",
-        "UMask": "0x10",
+        "PublicDescription": "Number of Sbo 1 credits acquired in a given =
cycle, per ring.",
+        "UMask": "0x1",
         "Unit": "HA"
     },
     {
-        "BriefDescription": "HA Requests to a TAD Region - Group 0; TAD Re=
gion 5",
-        "Counter": "0,1,2,3",
-        "EventCode": "0x1B",
-        "EventName": "UNC_H_TAD_REQUESTS_G0.REGION5",
+        "BriefDescription": "SBo1 Credits Acquired; For BL Ring",
+        "EventCode": "0x69",
+        "EventName": "UNC_H_SBO1_CREDITS_ACQUIRED.BL",
         "PerPkg": "1",
-        "UMask": "0x20",
+        "PublicDescription": "Number of Sbo 1 credits acquired in a given =
cycle, per ring.",
+        "UMask": "0x2",
         "Unit": "HA"
     },
     {
-        "BriefDescription": "HA Requests to a TAD Region - Group 0; TAD Re=
gion 6",
-        "Counter": "0,1,2,3",
-        "EventCode": "0x1B",
-        "EventName": "UNC_H_TAD_REQUESTS_G0.REGION6",
+        "BriefDescription": "SBo1 Credits Occupancy; For AD Ring",
+        "EventCode": "0x6B",
+        "EventName": "UNC_H_SBO1_CREDIT_OCCUPANCY.AD",
         "PerPkg": "1",
-        "UMask": "0x40",
+        "PublicDescription": "Number of Sbo 1 credits in use in a given cy=
cle, per ring.",
+        "UMask": "0x1",
         "Unit": "HA"
     },
     {
-        "BriefDescription": "HA Requests to a TAD Region - Group 0; TAD Re=
gion 7",
-        "Counter": "0,1,2,3",
-        "EventCode": "0x1B",
-        "EventName": "UNC_H_TAD_REQUESTS_G0.REGION7",
+        "BriefDescription": "SBo1 Credits Occupancy; For BL Ring",
+        "EventCode": "0x6B",
+        "EventName": "UNC_H_SBO1_CREDIT_OCCUPANCY.BL",
         "PerPkg": "1",
-        "UMask": "0x80",
+        "PublicDescription": "Number of Sbo 1 credits in use in a given cy=
cle, per ring.",
+        "UMask": "0x2",
         "Unit": "HA"
     },
     {
-        "BriefDescription": "HA Requests to a TAD Region - Group 1; TAD Re=
gion 8",
-        "Counter": "0,1,2,3",
-        "EventCode": "0x1C",
-        "EventName": "UNC_H_TAD_REQUESTS_G1.REGION8",
+        "BriefDescription": "Data beat the Snoop Responses; Local Requests=
",
+        "EventCode": "0xA",
+        "EventName": "UNC_H_SNOOPS_RSP_AFTER_DATA.LOCAL",
         "PerPkg": "1",
+        "PublicDescription": "Counts the number of reads when the snoop wa=
s on the critical path to the data return.; This filter includes only reque=
sts coming from the local socket.",
         "UMask": "0x1",
         "Unit": "HA"
     },
     {
-        "BriefDescription": "HA Requests to a TAD Region - Group 1; TAD Re=
gion 9",
-        "Counter": "0,1,2,3",
-        "EventCode": "0x1C",
-        "EventName": "UNC_H_TAD_REQUESTS_G1.REGION9",
+        "BriefDescription": "Data beat the Snoop Responses; Remote Request=
s",
+        "EventCode": "0xA",
+        "EventName": "UNC_H_SNOOPS_RSP_AFTER_DATA.REMOTE",
         "PerPkg": "1",
+        "PublicDescription": "Counts the number of reads when the snoop wa=
s on the critical path to the data return.; This filter includes only reque=
sts coming from remote sockets.",
         "UMask": "0x2",
         "Unit": "HA"
     },
     {
-        "BriefDescription": "HA Requests to a TAD Region - Group 1; TAD Re=
gion 10",
-        "Counter": "0,1,2,3",
-        "EventCode": "0x1C",
-        "EventName": "UNC_H_TAD_REQUESTS_G1.REGION10",
+        "BriefDescription": "Cycles with Snoops Outstanding; All Requests"=
,
+        "EventCode": "0x8",
+        "EventName": "UNC_H_SNOOP_CYCLES_NE.ALL",
         "PerPkg": "1",
-        "UMask": "0x4",
+        "PublicDescription": "Counts cycles when one or more snoops are ou=
tstanding.; Tracked for snoops from both local and remote sockets.",
+        "UMask": "0x3",
         "Unit": "HA"
     },
     {
-        "BriefDescription": "HA Requests to a TAD Region - Group 1; TAD Re=
gion 11",
-        "Counter": "0,1,2,3",
-        "EventCode": "0x1C",
-        "EventName": "UNC_H_TAD_REQUESTS_G1.REGION11",
+        "BriefDescription": "Cycles with Snoops Outstanding; Local Request=
s",
+        "EventCode": "0x8",
+        "EventName": "UNC_H_SNOOP_CYCLES_NE.LOCAL",
         "PerPkg": "1",
-        "UMask": "0x8",
+        "PublicDescription": "Counts cycles when one or more snoops are ou=
tstanding.; This filter includes only requests coming from the local socket=
.",
+        "UMask": "0x1",
         "Unit": "HA"
     },
     {
-        "BriefDescription": "Tracker Cycles Full; Cycles GP Completely Use=
d",
-        "Counter": "0,1,2,3",
-        "EventCode": "0x2",
-        "EventName": "UNC_H_TRACKER_CYCLES_FULL.GP",
+        "BriefDescription": "Cycles with Snoops Outstanding; Remote Reques=
ts",
+        "EventCode": "0x8",
+        "EventName": "UNC_H_SNOOP_CYCLES_NE.REMOTE",
+        "PerPkg": "1",
+        "PublicDescription": "Counts cycles when one or more snoops are ou=
tstanding.; This filter includes only requests coming from remote sockets."=
,
+        "UMask": "0x2",
+        "Unit": "HA"
+    },
+    {
+        "BriefDescription": "Tracker Snoops Outstanding Accumulator; Local=
 Requests",
+        "EventCode": "0x9",
+        "EventName": "UNC_H_SNOOP_OCCUPANCY.LOCAL",
         "PerPkg": "1",
+        "PublicDescription": "Accumulates the occupancy of either the loca=
l HA tracker pool that have snoops pending in every cycle.    This can be u=
sed in conjection with the not empty stat to calculate average queue occupa=
ncy or the allocations stat in order to calculate average queue latency.  H=
A trackers are allocated as soon as a request enters the HA if an HT (HomeT=
racker) entry is available and this occupancy is decremented when all the s=
noop responses have returned.; This filter includes only requests coming fr=
om the local socket.",
         "UMask": "0x1",
         "Unit": "HA"
     },
     {
-        "BriefDescription": "Tracker Cycles Full; Cycles Completely Used",
-        "Counter": "0,1,2,3",
-        "EventCode": "0x2",
-        "EventName": "UNC_H_TRACKER_CYCLES_FULL.ALL",
+        "BriefDescription": "Tracker Snoops Outstanding Accumulator; Remot=
e Requests",
+        "EventCode": "0x9",
+        "EventName": "UNC_H_SNOOP_OCCUPANCY.REMOTE",
         "PerPkg": "1",
+        "PublicDescription": "Accumulates the occupancy of either the loca=
l HA tracker pool that have snoops pending in every cycle.    This can be u=
sed in conjection with the not empty stat to calculate average queue occupa=
ncy or the allocations stat in order to calculate average queue latency.  H=
A trackers are allocated as soon as a request enters the HA if an HT (HomeT=
racker) entry is available and this occupancy is decremented when all the s=
noop responses have returned.; This filter includes only requests coming fr=
om remote sockets.",
         "UMask": "0x2",
         "Unit": "HA"
     },
     {
-        "BriefDescription": "Tracker Cycles Not Empty; Local Requests",
-        "Counter": "0,1,2,3",
-        "EventCode": "0x3",
-        "EventName": "UNC_H_TRACKER_CYCLES_NE.LOCAL",
+        "BriefDescription": "Snoop Responses Received; RSPCNFLCT*",
+        "EventCode": "0x21",
+        "EventName": "UNC_H_SNOOP_RESP.RSPCNFLCT",
         "PerPkg": "1",
-        "UMask": "0x1",
+        "PublicDescription": "Counts the total number of RspI snoop respon=
ses received.  Whenever a snoops are issued, one or more snoop responses wi=
ll be returned depending on the topology of the system.   In systems larger=
 than 2s, when multiple snoops are returned this will count all the snoops =
that are received.  For example, if 3 snoops were issued and returned RspI,=
 RspS, and RspSFwd; then each of these sub-events would increment by 1.; Fi=
lters for snoops responses of RspConflict.  This is returned when a snoop f=
inds an existing outstanding transaction in a remote caching agent when it =
CAMs that caching agent.  This triggers conflict resolution hardware.  This=
 covers both RspCnflct and RspCnflctWbI.",
+        "UMask": "0x40",
         "Unit": "HA"
     },
     {
-        "BriefDescription": "Tracker Cycles Not Empty; Remote Requests",
-        "Counter": "0,1,2,3",
-        "EventCode": "0x3",
-        "EventName": "UNC_H_TRACKER_CYCLES_NE.REMOTE",
+        "BriefDescription": "Snoop Responses Received; RspI",
+        "EventCode": "0x21",
+        "EventName": "UNC_H_SNOOP_RESP.RSPI",
         "PerPkg": "1",
-        "UMask": "0x2",
+        "PublicDescription": "Counts the total number of RspI snoop respon=
ses received.  Whenever a snoops are issued, one or more snoop responses wi=
ll be returned depending on the topology of the system.   In systems larger=
 than 2s, when multiple snoops are returned this will count all the snoops =
that are received.  For example, if 3 snoops were issued and returned RspI,=
 RspS, and RspSFwd; then each of these sub-events would increment by 1.; Fi=
lters for snoops responses of RspI.  RspI is returned when the remote cache=
 does not have the data, or when the remote cache silently evicts data (suc=
h as when an RFO hits non-modified data).",
+        "UMask": "0x1",
         "Unit": "HA"
     },
     {
-        "BriefDescription": "Tracker Cycles Not Empty; All Requests",
-        "Counter": "0,1,2,3",
-        "EventCode": "0x3",
-        "EventName": "UNC_H_TRACKER_CYCLES_NE.ALL",
+        "BriefDescription": "M line forwarded from remote cache with no wr=
iteback to memory",
+        "EventCode": "0x21",
+        "EventName": "UNC_H_SNOOP_RESP.RSPIFWD",
         "PerPkg": "1",
-        "UMask": "0x3",
+        "PublicDescription": "Counts the total number of RspI snoop respon=
ses received.  Whenever a snoops are issued, one or more snoop responses wi=
ll be returned depending on the topology of the system.   In systems larger=
 than 2s, when multiple snoops are returned this will count all the snoops =
that are received.  For example, if 3 snoops were issued and returned RspI,=
 RspS, and RspSFwd; then each of these sub-events would increment by 1.; Fi=
lters for snoop responses of RspIFwd.  This is returned when a remote cachi=
ng agent forwards data and the requesting agent is able to acquire the data=
 in E or M states.  This is commonly returned with RFO transactions.  It ca=
n be either a HitM or a HitFE.",
+        "ScaleUnit": "64Bytes",
+        "UMask": "0x4",
         "Unit": "HA"
     },
     {
-        "BriefDescription": "Tracker Occupancy Accumultor; Local Read Requ=
ests",
-        "Counter": "0,1,2,3",
-        "EventCode": "0x4",
-        "EventName": "UNC_H_TRACKER_OCCUPANCY.READS_LOCAL",
+        "BriefDescription": "Shared line response from remote cache",
+        "EventCode": "0x21",
+        "EventName": "UNC_H_SNOOP_RESP.RSPS",
         "PerPkg": "1",
-        "UMask": "0x4",
+        "PublicDescription": "Counts the total number of RspI snoop respon=
ses received.  Whenever a snoops are issued, one or more snoop responses wi=
ll be returned depending on the topology of the system.   In systems larger=
 than 2s, when multiple snoops are returned this will count all the snoops =
that are received.  For example, if 3 snoops were issued and returned RspI,=
 RspS, and RspSFwd; then each of these sub-events would increment by 1.; Fi=
lters for snoop responses of RspS.  RspS is returned when a remote cache ha=
s data but is not forwarding it.  It is a way to let the requesting socket =
know that it cannot allocate the data in E state.  No data is sent with S R=
spS.",
+        "ScaleUnit": "64Bytes",
+        "UMask": "0x2",
         "Unit": "HA"
     },
     {
-        "BriefDescription": "Tracker Occupancy Accumultor; Remote Read Req=
uests",
-        "Counter": "0,1,2,3",
-        "EventCode": "0x4",
-        "EventName": "UNC_H_TRACKER_OCCUPANCY.READS_REMOTE",
+        "BriefDescription": "Shared line forwarded from remote cache",
+        "EventCode": "0x21",
+        "EventName": "UNC_H_SNOOP_RESP.RSPSFWD",
         "PerPkg": "1",
+        "PublicDescription": "Counts the total number of RspI snoop respon=
ses received.  Whenever a snoops are issued, one or more snoop responses wi=
ll be returned depending on the topology of the system.   In systems larger=
 than 2s, when multiple snoops are returned this will count all the snoops =
that are received.  For example, if 3 snoops were issued and returned RspI,=
 RspS, and RspSFwd; then each of these sub-events would increment by 1.; Fi=
lters for a snoop response of RspSFwd.  This is returned when a remote cach=
ing agent forwards data but holds on to its currentl copy.  This is common =
for data and code reads that hit in a remote socket in E or F state.",
+        "ScaleUnit": "64Bytes",
         "UMask": "0x8",
         "Unit": "HA"
     },
     {
-        "BriefDescription": "Tracker Occupancy Accumultor; Local Write Req=
uests",
-        "Counter": "0,1,2,3",
-        "EventCode": "0x4",
-        "EventName": "UNC_H_TRACKER_OCCUPANCY.WRITES_LOCAL",
+        "BriefDescription": "M line forwarded from remote cache along with=
 writeback to memory",
+        "EventCode": "0x21",
+        "EventName": "UNC_H_SNOOP_RESP.RSP_FWD_WB",
+        "PerPkg": "1",
+        "PublicDescription": "Counts the total number of RspI snoop respon=
ses received.  Whenever a snoops are issued, one or more snoop responses wi=
ll be returned depending on the topology of the system.   In systems larger=
 than 2s, when multiple snoops are returned this will count all the snoops =
that are received.  For example, if 3 snoops were issued and returned RspI,=
 RspS, and RspSFwd; then each of these sub-events would increment by 1.; Fi=
lters for a snoop response of Rsp*Fwd*WB.  This snoop response is only used=
 in 4s systems.  It is used when a snoop HITM's in a remote caching agent a=
nd it directly forwards data to a requestor, and simultaneously returns dat=
a to the home to be written back to memory.",
+        "ScaleUnit": "64Bytes",
+        "UMask": "0x20",
+        "Unit": "HA"
+    },
+    {
+        "BriefDescription": "Snoop Responses Received; Rsp*WB",
+        "EventCode": "0x21",
+        "EventName": "UNC_H_SNOOP_RESP.RSP_WB",
         "PerPkg": "1",
+        "PublicDescription": "Counts the total number of RspI snoop respon=
ses received.  Whenever a snoops are issued, one or more snoop responses wi=
ll be returned depending on the topology of the system.   In systems larger=
 than 2s, when multiple snoops are returned this will count all the snoops =
that are received.  For example, if 3 snoops were issued and returned RspI,=
 RspS, and RspSFwd; then each of these sub-events would increment by 1.; Fi=
lters for a snoop response of RspIWB or RspSWB.  This is returned when a no=
n-RFO request hits in M state.  Data and Code Reads can return either RspIW=
B or RspSWB depending on how the system has been configured.  InvItoE trans=
actions will also return RspIWB because they must acquire ownership.",
         "UMask": "0x10",
         "Unit": "HA"
     },
     {
-        "BriefDescription": "Tracker Occupancy Accumultor; Remote Write Re=
quests",
-        "Counter": "0,1,2,3",
-        "EventCode": "0x4",
-        "EventName": "UNC_H_TRACKER_OCCUPANCY.WRITES_REMOTE",
+        "BriefDescription": "Snoop Responses Received Local; Other",
+        "EventCode": "0x60",
+        "EventName": "UNC_H_SNP_RESP_RECV_LOCAL.OTHER",
         "PerPkg": "1",
-        "UMask": "0x20",
+        "PublicDescription": "Number of snoop responses received for a Loc=
al  request; Filters for all other snoop responses.",
+        "UMask": "0x80",
         "Unit": "HA"
     },
     {
-        "BriefDescription": "Tracker Occupancy Accumultor; Local InvItoE R=
equests",
-        "Counter": "0,1,2,3",
-        "EventCode": "0x4",
-        "EventName": "UNC_H_TRACKER_OCCUPANCY.INVITOE_LOCAL",
+        "BriefDescription": "Snoop Responses Received Local; RspCnflct",
+        "EventCode": "0x60",
+        "EventName": "UNC_H_SNP_RESP_RECV_LOCAL.RSPCNFLCT",
         "PerPkg": "1",
+        "PublicDescription": "Number of snoop responses received for a Loc=
al  request; Filters for snoops responses of RspConflict.  This is returned=
 when a snoop finds an existing outstanding transaction in a remote caching=
 agent when it CAMs that caching agent.  This triggers conflict resolution =
hardware.  This covers both RspCnflct and RspCnflctWbI.",
         "UMask": "0x40",
         "Unit": "HA"
     },
     {
-        "BriefDescription": "Tracker Occupancy Accumultor; Remote InvItoE =
Requests",
-        "Counter": "0,1,2,3",
-        "EventCode": "0x4",
-        "EventName": "UNC_H_TRACKER_OCCUPANCY.INVITOE_REMOTE",
+        "BriefDescription": "Snoop Responses Received Local; RspI",
+        "EventCode": "0x60",
+        "EventName": "UNC_H_SNP_RESP_RECV_LOCAL.RSPI",
         "PerPkg": "1",
-        "UMask": "0x80",
+        "PublicDescription": "Number of snoop responses received for a Loc=
al  request; Filters for snoops responses of RspI.  RspI is returned when t=
he remote cache does not have the data, or when the remote cache silently e=
victs data (such as when an RFO hits non-modified data).",
+        "UMask": "0x1",
         "Unit": "HA"
     },
     {
-        "BriefDescription": "Data Pending Occupancy Accumultor; Local Requ=
ests",
-        "Counter": "0,1,2,3",
-        "EventCode": "0x5",
-        "EventName": "UNC_H_TRACKER_PENDING_OCCUPANCY.LOCAL",
+        "BriefDescription": "Snoop Responses Received Local; RspIFwd",
+        "EventCode": "0x60",
+        "EventName": "UNC_H_SNP_RESP_RECV_LOCAL.RSPIFWD",
         "PerPkg": "1",
-        "UMask": "0x1",
+        "PublicDescription": "Number of snoop responses received for a Loc=
al  request; Filters for snoop responses of RspIFwd.  This is returned when=
 a remote caching agent forwards data and the requesting agent is able to a=
cquire the data in E or M states.  This is commonly returned with RFO trans=
actions.  It can be either a HitM or a HitFE.",
+        "UMask": "0x4",
         "Unit": "HA"
     },
     {
-        "BriefDescription": "Data Pending Occupancy Accumultor; Remote Req=
uests",
-        "Counter": "0,1,2,3",
-        "EventCode": "0x5",
-        "EventName": "UNC_H_TRACKER_PENDING_OCCUPANCY.REMOTE",
+        "BriefDescription": "Snoop Responses Received Local; RspS",
+        "EventCode": "0x60",
+        "EventName": "UNC_H_SNP_RESP_RECV_LOCAL.RSPS",
         "PerPkg": "1",
+        "PublicDescription": "Number of snoop responses received for a Loc=
al  request; Filters for snoop responses of RspS.  RspS is returned when a =
remote cache has data but is not forwarding it.  It is a way to let the req=
uesting socket know that it cannot allocate the data in E state.  No data i=
s sent with S RspS.",
         "UMask": "0x2",
         "Unit": "HA"
     },
     {
-        "BriefDescription": "AD Egress Full; Scheduler 0",
-        "Counter": "0,1,2,3",
-        "EventCode": "0x2A",
-        "EventName": "UNC_H_TxR_AD_CYCLES_FULL.SCHED0",
+        "BriefDescription": "Snoop Responses Received Local; RspSFwd",
+        "EventCode": "0x60",
+        "EventName": "UNC_H_SNP_RESP_RECV_LOCAL.RSPSFWD",
         "PerPkg": "1",
-        "UMask": "0x1",
+        "PublicDescription": "Number of snoop responses received for a Loc=
al  request; Filters for a snoop response of RspSFwd.  This is returned whe=
n a remote caching agent forwards data but holds on to its currentl copy.  =
This is common for data and code reads that hit in a remote socket in E or =
F state.",
+        "UMask": "0x8",
         "Unit": "HA"
     },
     {
-        "BriefDescription": "AD Egress Full; Scheduler 1",
-        "Counter": "0,1,2,3",
-        "EventCode": "0x2A",
-        "EventName": "UNC_H_TxR_AD_CYCLES_FULL.SCHED1",
+        "BriefDescription": "Snoop Responses Received Local; Rsp*FWD*WB",
+        "EventCode": "0x60",
+        "EventName": "UNC_H_SNP_RESP_RECV_LOCAL.RSPxFWDxWB",
         "PerPkg": "1",
-        "UMask": "0x2",
+        "PublicDescription": "Number of snoop responses received for a Loc=
al  request; Filters for a snoop response of Rsp*Fwd*WB.  This snoop respon=
se is only used in 4s systems.  It is used when a snoop HITM's in a remote =
caching agent and it directly forwards data to a requestor, and simultaneou=
sly returns data to the home to be written back to memory.",
+        "UMask": "0x20",
         "Unit": "HA"
     },
     {
-        "BriefDescription": "AD Egress Full; All",
-        "Counter": "0,1,2,3",
-        "EventCode": "0x2A",
-        "EventName": "UNC_H_TxR_AD_CYCLES_FULL.ALL",
+        "BriefDescription": "Snoop Responses Received Local; Rsp*WB",
+        "EventCode": "0x60",
+        "EventName": "UNC_H_SNP_RESP_RECV_LOCAL.RSPxWB",
         "PerPkg": "1",
-        "UMask": "0x3",
+        "PublicDescription": "Number of snoop responses received for a Loc=
al  request; Filters for a snoop response of RspIWB or RspSWB.  This is ret=
urned when a non-RFO request hits in M state.  Data and Code Reads can retu=
rn either RspIWB or RspSWB depending on how the system has been configured.=
  InvItoE transactions will also return RspIWB because they must acquire ow=
nership.",
+        "UMask": "0x10",
         "Unit": "HA"
     },
     {
-        "BriefDescription": "AK Egress Full; Scheduler 0",
-        "Counter": "0,1,2,3",
-        "EventCode": "0x32",
-        "EventName": "UNC_H_TxR_AK_CYCLES_FULL.SCHED0",
+        "BriefDescription": "Stall on No Sbo Credits; For SBo0, AD Ring",
+        "EventCode": "0x6C",
+        "EventName": "UNC_H_STALL_NO_SBO_CREDIT.SBO0_AD",
         "PerPkg": "1",
+        "PublicDescription": "Number of cycles Egress is stalled waiting f=
or an Sbo credit to become available.  Per Sbo, per Ring.",
         "UMask": "0x1",
         "Unit": "HA"
     },
     {
-        "BriefDescription": "AK Egress Full; Scheduler 1",
-        "Counter": "0,1,2,3",
-        "EventCode": "0x32",
-        "EventName": "UNC_H_TxR_AK_CYCLES_FULL.SCHED1",
+        "BriefDescription": "Stall on No Sbo Credits; For SBo0, BL Ring",
+        "EventCode": "0x6C",
+        "EventName": "UNC_H_STALL_NO_SBO_CREDIT.SBO0_BL",
+        "PerPkg": "1",
+        "PublicDescription": "Number of cycles Egress is stalled waiting f=
or an Sbo credit to become available.  Per Sbo, per Ring.",
+        "UMask": "0x4",
+        "Unit": "HA"
+    },
+    {
+        "BriefDescription": "Stall on No Sbo Credits; For SBo1, AD Ring",
+        "EventCode": "0x6C",
+        "EventName": "UNC_H_STALL_NO_SBO_CREDIT.SBO1_AD",
         "PerPkg": "1",
+        "PublicDescription": "Number of cycles Egress is stalled waiting f=
or an Sbo credit to become available.  Per Sbo, per Ring.",
         "UMask": "0x2",
         "Unit": "HA"
     },
     {
-        "BriefDescription": "AK Egress Full; All",
-        "Counter": "0,1,2,3",
-        "EventCode": "0x32",
-        "EventName": "UNC_H_TxR_AK_CYCLES_FULL.ALL",
+        "BriefDescription": "Stall on No Sbo Credits; For SBo1, BL Ring",
+        "EventCode": "0x6C",
+        "EventName": "UNC_H_STALL_NO_SBO_CREDIT.SBO1_BL",
         "PerPkg": "1",
-        "UMask": "0x3",
+        "PublicDescription": "Number of cycles Egress is stalled waiting f=
or an Sbo credit to become available.  Per Sbo, per Ring.",
+        "UMask": "0x8",
         "Unit": "HA"
     },
     {
-        "BriefDescription": "Outbound DRS Ring Transactions to Cache; Data=
 to Cache",
-        "Counter": "0,1,2,3",
-        "EventCode": "0x10",
-        "EventName": "UNC_H_TxR_BL.DRS_CACHE",
+        "BriefDescription": "HA Requests to a TAD Region - Group 0; TAD Re=
gion 0",
+        "EventCode": "0x1B",
+        "EventName": "UNC_H_TAD_REQUESTS_G0.REGION0",
         "PerPkg": "1",
+        "PublicDescription": "Counts the number of HA requests to a given =
TAD region.  There are up to 11 TAD (target address decode) regions in each=
 home agent.  All requests destined for the memory controller must first be=
 decoded to determine which TAD region they are in.  This event is filtered=
 based on the TAD region ID, and covers regions 0 to 7.  This event is usef=
ul for understanding how applications are using the memory that is spread a=
cross the different memory regions.  It is particularly useful for Monroe s=
ystems that use the TAD to enable individual channels to enter self-refresh=
 to save power.; Filters request made to TAD Region 0",
         "UMask": "0x1",
         "Unit": "HA"
     },
     {
-        "BriefDescription": "Outbound DRS Ring Transactions to Cache; Data=
 to Core",
-        "Counter": "0,1,2,3",
-        "EventCode": "0x10",
-        "EventName": "UNC_H_TxR_BL.DRS_CORE",
+        "BriefDescription": "HA Requests to a TAD Region - Group 0; TAD Re=
gion 1",
+        "EventCode": "0x1B",
+        "EventName": "UNC_H_TAD_REQUESTS_G0.REGION1",
         "PerPkg": "1",
+        "PublicDescription": "Counts the number of HA requests to a given =
TAD region.  There are up to 11 TAD (target address decode) regions in each=
 home agent.  All requests destined for the memory controller must first be=
 decoded to determine which TAD region they are in.  This event is filtered=
 based on the TAD region ID, and covers regions 0 to 7.  This event is usef=
ul for understanding how applications are using the memory that is spread a=
cross the different memory regions.  It is particularly useful for Monroe s=
ystems that use the TAD to enable individual channels to enter self-refresh=
 to save power.; Filters request made to TAD Region 1",
         "UMask": "0x2",
         "Unit": "HA"
     },
     {
-        "BriefDescription": "Outbound DRS Ring Transactions to Cache; Data=
 to QPI",
-        "Counter": "0,1,2,3",
-        "EventCode": "0x10",
-        "EventName": "UNC_H_TxR_BL.DRS_QPI",
+        "BriefDescription": "HA Requests to a TAD Region - Group 0; TAD Re=
gion 2",
+        "EventCode": "0x1B",
+        "EventName": "UNC_H_TAD_REQUESTS_G0.REGION2",
         "PerPkg": "1",
+        "PublicDescription": "Counts the number of HA requests to a given =
TAD region.  There are up to 11 TAD (target address decode) regions in each=
 home agent.  All requests destined for the memory controller must first be=
 decoded to determine which TAD region they are in.  This event is filtered=
 based on the TAD region ID, and covers regions 0 to 7.  This event is usef=
ul for understanding how applications are using the memory that is spread a=
cross the different memory regions.  It is particularly useful for Monroe s=
ystems that use the TAD to enable individual channels to enter self-refresh=
 to save power.; Filters request made to TAD Region 2",
         "UMask": "0x4",
         "Unit": "HA"
     },
     {
-        "BriefDescription": "BL Egress Full; Scheduler 0",
-        "Counter": "0,1,2,3",
-        "EventCode": "0x36",
-        "EventName": "UNC_H_TxR_BL_CYCLES_FULL.SCHED0",
+        "BriefDescription": "HA Requests to a TAD Region - Group 0; TAD Re=
gion 3",
+        "EventCode": "0x1B",
+        "EventName": "UNC_H_TAD_REQUESTS_G0.REGION3",
         "PerPkg": "1",
-        "UMask": "0x1",
+        "PublicDescription": "Counts the number of HA requests to a given =
TAD region.  There are up to 11 TAD (target address decode) regions in each=
 home agent.  All requests destined for the memory controller must first be=
 decoded to determine which TAD region they are in.  This event is filtered=
 based on the TAD region ID, and covers regions 0 to 7.  This event is usef=
ul for understanding how applications are using the memory that is spread a=
cross the different memory regions.  It is particularly useful for Monroe s=
ystems that use the TAD to enable individual channels to enter self-refresh=
 to save power.; Filters request made to TAD Region 3",
+        "UMask": "0x8",
         "Unit": "HA"
     },
     {
-        "BriefDescription": "BL Egress Full; Scheduler 1",
-        "Counter": "0,1,2,3",
-        "EventCode": "0x36",
-        "EventName": "UNC_H_TxR_BL_CYCLES_FULL.SCHED1",
+        "BriefDescription": "HA Requests to a TAD Region - Group 0; TAD Re=
gion 4",
+        "EventCode": "0x1B",
+        "EventName": "UNC_H_TAD_REQUESTS_G0.REGION4",
         "PerPkg": "1",
-        "UMask": "0x2",
+        "PublicDescription": "Counts the number of HA requests to a given =
TAD region.  There are up to 11 TAD (target address decode) regions in each=
 home agent.  All requests destined for the memory controller must first be=
 decoded to determine which TAD region they are in.  This event is filtered=
 based on the TAD region ID, and covers regions 0 to 7.  This event is usef=
ul for understanding how applications are using the memory that is spread a=
cross the different memory regions.  It is particularly useful for Monroe s=
ystems that use the TAD to enable individual channels to enter self-refresh=
 to save power.; Filters request made to TAD Region 4",
+        "UMask": "0x10",
         "Unit": "HA"
     },
     {
-        "BriefDescription": "BL Egress Full; All",
-        "Counter": "0,1,2,3",
-        "EventCode": "0x36",
-        "EventName": "UNC_H_TxR_BL_CYCLES_FULL.ALL",
+        "BriefDescription": "HA Requests to a TAD Region - Group 0; TAD Re=
gion 5",
+        "EventCode": "0x1B",
+        "EventName": "UNC_H_TAD_REQUESTS_G0.REGION5",
         "PerPkg": "1",
-        "UMask": "0x3",
+        "PublicDescription": "Counts the number of HA requests to a given =
TAD region.  There are up to 11 TAD (target address decode) regions in each=
 home agent.  All requests destined for the memory controller must first be=
 decoded to determine which TAD region they are in.  This event is filtered=
 based on the TAD region ID, and covers regions 0 to 7.  This event is usef=
ul for understanding how applications are using the memory that is spread a=
cross the different memory regions.  It is particularly useful for Monroe s=
ystems that use the TAD to enable individual channels to enter self-refresh=
 to save power.; Filters request made to TAD Region 5",
+        "UMask": "0x20",
         "Unit": "HA"
     },
     {
-        "BriefDescription": "Injection Starvation; For AK Ring",
-        "Counter": "0,1,2,3",
-        "EventCode": "0x6D",
-        "EventName": "UNC_H_TxR_STARVED.AK",
+        "BriefDescription": "HA Requests to a TAD Region - Group 0; TAD Re=
gion 6",
+        "EventCode": "0x1B",
+        "EventName": "UNC_H_TAD_REQUESTS_G0.REGION6",
         "PerPkg": "1",
-        "UMask": "0x1",
+        "PublicDescription": "Counts the number of HA requests to a given =
TAD region.  There are up to 11 TAD (target address decode) regions in each=
 home agent.  All requests destined for the memory controller must first be=
 decoded to determine which TAD region they are in.  This event is filtered=
 based on the TAD region ID, and covers regions 0 to 7.  This event is usef=
ul for understanding how applications are using the memory that is spread a=
cross the different memory regions.  It is particularly useful for Monroe s=
ystems that use the TAD to enable individual channels to enter self-refresh=
 to save power.; Filters request made to TAD Region 6",
+        "UMask": "0x40",
         "Unit": "HA"
     },
     {
-        "BriefDescription": "Injection Starvation; For BL Ring",
-        "Counter": "0,1,2,3",
-        "EventCode": "0x6D",
-        "EventName": "UNC_H_TxR_STARVED.BL",
+        "BriefDescription": "HA Requests to a TAD Region - Group 0; TAD Re=
gion 7",
+        "EventCode": "0x1B",
+        "EventName": "UNC_H_TAD_REQUESTS_G0.REGION7",
         "PerPkg": "1",
-        "UMask": "0x2",
+        "PublicDescription": "Counts the number of HA requests to a given =
TAD region.  There are up to 11 TAD (target address decode) regions in each=
 home agent.  All requests destined for the memory controller must first be=
 decoded to determine which TAD region they are in.  This event is filtered=
 based on the TAD region ID, and covers regions 0 to 7.  This event is usef=
ul for understanding how applications are using the memory that is spread a=
cross the different memory regions.  It is particularly useful for Monroe s=
ystems that use the TAD to enable individual channels to enter self-refresh=
 to save power.; Filters request made to TAD Region 7",
+        "UMask": "0x80",
         "Unit": "HA"
     },
     {
-        "BriefDescription": "HA iMC CHN0 WPQ Credits Empty - Regular; Chan=
nel 0",
-        "Counter": "0,1,2,3",
-        "EventCode": "0x18",
-        "EventName": "UNC_H_WPQ_CYCLES_NO_REG_CREDITS.CHN0",
+        "BriefDescription": "HA Requests to a TAD Region - Group 1; TAD Re=
gion 10",
+        "EventCode": "0x1C",
+        "EventName": "UNC_H_TAD_REQUESTS_G1.REGION10",
         "PerPkg": "1",
-        "UMask": "0x1",
+        "PublicDescription": "Counts the number of HA requests to a given =
TAD region.  There are up to 11 TAD (target address decode) regions in each=
 home agent.  All requests destined for the memory controller must first be=
 decoded to determine which TAD region they are in.  This event is filtered=
 based on the TAD region ID, and covers regions 8 to 10.  This event is use=
ful for understanding how applications are using the memory that is spread =
across the different memory regions.  It is particularly useful for Monroe =
systems that use the TAD to enable individual channels to enter self-refres=
h to save power.; Filters request made to TAD Region 10",
+        "UMask": "0x4",
         "Unit": "HA"
     },
     {
-        "BriefDescription": "HA iMC CHN0 WPQ Credits Empty - Regular; Chan=
nel 1",
-        "Counter": "0,1,2,3",
-        "EventCode": "0x18",
-        "EventName": "UNC_H_WPQ_CYCLES_NO_REG_CREDITS.CHN1",
+        "BriefDescription": "HA Requests to a TAD Region - Group 1; TAD Re=
gion 11",
+        "EventCode": "0x1C",
+        "EventName": "UNC_H_TAD_REQUESTS_G1.REGION11",
         "PerPkg": "1",
-        "UMask": "0x2",
+        "PublicDescription": "Counts the number of HA requests to a given =
TAD region.  There are up to 11 TAD (target address decode) regions in each=
 home agent.  All requests destined for the memory controller must first be=
 decoded to determine which TAD region they are in.  This event is filtered=
 based on the TAD region ID, and covers regions 8 to 10.  This event is use=
ful for understanding how applications are using the memory that is spread =
across the different memory regions.  It is particularly useful for Monroe =
systems that use the TAD to enable individual channels to enter self-refres=
h to save power.; Filters request made to TAD Region 11",
+        "UMask": "0x8",
         "Unit": "HA"
     },
     {
-        "BriefDescription": "HA iMC CHN0 WPQ Credits Empty - Regular; Chan=
nel 2",
-        "Counter": "0,1,2,3",
-        "EventCode": "0x18",
-        "EventName": "UNC_H_WPQ_CYCLES_NO_REG_CREDITS.CHN2",
+        "BriefDescription": "HA Requests to a TAD Region - Group 1; TAD Re=
gion 8",
+        "EventCode": "0x1C",
+        "EventName": "UNC_H_TAD_REQUESTS_G1.REGION8",
         "PerPkg": "1",
-        "UMask": "0x4",
+        "PublicDescription": "Counts the number of HA requests to a given =
TAD region.  There are up to 11 TAD (target address decode) regions in each=
 home agent.  All requests destined for the memory controller must first be=
 decoded to determine which TAD region they are in.  This event is filtered=
 based on the TAD region ID, and covers regions 8 to 10.  This event is use=
ful for understanding how applications are using the memory that is spread =
across the different memory regions.  It is particularly useful for Monroe =
systems that use the TAD to enable individual channels to enter self-refres=
h to save power.; Filters request made to TAD Region 8",
+        "UMask": "0x1",
         "Unit": "HA"
     },
     {
-        "BriefDescription": "HA iMC CHN0 WPQ Credits Empty - Regular; Chan=
nel 3",
-        "Counter": "0,1,2,3",
-        "EventCode": "0x18",
-        "EventName": "UNC_H_WPQ_CYCLES_NO_REG_CREDITS.CHN3",
+        "BriefDescription": "HA Requests to a TAD Region - Group 1; TAD Re=
gion 9",
+        "EventCode": "0x1C",
+        "EventName": "UNC_H_TAD_REQUESTS_G1.REGION9",
         "PerPkg": "1",
-        "UMask": "0x8",
+        "PublicDescription": "Counts the number of HA requests to a given =
TAD region.  There are up to 11 TAD (target address decode) regions in each=
 home agent.  All requests destined for the memory controller must first be=
 decoded to determine which TAD region they are in.  This event is filtered=
 based on the TAD region ID, and covers regions 8 to 10.  This event is use=
ful for understanding how applications are using the memory that is spread =
across the different memory regions.  It is particularly useful for Monroe =
systems that use the TAD to enable individual channels to enter self-refres=
h to save power.; Filters request made to TAD Region 9",
+        "UMask": "0x2",
         "Unit": "HA"
     },
     {
-        "BriefDescription": "BT to HT Not Issued; Incoming Snoop Hazard",
-        "Counter": "0,1,2,3",
-        "EventCode": "0x51",
-        "EventName": "UNC_H_BT_TO_HT_NOT_ISSUED.INCOMING_SNP_HAZARD",
+        "BriefDescription": "Tracker Cycles Full; Cycles Completely Used",
+        "EventCode": "0x2",
+        "EventName": "UNC_H_TRACKER_CYCLES_FULL.ALL",
         "PerPkg": "1",
+        "PublicDescription": "Counts the number of cycles when the local H=
A tracker pool is completely used.  This can be used with edge detect to id=
entify the number of situations when the pool became fully utilized.  This =
should not be confused with RTID credit usage -- which must be tracked insi=
de each cbo individually -- but represents the actual tracker buffer struct=
ure.  In other words, the system could be starved for RTIDs but not fill up=
 the HA trackers.  HA trackers are allocated as soon as a request enters th=
e HA and is released after the snoop response and data return (or post in t=
he case of a write) and the response is returned on the ring.; Counts the n=
umber of cycles when the HA tracker pool (HT) is completely used including =
reserved HT entries.  It will not return valid count when BT is disabled.",
         "UMask": "0x2",
         "Unit": "HA"
     },
     {
-        "BriefDescription": "BT to HT Not Issued; Incoming Data Hazard",
-        "Counter": "0,1,2,3",
-        "EventCode": "0x51",
-        "EventName": "UNC_H_BT_TO_HT_NOT_ISSUED.INCOMING_BL_HAZARD",
+        "BriefDescription": "Tracker Cycles Full; Cycles GP Completely Use=
d",
+        "EventCode": "0x2",
+        "EventName": "UNC_H_TRACKER_CYCLES_FULL.GP",
         "PerPkg": "1",
-        "UMask": "0x4",
+        "PublicDescription": "Counts the number of cycles when the local H=
A tracker pool is completely used.  This can be used with edge detect to id=
entify the number of situations when the pool became fully utilized.  This =
should not be confused with RTID credit usage -- which must be tracked insi=
de each cbo individually -- but represents the actual tracker buffer struct=
ure.  In other words, the system could be starved for RTIDs but not fill up=
 the HA trackers.  HA trackers are allocated as soon as a request enters th=
e HA and is released after the snoop response and data return (or post in t=
he case of a write) and the response is returned on the ring.; Counts the n=
umber of cycles when the general purpose (GP) HA tracker pool (HT) is compl=
etely used.  It will not return valid count when BT is disabled.",
+        "UMask": "0x1",
         "Unit": "HA"
     },
     {
-        "BriefDescription": "BT to HT Not Issued; Incoming Data Hazard",
-        "Counter": "0,1,2,3",
-        "EventCode": "0x51",
-        "EventName": "UNC_H_BT_TO_HT_NOT_ISSUED.RSPACKCFLT_HAZARD",
+        "BriefDescription": "Tracker Cycles Not Empty; All Requests",
+        "EventCode": "0x3",
+        "EventName": "UNC_H_TRACKER_CYCLES_NE.ALL",
         "PerPkg": "1",
-        "UMask": "0x8",
+        "PublicDescription": "Counts the number of cycles when the local H=
A tracker pool is not empty.  This can be used with edge detect to identify=
 the number of situations when the pool became empty.  This should not be c=
onfused with RTID credit usage -- which must be tracked inside each cbo ind=
ividually -- but represents the actual tracker buffer structure.  In other =
words, this buffer could be completely empty, but there may still be credit=
s in use by the CBos.  This stat can be used in conjunction with the occupa=
ncy accumulation stat in order to calculate average queue occpancy.  HA tra=
ckers are allocated as soon as a request enters the HA if an HT (Home Track=
er) entry is available and is released after the snoop response and data re=
turn (or post in the case of a write) and the response is returned on the r=
ing.; Requests coming from both local and remote sockets.",
+        "UMask": "0x3",
         "Unit": "HA"
     },
     {
-        "BriefDescription": "BT to HT Not Issued; Incoming Data Hazard",
-        "Counter": "0,1,2,3",
-        "EventCode": "0x51",
-        "EventName": "UNC_H_BT_TO_HT_NOT_ISSUED.WBMDATA_HAZARD",
+        "BriefDescription": "Tracker Cycles Not Empty; Local Requests",
+        "EventCode": "0x3",
+        "EventName": "UNC_H_TRACKER_CYCLES_NE.LOCAL",
         "PerPkg": "1",
-        "UMask": "0x10",
+        "PublicDescription": "Counts the number of cycles when the local H=
A tracker pool is not empty.  This can be used with edge detect to identify=
 the number of situations when the pool became empty.  This should not be c=
onfused with RTID credit usage -- which must be tracked inside each cbo ind=
ividually -- but represents the actual tracker buffer structure.  In other =
words, this buffer could be completely empty, but there may still be credit=
s in use by the CBos.  This stat can be used in conjunction with the occupa=
ncy accumulation stat in order to calculate average queue occpancy.  HA tra=
ckers are allocated as soon as a request enters the HA if an HT (Home Track=
er) entry is available and is released after the snoop response and data re=
turn (or post in the case of a write) and the response is returned on the r=
ing.; This filter includes only requests coming from the local socket.",
+        "UMask": "0x1",
         "Unit": "HA"
     },
     {
-        "BriefDescription": "IOT Backpressure",
-        "Counter": "0,1,2",
-        "EventCode": "0x61",
-        "EventName": "UNC_H_IOT_BACKPRESSURE.SAT",
+        "BriefDescription": "Tracker Cycles Not Empty; Remote Requests",
+        "EventCode": "0x3",
+        "EventName": "UNC_H_TRACKER_CYCLES_NE.REMOTE",
         "PerPkg": "1",
-        "UMask": "0x1",
+        "PublicDescription": "Counts the number of cycles when the local H=
A tracker pool is not empty.  This can be used with edge detect to identify=
 the number of situations when the pool became empty.  This should not be c=
onfused with RTID credit usage -- which must be tracked inside each cbo ind=
ividually -- but represents the actual tracker buffer structure.  In other =
words, this buffer could be completely empty, but there may still be credit=
s in use by the CBos.  This stat can be used in conjunction with the occupa=
ncy accumulation stat in order to calculate average queue occpancy.  HA tra=
ckers are allocated as soon as a request enters the HA if an HT (Home Track=
er) entry is available and is released after the snoop response and data re=
turn (or post in the case of a write) and the response is returned on the r=
ing.; This filter includes only requests coming from remote sockets.",
+        "UMask": "0x2",
+        "Unit": "HA"
+    },
+    {
+        "BriefDescription": "Tracker Occupancy Accumultor; Local InvItoE R=
equests",
+        "EventCode": "0x4",
+        "EventName": "UNC_H_TRACKER_OCCUPANCY.INVITOE_LOCAL",
+        "PerPkg": "1",
+        "PublicDescription": "Accumulates the occupancy of the local HA tr=
acker pool in every cycle.  This can be used in conjection with the not emp=
ty stat to calculate average queue occupancy or the allocations stat in ord=
er to calculate average queue latency.  HA trackers are allocated as soon a=
s a request enters the HA if a HT (Home Tracker) entry is available and is =
released after the snoop response and data return (or post in the case of a=
 write) and the response is returned on the ring.",
+        "UMask": "0x40",
         "Unit": "HA"
     },
     {
-        "BriefDescription": "IOT Backpressure",
-        "Counter": "0,1,2",
-        "EventCode": "0x61",
-        "EventName": "UNC_H_IOT_BACKPRESSURE.HUB",
+        "BriefDescription": "Tracker Occupancy Accumultor; Remote InvItoE =
Requests",
+        "EventCode": "0x4",
+        "EventName": "UNC_H_TRACKER_OCCUPANCY.INVITOE_REMOTE",
         "PerPkg": "1",
-        "UMask": "0x2",
+        "PublicDescription": "Accumulates the occupancy of the local HA tr=
acker pool in every cycle.  This can be used in conjection with the not emp=
ty stat to calculate average queue occupancy or the allocations stat in ord=
er to calculate average queue latency.  HA trackers are allocated as soon a=
s a request enters the HA if a HT (Home Tracker) entry is available and is =
released after the snoop response and data return (or post in the case of a=
 write) and the response is returned on the ring.",
+        "UMask": "0x80",
         "Unit": "HA"
     },
     {
-        "BriefDescription": "IOT Common Trigger Sequencer - Lo",
-        "Counter": "0,1,2",
-        "EventCode": "0x64",
-        "EventName": "UNC_H_IOT_CTS_EAST_LO.CTS0",
+        "BriefDescription": "Tracker Occupancy Accumultor; Local Read Requ=
ests",
+        "EventCode": "0x4",
+        "EventName": "UNC_H_TRACKER_OCCUPANCY.READS_LOCAL",
         "PerPkg": "1",
-        "UMask": "0x1",
+        "PublicDescription": "Accumulates the occupancy of the local HA tr=
acker pool in every cycle.  This can be used in conjection with the not emp=
ty stat to calculate average queue occupancy or the allocations stat in ord=
er to calculate average queue latency.  HA trackers are allocated as soon a=
s a request enters the HA if a HT (Home Tracker) entry is available and is =
released after the snoop response and data return (or post in the case of a=
 write) and the response is returned on the ring.",
+        "UMask": "0x4",
         "Unit": "HA"
     },
     {
-        "BriefDescription": "IOT Common Trigger Sequencer - Lo",
-        "Counter": "0,1,2",
-        "EventCode": "0x64",
-        "EventName": "UNC_H_IOT_CTS_EAST_LO.CTS1",
+        "BriefDescription": "Tracker Occupancy Accumultor; Remote Read Req=
uests",
+        "EventCode": "0x4",
+        "EventName": "UNC_H_TRACKER_OCCUPANCY.READS_REMOTE",
         "PerPkg": "1",
-        "UMask": "0x2",
+        "PublicDescription": "Accumulates the occupancy of the local HA tr=
acker pool in every cycle.  This can be used in conjection with the not emp=
ty stat to calculate average queue occupancy or the allocations stat in ord=
er to calculate average queue latency.  HA trackers are allocated as soon a=
s a request enters the HA if a HT (Home Tracker) entry is available and is =
released after the snoop response and data return (or post in the case of a=
 write) and the response is returned on the ring.",
+        "UMask": "0x8",
         "Unit": "HA"
     },
     {
-        "BriefDescription": "IOT Common Trigger Sequencer - Hi",
-        "Counter": "0,1,2",
-        "EventCode": "0x65",
-        "EventName": "UNC_H_IOT_CTS_HI.CTS2",
+        "BriefDescription": "Tracker Occupancy Accumultor; Local Write Req=
uests",
+        "EventCode": "0x4",
+        "EventName": "UNC_H_TRACKER_OCCUPANCY.WRITES_LOCAL",
         "PerPkg": "1",
-        "UMask": "0x1",
+        "PublicDescription": "Accumulates the occupancy of the local HA tr=
acker pool in every cycle.  This can be used in conjection with the not emp=
ty stat to calculate average queue occupancy or the allocations stat in ord=
er to calculate average queue latency.  HA trackers are allocated as soon a=
s a request enters the HA if a HT (Home Tracker) entry is available and is =
released after the snoop response and data return (or post in the case of a=
 write) and the response is returned on the ring.",
+        "UMask": "0x10",
         "Unit": "HA"
     },
     {
-        "BriefDescription": "IOT Common Trigger Sequencer - Hi",
-        "Counter": "0,1,2",
-        "EventCode": "0x65",
-        "EventName": "UNC_H_IOT_CTS_HI.CTS3",
+        "BriefDescription": "Tracker Occupancy Accumultor; Remote Write Re=
quests",
+        "EventCode": "0x4",
+        "EventName": "UNC_H_TRACKER_OCCUPANCY.WRITES_REMOTE",
         "PerPkg": "1",
-        "UMask": "0x2",
+        "PublicDescription": "Accumulates the occupancy of the local HA tr=
acker pool in every cycle.  This can be used in conjection with the not emp=
ty stat to calculate average queue occupancy or the allocations stat in ord=
er to calculate average queue latency.  HA trackers are allocated as soon a=
s a request enters the HA if a HT (Home Tracker) entry is available and is =
released after the snoop response and data return (or post in the case of a=
 write) and the response is returned on the ring.",
+        "UMask": "0x20",
         "Unit": "HA"
     },
     {
-        "BriefDescription": "IOT Common Trigger Sequencer - Lo",
-        "Counter": "0,1,2",
-        "EventCode": "0x62",
-        "EventName": "UNC_H_IOT_CTS_WEST_LO.CTS0",
+        "BriefDescription": "Data Pending Occupancy Accumultor; Local Requ=
ests",
+        "EventCode": "0x5",
+        "EventName": "UNC_H_TRACKER_PENDING_OCCUPANCY.LOCAL",
         "PerPkg": "1",
+        "PublicDescription": "Accumulates the number of transactions that =
have data from the memory controller until they get scheduled to the Egress=
.  This can be used to calculate the queuing latency for two things.  (1) I=
f the system is waiting for snoops, this will increase.  (2) If the system =
can't schedule to the Egress because of either (a) Egress Credits or (b) QP=
I BL IGR credits for remote requests.; This filter includes only requests c=
oming from the local socket.",
         "UMask": "0x1",
         "Unit": "HA"
     },
     {
-        "BriefDescription": "IOT Common Trigger Sequencer - Lo",
-        "Counter": "0,1,2",
-        "EventCode": "0x62",
-        "EventName": "UNC_H_IOT_CTS_WEST_LO.CTS1",
+        "BriefDescription": "Data Pending Occupancy Accumultor; Remote Req=
uests",
+        "EventCode": "0x5",
+        "EventName": "UNC_H_TRACKER_PENDING_OCCUPANCY.REMOTE",
         "PerPkg": "1",
+        "PublicDescription": "Accumulates the number of transactions that =
have data from the memory controller until they get scheduled to the Egress=
.  This can be used to calculate the queuing latency for two things.  (1) I=
f the system is waiting for snoops, this will increase.  (2) If the system =
can't schedule to the Egress because of either (a) Egress Credits or (b) QP=
I BL IGR credits for remote requests.; This filter includes only requests c=
oming from remote sockets.",
         "UMask": "0x2",
         "Unit": "HA"
     },
     {
-        "BriefDescription": "iMC RPQ Credits Empty - Special; Channel 0",
-        "Counter": "0,1,2,3",
-        "EventCode": "0x16",
-        "EventName": "UNC_H_RPQ_CYCLES_NO_SPEC_CREDITS.CHN0",
+        "BriefDescription": "Outbound NDR Ring Transactions; Non-data Resp=
onses",
+        "EventCode": "0xF",
+        "EventName": "UNC_H_TxR_AD.HOM",
         "PerPkg": "1",
-        "UMask": "0x1",
+        "PublicDescription": "Counts the number of outbound transactions o=
n the AD ring.  This can be filtered by the NDR and SNP message classes.  S=
ee the filter descriptions for more details.; Filter for outbound NDR trans=
actions sent on the AD ring.  NDR stands for non-data response and is gener=
ally used for completions that do not include data.  AD NDR is used for tra=
nsactions to remote sockets.",
+        "UMask": "0x4",
         "Unit": "HA"
     },
     {
-        "BriefDescription": "iMC RPQ Credits Empty - Special; Channel 1",
-        "Counter": "0,1,2,3",
-        "EventCode": "0x16",
-        "EventName": "UNC_H_RPQ_CYCLES_NO_SPEC_CREDITS.CHN1",
+        "BriefDescription": "AD Egress Full; All",
+        "EventCode": "0x2A",
+        "EventName": "UNC_H_TxR_AD_CYCLES_FULL.ALL",
         "PerPkg": "1",
-        "UMask": "0x2",
+        "PublicDescription": "AD Egress Full; Cycles full from both schedu=
lers",
+        "UMask": "0x3",
         "Unit": "HA"
     },
     {
-        "BriefDescription": "iMC RPQ Credits Empty - Special; Channel 2",
-        "Counter": "0,1,2,3",
-        "EventCode": "0x16",
-        "EventName": "UNC_H_RPQ_CYCLES_NO_SPEC_CREDITS.CHN2",
+        "BriefDescription": "AD Egress Full; Scheduler 0",
+        "EventCode": "0x2A",
+        "EventName": "UNC_H_TxR_AD_CYCLES_FULL.SCHED0",
         "PerPkg": "1",
-        "UMask": "0x4",
+        "PublicDescription": "AD Egress Full; Filter for cycles full  from=
 scheduler bank 0",
+        "UMask": "0x1",
         "Unit": "HA"
     },
     {
-        "BriefDescription": "iMC RPQ Credits Empty - Special; Channel 3",
-        "Counter": "0,1,2,3",
-        "EventCode": "0x16",
-        "EventName": "UNC_H_RPQ_CYCLES_NO_SPEC_CREDITS.CHN3",
+        "BriefDescription": "AD Egress Full; Scheduler 1",
+        "EventCode": "0x2A",
+        "EventName": "UNC_H_TxR_AD_CYCLES_FULL.SCHED1",
         "PerPkg": "1",
-        "UMask": "0x8",
+        "PublicDescription": "AD Egress Full; Filter for cycles full  from=
 scheduler bank 1",
+        "UMask": "0x2",
         "Unit": "HA"
     },
     {
-        "BriefDescription": "Outbound NDR Ring Transactions; Non-data Resp=
onses",
-        "Counter": "0,1,2,3",
-        "EventCode": "0xF",
-        "EventName": "UNC_H_TxR_AD.HOM",
+        "BriefDescription": "AD Egress Not Empty; All",
+        "EventCode": "0x29",
+        "EventName": "UNC_H_TxR_AD_CYCLES_NE.ALL",
         "PerPkg": "1",
-        "UMask": "0x4",
+        "PublicDescription": "AD Egress Not Empty; Cycles full from both s=
chedulers",
+        "UMask": "0x3",
         "Unit": "HA"
     },
     {
         "BriefDescription": "AD Egress Not Empty; Scheduler 0",
-        "Counter": "0,1,2,3",
         "EventCode": "0x29",
         "EventName": "UNC_H_TxR_AD_CYCLES_NE.SCHED0",
         "PerPkg": "1",
+        "PublicDescription": "AD Egress Not Empty; Filter for cycles not e=
mpty  from scheduler bank 0",
         "UMask": "0x1",
         "Unit": "HA"
     },
     {
         "BriefDescription": "AD Egress Not Empty; Scheduler 1",
-        "Counter": "0,1,2,3",
         "EventCode": "0x29",
         "EventName": "UNC_H_TxR_AD_CYCLES_NE.SCHED1",
         "PerPkg": "1",
+        "PublicDescription": "AD Egress Not Empty; Filter for cycles not e=
mpty from scheduler bank 1",
         "UMask": "0x2",
         "Unit": "HA"
     },
     {
-        "BriefDescription": "AD Egress Not Empty; All",
-        "Counter": "0,1,2,3",
-        "EventCode": "0x29",
-        "EventName": "UNC_H_TxR_AD_CYCLES_NE.ALL",
+        "BriefDescription": "AD Egress Allocations; All",
+        "EventCode": "0x27",
+        "EventName": "UNC_H_TxR_AD_INSERTS.ALL",
         "PerPkg": "1",
+        "PublicDescription": "AD Egress Allocations; Allocations from both=
 schedulers",
         "UMask": "0x3",
         "Unit": "HA"
     },
     {
         "BriefDescription": "AD Egress Allocations; Scheduler 0",
-        "Counter": "0,1,2,3",
         "EventCode": "0x27",
         "EventName": "UNC_H_TxR_AD_INSERTS.SCHED0",
         "PerPkg": "1",
+        "PublicDescription": "AD Egress Allocations; Filter for allocation=
s from scheduler bank 0",
         "UMask": "0x1",
         "Unit": "HA"
     },
     {
         "BriefDescription": "AD Egress Allocations; Scheduler 1",
-        "Counter": "0,1,2,3",
         "EventCode": "0x27",
         "EventName": "UNC_H_TxR_AD_INSERTS.SCHED1",
         "PerPkg": "1",
+        "PublicDescription": "AD Egress Allocations; Filter for allocation=
s from scheduler bank 1",
         "UMask": "0x2",
         "Unit": "HA"
     },
     {
-        "BriefDescription": "AD Egress Allocations; All",
-        "Counter": "0,1,2,3",
-        "EventCode": "0x27",
-        "EventName": "UNC_H_TxR_AD_INSERTS.ALL",
+        "BriefDescription": "AK Egress Full; All",
+        "EventCode": "0x32",
+        "EventName": "UNC_H_TxR_AK_CYCLES_FULL.ALL",
+        "PerPkg": "1",
+        "PublicDescription": "AK Egress Full; Cycles full from both schedu=
lers",
+        "UMask": "0x3",
+        "Unit": "HA"
+    },
+    {
+        "BriefDescription": "AK Egress Full; Scheduler 0",
+        "EventCode": "0x32",
+        "EventName": "UNC_H_TxR_AK_CYCLES_FULL.SCHED0",
+        "PerPkg": "1",
+        "PublicDescription": "AK Egress Full; Filter for cycles full  from=
 scheduler bank 0",
+        "UMask": "0x1",
+        "Unit": "HA"
+    },
+    {
+        "BriefDescription": "AK Egress Full; Scheduler 1",
+        "EventCode": "0x32",
+        "EventName": "UNC_H_TxR_AK_CYCLES_FULL.SCHED1",
+        "PerPkg": "1",
+        "PublicDescription": "AK Egress Full; Filter for cycles full  from=
 scheduler bank 1",
+        "UMask": "0x2",
+        "Unit": "HA"
+    },
+    {
+        "BriefDescription": "AK Egress Not Empty; All",
+        "EventCode": "0x31",
+        "EventName": "UNC_H_TxR_AK_CYCLES_NE.ALL",
         "PerPkg": "1",
+        "PublicDescription": "AK Egress Not Empty; Cycles full from both s=
chedulers",
         "UMask": "0x3",
         "Unit": "HA"
     },
     {
         "BriefDescription": "AK Egress Not Empty; Scheduler 0",
-        "Counter": "0,1,2,3",
         "EventCode": "0x31",
         "EventName": "UNC_H_TxR_AK_CYCLES_NE.SCHED0",
         "PerPkg": "1",
+        "PublicDescription": "AK Egress Not Empty; Filter for cycles not e=
mpty  from scheduler bank 0",
         "UMask": "0x1",
         "Unit": "HA"
     },
     {
         "BriefDescription": "AK Egress Not Empty; Scheduler 1",
-        "Counter": "0,1,2,3",
         "EventCode": "0x31",
         "EventName": "UNC_H_TxR_AK_CYCLES_NE.SCHED1",
         "PerPkg": "1",
+        "PublicDescription": "AK Egress Not Empty; Filter for cycles not e=
mpty from scheduler bank 1",
         "UMask": "0x2",
         "Unit": "HA"
     },
     {
-        "BriefDescription": "AK Egress Not Empty; All",
-        "Counter": "0,1,2,3",
-        "EventCode": "0x31",
-        "EventName": "UNC_H_TxR_AK_CYCLES_NE.ALL",
+        "BriefDescription": "AK Egress Allocations; All",
+        "EventCode": "0x2F",
+        "EventName": "UNC_H_TxR_AK_INSERTS.ALL",
         "PerPkg": "1",
+        "PublicDescription": "AK Egress Allocations; Allocations from both=
 schedulers",
         "UMask": "0x3",
         "Unit": "HA"
     },
     {
         "BriefDescription": "AK Egress Allocations; Scheduler 0",
-        "Counter": "0,1,2,3",
         "EventCode": "0x2F",
         "EventName": "UNC_H_TxR_AK_INSERTS.SCHED0",
         "PerPkg": "1",
+        "PublicDescription": "AK Egress Allocations; Filter for allocation=
s from scheduler bank 0",
         "UMask": "0x1",
         "Unit": "HA"
     },
     {
         "BriefDescription": "AK Egress Allocations; Scheduler 1",
-        "Counter": "0,1,2,3",
         "EventCode": "0x2F",
         "EventName": "UNC_H_TxR_AK_INSERTS.SCHED1",
         "PerPkg": "1",
+        "PublicDescription": "AK Egress Allocations; Filter for allocation=
s from scheduler bank 1",
         "UMask": "0x2",
         "Unit": "HA"
     },
     {
-        "BriefDescription": "AK Egress Allocations; All",
-        "Counter": "0,1,2,3",
-        "EventCode": "0x2F",
-        "EventName": "UNC_H_TxR_AK_INSERTS.ALL",
+        "BriefDescription": "Outbound DRS Ring Transactions to Cache; Data=
 to Cache",
+        "EventCode": "0x10",
+        "EventName": "UNC_H_TxR_BL.DRS_CACHE",
+        "PerPkg": "1",
+        "PublicDescription": "Counts the number of DRS messages sent out o=
n the BL ring.   This can be filtered by the destination.; Filter for data =
being sent to the cache.",
+        "UMask": "0x1",
+        "Unit": "HA"
+    },
+    {
+        "BriefDescription": "Outbound DRS Ring Transactions to Cache; Data=
 to Core",
+        "EventCode": "0x10",
+        "EventName": "UNC_H_TxR_BL.DRS_CORE",
+        "PerPkg": "1",
+        "PublicDescription": "Counts the number of DRS messages sent out o=
n the BL ring.   This can be filtered by the destination.; Filter for data =
being sent directly to the requesting core.",
+        "UMask": "0x2",
+        "Unit": "HA"
+    },
+    {
+        "BriefDescription": "Outbound DRS Ring Transactions to Cache; Data=
 to QPI",
+        "EventCode": "0x10",
+        "EventName": "UNC_H_TxR_BL.DRS_QPI",
+        "PerPkg": "1",
+        "PublicDescription": "Counts the number of DRS messages sent out o=
n the BL ring.   This can be filtered by the destination.; Filter for data =
being sent to a remote socket over QPI.",
+        "UMask": "0x4",
+        "Unit": "HA"
+    },
+    {
+        "BriefDescription": "BL Egress Full; All",
+        "EventCode": "0x36",
+        "EventName": "UNC_H_TxR_BL_CYCLES_FULL.ALL",
+        "PerPkg": "1",
+        "PublicDescription": "BL Egress Full; Cycles full from both schedu=
lers",
+        "UMask": "0x3",
+        "Unit": "HA"
+    },
+    {
+        "BriefDescription": "BL Egress Full; Scheduler 0",
+        "EventCode": "0x36",
+        "EventName": "UNC_H_TxR_BL_CYCLES_FULL.SCHED0",
+        "PerPkg": "1",
+        "PublicDescription": "BL Egress Full; Filter for cycles full  from=
 scheduler bank 0",
+        "UMask": "0x1",
+        "Unit": "HA"
+    },
+    {
+        "BriefDescription": "BL Egress Full; Scheduler 1",
+        "EventCode": "0x36",
+        "EventName": "UNC_H_TxR_BL_CYCLES_FULL.SCHED1",
+        "PerPkg": "1",
+        "PublicDescription": "BL Egress Full; Filter for cycles full  from=
 scheduler bank 1",
+        "UMask": "0x2",
+        "Unit": "HA"
+    },
+    {
+        "BriefDescription": "BL Egress Not Empty; All",
+        "EventCode": "0x35",
+        "EventName": "UNC_H_TxR_BL_CYCLES_NE.ALL",
         "PerPkg": "1",
+        "PublicDescription": "BL Egress Not Empty; Cycles full from both s=
chedulers",
         "UMask": "0x3",
         "Unit": "HA"
     },
     {
         "BriefDescription": "BL Egress Not Empty; Scheduler 0",
-        "Counter": "0,1,2,3",
         "EventCode": "0x35",
         "EventName": "UNC_H_TxR_BL_CYCLES_NE.SCHED0",
         "PerPkg": "1",
+        "PublicDescription": "BL Egress Not Empty; Filter for cycles not e=
mpty  from scheduler bank 0",
         "UMask": "0x1",
         "Unit": "HA"
     },
     {
         "BriefDescription": "BL Egress Not Empty; Scheduler 1",
-        "Counter": "0,1,2,3",
         "EventCode": "0x35",
         "EventName": "UNC_H_TxR_BL_CYCLES_NE.SCHED1",
         "PerPkg": "1",
+        "PublicDescription": "BL Egress Not Empty; Filter for cycles not e=
mpty from scheduler bank 1",
         "UMask": "0x2",
         "Unit": "HA"
     },
     {
-        "BriefDescription": "BL Egress Not Empty; All",
-        "Counter": "0,1,2,3",
-        "EventCode": "0x35",
-        "EventName": "UNC_H_TxR_BL_CYCLES_NE.ALL",
+        "BriefDescription": "BL Egress Allocations; All",
+        "EventCode": "0x33",
+        "EventName": "UNC_H_TxR_BL_INSERTS.ALL",
         "PerPkg": "1",
+        "PublicDescription": "BL Egress Allocations; Allocations from both=
 schedulers",
         "UMask": "0x3",
         "Unit": "HA"
     },
     {
         "BriefDescription": "BL Egress Allocations; Scheduler 0",
-        "Counter": "0,1,2,3",
         "EventCode": "0x33",
         "EventName": "UNC_H_TxR_BL_INSERTS.SCHED0",
         "PerPkg": "1",
+        "PublicDescription": "BL Egress Allocations; Filter for allocation=
s from scheduler bank 0",
         "UMask": "0x1",
         "Unit": "HA"
     },
     {
         "BriefDescription": "BL Egress Allocations; Scheduler 1",
-        "Counter": "0,1,2,3",
         "EventCode": "0x33",
         "EventName": "UNC_H_TxR_BL_INSERTS.SCHED1",
         "PerPkg": "1",
+        "PublicDescription": "BL Egress Allocations; Filter for allocation=
s from scheduler bank 1",
         "UMask": "0x2",
         "Unit": "HA"
     },
     {
-        "BriefDescription": "BL Egress Allocations; All",
-        "Counter": "0,1,2,3",
-        "EventCode": "0x33",
-        "EventName": "UNC_H_TxR_BL_INSERTS.ALL",
+        "BriefDescription": "Injection Starvation; For AK Ring",
+        "EventCode": "0x6D",
+        "EventName": "UNC_H_TxR_STARVED.AK",
         "PerPkg": "1",
-        "UMask": "0x3",
+        "PublicDescription": "Counts injection starvation.  This starvatio=
n is triggered when the Egress cannot send a transaction onto the ring for =
a long period of time.",
+        "UMask": "0x1",
+        "Unit": "HA"
+    },
+    {
+        "BriefDescription": "Injection Starvation; For BL Ring",
+        "EventCode": "0x6D",
+        "EventName": "UNC_H_TxR_STARVED.BL",
+        "PerPkg": "1",
+        "PublicDescription": "Counts injection starvation.  This starvatio=
n is triggered when the Egress cannot send a transaction onto the ring for =
a long period of time.",
+        "UMask": "0x2",
+        "Unit": "HA"
+    },
+    {
+        "BriefDescription": "HA iMC CHN0 WPQ Credits Empty - Regular; Chan=
nel 0",
+        "EventCode": "0x18",
+        "EventName": "UNC_H_WPQ_CYCLES_NO_REG_CREDITS.CHN0",
+        "PerPkg": "1",
+        "PublicDescription": "Counts the number of cycles when there are n=
o regular credits available for posting writes from the HA into the iMC.  I=
n order to send writes into the memory controller, the HA must first acquir=
e a credit for the iMC's WPQ (write pending queue).  This queue is broken i=
nto regular credits/buffers that are used by general writes, and special re=
quests such as ISOCH writes.  This count only tracks the regular credits  C=
ommon high banwidth workloads should be able to make use of all of the regu=
lar buffers, but it will be difficult (and uncommon) to make use of both th=
e regular and special buffers at the same time.  One can filter based on th=
e memory controller channel.  One or more channels can be tracked at a give=
n time.; Filter for memory controller channel 0 only.",
+        "UMask": "0x1",
+        "Unit": "HA"
+    },
+    {
+        "BriefDescription": "HA iMC CHN0 WPQ Credits Empty - Regular; Chan=
nel 1",
+        "EventCode": "0x18",
+        "EventName": "UNC_H_WPQ_CYCLES_NO_REG_CREDITS.CHN1",
+        "PerPkg": "1",
+        "PublicDescription": "Counts the number of cycles when there are n=
o regular credits available for posting writes from the HA into the iMC.  I=
n order to send writes into the memory controller, the HA must first acquir=
e a credit for the iMC's WPQ (write pending queue).  This queue is broken i=
nto regular credits/buffers that are used by general writes, and special re=
quests such as ISOCH writes.  This count only tracks the regular credits  C=
ommon high banwidth workloads should be able to make use of all of the regu=
lar buffers, but it will be difficult (and uncommon) to make use of both th=
e regular and special buffers at the same time.  One can filter based on th=
e memory controller channel.  One or more channels can be tracked at a give=
n time.; Filter for memory controller channel 1 only.",
+        "UMask": "0x2",
+        "Unit": "HA"
+    },
+    {
+        "BriefDescription": "HA iMC CHN0 WPQ Credits Empty - Regular; Chan=
nel 2",
+        "EventCode": "0x18",
+        "EventName": "UNC_H_WPQ_CYCLES_NO_REG_CREDITS.CHN2",
+        "PerPkg": "1",
+        "PublicDescription": "Counts the number of cycles when there are n=
o regular credits available for posting writes from the HA into the iMC.  I=
n order to send writes into the memory controller, the HA must first acquir=
e a credit for the iMC's WPQ (write pending queue).  This queue is broken i=
nto regular credits/buffers that are used by general writes, and special re=
quests such as ISOCH writes.  This count only tracks the regular credits  C=
ommon high banwidth workloads should be able to make use of all of the regu=
lar buffers, but it will be difficult (and uncommon) to make use of both th=
e regular and special buffers at the same time.  One can filter based on th=
e memory controller channel.  One or more channels can be tracked at a give=
n time.; Filter for memory controller channel 2 only.",
+        "UMask": "0x4",
+        "Unit": "HA"
+    },
+    {
+        "BriefDescription": "HA iMC CHN0 WPQ Credits Empty - Regular; Chan=
nel 3",
+        "EventCode": "0x18",
+        "EventName": "UNC_H_WPQ_CYCLES_NO_REG_CREDITS.CHN3",
+        "PerPkg": "1",
+        "PublicDescription": "Counts the number of cycles when there are n=
o regular credits available for posting writes from the HA into the iMC.  I=
n order to send writes into the memory controller, the HA must first acquir=
e a credit for the iMC's WPQ (write pending queue).  This queue is broken i=
nto regular credits/buffers that are used by general writes, and special re=
quests such as ISOCH writes.  This count only tracks the regular credits  C=
ommon high banwidth workloads should be able to make use of all of the regu=
lar buffers, but it will be difficult (and uncommon) to make use of both th=
e regular and special buffers at the same time.  One can filter based on th=
e memory controller channel.  One or more channels can be tracked at a give=
n time.; Filter for memory controller channel 3 only.",
+        "UMask": "0x8",
         "Unit": "HA"
     },
     {
         "BriefDescription": "HA iMC CHN0 WPQ Credits Empty - Special; Chan=
nel 0",
-        "Counter": "0,1,2,3",
         "EventCode": "0x19",
         "EventName": "UNC_H_WPQ_CYCLES_NO_SPEC_CREDITS.CHN0",
         "PerPkg": "1",
+        "PublicDescription": "Counts the number of cycles when there are n=
o special credits available for posting writes from the HA into the iMC.  I=
n order to send writes into the memory controller, the HA must first acquir=
e a credit for the iMC's WPQ (write pending queue).  This queue is broken i=
nto regular credits/buffers that are used by general writes, and special re=
quests such as ISOCH writes.  This count only tracks the special credits.  =
This statistic is generally not interesting for general IA workloads, but m=
ay be of interest for understanding the characteristics of systems using IS=
OCH.  One can filter based on the memory controller channel.  One or more c=
hannels can be tracked at a given time.; Filter for memory controller chann=
el 0 only.",
         "UMask": "0x1",
         "Unit": "HA"
     },
     {
         "BriefDescription": "HA iMC CHN0 WPQ Credits Empty - Special; Chan=
nel 1",
-        "Counter": "0,1,2,3",
         "EventCode": "0x19",
         "EventName": "UNC_H_WPQ_CYCLES_NO_SPEC_CREDITS.CHN1",
         "PerPkg": "1",
+        "PublicDescription": "Counts the number of cycles when there are n=
o special credits available for posting writes from the HA into the iMC.  I=
n order to send writes into the memory controller, the HA must first acquir=
e a credit for the iMC's WPQ (write pending queue).  This queue is broken i=
nto regular credits/buffers that are used by general writes, and special re=
quests such as ISOCH writes.  This count only tracks the special credits.  =
This statistic is generally not interesting for general IA workloads, but m=
ay be of interest for understanding the characteristics of systems using IS=
OCH.  One can filter based on the memory controller channel.  One or more c=
hannels can be tracked at a given time.; Filter for memory controller chann=
el 1 only.",
         "UMask": "0x2",
         "Unit": "HA"
     },
     {
         "BriefDescription": "HA iMC CHN0 WPQ Credits Empty - Special; Chan=
nel 2",
-        "Counter": "0,1,2,3",
         "EventCode": "0x19",
         "EventName": "UNC_H_WPQ_CYCLES_NO_SPEC_CREDITS.CHN2",
         "PerPkg": "1",
+        "PublicDescription": "Counts the number of cycles when there are n=
o special credits available for posting writes from the HA into the iMC.  I=
n order to send writes into the memory controller, the HA must first acquir=
e a credit for the iMC's WPQ (write pending queue).  This queue is broken i=
nto regular credits/buffers that are used by general writes, and special re=
quests such as ISOCH writes.  This count only tracks the special credits.  =
This statistic is generally not interesting for general IA workloads, but m=
ay be of interest for understanding the characteristics of systems using IS=
OCH.  One can filter based on the memory controller channel.  One or more c=
hannels can be tracked at a given time.; Filter for memory controller chann=
el 2 only.",
         "UMask": "0x4",
         "Unit": "HA"
     },
     {
         "BriefDescription": "HA iMC CHN0 WPQ Credits Empty - Special; Chan=
nel 3",
-        "Counter": "0,1,2,3",
         "EventCode": "0x19",
         "EventName": "UNC_H_WPQ_CYCLES_NO_SPEC_CREDITS.CHN3",
         "PerPkg": "1",
+        "PublicDescription": "Counts the number of cycles when there are n=
o special credits available for posting writes from the HA into the iMC.  I=
n order to send writes into the memory controller, the HA must first acquir=
e a credit for the iMC's WPQ (write pending queue).  This queue is broken i=
nto regular credits/buffers that are used by general writes, and special re=
quests such as ISOCH writes.  This count only tracks the special credits.  =
This statistic is generally not interesting for general IA workloads, but m=
ay be of interest for understanding the characteristics of systems using IS=
OCH.  One can filter based on the memory controller channel.  One or more c=
hannels can be tracked at a given time.; Filter for memory controller chann=
el 3 only.",
         "UMask": "0x8",
         "Unit": "HA"
-    },
-    {
-        "BriefDescription": "HA AK Ring in Use; All",
-        "Counter": "0,1,2,3",
-        "EventCode": "0x3F",
-        "EventName": "UNC_H_RING_AK_USED.ALL",
-        "PerPkg": "1",
-        "UMask": "0xF",
-        "Unit": "HA"
-    },
-    {
-        "BriefDescription": "HA BL Ring in Use; All",
-        "Counter": "0,1,2,3",
-        "EventCode": "0x40",
-        "EventName": "UNC_H_RING_BL_USED.ALL",
-        "PerPkg": "1",
-        "UMask": "0xF",
-        "Unit": "HA"
     }
 ]
diff --git a/tools/perf/pmu-events/arch/x86/broadwellx/uncore-interconnect.=
json b/tools/perf/pmu-events/arch/x86/broadwellx/uncore-interconnect.json
index cb1916f52607..489a3673323d 100644
--- a/tools/perf/pmu-events/arch/x86/broadwellx/uncore-interconnect.json
+++ b/tools/perf/pmu-events/arch/x86/broadwellx/uncore-interconnect.json
@@ -1,1452 +1,1331 @@
 [
+    {
+        "BriefDescription": "Number of non data (control) flits transmitte=
d . Derived from unc_q_txl_flits_g0.non_data",
+        "EventName": "QPI_CTL_BANDWIDTH_TX",
+        "PerPkg": "1",
+        "PublicDescription": "Counts the number of flits transmitted acros=
s the QPI Link.  It includes filters for Idle, protocol, and Data Flits.  E=
ach flit is made up of 80 bits of information (in addition to some ECC data=
).  In full-width (L0) mode, flits are made up of four fits, each of which =
contains 20 bits of data (along with some additional ECC data).   In half-w=
idth (L0p) mode, the fits are only 10 bits, and therefore it takes twice as=
 many fits to transmit a flit.  When one talks about QPI speed (for example=
, 8.0 GT/s), the transfers here refer to fits.  Therefore, in L0, the syste=
m will transfer 1 flit at the rate of 1/4th the QPI speed.  One can calcula=
te the bandwidth of the link by taking: flits*80b/time.  Note that this is =
not the same as data bandwidth.  For example, when we are transferring a 64=
B cacheline across QPI, we will break it into 9 flits -- 1 with header info=
rmation and 8 with 64 bits of actual data and an additional 16 bits of othe=
r information.  To calculate data bandwidth, one should therefore do: data =
flits * 8B / time (for L0) or 4B instead of 8B for L0p.; Number of non-NULL=
 non-data flits transmitted across QPI.  This basically tracks the protocol=
 overhead on the QPI link.  One can get a good picture of the QPI-link char=
acteristics by evaluating the protocol flits, data flits, and idle/null fli=
ts.  This includes the header flits for data packets.",
+        "ScaleUnit": "8Bytes",
+        "UMask": "0x4",
+        "Unit": "QPI LL"
+    },
+    {
+        "BriefDescription": "Number of data flits transmitted . Derived fr=
om unc_q_txl_flits_g0.data",
+        "EventName": "QPI_DATA_BANDWIDTH_TX",
+        "PerPkg": "1",
+        "PublicDescription": "Counts the number of flits transmitted acros=
s the QPI Link.  It includes filters for Idle, protocol, and Data Flits.  E=
ach flit is made up of 80 bits of information (in addition to some ECC data=
).  In full-width (L0) mode, flits are made up of four fits, each of which =
contains 20 bits of data (along with some additional ECC data).   In half-w=
idth (L0p) mode, the fits are only 10 bits, and therefore it takes twice as=
 many fits to transmit a flit.  When one talks about QPI speed (for example=
, 8.0 GT/s), the transfers here refer to fits.  Therefore, in L0, the syste=
m will transfer 1 flit at the rate of 1/4th the QPI speed.  One can calcula=
te the bandwidth of the link by taking: flits*80b/time.  Note that this is =
not the same as data bandwidth.  For example, when we are transferring a 64=
B cacheline across QPI, we will break it into 9 flits -- 1 with header info=
rmation and 8 with 64 bits of actual data and an additional 16 bits of othe=
r information.  To calculate data bandwidth, one should therefore do: data =
flits * 8B / time (for L0) or 4B instead of 8B for L0p.; Number of data fli=
ts transmitted over QPI.  Each flit contains 64b of data.  This includes bo=
th DRS and NCB data flits (coherent and non-coherent).  This can be used to=
 calculate the data bandwidth of the QPI link.  One can get a good picture =
of the QPI-link characteristics by evaluating the protocol flits, data flit=
s, and idle/null flits.  This does not include the header flits that go in =
data packets.",
+        "ScaleUnit": "8Bytes",
+        "UMask": "0x2",
+        "Unit": "QPI LL"
+    },
     {
         "BriefDescription": "Number of qfclks",
-        "Counter": "0,1,2,3",
         "EventCode": "0x14",
         "EventName": "UNC_Q_CLOCKTICKS",
         "PerPkg": "1",
+        "PublicDescription": "Counts the number of clocks in the QPI LL.  =
This clock runs at 1/4th the GT/s speed of the QPI link.  For example, a 4G=
T/s link will have qfclk or 1GHz.  BDX does not support dynamic link speeds=
, so this frequency is fixed.",
         "Unit": "QPI LL"
     },
     {
         "BriefDescription": "Count of CTO Events",
-        "Counter": "0,1,2,3",
         "EventCode": "0x38",
         "EventName": "UNC_Q_CTO_COUNT",
-        "ExtSel": "1",
         "PerPkg": "1",
-        "Unit": "QPI LL"
-    },
-    {
-        "BriefDescription": "Direct 2 Core Spawning; Spawn Success",
-        "Counter": "0,1,2,3",
-        "EventCode": "0x13",
-        "EventName": "UNC_Q_DIRECT2CORE.SUCCESS_RBT_HIT",
-        "PerPkg": "1",
-        "UMask": "0x1",
+        "PublicDescription": "Counts the number of CTO (cluster trigger ou=
ts) events that were asserted across the two slots.  If both slots trigger =
in a given cycle, the event will increment by 2.  You can use edge detect t=
o count the number of cases when both events triggered.",
         "Unit": "QPI LL"
     },
     {
         "BriefDescription": "Direct 2 Core Spawning; Spawn Failure - Egres=
s Credits",
-        "Counter": "0,1,2,3",
         "EventCode": "0x13",
         "EventName": "UNC_Q_DIRECT2CORE.FAILURE_CREDITS",
         "PerPkg": "1",
+        "PublicDescription": "Counts the number of DRS packets that we att=
empted to do direct2core on.  There are 4 mutually exlusive filters.  Filte=
r [0] can be used to get successful spawns, while [1:3] provide the differe=
nt failure cases.  Note that this does not count packets that are not candi=
dates for Direct2Core.  The only candidates for Direct2Core are DRS packets=
 destined for Cbos.; The spawn failed because there were not enough Egress =
credits.  Had there been enough credits, the spawn would have worked as the=
 RBT bit was set and the RBT tag matched.",
         "UMask": "0x2",
         "Unit": "QPI LL"
     },
     {
-        "BriefDescription": "Direct 2 Core Spawning; Spawn Failure - RBT I=
nvalid",
-        "Counter": "0,1,2,3",
+        "BriefDescription": "Direct 2 Core Spawning; Spawn Failure - Egres=
s and RBT Miss",
         "EventCode": "0x13",
-        "EventName": "UNC_Q_DIRECT2CORE.FAILURE_RBT_HIT",
+        "EventName": "UNC_Q_DIRECT2CORE.FAILURE_CREDITS_MISS",
         "PerPkg": "1",
-        "UMask": "0x4",
+        "PublicDescription": "Counts the number of DRS packets that we att=
empted to do direct2core on.  There are 4 mutually exlusive filters.  Filte=
r [0] can be used to get successful spawns, while [1:3] provide the differe=
nt failure cases.  Note that this does not count packets that are not candi=
dates for Direct2Core.  The only candidates for Direct2Core are DRS packets=
 destined for Cbos.; The spawn failed because the RBT tag did not match and=
 there weren't enough Egress credits.   The valid bit was set.",
+        "UMask": "0x20",
         "Unit": "QPI LL"
     },
     {
         "BriefDescription": "Direct 2 Core Spawning; Spawn Failure - Egres=
s and RBT Invalid",
-        "Counter": "0,1,2,3",
         "EventCode": "0x13",
         "EventName": "UNC_Q_DIRECT2CORE.FAILURE_CREDITS_RBT",
         "PerPkg": "1",
+        "PublicDescription": "Counts the number of DRS packets that we att=
empted to do direct2core on.  There are 4 mutually exlusive filters.  Filte=
r [0] can be used to get successful spawns, while [1:3] provide the differe=
nt failure cases.  Note that this does not count packets that are not candi=
dates for Direct2Core.  The only candidates for Direct2Core are DRS packets=
 destined for Cbos.; The spawn failed because there were not enough Egress =
credits AND the RBT bit was not set, but the RBT tag matched.",
         "UMask": "0x8",
         "Unit": "QPI LL"
     },
+    {
+        "BriefDescription": "Direct 2 Core Spawning; Spawn Failure - Egres=
s and RBT Miss, Invalid",
+        "EventCode": "0x13",
+        "EventName": "UNC_Q_DIRECT2CORE.FAILURE_CREDITS_RBT_MISS",
+        "PerPkg": "1",
+        "PublicDescription": "Counts the number of DRS packets that we att=
empted to do direct2core on.  There are 4 mutually exlusive filters.  Filte=
r [0] can be used to get successful spawns, while [1:3] provide the differe=
nt failure cases.  Note that this does not count packets that are not candi=
dates for Direct2Core.  The only candidates for Direct2Core are DRS packets=
 destined for Cbos.; The spawn failed because the RBT tag did not match, th=
e valid bit was not set and there weren't enough Egress credits.",
+        "UMask": "0x80",
+        "Unit": "QPI LL"
+    },
     {
         "BriefDescription": "Direct 2 Core Spawning; Spawn Failure - RBT M=
iss",
-        "Counter": "0,1,2,3",
         "EventCode": "0x13",
         "EventName": "UNC_Q_DIRECT2CORE.FAILURE_MISS",
         "PerPkg": "1",
+        "PublicDescription": "Counts the number of DRS packets that we att=
empted to do direct2core on.  There are 4 mutually exlusive filters.  Filte=
r [0] can be used to get successful spawns, while [1:3] provide the differe=
nt failure cases.  Note that this does not count packets that are not candi=
dates for Direct2Core.  The only candidates for Direct2Core are DRS packets=
 destined for Cbos.; The spawn failed because the RBT tag did not match alt=
hough the valid bit was set and there were enough Egress credits.",
         "UMask": "0x10",
         "Unit": "QPI LL"
     },
     {
-        "BriefDescription": "Direct 2 Core Spawning; Spawn Failure - Egres=
s and RBT Miss",
-        "Counter": "0,1,2,3",
+        "BriefDescription": "Direct 2 Core Spawning; Spawn Failure - RBT I=
nvalid",
         "EventCode": "0x13",
-        "EventName": "UNC_Q_DIRECT2CORE.FAILURE_CREDITS_MISS",
+        "EventName": "UNC_Q_DIRECT2CORE.FAILURE_RBT_HIT",
         "PerPkg": "1",
-        "UMask": "0x20",
+        "PublicDescription": "Counts the number of DRS packets that we att=
empted to do direct2core on.  There are 4 mutually exlusive filters.  Filte=
r [0] can be used to get successful spawns, while [1:3] provide the differe=
nt failure cases.  Note that this does not count packets that are not candi=
dates for Direct2Core.  The only candidates for Direct2Core are DRS packets=
 destined for Cbos.; The spawn failed because the route-back table (RBT) sp=
ecified that the transaction should not trigger a direct2core tranaction.  =
This is common for IO transactions.  There were enough Egress credits and t=
he RBT tag matched but the valid bit was not set.",
+        "UMask": "0x4",
         "Unit": "QPI LL"
     },
     {
         "BriefDescription": "Direct 2 Core Spawning; Spawn Failure - RBT M=
iss and Invalid",
-        "Counter": "0,1,2,3",
         "EventCode": "0x13",
         "EventName": "UNC_Q_DIRECT2CORE.FAILURE_RBT_MISS",
         "PerPkg": "1",
+        "PublicDescription": "Counts the number of DRS packets that we att=
empted to do direct2core on.  There are 4 mutually exlusive filters.  Filte=
r [0] can be used to get successful spawns, while [1:3] provide the differe=
nt failure cases.  Note that this does not count packets that are not candi=
dates for Direct2Core.  The only candidates for Direct2Core are DRS packets=
 destined for Cbos.; The spawn failed because the RBT tag did not match and=
 the valid bit was not set although there were enough Egress credits.",
         "UMask": "0x40",
         "Unit": "QPI LL"
     },
     {
-        "BriefDescription": "Direct 2 Core Spawning; Spawn Failure - Egres=
s and RBT Miss, Invalid",
-        "Counter": "0,1,2,3",
+        "BriefDescription": "Direct 2 Core Spawning; Spawn Success",
         "EventCode": "0x13",
-        "EventName": "UNC_Q_DIRECT2CORE.FAILURE_CREDITS_RBT_MISS",
+        "EventName": "UNC_Q_DIRECT2CORE.SUCCESS_RBT_HIT",
         "PerPkg": "1",
-        "UMask": "0x80",
+        "PublicDescription": "Counts the number of DRS packets that we att=
empted to do direct2core on.  There are 4 mutually exlusive filters.  Filte=
r [0] can be used to get successful spawns, while [1:3] provide the differe=
nt failure cases.  Note that this does not count packets that are not candi=
dates for Direct2Core.  The only candidates for Direct2Core are DRS packets=
 destined for Cbos.; The spawn was successful.  There were sufficient credi=
ts, the RBT valid bit was set and there was an RBT tag match.  The message =
was marked to spawn direct2core.",
+        "UMask": "0x1",
         "Unit": "QPI LL"
     },
     {
         "BriefDescription": "Cycles in L1",
-        "Counter": "0,1,2,3",
         "EventCode": "0x12",
         "EventName": "UNC_Q_L1_POWER_CYCLES",
         "PerPkg": "1",
+        "PublicDescription": "Number of QPI qfclk cycles spent in L1 power=
 mode.  L1 is a mode that totally shuts down a QPI link.  Use edge detect t=
o count the number of instances when the QPI link entered L1.  Link power s=
tates are per link and per direction, so for example the Tx direction could=
 be in one state while Rx was in another. Because L1 totally shuts down the=
 link, it takes a good amount of time to exit this mode.",
         "Unit": "QPI LL"
     },
     {
         "BriefDescription": "Cycles in L0p",
-        "Counter": "0,1,2,3",
         "EventCode": "0x10",
         "EventName": "UNC_Q_RxL0P_POWER_CYCLES",
         "PerPkg": "1",
+        "PublicDescription": "Number of QPI qfclk cycles spent in L0p powe=
r mode.  L0p is a mode where we disable 1/2 of the QPI lanes, decreasing ou=
r bandwidth in order to save power.  It increases snoop and data transfer l=
atencies and decreases overall bandwidth.  This mode can be very useful in =
NUMA optimized workloads that largely only utilize QPI for snoops and their=
 responses.  Use edge detect to count the number of instances when the QPI =
link entered L0p.  Link power states are per link and per direction, so for=
 example the Tx direction could be in one state while Rx was in another.",
         "Unit": "QPI LL"
     },
     {
         "BriefDescription": "Cycles in L0",
-        "Counter": "0,1,2,3",
         "EventCode": "0xF",
         "EventName": "UNC_Q_RxL0_POWER_CYCLES",
         "PerPkg": "1",
+        "PublicDescription": "Number of QPI qfclk cycles spent in L0 power=
 mode in the Link Layer.  L0 is the default mode which provides the highest=
 performance with the most power.  Use edge detect to count the number of i=
nstances that the link entered L0.  Link power states are per link and per =
direction, so for example the Tx direction could be in one state while Rx w=
as in another.  The phy layer  sometimes leaves L0 for training, which will=
 not be captured by this event.",
         "Unit": "QPI LL"
     },
     {
         "BriefDescription": "Rx Flit Buffer Bypassed",
-        "Counter": "0,1,2,3",
         "EventCode": "0x9",
         "EventName": "UNC_Q_RxL_BYPASSED",
         "PerPkg": "1",
+        "PublicDescription": "Counts the number of times that an incoming =
flit was able to bypass the flit buffer and pass directly across the BGF an=
d into the Egress.  This is a latency optimization, and should generally be=
 the common case.  If this value is less than the number of flits transferr=
ed, it implies that there was queueing getting onto the ring, and thus the =
transactions saw higher latency.",
+        "Unit": "QPI LL"
+    },
+    {
+        "BriefDescription": "CRC Errors Detected; LinkInit",
+        "EventCode": "0x3",
+        "EventName": "UNC_Q_RxL_CRC_ERRORS.LINK_INIT",
+        "PerPkg": "1",
+        "PublicDescription": "Number of CRC errors detected in the QPI Age=
nt.  Each QPI flit incorporates 8 bits of CRC for error detection.  This co=
unts the number of flits where the CRC was able to detect an error.  After =
an error has been detected, the QPI agent will send a request to the transm=
itting socket to resend the flit (as well as any flits that came after it).=
; CRC errors detected during link initialization.",
+        "UMask": "0x1",
+        "Unit": "QPI LL"
+    },
+    {
+        "BriefDescription": "UNC_Q_RxL_CRC_ERRORS.NORMAL_OP",
+        "EventCode": "0x3",
+        "EventName": "UNC_Q_RxL_CRC_ERRORS.NORMAL_OP",
+        "PerPkg": "1",
+        "UMask": "0x2",
         "Unit": "QPI LL"
     },
     {
         "BriefDescription": "VN0 Credit Consumed; DRS",
-        "Counter": "0,1,2,3",
         "EventCode": "0x1E",
         "EventName": "UNC_Q_RxL_CREDITS_CONSUMED_VN0.DRS",
-        "ExtSel": "1",
         "PerPkg": "1",
+        "PublicDescription": "Counts the number of times that an RxQ VN0 c=
redit was consumed (i.e. message uses a VN0 credit for the Rx Buffer).  Thi=
s includes packets that went through the RxQ and those that were bypasssed.=
; VN0 credit for the DRS message class.",
         "UMask": "0x1",
         "Unit": "QPI LL"
     },
+    {
+        "BriefDescription": "VN0 Credit Consumed; HOM",
+        "EventCode": "0x1E",
+        "EventName": "UNC_Q_RxL_CREDITS_CONSUMED_VN0.HOM",
+        "PerPkg": "1",
+        "PublicDescription": "Counts the number of times that an RxQ VN0 c=
redit was consumed (i.e. message uses a VN0 credit for the Rx Buffer).  Thi=
s includes packets that went through the RxQ and those that were bypasssed.=
; VN0 credit for the HOM message class.",
+        "UMask": "0x8",
+        "Unit": "QPI LL"
+    },
     {
         "BriefDescription": "VN0 Credit Consumed; NCB",
-        "Counter": "0,1,2,3",
         "EventCode": "0x1E",
         "EventName": "UNC_Q_RxL_CREDITS_CONSUMED_VN0.NCB",
-        "ExtSel": "1",
         "PerPkg": "1",
+        "PublicDescription": "Counts the number of times that an RxQ VN0 c=
redit was consumed (i.e. message uses a VN0 credit for the Rx Buffer).  Thi=
s includes packets that went through the RxQ and those that were bypasssed.=
; VN0 credit for the NCB message class.",
         "UMask": "0x2",
         "Unit": "QPI LL"
     },
     {
         "BriefDescription": "VN0 Credit Consumed; NCS",
-        "Counter": "0,1,2,3",
         "EventCode": "0x1E",
         "EventName": "UNC_Q_RxL_CREDITS_CONSUMED_VN0.NCS",
-        "ExtSel": "1",
         "PerPkg": "1",
+        "PublicDescription": "Counts the number of times that an RxQ VN0 c=
redit was consumed (i.e. message uses a VN0 credit for the Rx Buffer).  Thi=
s includes packets that went through the RxQ and those that were bypasssed.=
; VN0 credit for the NCS message class.",
         "UMask": "0x4",
         "Unit": "QPI LL"
     },
     {
-        "BriefDescription": "VN0 Credit Consumed; HOM",
-        "Counter": "0,1,2,3",
+        "BriefDescription": "VN0 Credit Consumed; NDR",
         "EventCode": "0x1E",
-        "EventName": "UNC_Q_RxL_CREDITS_CONSUMED_VN0.HOM",
-        "ExtSel": "1",
+        "EventName": "UNC_Q_RxL_CREDITS_CONSUMED_VN0.NDR",
         "PerPkg": "1",
-        "UMask": "0x8",
+        "PublicDescription": "Counts the number of times that an RxQ VN0 c=
redit was consumed (i.e. message uses a VN0 credit for the Rx Buffer).  Thi=
s includes packets that went through the RxQ and those that were bypasssed.=
; VN0 credit for the NDR message class.",
+        "UMask": "0x20",
         "Unit": "QPI LL"
     },
     {
         "BriefDescription": "VN0 Credit Consumed; SNP",
-        "Counter": "0,1,2,3",
         "EventCode": "0x1E",
         "EventName": "UNC_Q_RxL_CREDITS_CONSUMED_VN0.SNP",
-        "ExtSel": "1",
         "PerPkg": "1",
+        "PublicDescription": "Counts the number of times that an RxQ VN0 c=
redit was consumed (i.e. message uses a VN0 credit for the Rx Buffer).  Thi=
s includes packets that went through the RxQ and those that were bypasssed.=
; VN0 credit for the SNP message class.",
         "UMask": "0x10",
         "Unit": "QPI LL"
     },
     {
-        "BriefDescription": "VN0 Credit Consumed; NDR",
-        "Counter": "0,1,2,3",
-        "EventCode": "0x1E",
-        "EventName": "UNC_Q_RxL_CREDITS_CONSUMED_VN0.NDR",
-        "ExtSel": "1",
+        "BriefDescription": "VN1 Credit Consumed; DRS",
+        "EventCode": "0x39",
+        "EventName": "UNC_Q_RxL_CREDITS_CONSUMED_VN1.DRS",
         "PerPkg": "1",
-        "UMask": "0x20",
+        "PublicDescription": "Counts the number of times that an RxQ VN1 c=
redit was consumed (i.e. message uses a VN1 credit for the Rx Buffer).  Thi=
s includes packets that went through the RxQ and those that were bypasssed.=
; VN1 credit for the DRS message class.",
+        "UMask": "0x1",
         "Unit": "QPI LL"
     },
     {
-        "BriefDescription": "VN1 Credit Consumed; DRS",
-        "Counter": "0,1,2,3",
+        "BriefDescription": "VN1 Credit Consumed; HOM",
         "EventCode": "0x39",
-        "EventName": "UNC_Q_RxL_CREDITS_CONSUMED_VN1.DRS",
-        "ExtSel": "1",
+        "EventName": "UNC_Q_RxL_CREDITS_CONSUMED_VN1.HOM",
         "PerPkg": "1",
-        "UMask": "0x1",
+        "PublicDescription": "Counts the number of times that an RxQ VN1 c=
redit was consumed (i.e. message uses a VN1 credit for the Rx Buffer).  Thi=
s includes packets that went through the RxQ and those that were bypasssed.=
; VN1 credit for the HOM message class.",
+        "UMask": "0x8",
         "Unit": "QPI LL"
     },
     {
         "BriefDescription": "VN1 Credit Consumed; NCB",
-        "Counter": "0,1,2,3",
         "EventCode": "0x39",
         "EventName": "UNC_Q_RxL_CREDITS_CONSUMED_VN1.NCB",
-        "ExtSel": "1",
         "PerPkg": "1",
+        "PublicDescription": "Counts the number of times that an RxQ VN1 c=
redit was consumed (i.e. message uses a VN1 credit for the Rx Buffer).  Thi=
s includes packets that went through the RxQ and those that were bypasssed.=
; VN1 credit for the NCB message class.",
         "UMask": "0x2",
         "Unit": "QPI LL"
     },
     {
         "BriefDescription": "VN1 Credit Consumed; NCS",
-        "Counter": "0,1,2,3",
         "EventCode": "0x39",
         "EventName": "UNC_Q_RxL_CREDITS_CONSUMED_VN1.NCS",
-        "ExtSel": "1",
         "PerPkg": "1",
+        "PublicDescription": "Counts the number of times that an RxQ VN1 c=
redit was consumed (i.e. message uses a VN1 credit for the Rx Buffer).  Thi=
s includes packets that went through the RxQ and those that were bypasssed.=
; VN1 credit for the NCS message class.",
         "UMask": "0x4",
         "Unit": "QPI LL"
     },
     {
-        "BriefDescription": "VN1 Credit Consumed; HOM",
-        "Counter": "0,1,2,3",
+        "BriefDescription": "VN1 Credit Consumed; NDR",
         "EventCode": "0x39",
-        "EventName": "UNC_Q_RxL_CREDITS_CONSUMED_VN1.HOM",
-        "ExtSel": "1",
+        "EventName": "UNC_Q_RxL_CREDITS_CONSUMED_VN1.NDR",
         "PerPkg": "1",
-        "UMask": "0x8",
+        "PublicDescription": "Counts the number of times that an RxQ VN1 c=
redit was consumed (i.e. message uses a VN1 credit for the Rx Buffer).  Thi=
s includes packets that went through the RxQ and those that were bypasssed.=
; VN1 credit for the NDR message class.",
+        "UMask": "0x20",
         "Unit": "QPI LL"
     },
     {
         "BriefDescription": "VN1 Credit Consumed; SNP",
-        "Counter": "0,1,2,3",
         "EventCode": "0x39",
         "EventName": "UNC_Q_RxL_CREDITS_CONSUMED_VN1.SNP",
-        "ExtSel": "1",
         "PerPkg": "1",
+        "PublicDescription": "Counts the number of times that an RxQ VN1 c=
redit was consumed (i.e. message uses a VN1 credit for the Rx Buffer).  Thi=
s includes packets that went through the RxQ and those that were bypasssed.=
; VN1 credit for the SNP message class.",
         "UMask": "0x10",
         "Unit": "QPI LL"
     },
-    {
-        "BriefDescription": "VN1 Credit Consumed; NDR",
-        "Counter": "0,1,2,3",
-        "EventCode": "0x39",
-        "EventName": "UNC_Q_RxL_CREDITS_CONSUMED_VN1.NDR",
-        "ExtSel": "1",
-        "PerPkg": "1",
-        "UMask": "0x20",
-        "Unit": "QPI LL"
-    },
     {
         "BriefDescription": "VNA Credit Consumed",
-        "Counter": "0,1,2,3",
         "EventCode": "0x1D",
         "EventName": "UNC_Q_RxL_CREDITS_CONSUMED_VNA",
-        "ExtSel": "1",
         "PerPkg": "1",
+        "PublicDescription": "Counts the number of times that an RxQ VNA c=
redit was consumed (i.e. message uses a VNA credit for the Rx Buffer).  Thi=
s includes packets that went through the RxQ and those that were bypasssed.=
",
         "Unit": "QPI LL"
     },
     {
         "BriefDescription": "RxQ Cycles Not Empty",
-        "Counter": "0,1,2,3",
         "EventCode": "0xA",
         "EventName": "UNC_Q_RxL_CYCLES_NE",
         "PerPkg": "1",
+        "PublicDescription": "Counts the number of cycles that the QPI RxQ=
 was not empty.  Generally, when data is transmitted across QPI, it will by=
pass the RxQ and pass directly to the ring interface.  If things back up ge=
tting transmitted onto the ring, however, it may need to allocate into this=
 buffer, thus increasing the latency.  This event can be used in conjunctio=
n with the Flit Buffer Occupancy Accumulator event to calculate the average=
 occupancy.",
         "Unit": "QPI LL"
     },
     {
-        "BriefDescription": "Flits Received - Group 0; Idle and Null Flits=
",
-        "Counter": "0,1,2,3",
-        "EventCode": "0x1",
-        "EventName": "UNC_Q_RxL_FLITS_G0.IDLE",
+        "BriefDescription": "RxQ Cycles Not Empty - DRS; for VN0",
+        "EventCode": "0xF",
+        "EventName": "UNC_Q_RxL_CYCLES_NE_DRS.VN0",
         "PerPkg": "1",
+        "PublicDescription": "Counts the number of cycles that the QPI RxQ=
 was not empty.  Generally, when data is transmitted across QPI, it will by=
pass the RxQ and pass directly to the ring interface.  If things back up ge=
tting transmitted onto the ring, however, it may need to allocate into this=
 buffer, thus increasing the latency.  This event can be used in conjunctio=
n with the Flit Buffer Occupancy Accumulator event to calculate the average=
 occupancy.  This monitors DRS flits only.",
         "UMask": "0x1",
         "Unit": "QPI LL"
     },
     {
-        "BriefDescription": "Flits Received - Group 1; SNP Flits",
-        "Counter": "0,1,2,3",
-        "EventCode": "0x2",
-        "EventName": "UNC_Q_RxL_FLITS_G1.SNP",
-        "ExtSel": "1",
+        "BriefDescription": "RxQ Cycles Not Empty - DRS; for VN1",
+        "EventCode": "0xF",
+        "EventName": "UNC_Q_RxL_CYCLES_NE_DRS.VN1",
         "PerPkg": "1",
-        "UMask": "0x1",
+        "PublicDescription": "Counts the number of cycles that the QPI RxQ=
 was not empty.  Generally, when data is transmitted across QPI, it will by=
pass the RxQ and pass directly to the ring interface.  If things back up ge=
tting transmitted onto the ring, however, it may need to allocate into this=
 buffer, thus increasing the latency.  This event can be used in conjunctio=
n with the Flit Buffer Occupancy Accumulator event to calculate the average=
 occupancy.  This monitors DRS flits only.",
+        "UMask": "0x2",
         "Unit": "QPI LL"
     },
     {
-        "BriefDescription": "Flits Received - Group 1; HOM Request Flits",
-        "Counter": "0,1,2,3",
-        "EventCode": "0x2",
-        "EventName": "UNC_Q_RxL_FLITS_G1.HOM_REQ",
-        "ExtSel": "1",
+        "BriefDescription": "RxQ Cycles Not Empty - HOM; for VN0",
+        "EventCode": "0x12",
+        "EventName": "UNC_Q_RxL_CYCLES_NE_HOM.VN0",
         "PerPkg": "1",
-        "UMask": "0x2",
+        "PublicDescription": "Counts the number of cycles that the QPI RxQ=
 was not empty.  Generally, when data is transmitted across QPI, it will by=
pass the RxQ and pass directly to the ring interface.  If things back up ge=
tting transmitted onto the ring, however, it may need to allocate into this=
 buffer, thus increasing the latency.  This event can be used in conjunctio=
n with the Flit Buffer Occupancy Accumulator event to calculate the average=
 occupancy.  This monitors HOM flits only.",
+        "UMask": "0x1",
         "Unit": "QPI LL"
     },
     {
-        "BriefDescription": "Flits Received - Group 1; HOM Non-Request Fli=
ts",
-        "Counter": "0,1,2,3",
-        "EventCode": "0x2",
-        "EventName": "UNC_Q_RxL_FLITS_G1.HOM_NONREQ",
-        "ExtSel": "1",
+        "BriefDescription": "RxQ Cycles Not Empty - HOM; for VN1",
+        "EventCode": "0x12",
+        "EventName": "UNC_Q_RxL_CYCLES_NE_HOM.VN1",
         "PerPkg": "1",
-        "UMask": "0x4",
+        "PublicDescription": "Counts the number of cycles that the QPI RxQ=
 was not empty.  Generally, when data is transmitted across QPI, it will by=
pass the RxQ and pass directly to the ring interface.  If things back up ge=
tting transmitted onto the ring, however, it may need to allocate into this=
 buffer, thus increasing the latency.  This event can be used in conjunctio=
n with the Flit Buffer Occupancy Accumulator event to calculate the average=
 occupancy.  This monitors HOM flits only.",
+        "UMask": "0x2",
         "Unit": "QPI LL"
     },
     {
-        "BriefDescription": "Flits Received - Group 1; HOM Flits",
-        "Counter": "0,1,2,3",
-        "EventCode": "0x2",
-        "EventName": "UNC_Q_RxL_FLITS_G1.HOM",
-        "ExtSel": "1",
+        "BriefDescription": "RxQ Cycles Not Empty - NCB; for VN0",
+        "EventCode": "0x10",
+        "EventName": "UNC_Q_RxL_CYCLES_NE_NCB.VN0",
         "PerPkg": "1",
-        "UMask": "0x6",
+        "PublicDescription": "Counts the number of cycles that the QPI RxQ=
 was not empty.  Generally, when data is transmitted across QPI, it will by=
pass the RxQ and pass directly to the ring interface.  If things back up ge=
tting transmitted onto the ring, however, it may need to allocate into this=
 buffer, thus increasing the latency.  This event can be used in conjunctio=
n with the Flit Buffer Occupancy Accumulator event to calculate the average=
 occupancy.  This monitors NCB flits only.",
+        "UMask": "0x1",
         "Unit": "QPI LL"
     },
     {
-        "BriefDescription": "Flits Received - Group 1; DRS Data Flits",
-        "Counter": "0,1,2,3",
-        "EventCode": "0x2",
-        "EventName": "UNC_Q_RxL_FLITS_G1.DRS_DATA",
-        "ExtSel": "1",
+        "BriefDescription": "RxQ Cycles Not Empty - NCB; for VN1",
+        "EventCode": "0x10",
+        "EventName": "UNC_Q_RxL_CYCLES_NE_NCB.VN1",
         "PerPkg": "1",
-        "UMask": "0x8",
+        "PublicDescription": "Counts the number of cycles that the QPI RxQ=
 was not empty.  Generally, when data is transmitted across QPI, it will by=
pass the RxQ and pass directly to the ring interface.  If things back up ge=
tting transmitted onto the ring, however, it may need to allocate into this=
 buffer, thus increasing the latency.  This event can be used in conjunctio=
n with the Flit Buffer Occupancy Accumulator event to calculate the average=
 occupancy.  This monitors NCB flits only.",
+        "UMask": "0x2",
         "Unit": "QPI LL"
     },
     {
-        "BriefDescription": "Flits Received - Group 1; DRS Header Flits",
-        "Counter": "0,1,2,3",
-        "EventCode": "0x2",
-        "EventName": "UNC_Q_RxL_FLITS_G1.DRS_NONDATA",
-        "ExtSel": "1",
+        "BriefDescription": "RxQ Cycles Not Empty - NCS; for VN0",
+        "EventCode": "0x11",
+        "EventName": "UNC_Q_RxL_CYCLES_NE_NCS.VN0",
         "PerPkg": "1",
-        "UMask": "0x10",
+        "PublicDescription": "Counts the number of cycles that the QPI RxQ=
 was not empty.  Generally, when data is transmitted across QPI, it will by=
pass the RxQ and pass directly to the ring interface.  If things back up ge=
tting transmitted onto the ring, however, it may need to allocate into this=
 buffer, thus increasing the latency.  This event can be used in conjunctio=
n with the Flit Buffer Occupancy Accumulator event to calculate the average=
 occupancy.  This monitors NCS flits only.",
+        "UMask": "0x1",
         "Unit": "QPI LL"
     },
     {
-        "BriefDescription": "Flits Received - Group 1; DRS Flits (both Hea=
der and Data)",
-        "Counter": "0,1,2,3",
-        "EventCode": "0x2",
-        "EventName": "UNC_Q_RxL_FLITS_G1.DRS",
-        "ExtSel": "1",
+        "BriefDescription": "RxQ Cycles Not Empty - NCS; for VN1",
+        "EventCode": "0x11",
+        "EventName": "UNC_Q_RxL_CYCLES_NE_NCS.VN1",
         "PerPkg": "1",
-        "UMask": "0x18",
+        "PublicDescription": "Counts the number of cycles that the QPI RxQ=
 was not empty.  Generally, when data is transmitted across QPI, it will by=
pass the RxQ and pass directly to the ring interface.  If things back up ge=
tting transmitted onto the ring, however, it may need to allocate into this=
 buffer, thus increasing the latency.  This event can be used in conjunctio=
n with the Flit Buffer Occupancy Accumulator event to calculate the average=
 occupancy.  This monitors NCS flits only.",
+        "UMask": "0x2",
         "Unit": "QPI LL"
     },
     {
-        "BriefDescription": "Flits Received - Group 2; Non-Data Response R=
x Flits - AD",
-        "Counter": "0,1,2,3",
-        "EventCode": "0x3",
-        "EventName": "UNC_Q_RxL_FLITS_G2.NDR_AD",
-        "ExtSel": "1",
+        "BriefDescription": "RxQ Cycles Not Empty - NDR; for VN0",
+        "EventCode": "0x14",
+        "EventName": "UNC_Q_RxL_CYCLES_NE_NDR.VN0",
         "PerPkg": "1",
+        "PublicDescription": "Counts the number of cycles that the QPI RxQ=
 was not empty.  Generally, when data is transmitted across QPI, it will by=
pass the RxQ and pass directly to the ring interface.  If things back up ge=
tting transmitted onto the ring, however, it may need to allocate into this=
 buffer, thus increasing the latency.  This event can be used in conjunctio=
n with the Flit Buffer Occupancy Accumulator event to calculate the average=
 occupancy.  This monitors NDR flits only.",
         "UMask": "0x1",
         "Unit": "QPI LL"
     },
     {
-        "BriefDescription": "Flits Received - Group 2; Non-Data Response R=
x Flits - AK",
-        "Counter": "0,1,2,3",
-        "EventCode": "0x3",
-        "EventName": "UNC_Q_RxL_FLITS_G2.NDR_AK",
-        "ExtSel": "1",
+        "BriefDescription": "RxQ Cycles Not Empty - NDR; for VN1",
+        "EventCode": "0x14",
+        "EventName": "UNC_Q_RxL_CYCLES_NE_NDR.VN1",
         "PerPkg": "1",
+        "PublicDescription": "Counts the number of cycles that the QPI RxQ=
 was not empty.  Generally, when data is transmitted across QPI, it will by=
pass the RxQ and pass directly to the ring interface.  If things back up ge=
tting transmitted onto the ring, however, it may need to allocate into this=
 buffer, thus increasing the latency.  This event can be used in conjunctio=
n with the Flit Buffer Occupancy Accumulator event to calculate the average=
 occupancy.  This monitors NDR flits only.",
         "UMask": "0x2",
         "Unit": "QPI LL"
     },
     {
-        "BriefDescription": "Flits Received - Group 2; Non-Coherent data R=
x Flits",
-        "Counter": "0,1,2,3",
-        "EventCode": "0x3",
-        "EventName": "UNC_Q_RxL_FLITS_G2.NCB_DATA",
-        "ExtSel": "1",
+        "BriefDescription": "RxQ Cycles Not Empty - SNP; for VN0",
+        "EventCode": "0x13",
+        "EventName": "UNC_Q_RxL_CYCLES_NE_SNP.VN0",
         "PerPkg": "1",
-        "UMask": "0x4",
+        "PublicDescription": "Counts the number of cycles that the QPI RxQ=
 was not empty.  Generally, when data is transmitted across QPI, it will by=
pass the RxQ and pass directly to the ring interface.  If things back up ge=
tting transmitted onto the ring, however, it may need to allocate into this=
 buffer, thus increasing the latency.  This event can be used in conjunctio=
n with the Flit Buffer Occupancy Accumulator event to calculate the average=
 occupancy.  This monitors SNP flits only.",
+        "UMask": "0x1",
         "Unit": "QPI LL"
     },
     {
-        "BriefDescription": "Flits Received - Group 2; Non-Coherent non-da=
ta Rx Flits",
-        "Counter": "0,1,2,3",
-        "EventCode": "0x3",
-        "EventName": "UNC_Q_RxL_FLITS_G2.NCB_NONDATA",
-        "ExtSel": "1",
+        "BriefDescription": "RxQ Cycles Not Empty - SNP; for VN1",
+        "EventCode": "0x13",
+        "EventName": "UNC_Q_RxL_CYCLES_NE_SNP.VN1",
         "PerPkg": "1",
-        "UMask": "0x8",
+        "PublicDescription": "Counts the number of cycles that the QPI RxQ=
 was not empty.  Generally, when data is transmitted across QPI, it will by=
pass the RxQ and pass directly to the ring interface.  If things back up ge=
tting transmitted onto the ring, however, it may need to allocate into this=
 buffer, thus increasing the latency.  This event can be used in conjunctio=
n with the Flit Buffer Occupancy Accumulator event to calculate the average=
 occupancy.  This monitors SNP flits only.",
+        "UMask": "0x2",
         "Unit": "QPI LL"
     },
     {
-        "BriefDescription": "Flits Received - Group 2; Non-Coherent Rx Fli=
ts",
-        "Counter": "0,1,2,3",
-        "EventCode": "0x3",
-        "EventName": "UNC_Q_RxL_FLITS_G2.NCB",
-        "ExtSel": "1",
+        "BriefDescription": "Flits Received - Group 0; Idle and Null Flits=
",
+        "EventCode": "0x1",
+        "EventName": "UNC_Q_RxL_FLITS_G0.IDLE",
         "PerPkg": "1",
-        "UMask": "0xC",
+        "PublicDescription": "Counts the number of flits received from the=
 QPI Link.  It includes filters for Idle, protocol, and Data Flits.  Each f=
lit is made up of 80 bits of information (in addition to some ECC data).  I=
n full-width (L0) mode, flits are made up of four fits, each of which conta=
ins 20 bits of data (along with some additional ECC data).   In half-width =
(L0p) mode, the fits are only 10 bits, and therefore it takes twice as many=
 fits to transmit a flit.  When one talks about QPI speed (for example, 8.0=
 GT/s), the transfers here refer to fits.  Therefore, in L0, the system wil=
l transfer 1 flit at the rate of 1/4th the QPI speed.  One can calculate th=
e bandwidth of the link by taking: flits*80b/time.  Note that this is not t=
he same as data bandwidth.  For example, when we are transferring a 64B cac=
heline across QPI, we will break it into 9 flits -- 1 with header informati=
on and 8 with 64 bits of actual data and an additional 16 bits of other inf=
ormation.  To calculate data bandwidth, one should therefore do: data flits=
 * 8B / time (for L0) or 4B instead of 8B for L0p.; Number of flits receive=
d over QPI that do not hold protocol payload.  When QPI is not in a power s=
aving state, it continuously transmits flits across the link.  When there a=
re no protocol flits to send, it will send IDLE and NULL flits  across.  Th=
ese flits sometimes do carry a payload, such as credit returns, but are gen=
erall not considered part of the QPI bandwidth.",
+        "UMask": "0x1",
         "Unit": "QPI LL"
     },
     {
-        "BriefDescription": "Flits Received - Group 2; Non-Coherent standa=
rd Rx Flits",
-        "Counter": "0,1,2,3",
-        "EventCode": "0x3",
-        "EventName": "UNC_Q_RxL_FLITS_G2.NCS",
-        "ExtSel": "1",
+        "BriefDescription": "Flits Received - Group 1; DRS Flits (both Hea=
der and Data)",
+        "EventCode": "0x2",
+        "EventName": "UNC_Q_RxL_FLITS_G1.DRS",
         "PerPkg": "1",
-        "UMask": "0x10",
+        "PublicDescription": "Counts the number of flits received from the=
 QPI Link.  This is one of three groups that allow us to track flits.  It i=
ncludes filters for SNP, HOM, and DRS message classes.  Each flit is made u=
p of 80 bits of information (in addition to some ECC data).  In full-width =
(L0) mode, flits are made up of four fits, each of which contains 20 bits o=
f data (along with some additional ECC data).   In half-width (L0p) mode, t=
he fits are only 10 bits, and therefore it takes twice as many fits to tran=
smit a flit.  When one talks about QPI speed (for example, 8.0 GT/s), the t=
ransfers here refer to fits.  Therefore, in L0, the system will transfer 1 =
flit at the rate of 1/4th the QPI speed.  One can calculate the bandwidth o=
f the link by taking: flits*80b/time.  Note that this is not the same as da=
ta bandwidth.  For example, when we are transferring a 64B cacheline across=
 QPI, we will break it into 9 flits -- 1 with header information and 8 with=
 64 bits of actual data and an additional 16 bits of other information.  To=
 calculate data bandwidth, one should therefore do: data flits * 8B / time.=
; Counts the total number of flits received over QPI on the DRS (Data Respo=
nse) channel.  DRS flits are used to transmit data with coherency.  This do=
es not count data flits received over the NCB channel which transmits non-c=
oherent data.",
+        "UMask": "0x18",
         "Unit": "QPI LL"
     },
     {
-        "BriefDescription": "Rx Flit Buffer Allocations",
-        "Counter": "0,1,2,3",
-        "EventCode": "0x8",
-        "EventName": "UNC_Q_RxL_INSERTS",
+        "BriefDescription": "Flits Received - Group 1; DRS Data Flits",
+        "EventCode": "0x2",
+        "EventName": "UNC_Q_RxL_FLITS_G1.DRS_DATA",
         "PerPkg": "1",
+        "PublicDescription": "Counts the number of flits received from the=
 QPI Link.  This is one of three groups that allow us to track flits.  It i=
ncludes filters for SNP, HOM, and DRS message classes.  Each flit is made u=
p of 80 bits of information (in addition to some ECC data).  In full-width =
(L0) mode, flits are made up of four fits, each of which contains 20 bits o=
f data (along with some additional ECC data).   In half-width (L0p) mode, t=
he fits are only 10 bits, and therefore it takes twice as many fits to tran=
smit a flit.  When one talks about QPI speed (for example, 8.0 GT/s), the t=
ransfers here refer to fits.  Therefore, in L0, the system will transfer 1 =
flit at the rate of 1/4th the QPI speed.  One can calculate the bandwidth o=
f the link by taking: flits*80b/time.  Note that this is not the same as da=
ta bandwidth.  For example, when we are transferring a 64B cacheline across=
 QPI, we will break it into 9 flits -- 1 with header information and 8 with=
 64 bits of actual data and an additional 16 bits of other information.  To=
 calculate data bandwidth, one should therefore do: data flits * 8B / time.=
; Counts the total number of data flits received over QPI on the DRS (Data =
Response) channel.  DRS flits are used to transmit data with coherency.  Th=
is does not count data flits received over the NCB channel which transmits =
non-coherent data.  This includes only the data flits (not the header).",
+        "UMask": "0x8",
         "Unit": "QPI LL"
     },
     {
-        "BriefDescription": "Rx Flit Buffer Allocations - DRS; for VN0",
-        "Counter": "0,1,2,3",
-        "EventCode": "0x9",
-        "EventName": "UNC_Q_RxL_INSERTS_DRS.VN0",
-        "ExtSel": "1",
+        "BriefDescription": "Flits Received - Group 1; DRS Header Flits",
+        "EventCode": "0x2",
+        "EventName": "UNC_Q_RxL_FLITS_G1.DRS_NONDATA",
         "PerPkg": "1",
-        "UMask": "0x1",
+        "PublicDescription": "Counts the number of flits received from the=
 QPI Link.  This is one of three groups that allow us to track flits.  It i=
ncludes filters for SNP, HOM, and DRS message classes.  Each flit is made u=
p of 80 bits of information (in addition to some ECC data).  In full-width =
(L0) mode, flits are made up of four fits, each of which contains 20 bits o=
f data (along with some additional ECC data).   In half-width (L0p) mode, t=
he fits are only 10 bits, and therefore it takes twice as many fits to tran=
smit a flit.  When one talks about QPI speed (for example, 8.0 GT/s), the t=
ransfers here refer to fits.  Therefore, in L0, the system will transfer 1 =
flit at the rate of 1/4th the QPI speed.  One can calculate the bandwidth o=
f the link by taking: flits*80b/time.  Note that this is not the same as da=
ta bandwidth.  For example, when we are transferring a 64B cacheline across=
 QPI, we will break it into 9 flits -- 1 with header information and 8 with=
 64 bits of actual data and an additional 16 bits of other information.  To=
 calculate data bandwidth, one should therefore do: data flits * 8B / time.=
; Counts the total number of protocol flits received over QPI on the DRS (D=
ata Response) channel.  DRS flits are used to transmit data with coherency.=
  This does not count data flits received over the NCB channel which transm=
its non-coherent data.  This includes only the header flits (not the data).=
  This includes extended headers.",
+        "UMask": "0x10",
         "Unit": "QPI LL"
     },
     {
-        "BriefDescription": "Rx Flit Buffer Allocations - DRS; for VN1",
-        "Counter": "0,1,2,3",
-        "EventCode": "0x9",
-        "EventName": "UNC_Q_RxL_INSERTS_DRS.VN1",
-        "ExtSel": "1",
+        "BriefDescription": "Flits Received - Group 1; HOM Flits",
+        "EventCode": "0x2",
+        "EventName": "UNC_Q_RxL_FLITS_G1.HOM",
         "PerPkg": "1",
-        "UMask": "0x2",
+        "PublicDescription": "Counts the number of flits received from the=
 QPI Link.  This is one of three groups that allow us to track flits.  It i=
ncludes filters for SNP, HOM, and DRS message classes.  Each flit is made u=
p of 80 bits of information (in addition to some ECC data).  In full-width =
(L0) mode, flits are made up of four fits, each of which contains 20 bits o=
f data (along with some additional ECC data).   In half-width (L0p) mode, t=
he fits are only 10 bits, and therefore it takes twice as many fits to tran=
smit a flit.  When one talks about QPI speed (for example, 8.0 GT/s), the t=
ransfers here refer to fits.  Therefore, in L0, the system will transfer 1 =
flit at the rate of 1/4th the QPI speed.  One can calculate the bandwidth o=
f the link by taking: flits*80b/time.  Note that this is not the same as da=
ta bandwidth.  For example, when we are transferring a 64B cacheline across=
 QPI, we will break it into 9 flits -- 1 with header information and 8 with=
 64 bits of actual data and an additional 16 bits of other information.  To=
 calculate data bandwidth, one should therefore do: data flits * 8B / time.=
; Counts the number of flits received over QPI on the home channel.",
+        "UMask": "0x6",
         "Unit": "QPI LL"
     },
     {
-        "BriefDescription": "Rx Flit Buffer Allocations - HOM; for VN0",
-        "Counter": "0,1,2,3",
-        "EventCode": "0xC",
-        "EventName": "UNC_Q_RxL_INSERTS_HOM.VN0",
-        "ExtSel": "1",
+        "BriefDescription": "Flits Received - Group 1; HOM Non-Request Fli=
ts",
+        "EventCode": "0x2",
+        "EventName": "UNC_Q_RxL_FLITS_G1.HOM_NONREQ",
         "PerPkg": "1",
-        "UMask": "0x1",
+        "PublicDescription": "Counts the number of flits received from the=
 QPI Link.  This is one of three groups that allow us to track flits.  It i=
ncludes filters for SNP, HOM, and DRS message classes.  Each flit is made u=
p of 80 bits of information (in addition to some ECC data).  In full-width =
(L0) mode, flits are made up of four fits, each of which contains 20 bits o=
f data (along with some additional ECC data).   In half-width (L0p) mode, t=
he fits are only 10 bits, and therefore it takes twice as many fits to tran=
smit a flit.  When one talks about QPI speed (for example, 8.0 GT/s), the t=
ransfers here refer to fits.  Therefore, in L0, the system will transfer 1 =
flit at the rate of 1/4th the QPI speed.  One can calculate the bandwidth o=
f the link by taking: flits*80b/time.  Note that this is not the same as da=
ta bandwidth.  For example, when we are transferring a 64B cacheline across=
 QPI, we will break it into 9 flits -- 1 with header information and 8 with=
 64 bits of actual data and an additional 16 bits of other information.  To=
 calculate data bandwidth, one should therefore do: data flits * 8B / time.=
; Counts the number of non-request flits received over QPI on the home chan=
nel.  These are most commonly snoop responses, and this event can be used a=
s a proxy for that.",
+        "UMask": "0x4",
         "Unit": "QPI LL"
     },
     {
-        "BriefDescription": "Rx Flit Buffer Allocations - HOM; for VN1",
-        "Counter": "0,1,2,3",
-        "EventCode": "0xC",
-        "EventName": "UNC_Q_RxL_INSERTS_HOM.VN1",
-        "ExtSel": "1",
+        "BriefDescription": "Flits Received - Group 1; HOM Request Flits",
+        "EventCode": "0x2",
+        "EventName": "UNC_Q_RxL_FLITS_G1.HOM_REQ",
         "PerPkg": "1",
+        "PublicDescription": "Counts the number of flits received from the=
 QPI Link.  This is one of three groups that allow us to track flits.  It i=
ncludes filters for SNP, HOM, and DRS message classes.  Each flit is made u=
p of 80 bits of information (in addition to some ECC data).  In full-width =
(L0) mode, flits are made up of four fits, each of which contains 20 bits o=
f data (along with some additional ECC data).   In half-width (L0p) mode, t=
he fits are only 10 bits, and therefore it takes twice as many fits to tran=
smit a flit.  When one talks about QPI speed (for example, 8.0 GT/s), the t=
ransfers here refer to fits.  Therefore, in L0, the system will transfer 1 =
flit at the rate of 1/4th the QPI speed.  One can calculate the bandwidth o=
f the link by taking: flits*80b/time.  Note that this is not the same as da=
ta bandwidth.  For example, when we are transferring a 64B cacheline across=
 QPI, we will break it into 9 flits -- 1 with header information and 8 with=
 64 bits of actual data and an additional 16 bits of other information.  To=
 calculate data bandwidth, one should therefore do: data flits * 8B / time.=
; Counts the number of data request received over QPI on the home channel. =
 This basically counts the number of remote memory requests received over Q=
PI.  In conjunction with the local read count in the Home Agent, one can ca=
lculate the number of LLC Misses.",
         "UMask": "0x2",
         "Unit": "QPI LL"
     },
     {
-        "BriefDescription": "Rx Flit Buffer Allocations - NCB; for VN0",
-        "Counter": "0,1,2,3",
-        "EventCode": "0xA",
-        "EventName": "UNC_Q_RxL_INSERTS_NCB.VN0",
-        "ExtSel": "1",
+        "BriefDescription": "Flits Received - Group 1; SNP Flits",
+        "EventCode": "0x2",
+        "EventName": "UNC_Q_RxL_FLITS_G1.SNP",
         "PerPkg": "1",
+        "PublicDescription": "Counts the number of flits received from the=
 QPI Link.  This is one of three groups that allow us to track flits.  It i=
ncludes filters for SNP, HOM, and DRS message classes.  Each flit is made u=
p of 80 bits of information (in addition to some ECC data).  In full-width =
(L0) mode, flits are made up of four fits, each of which contains 20 bits o=
f data (along with some additional ECC data).   In half-width (L0p) mode, t=
he fits are only 10 bits, and therefore it takes twice as many fits to tran=
smit a flit.  When one talks about QPI speed (for example, 8.0 GT/s), the t=
ransfers here refer to fits.  Therefore, in L0, the system will transfer 1 =
flit at the rate of 1/4th the QPI speed.  One can calculate the bandwidth o=
f the link by taking: flits*80b/time.  Note that this is not the same as da=
ta bandwidth.  For example, when we are transferring a 64B cacheline across=
 QPI, we will break it into 9 flits -- 1 with header information and 8 with=
 64 bits of actual data and an additional 16 bits of other information.  To=
 calculate data bandwidth, one should therefore do: data flits * 8B / time.=
; Counts the number of snoop request flits received over QPI.  These reques=
ts are contained in the snoop channel.  This does not include snoop respons=
es, which are received on the home channel.",
+        "UMask": "0x1",
+        "Unit": "QPI LL"
+    },
+    {
+        "BriefDescription": "Flits Received - Group 2; Non-Coherent Rx Fli=
ts",
+        "EventCode": "0x3",
+        "EventName": "UNC_Q_RxL_FLITS_G2.NCB",
+        "PerPkg": "1",
+        "PublicDescription": "Counts the number of flits received from the=
 QPI Link.  This is one of three groups that allow us to track flits.  It i=
ncludes filters for NDR, NCB, and NCS message classes.  Each flit is made u=
p of 80 bits of information (in addition to some ECC data).  In full-width =
(L0) mode, flits are made up of four fits, each of which contains 20 bits o=
f data (along with some additional ECC data).   In half-width (L0p) mode, t=
he fits are only 10 bits, and therefore it takes twice as many fits to tran=
smit a flit.  When one talks about QPI speed (for example, 8.0 GT/s), the t=
ransfers here refer to fits.  Therefore, in L0, the system will transfer 1 =
flit at the rate of 1/4th the QPI speed.  One can calculate the bandwidth o=
f the link by taking: flits*80b/time.  Note that this is not the same as da=
ta bandwidth.  For example, when we are transferring a 64B cacheline across=
 QPI, we will break it into 9 flits -- 1 with header information and 8 with=
 64 bits of actual data and an additional 16 bits of other information.  To=
 calculate data bandwidth, one should therefore do: data flits * 8B / time.=
; Number of Non-Coherent Bypass flits.  These packets are generally used to=
 transmit non-coherent data across QPI.",
+        "UMask": "0xc",
+        "Unit": "QPI LL"
+    },
+    {
+        "BriefDescription": "Flits Received - Group 2; Non-Coherent data R=
x Flits",
+        "EventCode": "0x3",
+        "EventName": "UNC_Q_RxL_FLITS_G2.NCB_DATA",
+        "PerPkg": "1",
+        "PublicDescription": "Counts the number of flits received from the=
 QPI Link.  This is one of three groups that allow us to track flits.  It i=
ncludes filters for NDR, NCB, and NCS message classes.  Each flit is made u=
p of 80 bits of information (in addition to some ECC data).  In full-width =
(L0) mode, flits are made up of four fits, each of which contains 20 bits o=
f data (along with some additional ECC data).   In half-width (L0p) mode, t=
he fits are only 10 bits, and therefore it takes twice as many fits to tran=
smit a flit.  When one talks about QPI speed (for example, 8.0 GT/s), the t=
ransfers here refer to fits.  Therefore, in L0, the system will transfer 1 =
flit at the rate of 1/4th the QPI speed.  One can calculate the bandwidth o=
f the link by taking: flits*80b/time.  Note that this is not the same as da=
ta bandwidth.  For example, when we are transferring a 64B cacheline across=
 QPI, we will break it into 9 flits -- 1 with header information and 8 with=
 64 bits of actual data and an additional 16 bits of other information.  To=
 calculate data bandwidth, one should therefore do: data flits * 8B / time.=
; Number of Non-Coherent Bypass data flits.  These flits are generally used=
 to transmit non-coherent data across QPI.  This does not include a count o=
f the DRS (coherent) data flits.  This only counts the data flits, not the =
NCB headers.",
+        "UMask": "0x4",
+        "Unit": "QPI LL"
+    },
+    {
+        "BriefDescription": "Flits Received - Group 2; Non-Coherent non-da=
ta Rx Flits",
+        "EventCode": "0x3",
+        "EventName": "UNC_Q_RxL_FLITS_G2.NCB_NONDATA",
+        "PerPkg": "1",
+        "PublicDescription": "Counts the number of flits received from the=
 QPI Link.  This is one of three groups that allow us to track flits.  It i=
ncludes filters for NDR, NCB, and NCS message classes.  Each flit is made u=
p of 80 bits of information (in addition to some ECC data).  In full-width =
(L0) mode, flits are made up of four fits, each of which contains 20 bits o=
f data (along with some additional ECC data).   In half-width (L0p) mode, t=
he fits are only 10 bits, and therefore it takes twice as many fits to tran=
smit a flit.  When one talks about QPI speed (for example, 8.0 GT/s), the t=
ransfers here refer to fits.  Therefore, in L0, the system will transfer 1 =
flit at the rate of 1/4th the QPI speed.  One can calculate the bandwidth o=
f the link by taking: flits*80b/time.  Note that this is not the same as da=
ta bandwidth.  For example, when we are transferring a 64B cacheline across=
 QPI, we will break it into 9 flits -- 1 with header information and 8 with=
 64 bits of actual data and an additional 16 bits of other information.  To=
 calculate data bandwidth, one should therefore do: data flits * 8B / time.=
; Number of Non-Coherent Bypass non-data flits.  These packets are generall=
y used to transmit non-coherent data across QPI, and the flits counted here=
 are for headers and other non-data flits.  This includes extended headers.=
",
+        "UMask": "0x8",
+        "Unit": "QPI LL"
+    },
+    {
+        "BriefDescription": "Flits Received - Group 2; Non-Coherent standa=
rd Rx Flits",
+        "EventCode": "0x3",
+        "EventName": "UNC_Q_RxL_FLITS_G2.NCS",
+        "PerPkg": "1",
+        "PublicDescription": "Counts the number of flits received from the=
 QPI Link.  This is one of three groups that allow us to track flits.  It i=
ncludes filters for NDR, NCB, and NCS message classes.  Each flit is made u=
p of 80 bits of information (in addition to some ECC data).  In full-width =
(L0) mode, flits are made up of four fits, each of which contains 20 bits o=
f data (along with some additional ECC data).   In half-width (L0p) mode, t=
he fits are only 10 bits, and therefore it takes twice as many fits to tran=
smit a flit.  When one talks about QPI speed (for example, 8.0 GT/s), the t=
ransfers here refer to fits.  Therefore, in L0, the system will transfer 1 =
flit at the rate of 1/4th the QPI speed.  One can calculate the bandwidth o=
f the link by taking: flits*80b/time.  Note that this is not the same as da=
ta bandwidth.  For example, when we are transferring a 64B cacheline across=
 QPI, we will break it into 9 flits -- 1 with header information and 8 with=
 64 bits of actual data and an additional 16 bits of other information.  To=
 calculate data bandwidth, one should therefore do: data flits * 8B / time.=
; Number of NCS (non-coherent standard) flits received over QPI.    This in=
cludes extended headers.",
+        "UMask": "0x10",
+        "Unit": "QPI LL"
+    },
+    {
+        "BriefDescription": "Flits Received - Group 2; Non-Data Response R=
x Flits - AD",
+        "EventCode": "0x3",
+        "EventName": "UNC_Q_RxL_FLITS_G2.NDR_AD",
+        "PerPkg": "1",
+        "PublicDescription": "Counts the number of flits received from the=
 QPI Link.  This is one of three groups that allow us to track flits.  It i=
ncludes filters for NDR, NCB, and NCS message classes.  Each flit is made u=
p of 80 bits of information (in addition to some ECC data).  In full-width =
(L0) mode, flits are made up of four fits, each of which contains 20 bits o=
f data (along with some additional ECC data).   In half-width (L0p) mode, t=
he fits are only 10 bits, and therefore it takes twice as many fits to tran=
smit a flit.  When one talks about QPI speed (for example, 8.0 GT/s), the t=
ransfers here refer to fits.  Therefore, in L0, the system will transfer 1 =
flit at the rate of 1/4th the QPI speed.  One can calculate the bandwidth o=
f the link by taking: flits*80b/time.  Note that this is not the same as da=
ta bandwidth.  For example, when we are transferring a 64B cacheline across=
 QPI, we will break it into 9 flits -- 1 with header information and 8 with=
 64 bits of actual data and an additional 16 bits of other information.  To=
 calculate data bandwidth, one should therefore do: data flits * 8B / time.=
; Counts the total number of flits received over the NDR (Non-Data Response=
) channel.  This channel is used to send a variety of protocol flits includ=
ing grants and completions.  This is only for NDR packets to the local sock=
et which use the AK ring.",
+        "UMask": "0x1",
+        "Unit": "QPI LL"
+    },
+    {
+        "BriefDescription": "Flits Received - Group 2; Non-Data Response R=
x Flits - AK",
+        "EventCode": "0x3",
+        "EventName": "UNC_Q_RxL_FLITS_G2.NDR_AK",
+        "PerPkg": "1",
+        "PublicDescription": "Counts the number of flits received from the=
 QPI Link.  This is one of three groups that allow us to track flits.  It i=
ncludes filters for NDR, NCB, and NCS message classes.  Each flit is made u=
p of 80 bits of information (in addition to some ECC data).  In full-width =
(L0) mode, flits are made up of four fits, each of which contains 20 bits o=
f data (along with some additional ECC data).   In half-width (L0p) mode, t=
he fits are only 10 bits, and therefore it takes twice as many fits to tran=
smit a flit.  When one talks about QPI speed (for example, 8.0 GT/s), the t=
ransfers here refer to fits.  Therefore, in L0, the system will transfer 1 =
flit at the rate of 1/4th the QPI speed.  One can calculate the bandwidth o=
f the link by taking: flits*80b/time.  Note that this is not the same as da=
ta bandwidth.  For example, when we are transferring a 64B cacheline across=
 QPI, we will break it into 9 flits -- 1 with header information and 8 with=
 64 bits of actual data and an additional 16 bits of other information.  To=
 calculate data bandwidth, one should therefore do: data flits * 8B / time.=
; Counts the total number of flits received over the NDR (Non-Data Response=
) channel.  This channel is used to send a variety of protocol flits includ=
ing grants and completions.  This is only for NDR packets destined for Rout=
e-thru to a remote socket.",
+        "UMask": "0x2",
+        "Unit": "QPI LL"
+    },
+    {
+        "BriefDescription": "Rx Flit Buffer Allocations",
+        "EventCode": "0x8",
+        "EventName": "UNC_Q_RxL_INSERTS",
+        "PerPkg": "1",
+        "PublicDescription": "Number of allocations into the QPI Rx Flit B=
uffer.  Generally, when data is transmitted across QPI, it will bypass the =
RxQ and pass directly to the ring interface.  If things back up getting tra=
nsmitted onto the ring, however, it may need to allocate into this buffer, =
thus increasing the latency.  This event can be used in conjunction with th=
e Flit Buffer Occupancy event in order to calculate the average flit buffer=
 lifetime.",
+        "Unit": "QPI LL"
+    },
+    {
+        "BriefDescription": "Rx Flit Buffer Allocations - DRS; for VN0",
+        "EventCode": "0x9",
+        "EventName": "UNC_Q_RxL_INSERTS_DRS.VN0",
+        "PerPkg": "1",
+        "PublicDescription": "Number of allocations into the QPI Rx Flit B=
uffer.  Generally, when data is transmitted across QPI, it will bypass the =
RxQ and pass directly to the ring interface.  If things back up getting tra=
nsmitted onto the ring, however, it may need to allocate into this buffer, =
thus increasing the latency.  This event can be used in conjunction with th=
e Flit Buffer Occupancy event in order to calculate the average flit buffer=
 lifetime.  This monitors only DRS flits.",
+        "UMask": "0x1",
+        "Unit": "QPI LL"
+    },
+    {
+        "BriefDescription": "Rx Flit Buffer Allocations - DRS; for VN1",
+        "EventCode": "0x9",
+        "EventName": "UNC_Q_RxL_INSERTS_DRS.VN1",
+        "PerPkg": "1",
+        "PublicDescription": "Number of allocations into the QPI Rx Flit B=
uffer.  Generally, when data is transmitted across QPI, it will bypass the =
RxQ and pass directly to the ring interface.  If things back up getting tra=
nsmitted onto the ring, however, it may need to allocate into this buffer, =
thus increasing the latency.  This event can be used in conjunction with th=
e Flit Buffer Occupancy event in order to calculate the average flit buffer=
 lifetime.  This monitors only DRS flits.",
+        "UMask": "0x2",
+        "Unit": "QPI LL"
+    },
+    {
+        "BriefDescription": "Rx Flit Buffer Allocations - HOM; for VN0",
+        "EventCode": "0xC",
+        "EventName": "UNC_Q_RxL_INSERTS_HOM.VN0",
+        "PerPkg": "1",
+        "PublicDescription": "Number of allocations into the QPI Rx Flit B=
uffer.  Generally, when data is transmitted across QPI, it will bypass the =
RxQ and pass directly to the ring interface.  If things back up getting tra=
nsmitted onto the ring, however, it may need to allocate into this buffer, =
thus increasing the latency.  This event can be used in conjunction with th=
e Flit Buffer Occupancy event in order to calculate the average flit buffer=
 lifetime.  This monitors only HOM flits.",
+        "UMask": "0x1",
+        "Unit": "QPI LL"
+    },
+    {
+        "BriefDescription": "Rx Flit Buffer Allocations - HOM; for VN1",
+        "EventCode": "0xC",
+        "EventName": "UNC_Q_RxL_INSERTS_HOM.VN1",
+        "PerPkg": "1",
+        "PublicDescription": "Number of allocations into the QPI Rx Flit B=
uffer.  Generally, when data is transmitted across QPI, it will bypass the =
RxQ and pass directly to the ring interface.  If things back up getting tra=
nsmitted onto the ring, however, it may need to allocate into this buffer, =
thus increasing the latency.  This event can be used in conjunction with th=
e Flit Buffer Occupancy event in order to calculate the average flit buffer=
 lifetime.  This monitors only HOM flits.",
+        "UMask": "0x2",
+        "Unit": "QPI LL"
+    },
+    {
+        "BriefDescription": "Rx Flit Buffer Allocations - NCB; for VN0",
+        "EventCode": "0xA",
+        "EventName": "UNC_Q_RxL_INSERTS_NCB.VN0",
+        "PerPkg": "1",
+        "PublicDescription": "Number of allocations into the QPI Rx Flit B=
uffer.  Generally, when data is transmitted across QPI, it will bypass the =
RxQ and pass directly to the ring interface.  If things back up getting tra=
nsmitted onto the ring, however, it may need to allocate into this buffer, =
thus increasing the latency.  This event can be used in conjunction with th=
e Flit Buffer Occupancy event in order to calculate the average flit buffer=
 lifetime.  This monitors only NCB flits.",
         "UMask": "0x1",
         "Unit": "QPI LL"
     },
     {
         "BriefDescription": "Rx Flit Buffer Allocations - NCB; for VN1",
-        "Counter": "0,1,2,3",
         "EventCode": "0xA",
         "EventName": "UNC_Q_RxL_INSERTS_NCB.VN1",
-        "ExtSel": "1",
         "PerPkg": "1",
+        "PublicDescription": "Number of allocations into the QPI Rx Flit B=
uffer.  Generally, when data is transmitted across QPI, it will bypass the =
RxQ and pass directly to the ring interface.  If things back up getting tra=
nsmitted onto the ring, however, it may need to allocate into this buffer, =
thus increasing the latency.  This event can be used in conjunction with th=
e Flit Buffer Occupancy event in order to calculate the average flit buffer=
 lifetime.  This monitors only NCB flits.",
         "UMask": "0x2",
         "Unit": "QPI LL"
     },
     {
         "BriefDescription": "Rx Flit Buffer Allocations - NCS; for VN0",
-        "Counter": "0,1,2,3",
         "EventCode": "0xB",
         "EventName": "UNC_Q_RxL_INSERTS_NCS.VN0",
-        "ExtSel": "1",
         "PerPkg": "1",
+        "PublicDescription": "Number of allocations into the QPI Rx Flit B=
uffer.  Generally, when data is transmitted across QPI, it will bypass the =
RxQ and pass directly to the ring interface.  If things back up getting tra=
nsmitted onto the ring, however, it may need to allocate into this buffer, =
thus increasing the latency.  This event can be used in conjunction with th=
e Flit Buffer Occupancy event in order to calculate the average flit buffer=
 lifetime.  This monitors only NCS flits.",
         "UMask": "0x1",
         "Unit": "QPI LL"
     },
     {
         "BriefDescription": "Rx Flit Buffer Allocations - NCS; for VN1",
-        "Counter": "0,1,2,3",
         "EventCode": "0xB",
         "EventName": "UNC_Q_RxL_INSERTS_NCS.VN1",
-        "ExtSel": "1",
         "PerPkg": "1",
+        "PublicDescription": "Number of allocations into the QPI Rx Flit B=
uffer.  Generally, when data is transmitted across QPI, it will bypass the =
RxQ and pass directly to the ring interface.  If things back up getting tra=
nsmitted onto the ring, however, it may need to allocate into this buffer, =
thus increasing the latency.  This event can be used in conjunction with th=
e Flit Buffer Occupancy event in order to calculate the average flit buffer=
 lifetime.  This monitors only NCS flits.",
         "UMask": "0x2",
         "Unit": "QPI LL"
     },
     {
         "BriefDescription": "Rx Flit Buffer Allocations - NDR; for VN0",
-        "Counter": "0,1,2,3",
         "EventCode": "0xE",
         "EventName": "UNC_Q_RxL_INSERTS_NDR.VN0",
-        "ExtSel": "1",
         "PerPkg": "1",
+        "PublicDescription": "Number of allocations into the QPI Rx Flit B=
uffer.  Generally, when data is transmitted across QPI, it will bypass the =
RxQ and pass directly to the ring interface.  If things back up getting tra=
nsmitted onto the ring, however, it may need to allocate into this buffer, =
thus increasing the latency.  This event can be used in conjunction with th=
e Flit Buffer Occupancy event in order to calculate the average flit buffer=
 lifetime.  This monitors only NDR flits.",
         "UMask": "0x1",
         "Unit": "QPI LL"
     },
     {
         "BriefDescription": "Rx Flit Buffer Allocations - NDR; for VN1",
-        "Counter": "0,1,2,3",
         "EventCode": "0xE",
         "EventName": "UNC_Q_RxL_INSERTS_NDR.VN1",
-        "ExtSel": "1",
         "PerPkg": "1",
+        "PublicDescription": "Number of allocations into the QPI Rx Flit B=
uffer.  Generally, when data is transmitted across QPI, it will bypass the =
RxQ and pass directly to the ring interface.  If things back up getting tra=
nsmitted onto the ring, however, it may need to allocate into this buffer, =
thus increasing the latency.  This event can be used in conjunction with th=
e Flit Buffer Occupancy event in order to calculate the average flit buffer=
 lifetime.  This monitors only NDR flits.",
         "UMask": "0x2",
         "Unit": "QPI LL"
     },
     {
         "BriefDescription": "Rx Flit Buffer Allocations - SNP; for VN0",
-        "Counter": "0,1,2,3",
         "EventCode": "0xD",
         "EventName": "UNC_Q_RxL_INSERTS_SNP.VN0",
-        "ExtSel": "1",
         "PerPkg": "1",
+        "PublicDescription": "Number of allocations into the QPI Rx Flit B=
uffer.  Generally, when data is transmitted across QPI, it will bypass the =
RxQ and pass directly to the ring interface.  If things back up getting tra=
nsmitted onto the ring, however, it may need to allocate into this buffer, =
thus increasing the latency.  This event can be used in conjunction with th=
e Flit Buffer Occupancy event in order to calculate the average flit buffer=
 lifetime.  This monitors only SNP flits.",
         "UMask": "0x1",
         "Unit": "QPI LL"
     },
     {
         "BriefDescription": "Rx Flit Buffer Allocations - SNP; for VN1",
-        "Counter": "0,1,2,3",
         "EventCode": "0xD",
         "EventName": "UNC_Q_RxL_INSERTS_SNP.VN1",
-        "ExtSel": "1",
         "PerPkg": "1",
+        "PublicDescription": "Number of allocations into the QPI Rx Flit B=
uffer.  Generally, when data is transmitted across QPI, it will bypass the =
RxQ and pass directly to the ring interface.  If things back up getting tra=
nsmitted onto the ring, however, it may need to allocate into this buffer, =
thus increasing the latency.  This event can be used in conjunction with th=
e Flit Buffer Occupancy event in order to calculate the average flit buffer=
 lifetime.  This monitors only SNP flits.",
         "UMask": "0x2",
         "Unit": "QPI LL"
     },
     {
         "BriefDescription": "RxQ Occupancy - All Packets",
-        "Counter": "0,1,2,3",
         "EventCode": "0xB",
         "EventName": "UNC_Q_RxL_OCCUPANCY",
         "PerPkg": "1",
+        "PublicDescription": "Accumulates the number of elements in the QP=
I RxQ in each cycle.  Generally, when data is transmitted across QPI, it wi=
ll bypass the RxQ and pass directly to the ring interface.  If things back =
up getting transmitted onto the ring, however, it may need to allocate into=
 this buffer, thus increasing the latency.  This event can be used in conju=
nction with the Flit Buffer Not Empty event to calculate average occupancy,=
 or with the Flit Buffer Allocations event to track average lifetime.",
         "Unit": "QPI LL"
     },
     {
         "BriefDescription": "RxQ Occupancy - DRS; for VN0",
-        "Counter": "0,1,2,3",
         "EventCode": "0x15",
         "EventName": "UNC_Q_RxL_OCCUPANCY_DRS.VN0",
-        "ExtSel": "1",
         "PerPkg": "1",
+        "PublicDescription": "Accumulates the number of elements in the QP=
I RxQ in each cycle.  Generally, when data is transmitted across QPI, it wi=
ll bypass the RxQ and pass directly to the ring interface.  If things back =
up getting transmitted onto the ring, however, it may need to allocate into=
 this buffer, thus increasing the latency.  This event can be used in conju=
nction with the Flit Buffer Not Empty event to calculate average occupancy,=
 or with the Flit Buffer Allocations event to track average lifetime.  This=
 monitors DRS flits only.",
         "UMask": "0x1",
         "Unit": "QPI LL"
     },
     {
         "BriefDescription": "RxQ Occupancy - DRS; for VN1",
-        "Counter": "0,1,2,3",
         "EventCode": "0x15",
         "EventName": "UNC_Q_RxL_OCCUPANCY_DRS.VN1",
-        "ExtSel": "1",
         "PerPkg": "1",
+        "PublicDescription": "Accumulates the number of elements in the QP=
I RxQ in each cycle.  Generally, when data is transmitted across QPI, it wi=
ll bypass the RxQ and pass directly to the ring interface.  If things back =
up getting transmitted onto the ring, however, it may need to allocate into=
 this buffer, thus increasing the latency.  This event can be used in conju=
nction with the Flit Buffer Not Empty event to calculate average occupancy,=
 or with the Flit Buffer Allocations event to track average lifetime.  This=
 monitors DRS flits only.",
         "UMask": "0x2",
         "Unit": "QPI LL"
     },
     {
         "BriefDescription": "RxQ Occupancy - HOM; for VN0",
-        "Counter": "0,1,2,3",
         "EventCode": "0x18",
         "EventName": "UNC_Q_RxL_OCCUPANCY_HOM.VN0",
-        "ExtSel": "1",
         "PerPkg": "1",
+        "PublicDescription": "Accumulates the number of elements in the QP=
I RxQ in each cycle.  Generally, when data is transmitted across QPI, it wi=
ll bypass the RxQ and pass directly to the ring interface.  If things back =
up getting transmitted onto the ring, however, it may need to allocate into=
 this buffer, thus increasing the latency.  This event can be used in conju=
nction with the Flit Buffer Not Empty event to calculate average occupancy,=
 or with the Flit Buffer Allocations event to track average lifetime.  This=
 monitors HOM flits only.",
         "UMask": "0x1",
         "Unit": "QPI LL"
     },
     {
         "BriefDescription": "RxQ Occupancy - HOM; for VN1",
-        "Counter": "0,1,2,3",
         "EventCode": "0x18",
         "EventName": "UNC_Q_RxL_OCCUPANCY_HOM.VN1",
-        "ExtSel": "1",
         "PerPkg": "1",
+        "PublicDescription": "Accumulates the number of elements in the QP=
I RxQ in each cycle.  Generally, when data is transmitted across QPI, it wi=
ll bypass the RxQ and pass directly to the ring interface.  If things back =
up getting transmitted onto the ring, however, it may need to allocate into=
 this buffer, thus increasing the latency.  This event can be used in conju=
nction with the Flit Buffer Not Empty event to calculate average occupancy,=
 or with the Flit Buffer Allocations event to track average lifetime.  This=
 monitors HOM flits only.",
         "UMask": "0x2",
         "Unit": "QPI LL"
     },
     {
         "BriefDescription": "RxQ Occupancy - NCB; for VN0",
-        "Counter": "0,1,2,3",
         "EventCode": "0x16",
         "EventName": "UNC_Q_RxL_OCCUPANCY_NCB.VN0",
-        "ExtSel": "1",
         "PerPkg": "1",
+        "PublicDescription": "Accumulates the number of elements in the QP=
I RxQ in each cycle.  Generally, when data is transmitted across QPI, it wi=
ll bypass the RxQ and pass directly to the ring interface.  If things back =
up getting transmitted onto the ring, however, it may need to allocate into=
 this buffer, thus increasing the latency.  This event can be used in conju=
nction with the Flit Buffer Not Empty event to calculate average occupancy,=
 or with the Flit Buffer Allocations event to track average lifetime.  This=
 monitors NCB flits only.",
         "UMask": "0x1",
         "Unit": "QPI LL"
     },
     {
         "BriefDescription": "RxQ Occupancy - NCB; for VN1",
-        "Counter": "0,1,2,3",
         "EventCode": "0x16",
         "EventName": "UNC_Q_RxL_OCCUPANCY_NCB.VN1",
-        "ExtSel": "1",
         "PerPkg": "1",
+        "PublicDescription": "Accumulates the number of elements in the QP=
I RxQ in each cycle.  Generally, when data is transmitted across QPI, it wi=
ll bypass the RxQ and pass directly to the ring interface.  If things back =
up getting transmitted onto the ring, however, it may need to allocate into=
 this buffer, thus increasing the latency.  This event can be used in conju=
nction with the Flit Buffer Not Empty event to calculate average occupancy,=
 or with the Flit Buffer Allocations event to track average lifetime.  This=
 monitors NCB flits only.",
         "UMask": "0x2",
         "Unit": "QPI LL"
     },
     {
         "BriefDescription": "RxQ Occupancy - NCS; for VN0",
-        "Counter": "0,1,2,3",
         "EventCode": "0x17",
         "EventName": "UNC_Q_RxL_OCCUPANCY_NCS.VN0",
-        "ExtSel": "1",
         "PerPkg": "1",
+        "PublicDescription": "Accumulates the number of elements in the QP=
I RxQ in each cycle.  Generally, when data is transmitted across QPI, it wi=
ll bypass the RxQ and pass directly to the ring interface.  If things back =
up getting transmitted onto the ring, however, it may need to allocate into=
 this buffer, thus increasing the latency.  This event can be used in conju=
nction with the Flit Buffer Not Empty event to calculate average occupancy,=
 or with the Flit Buffer Allocations event to track average lifetime.  This=
 monitors NCS flits only.",
         "UMask": "0x1",
         "Unit": "QPI LL"
     },
     {
         "BriefDescription": "RxQ Occupancy - NCS; for VN1",
-        "Counter": "0,1,2,3",
         "EventCode": "0x17",
         "EventName": "UNC_Q_RxL_OCCUPANCY_NCS.VN1",
-        "ExtSel": "1",
         "PerPkg": "1",
+        "PublicDescription": "Accumulates the number of elements in the QP=
I RxQ in each cycle.  Generally, when data is transmitted across QPI, it wi=
ll bypass the RxQ and pass directly to the ring interface.  If things back =
up getting transmitted onto the ring, however, it may need to allocate into=
 this buffer, thus increasing the latency.  This event can be used in conju=
nction with the Flit Buffer Not Empty event to calculate average occupancy,=
 or with the Flit Buffer Allocations event to track average lifetime.  This=
 monitors NCS flits only.",
         "UMask": "0x2",
         "Unit": "QPI LL"
     },
     {
         "BriefDescription": "RxQ Occupancy - NDR; for VN0",
-        "Counter": "0,1,2,3",
         "EventCode": "0x1A",
         "EventName": "UNC_Q_RxL_OCCUPANCY_NDR.VN0",
-        "ExtSel": "1",
         "PerPkg": "1",
+        "PublicDescription": "Accumulates the number of elements in the QP=
I RxQ in each cycle.  Generally, when data is transmitted across QPI, it wi=
ll bypass the RxQ and pass directly to the ring interface.  If things back =
up getting transmitted onto the ring, however, it may need to allocate into=
 this buffer, thus increasing the latency.  This event can be used in conju=
nction with the Flit Buffer Not Empty event to calculate average occupancy,=
 or with the Flit Buffer Allocations event to track average lifetime.  This=
 monitors NDR flits only.",
         "UMask": "0x1",
         "Unit": "QPI LL"
     },
     {
         "BriefDescription": "RxQ Occupancy - NDR; for VN1",
-        "Counter": "0,1,2,3",
         "EventCode": "0x1A",
         "EventName": "UNC_Q_RxL_OCCUPANCY_NDR.VN1",
-        "ExtSel": "1",
         "PerPkg": "1",
+        "PublicDescription": "Accumulates the number of elements in the QP=
I RxQ in each cycle.  Generally, when data is transmitted across QPI, it wi=
ll bypass the RxQ and pass directly to the ring interface.  If things back =
up getting transmitted onto the ring, however, it may need to allocate into=
 this buffer, thus increasing the latency.  This event can be used in conju=
nction with the Flit Buffer Not Empty event to calculate average occupancy,=
 or with the Flit Buffer Allocations event to track average lifetime.  This=
 monitors NDR flits only.",
         "UMask": "0x2",
         "Unit": "QPI LL"
     },
     {
         "BriefDescription": "RxQ Occupancy - SNP; for VN0",
-        "Counter": "0,1,2,3",
         "EventCode": "0x19",
         "EventName": "UNC_Q_RxL_OCCUPANCY_SNP.VN0",
-        "ExtSel": "1",
         "PerPkg": "1",
+        "PublicDescription": "Accumulates the number of elements in the QP=
I RxQ in each cycle.  Generally, when data is transmitted across QPI, it wi=
ll bypass the RxQ and pass directly to the ring interface.  If things back =
up getting transmitted onto the ring, however, it may need to allocate into=
 this buffer, thus increasing the latency.  This event can be used in conju=
nction with the Flit Buffer Not Empty event to calculate average occupancy,=
 or with the Flit Buffer Allocations event to track average lifetime.  This=
 monitors SNP flits only.",
         "UMask": "0x1",
         "Unit": "QPI LL"
     },
     {
         "BriefDescription": "RxQ Occupancy - SNP; for VN1",
-        "Counter": "0,1,2,3",
         "EventCode": "0x19",
         "EventName": "UNC_Q_RxL_OCCUPANCY_SNP.VN1",
-        "ExtSel": "1",
         "PerPkg": "1",
+        "PublicDescription": "Accumulates the number of elements in the QP=
I RxQ in each cycle.  Generally, when data is transmitted across QPI, it wi=
ll bypass the RxQ and pass directly to the ring interface.  If things back =
up getting transmitted onto the ring, however, it may need to allocate into=
 this buffer, thus increasing the latency.  This event can be used in conju=
nction with the Flit Buffer Not Empty event to calculate average occupancy,=
 or with the Flit Buffer Allocations event to track average lifetime.  This=
 monitors SNP flits only.",
         "UMask": "0x2",
         "Unit": "QPI LL"
     },
     {
-        "BriefDescription": "Cycles in L0p",
-        "Counter": "0,1,2,3",
-        "EventCode": "0xD",
-        "EventName": "UNC_Q_TxL0P_POWER_CYCLES",
+        "BriefDescription": "Stalls Sending to R3QPI on VN0; BGF Stall - H=
OM",
+        "EventCode": "0x35",
+        "EventName": "UNC_Q_RxL_STALLS_VN0.BGF_DRS",
         "PerPkg": "1",
+        "PublicDescription": "Number of stalls trying to send to R3QPI on =
Virtual Network 0; Stalled a packet from the HOM message class because ther=
e were not enough BGF credits.  In bypass mode, we will stall on the packet=
 boundary, while in RxQ mode we will stall on the flit boundary.",
+        "UMask": "0x1",
         "Unit": "QPI LL"
     },
     {
-        "BriefDescription": "Cycles in L0",
-        "Counter": "0,1,2,3",
-        "EventCode": "0xC",
-        "EventName": "UNC_Q_TxL0_POWER_CYCLES",
+        "BriefDescription": "Stalls Sending to R3QPI on VN0; BGF Stall - D=
RS",
+        "EventCode": "0x35",
+        "EventName": "UNC_Q_RxL_STALLS_VN0.BGF_HOM",
+        "PerPkg": "1",
+        "PublicDescription": "Number of stalls trying to send to R3QPI on =
Virtual Network 0; Stalled a packet from the DRS message class because ther=
e were not enough BGF credits.  In bypass mode, we will stall on the packet=
 boundary, while in RxQ mode we will stall on the flit boundary.",
+        "UMask": "0x8",
+        "Unit": "QPI LL"
+    },
+    {
+        "BriefDescription": "Stalls Sending to R3QPI on VN0; BGF Stall - S=
NP",
+        "EventCode": "0x35",
+        "EventName": "UNC_Q_RxL_STALLS_VN0.BGF_NCB",
         "PerPkg": "1",
+        "PublicDescription": "Number of stalls trying to send to R3QPI on =
Virtual Network 0; Stalled a packet from the SNP message class because ther=
e were not enough BGF credits.  In bypass mode, we will stall on the packet=
 boundary, while in RxQ mode we will stall on the flit boundary.",
+        "UMask": "0x2",
         "Unit": "QPI LL"
     },
     {
-        "BriefDescription": "Tx Flit Buffer Bypassed",
-        "Counter": "0,1,2,3",
-        "EventCode": "0x5",
-        "EventName": "UNC_Q_TxL_BYPASSED",
+        "BriefDescription": "Stalls Sending to R3QPI on VN0; BGF Stall - N=
DR",
+        "EventCode": "0x35",
+        "EventName": "UNC_Q_RxL_STALLS_VN0.BGF_NCS",
         "PerPkg": "1",
+        "PublicDescription": "Number of stalls trying to send to R3QPI on =
Virtual Network 0; Stalled a packet from the NDR message class because ther=
e were not enough BGF credits.  In bypass mode, we will stall on the packet=
 boundary, while in RxQ mode we will stall on the flit boundary.",
+        "UMask": "0x4",
         "Unit": "QPI LL"
     },
     {
-        "BriefDescription": "Tx Flit Buffer Cycles not Empty",
-        "Counter": "0,1,2,3",
-        "EventCode": "0x6",
-        "EventName": "UNC_Q_TxL_CYCLES_NE",
+        "BriefDescription": "Stalls Sending to R3QPI on VN0; BGF Stall - N=
CS",
+        "EventCode": "0x35",
+        "EventName": "UNC_Q_RxL_STALLS_VN0.BGF_NDR",
         "PerPkg": "1",
+        "PublicDescription": "Number of stalls trying to send to R3QPI on =
Virtual Network 0; Stalled a packet from the NCS message class because ther=
e were not enough BGF credits.  In bypass mode, we will stall on the packet=
 boundary, while in RxQ mode we will stall on the flit boundary.",
+        "UMask": "0x20",
         "Unit": "QPI LL"
     },
     {
-        "BriefDescription": "Flits Transferred - Group 0; Data Tx Flits",
-        "Counter": "0,1,2,3",
-        "EventName": "UNC_Q_TxL_FLITS_G0.DATA",
+        "BriefDescription": "Stalls Sending to R3QPI on VN0; BGF Stall - N=
CB",
+        "EventCode": "0x35",
+        "EventName": "UNC_Q_RxL_STALLS_VN0.BGF_SNP",
         "PerPkg": "1",
-        "UMask": "0x2",
+        "PublicDescription": "Number of stalls trying to send to R3QPI on =
Virtual Network 0; Stalled a packet from the NCB message class because ther=
e were not enough BGF credits.  In bypass mode, we will stall on the packet=
 boundary, while in RxQ mode we will stall on the flit boundary.",
+        "UMask": "0x10",
         "Unit": "QPI LL"
     },
     {
-        "BriefDescription": "Number of data flits transmitted . Derived fr=
om unc_q_txl_flits_g0.data",
-        "Counter": "0,1,2,3",
-        "EventName": "QPI_DATA_BANDWIDTH_TX",
+        "BriefDescription": "Stalls Sending to R3QPI on VN0; Egress Credit=
s",
+        "EventCode": "0x35",
+        "EventName": "UNC_Q_RxL_STALLS_VN0.EGRESS_CREDITS",
         "PerPkg": "1",
-        "ScaleUnit": "8Bytes",
+        "PublicDescription": "Number of stalls trying to send to R3QPI on =
Virtual Network 0; Stalled a packet because there were insufficient BGF cre=
dits.  For details on a message class granularity, use the Egress Credit Oc=
cupancy events.",
+        "UMask": "0x40",
+        "Unit": "QPI LL"
+    },
+    {
+        "BriefDescription": "Stalls Sending to R3QPI on VN0; GV",
+        "EventCode": "0x35",
+        "EventName": "UNC_Q_RxL_STALLS_VN0.GV",
+        "PerPkg": "1",
+        "PublicDescription": "Number of stalls trying to send to R3QPI on =
Virtual Network 0; Stalled because a GV transition (frequency transition) w=
as taking place.",
+        "UMask": "0x80",
+        "Unit": "QPI LL"
+    },
+    {
+        "BriefDescription": "Stalls Sending to R3QPI on VN1; BGF Stall - H=
OM",
+        "EventCode": "0x3A",
+        "EventName": "UNC_Q_RxL_STALLS_VN1.BGF_DRS",
+        "PerPkg": "1",
+        "PublicDescription": "Number of stalls trying to send to R3QPI on =
Virtual Network 1.; Stalled a packet from the HOM message class because the=
re were not enough BGF credits.  In bypass mode, we will stall on the packe=
t boundary, while in RxQ mode we will stall on the flit boundary.",
+        "UMask": "0x1",
+        "Unit": "QPI LL"
+    },
+    {
+        "BriefDescription": "Stalls Sending to R3QPI on VN1; BGF Stall - D=
RS",
+        "EventCode": "0x3A",
+        "EventName": "UNC_Q_RxL_STALLS_VN1.BGF_HOM",
+        "PerPkg": "1",
+        "PublicDescription": "Number of stalls trying to send to R3QPI on =
Virtual Network 1.; Stalled a packet from the DRS message class because the=
re were not enough BGF credits.  In bypass mode, we will stall on the packe=
t boundary, while in RxQ mode we will stall on the flit boundary.",
+        "UMask": "0x8",
+        "Unit": "QPI LL"
+    },
+    {
+        "BriefDescription": "Stalls Sending to R3QPI on VN1; BGF Stall - S=
NP",
+        "EventCode": "0x3A",
+        "EventName": "UNC_Q_RxL_STALLS_VN1.BGF_NCB",
+        "PerPkg": "1",
+        "PublicDescription": "Number of stalls trying to send to R3QPI on =
Virtual Network 1.; Stalled a packet from the SNP message class because the=
re were not enough BGF credits.  In bypass mode, we will stall on the packe=
t boundary, while in RxQ mode we will stall on the flit boundary.",
         "UMask": "0x2",
         "Unit": "QPI LL"
     },
     {
-        "BriefDescription": "Flits Transferred - Group 0; Non-Data protoco=
l Tx Flits",
-        "Counter": "0,1,2,3",
-        "EventName": "UNC_Q_TxL_FLITS_G0.NON_DATA",
+        "BriefDescription": "Stalls Sending to R3QPI on VN1; BGF Stall - N=
DR",
+        "EventCode": "0x3A",
+        "EventName": "UNC_Q_RxL_STALLS_VN1.BGF_NCS",
         "PerPkg": "1",
+        "PublicDescription": "Number of stalls trying to send to R3QPI on =
Virtual Network 1.; Stalled a packet from the NDR message class because the=
re were not enough BGF credits.  In bypass mode, we will stall on the packe=
t boundary, while in RxQ mode we will stall on the flit boundary.",
         "UMask": "0x4",
         "Unit": "QPI LL"
     },
     {
-        "BriefDescription": "Number of non data (control) flits transmitte=
d . Derived from unc_q_txl_flits_g0.non_data",
-        "Counter": "0,1,2,3",
-        "EventName": "QPI_CTL_BANDWIDTH_TX",
+        "BriefDescription": "Stalls Sending to R3QPI on VN1; BGF Stall - N=
CS",
+        "EventCode": "0x3A",
+        "EventName": "UNC_Q_RxL_STALLS_VN1.BGF_NDR",
         "PerPkg": "1",
-        "ScaleUnit": "8Bytes",
-        "UMask": "0x4",
+        "PublicDescription": "Number of stalls trying to send to R3QPI on =
Virtual Network 1.; Stalled a packet from the NCS message class because the=
re were not enough BGF credits.  In bypass mode, we will stall on the packe=
t boundary, while in RxQ mode we will stall on the flit boundary.",
+        "UMask": "0x20",
         "Unit": "QPI LL"
     },
     {
-        "BriefDescription": "Flits Transferred - Group 1; SNP Flits",
-        "Counter": "0,1,2,3",
-        "EventName": "UNC_Q_TxL_FLITS_G1.SNP",
-        "ExtSel": "1",
+        "BriefDescription": "Stalls Sending to R3QPI on VN1; BGF Stall - N=
CB",
+        "EventCode": "0x3A",
+        "EventName": "UNC_Q_RxL_STALLS_VN1.BGF_SNP",
+        "PerPkg": "1",
+        "PublicDescription": "Number of stalls trying to send to R3QPI on =
Virtual Network 1.; Stalled a packet from the NCB message class because the=
re were not enough BGF credits.  In bypass mode, we will stall on the packe=
t boundary, while in RxQ mode we will stall on the flit boundary.",
+        "UMask": "0x10",
+        "Unit": "QPI LL"
+    },
+    {
+        "BriefDescription": "Cycles in L0p",
+        "EventCode": "0xD",
+        "EventName": "UNC_Q_TxL0P_POWER_CYCLES",
+        "PerPkg": "1",
+        "PublicDescription": "Number of QPI qfclk cycles spent in L0p powe=
r mode.  L0p is a mode where we disable 1/2 of the QPI lanes, decreasing ou=
r bandwidth in order to save power.  It increases snoop and data transfer l=
atencies and decreases overall bandwidth.  This mode can be very useful in =
NUMA optimized workloads that largely only utilize QPI for snoops and their=
 responses.  Use edge detect to count the number of instances when the QPI =
link entered L0p.  Link power states are per link and per direction, so for=
 example the Tx direction could be in one state while Rx was in another.",
+        "Unit": "QPI LL"
+    },
+    {
+        "BriefDescription": "Cycles in L0",
+        "EventCode": "0xC",
+        "EventName": "UNC_Q_TxL0_POWER_CYCLES",
+        "PerPkg": "1",
+        "PublicDescription": "Number of QPI qfclk cycles spent in L0 power=
 mode in the Link Layer.  L0 is the default mode which provides the highest=
 performance with the most power.  Use edge detect to count the number of i=
nstances that the link entered L0.  Link power states are per link and per =
direction, so for example the Tx direction could be in one state while Rx w=
as in another.  The phy layer  sometimes leaves L0 for training, which will=
 not be captured by this event.",
+        "Unit": "QPI LL"
+    },
+    {
+        "BriefDescription": "Tx Flit Buffer Bypassed",
+        "EventCode": "0x5",
+        "EventName": "UNC_Q_TxL_BYPASSED",
+        "PerPkg": "1",
+        "PublicDescription": "Counts the number of times that an incoming =
flit was able to bypass the Tx flit buffer and pass directly out the QPI Li=
nk. Generally, when data is transmitted across QPI, it will bypass the TxQ =
and pass directly to the link.  However, the TxQ will be used with L0p and =
when LLR occurs, increasing latency to transfer out to the link.",
+        "Unit": "QPI LL"
+    },
+    {
+        "BriefDescription": "Cycles Stalled with no LLR Credits; LLR is al=
most full",
+        "EventCode": "0x2",
+        "EventName": "UNC_Q_TxL_CRC_NO_CREDITS.ALMOST_FULL",
+        "PerPkg": "1",
+        "PublicDescription": "Number of cycles when the Tx side ran out of=
 Link Layer Retry credits, causing the Tx to stall.; When LLR is almost ful=
l, we block some but not all packets.",
+        "UMask": "0x2",
+        "Unit": "QPI LL"
+    },
+    {
+        "BriefDescription": "Cycles Stalled with no LLR Credits; LLR is fu=
ll",
+        "EventCode": "0x2",
+        "EventName": "UNC_Q_TxL_CRC_NO_CREDITS.FULL",
         "PerPkg": "1",
+        "PublicDescription": "Number of cycles when the Tx side ran out of=
 Link Layer Retry credits, causing the Tx to stall.; When LLR is totally fu=
ll, we are not allowed to send any packets.",
         "UMask": "0x1",
         "Unit": "QPI LL"
     },
     {
-        "BriefDescription": "Flits Transferred - Group 1; HOM Request Flit=
s",
-        "Counter": "0,1,2,3",
-        "EventName": "UNC_Q_TxL_FLITS_G1.HOM_REQ",
-        "ExtSel": "1",
+        "BriefDescription": "Tx Flit Buffer Cycles not Empty",
+        "EventCode": "0x6",
+        "EventName": "UNC_Q_TxL_CYCLES_NE",
         "PerPkg": "1",
+        "PublicDescription": "Counts the number of cycles when the TxQ is =
not empty. Generally, when data is transmitted across QPI, it will bypass t=
he TxQ and pass directly to the link.  However, the TxQ will be used with L=
0p and when LLR occurs, increasing latency to transfer out to the link.",
+        "Unit": "QPI LL"
+    },
+    {
+        "BriefDescription": "Flits Transferred - Group 0; Data Tx Flits",
+        "EventName": "UNC_Q_TxL_FLITS_G0.DATA",
+        "PerPkg": "1",
+        "PublicDescription": "Counts the number of flits transmitted acros=
s the QPI Link.  It includes filters for Idle, protocol, and Data Flits.  E=
ach flit is made up of 80 bits of information (in addition to some ECC data=
).  In full-width (L0) mode, flits are made up of four fits, each of which =
contains 20 bits of data (along with some additional ECC data).   In half-w=
idth (L0p) mode, the fits are only 10 bits, and therefore it takes twice as=
 many fits to transmit a flit.  When one talks about QPI speed (for example=
, 8.0 GT/s), the transfers here refer to fits.  Therefore, in L0, the syste=
m will transfer 1 flit at the rate of 1/4th the QPI speed.  One can calcula=
te the bandwidth of the link by taking: flits*80b/time.  Note that this is =
not the same as data bandwidth.  For example, when we are transferring a 64=
B cacheline across QPI, we will break it into 9 flits -- 1 with header info=
rmation and 8 with 64 bits of actual data and an additional 16 bits of othe=
r information.  To calculate data bandwidth, one should therefore do: data =
flits * 8B / time (for L0) or 4B instead of 8B for L0p.; Number of data fli=
ts transmitted over QPI.  Each flit contains 64b of data.  This includes bo=
th DRS and NCB data flits (coherent and non-coherent).  This can be used to=
 calculate the data bandwidth of the QPI link.  One can get a good picture =
of the QPI-link characteristics by evaluating the protocol flits, data flit=
s, and idle/null flits.  This does not include the header flits that go in =
data packets.",
         "UMask": "0x2",
         "Unit": "QPI LL"
     },
     {
-        "BriefDescription": "Flits Transferred - Group 1; HOM Non-Request =
Flits",
-        "Counter": "0,1,2,3",
-        "EventName": "UNC_Q_TxL_FLITS_G1.HOM_NONREQ",
-        "ExtSel": "1",
+        "BriefDescription": "Flits Transferred - Group 0; Non-Data protoco=
l Tx Flits",
+        "EventName": "UNC_Q_TxL_FLITS_G0.NON_DATA",
         "PerPkg": "1",
+        "PublicDescription": "Counts the number of flits transmitted acros=
s the QPI Link.  It includes filters for Idle, protocol, and Data Flits.  E=
ach flit is made up of 80 bits of information (in addition to some ECC data=
).  In full-width (L0) mode, flits are made up of four fits, each of which =
contains 20 bits of data (along with some additional ECC data).   In half-w=
idth (L0p) mode, the fits are only 10 bits, and therefore it takes twice as=
 many fits to transmit a flit.  When one talks about QPI speed (for example=
, 8.0 GT/s), the transfers here refer to fits.  Therefore, in L0, the syste=
m will transfer 1 flit at the rate of 1/4th the QPI speed.  One can calcula=
te the bandwidth of the link by taking: flits*80b/time.  Note that this is =
not the same as data bandwidth.  For example, when we are transferring a 64=
B cacheline across QPI, we will break it into 9 flits -- 1 with header info=
rmation and 8 with 64 bits of actual data and an additional 16 bits of othe=
r information.  To calculate data bandwidth, one should therefore do: data =
flits * 8B / time (for L0) or 4B instead of 8B for L0p.; Number of non-NULL=
 non-data flits transmitted across QPI.  This basically tracks the protocol=
 overhead on the QPI link.  One can get a good picture of the QPI-link char=
acteristics by evaluating the protocol flits, data flits, and idle/null fli=
ts.  This includes the header flits for data packets.",
         "UMask": "0x4",
         "Unit": "QPI LL"
     },
     {
-        "BriefDescription": "Flits Transferred - Group 1; HOM Flits",
-        "Counter": "0,1,2,3",
-        "EventName": "UNC_Q_TxL_FLITS_G1.HOM",
-        "ExtSel": "1",
+        "BriefDescription": "Flits Transferred - Group 1; DRS Flits (both =
Header and Data)",
+        "EventName": "UNC_Q_TxL_FLITS_G1.DRS",
         "PerPkg": "1",
-        "UMask": "0x6",
+        "PublicDescription": "Counts the number of flits trasmitted across=
 the QPI Link.  This is one of three groups that allow us to track flits.  =
It includes filters for SNP, HOM, and DRS message classes.  Each flit is ma=
de up of 80 bits of information (in addition to some ECC data).  In full-wi=
dth (L0) mode, flits are made up of four fits, each of which contains 20 bi=
ts of data (along with some additional ECC data).   In half-width (L0p) mod=
e, the fits are only 10 bits, and therefore it takes twice as many fits to =
transmit a flit.  When one talks about QPI speed (for example, 8.0 GT/s), t=
he transfers here refer to fits.  Therefore, in L0, the system will transfe=
r 1 flit at the rate of 1/4th the QPI speed.  One can calculate the bandwid=
th of the link by taking: flits*80b/time.  Note that this is not the same a=
s data bandwidth.  For example, when we are transferring a 64B cacheline ac=
ross QPI, we will break it into 9 flits -- 1 with header information and 8 =
with 64 bits of actual data and an additional 16 bits of other information.=
  To calculate data bandwidth, one should therefore do: data flits * 8B / t=
ime.; Counts the total number of flits transmitted over QPI on the DRS (Dat=
a Response) channel.  DRS flits are used to transmit data with coherency.",
+        "UMask": "0x18",
         "Unit": "QPI LL"
     },
     {
         "BriefDescription": "Flits Transferred - Group 1; DRS Data Flits",
-        "Counter": "0,1,2,3",
         "EventName": "UNC_Q_TxL_FLITS_G1.DRS_DATA",
-        "ExtSel": "1",
         "PerPkg": "1",
+        "PublicDescription": "Counts the number of flits trasmitted across=
 the QPI Link.  This is one of three groups that allow us to track flits.  =
It includes filters for SNP, HOM, and DRS message classes.  Each flit is ma=
de up of 80 bits of information (in addition to some ECC data).  In full-wi=
dth (L0) mode, flits are made up of four fits, each of which contains 20 bi=
ts of data (along with some additional ECC data).   In half-width (L0p) mod=
e, the fits are only 10 bits, and therefore it takes twice as many fits to =
transmit a flit.  When one talks about QPI speed (for example, 8.0 GT/s), t=
he transfers here refer to fits.  Therefore, in L0, the system will transfe=
r 1 flit at the rate of 1/4th the QPI speed.  One can calculate the bandwid=
th of the link by taking: flits*80b/time.  Note that this is not the same a=
s data bandwidth.  For example, when we are transferring a 64B cacheline ac=
ross QPI, we will break it into 9 flits -- 1 with header information and 8 =
with 64 bits of actual data and an additional 16 bits of other information.=
  To calculate data bandwidth, one should therefore do: data flits * 8B / t=
ime.; Counts the total number of data flits transmitted over QPI on the DRS=
 (Data Response) channel.  DRS flits are used to transmit data with coheren=
cy.  This does not count data flits transmitted over the NCB channel which =
transmits non-coherent data.  This includes only the data flits (not the he=
ader).",
         "UMask": "0x8",
         "Unit": "QPI LL"
     },
     {
         "BriefDescription": "Flits Transferred - Group 1; DRS Header Flits=
",
-        "Counter": "0,1,2,3",
         "EventName": "UNC_Q_TxL_FLITS_G1.DRS_NONDATA",
-        "ExtSel": "1",
         "PerPkg": "1",
+        "PublicDescription": "Counts the number of flits trasmitted across=
 the QPI Link.  This is one of three groups that allow us to track flits.  =
It includes filters for SNP, HOM, and DRS message classes.  Each flit is ma=
de up of 80 bits of information (in addition to some ECC data).  In full-wi=
dth (L0) mode, flits are made up of four fits, each of which contains 20 bi=
ts of data (along with some additional ECC data).   In half-width (L0p) mod=
e, the fits are only 10 bits, and therefore it takes twice as many fits to =
transmit a flit.  When one talks about QPI speed (for example, 8.0 GT/s), t=
he transfers here refer to fits.  Therefore, in L0, the system will transfe=
r 1 flit at the rate of 1/4th the QPI speed.  One can calculate the bandwid=
th of the link by taking: flits*80b/time.  Note that this is not the same a=
s data bandwidth.  For example, when we are transferring a 64B cacheline ac=
ross QPI, we will break it into 9 flits -- 1 with header information and 8 =
with 64 bits of actual data and an additional 16 bits of other information.=
  To calculate data bandwidth, one should therefore do: data flits * 8B / t=
ime.; Counts the total number of protocol flits transmitted over QPI on the=
 DRS (Data Response) channel.  DRS flits are used to transmit data with coh=
erency.  This does not count data flits transmitted over the NCB channel wh=
ich transmits non-coherent data.  This includes only the header flits (not =
the data).  This includes extended headers.",
         "UMask": "0x10",
         "Unit": "QPI LL"
     },
     {
-        "BriefDescription": "Flits Transferred - Group 1; DRS Flits (both =
Header and Data)",
-        "Counter": "0,1,2,3",
-        "EventName": "UNC_Q_TxL_FLITS_G1.DRS",
-        "ExtSel": "1",
+        "BriefDescription": "Flits Transferred - Group 1; HOM Flits",
+        "EventName": "UNC_Q_TxL_FLITS_G1.HOM",
         "PerPkg": "1",
-        "UMask": "0x18",
+        "PublicDescription": "Counts the number of flits trasmitted across=
 the QPI Link.  This is one of three groups that allow us to track flits.  =
It includes filters for SNP, HOM, and DRS message classes.  Each flit is ma=
de up of 80 bits of information (in addition to some ECC data).  In full-wi=
dth (L0) mode, flits are made up of four fits, each of which contains 20 bi=
ts of data (along with some additional ECC data).   In half-width (L0p) mod=
e, the fits are only 10 bits, and therefore it takes twice as many fits to =
transmit a flit.  When one talks about QPI speed (for example, 8.0 GT/s), t=
he transfers here refer to fits.  Therefore, in L0, the system will transfe=
r 1 flit at the rate of 1/4th the QPI speed.  One can calculate the bandwid=
th of the link by taking: flits*80b/time.  Note that this is not the same a=
s data bandwidth.  For example, when we are transferring a 64B cacheline ac=
ross QPI, we will break it into 9 flits -- 1 with header information and 8 =
with 64 bits of actual data and an additional 16 bits of other information.=
  To calculate data bandwidth, one should therefore do: data flits * 8B / t=
ime.; Counts the number of flits transmitted over QPI on the home channel."=
,
+        "UMask": "0x6",
         "Unit": "QPI LL"
     },
     {
-        "BriefDescription": "Flits Transferred - Group 2; Non-Data Respons=
e Tx Flits - AD",
-        "Counter": "0,1,2,3",
-        "EventCode": "0x1",
-        "EventName": "UNC_Q_TxL_FLITS_G2.NDR_AD",
-        "ExtSel": "1",
+        "BriefDescription": "Flits Transferred - Group 1; HOM Non-Request =
Flits",
+        "EventName": "UNC_Q_TxL_FLITS_G1.HOM_NONREQ",
+        "PerPkg": "1",
+        "PublicDescription": "Counts the number of flits trasmitted across=
 the QPI Link.  This is one of three groups that allow us to track flits.  =
It includes filters for SNP, HOM, and DRS message classes.  Each flit is ma=
de up of 80 bits of information (in addition to some ECC data).  In full-wi=
dth (L0) mode, flits are made up of four fits, each of which contains 20 bi=
ts of data (along with some additional ECC data).   In half-width (L0p) mod=
e, the fits are only 10 bits, and therefore it takes twice as many fits to =
transmit a flit.  When one talks about QPI speed (for example, 8.0 GT/s), t=
he transfers here refer to fits.  Therefore, in L0, the system will transfe=
r 1 flit at the rate of 1/4th the QPI speed.  One can calculate the bandwid=
th of the link by taking: flits*80b/time.  Note that this is not the same a=
s data bandwidth.  For example, when we are transferring a 64B cacheline ac=
ross QPI, we will break it into 9 flits -- 1 with header information and 8 =
with 64 bits of actual data and an additional 16 bits of other information.=
  To calculate data bandwidth, one should therefore do: data flits * 8B / t=
ime.; Counts the number of non-request flits transmitted over QPI on the ho=
me channel.  These are most commonly snoop responses, and this event can be=
 used as a proxy for that.",
+        "UMask": "0x4",
+        "Unit": "QPI LL"
+    },
+    {
+        "BriefDescription": "Flits Transferred - Group 1; HOM Request Flit=
s",
+        "EventName": "UNC_Q_TxL_FLITS_G1.HOM_REQ",
+        "PerPkg": "1",
+        "PublicDescription": "Counts the number of flits trasmitted across=
 the QPI Link.  This is one of three groups that allow us to track flits.  =
It includes filters for SNP, HOM, and DRS message classes.  Each flit is ma=
de up of 80 bits of information (in addition to some ECC data).  In full-wi=
dth (L0) mode, flits are made up of four fits, each of which contains 20 bi=
ts of data (along with some additional ECC data).   In half-width (L0p) mod=
e, the fits are only 10 bits, and therefore it takes twice as many fits to =
transmit a flit.  When one talks about QPI speed (for example, 8.0 GT/s), t=
he transfers here refer to fits.  Therefore, in L0, the system will transfe=
r 1 flit at the rate of 1/4th the QPI speed.  One can calculate the bandwid=
th of the link by taking: flits*80b/time.  Note that this is not the same a=
s data bandwidth.  For example, when we are transferring a 64B cacheline ac=
ross QPI, we will break it into 9 flits -- 1 with header information and 8 =
with 64 bits of actual data and an additional 16 bits of other information.=
  To calculate data bandwidth, one should therefore do: data flits * 8B / t=
ime.; Counts the number of data request transmitted over QPI on the home ch=
annel.  This basically counts the number of remote memory requests transmit=
ted over QPI.  In conjunction with the local read count in the Home Agent, =
one can calculate the number of LLC Misses.",
+        "UMask": "0x2",
+        "Unit": "QPI LL"
+    },
+    {
+        "BriefDescription": "Flits Transferred - Group 1; SNP Flits",
+        "EventName": "UNC_Q_TxL_FLITS_G1.SNP",
         "PerPkg": "1",
+        "PublicDescription": "Counts the number of flits trasmitted across=
 the QPI Link.  This is one of three groups that allow us to track flits.  =
It includes filters for SNP, HOM, and DRS message classes.  Each flit is ma=
de up of 80 bits of information (in addition to some ECC data).  In full-wi=
dth (L0) mode, flits are made up of four fits, each of which contains 20 bi=
ts of data (along with some additional ECC data).   In half-width (L0p) mod=
e, the fits are only 10 bits, and therefore it takes twice as many fits to =
transmit a flit.  When one talks about QPI speed (for example, 8.0 GT/s), t=
he transfers here refer to fits.  Therefore, in L0, the system will transfe=
r 1 flit at the rate of 1/4th the QPI speed.  One can calculate the bandwid=
th of the link by taking: flits*80b/time.  Note that this is not the same a=
s data bandwidth.  For example, when we are transferring a 64B cacheline ac=
ross QPI, we will break it into 9 flits -- 1 with header information and 8 =
with 64 bits of actual data and an additional 16 bits of other information.=
  To calculate data bandwidth, one should therefore do: data flits * 8B / t=
ime.; Counts the number of snoop request flits transmitted over QPI.  These=
 requests are contained in the snoop channel.  This does not include snoop =
responses, which are transmitted on the home channel.",
         "UMask": "0x1",
         "Unit": "QPI LL"
     },
     {
-        "BriefDescription": "Flits Transferred - Group 2; Non-Data Respons=
e Tx Flits - AK",
-        "Counter": "0,1,2,3",
+        "BriefDescription": "Flits Transferred - Group 2; Non-Coherent Byp=
ass Tx Flits",
         "EventCode": "0x1",
-        "EventName": "UNC_Q_TxL_FLITS_G2.NDR_AK",
-        "ExtSel": "1",
+        "EventName": "UNC_Q_TxL_FLITS_G2.NCB",
         "PerPkg": "1",
-        "UMask": "0x2",
+        "PublicDescription": "Counts the number of flits trasmitted across=
 the QPI Link.  This is one of three groups that allow us to track flits.  =
It includes filters for NDR, NCB, and NCS message classes.  Each flit is ma=
de up of 80 bits of information (in addition to some ECC data).  In full-wi=
dth (L0) mode, flits are made up of four fits, each of which contains 20 bi=
ts of data (along with some additional ECC data).   In half-width (L0p) mod=
e, the fits are only 10 bits, and therefore it takes twice as many fits to =
transmit a flit.  When one talks about QPI speed (for example, 8.0 GT/s), t=
he transfers here refer to fits.  Therefore, in L0, the system will transfe=
r 1 flit at the rate of 1/4th the QPI speed.  One can calculate the bandwid=
th of the link by taking: flits*80b/time.  Note that this is not the same a=
s data bandwidth.  For example, when we are transferring a 64B cacheline ac=
ross QPI, we will break it into 9 flits -- 1 with header information and 8 =
with 64 bits of actual data and an additional 16 bits of other information.=
  To calculate data bandwidth, one should therefore do: data flits * 8B / t=
ime.; Number of Non-Coherent Bypass flits.  These packets are generally use=
d to transmit non-coherent data across QPI.",
+        "UMask": "0xc",
         "Unit": "QPI LL"
     },
     {
         "BriefDescription": "Flits Transferred - Group 2; Non-Coherent dat=
a Tx Flits",
-        "Counter": "0,1,2,3",
         "EventCode": "0x1",
         "EventName": "UNC_Q_TxL_FLITS_G2.NCB_DATA",
-        "ExtSel": "1",
         "PerPkg": "1",
+        "PublicDescription": "Counts the number of flits trasmitted across=
 the QPI Link.  This is one of three groups that allow us to track flits.  =
It includes filters for NDR, NCB, and NCS message classes.  Each flit is ma=
de up of 80 bits of information (in addition to some ECC data).  In full-wi=
dth (L0) mode, flits are made up of four fits, each of which contains 20 bi=
ts of data (along with some additional ECC data).   In half-width (L0p) mod=
e, the fits are only 10 bits, and therefore it takes twice as many fits to =
transmit a flit.  When one talks about QPI speed (for example, 8.0 GT/s), t=
he transfers here refer to fits.  Therefore, in L0, the system will transfe=
r 1 flit at the rate of 1/4th the QPI speed.  One can calculate the bandwid=
th of the link by taking: flits*80b/time.  Note that this is not the same a=
s data bandwidth.  For example, when we are transferring a 64B cacheline ac=
ross QPI, we will break it into 9 flits -- 1 with header information and 8 =
with 64 bits of actual data and an additional 16 bits of other information.=
  To calculate data bandwidth, one should therefore do: data flits * 8B / t=
ime.; Number of Non-Coherent Bypass data flits.  These flits are generally =
used to transmit non-coherent data across QPI.  This does not include a cou=
nt of the DRS (coherent) data flits.  This only counts the data flits, not =
te NCB headers.",
         "UMask": "0x4",
         "Unit": "QPI LL"
     },
     {
         "BriefDescription": "Flits Transferred - Group 2; Non-Coherent non=
-data Tx Flits",
-        "Counter": "0,1,2,3",
         "EventCode": "0x1",
-        "EventName": "UNC_Q_TxL_FLITS_G2.NCB_NONDATA",
-        "ExtSel": "1",
+        "EventName": "UNC_Q_TxL_FLITS_G2.NCB_NONDATA",
+        "PerPkg": "1",
+        "PublicDescription": "Counts the number of flits trasmitted across=
 the QPI Link.  This is one of three groups that allow us to track flits.  =
It includes filters for NDR, NCB, and NCS message classes.  Each flit is ma=
de up of 80 bits of information (in addition to some ECC data).  In full-wi=
dth (L0) mode, flits are made up of four fits, each of which contains 20 bi=
ts of data (along with some additional ECC data).   In half-width (L0p) mod=
e, the fits are only 10 bits, and therefore it takes twice as many fits to =
transmit a flit.  When one talks about QPI speed (for example, 8.0 GT/s), t=
he transfers here refer to fits.  Therefore, in L0, the system will transfe=
r 1 flit at the rate of 1/4th the QPI speed.  One can calculate the bandwid=
th of the link by taking: flits*80b/time.  Note that this is not the same a=
s data bandwidth.  For example, when we are transferring a 64B cacheline ac=
ross QPI, we will break it into 9 flits -- 1 with header information and 8 =
with 64 bits of actual data and an additional 16 bits of other information.=
  To calculate data bandwidth, one should therefore do: data flits * 8B / t=
ime.; Number of Non-Coherent Bypass non-data flits.  These packets are gene=
rally used to transmit non-coherent data across QPI, and the flits counted =
here are for headers and other non-data flits.  This includes extended head=
ers.",
+        "UMask": "0x8",
+        "Unit": "QPI LL"
+    },
+    {
+        "BriefDescription": "Flits Transferred - Group 2; Non-Coherent sta=
ndard Tx Flits",
+        "EventCode": "0x1",
+        "EventName": "UNC_Q_TxL_FLITS_G2.NCS",
         "PerPkg": "1",
-        "UMask": "0x8",
+        "PublicDescription": "Counts the number of flits trasmitted across=
 the QPI Link.  This is one of three groups that allow us to track flits.  =
It includes filters for NDR, NCB, and NCS message classes.  Each flit is ma=
de up of 80 bits of information (in addition to some ECC data).  In full-wi=
dth (L0) mode, flits are made up of four fits, each of which contains 20 bi=
ts of data (along with some additional ECC data).   In half-width (L0p) mod=
e, the fits are only 10 bits, and therefore it takes twice as many fits to =
transmit a flit.  When one talks about QPI speed (for example, 8.0 GT/s), t=
he transfers here refer to fits.  Therefore, in L0, the system will transfe=
r 1 flit at the rate of 1/4th the QPI speed.  One can calculate the bandwid=
th of the link by taking: flits*80b/time.  Note that this is not the same a=
s data bandwidth.  For example, when we are transferring a 64B cacheline ac=
ross QPI, we will break it into 9 flits -- 1 with header information and 8 =
with 64 bits of actual data and an additional 16 bits of other information.=
  To calculate data bandwidth, one should therefore do: data flits * 8B / t=
ime.; Number of NCS (non-coherent standard) flits transmitted over QPI.    =
This includes extended headers.",
+        "UMask": "0x10",
         "Unit": "QPI LL"
     },
     {
-        "BriefDescription": "Flits Transferred - Group 2; Non-Coherent Byp=
ass Tx Flits",
-        "Counter": "0,1,2,3",
+        "BriefDescription": "Flits Transferred - Group 2; Non-Data Respons=
e Tx Flits - AD",
         "EventCode": "0x1",
-        "EventName": "UNC_Q_TxL_FLITS_G2.NCB",
-        "ExtSel": "1",
+        "EventName": "UNC_Q_TxL_FLITS_G2.NDR_AD",
         "PerPkg": "1",
-        "UMask": "0xC",
+        "PublicDescription": "Counts the number of flits trasmitted across=
 the QPI Link.  This is one of three groups that allow us to track flits.  =
It includes filters for NDR, NCB, and NCS message classes.  Each flit is ma=
de up of 80 bits of information (in addition to some ECC data).  In full-wi=
dth (L0) mode, flits are made up of four fits, each of which contains 20 bi=
ts of data (along with some additional ECC data).   In half-width (L0p) mod=
e, the fits are only 10 bits, and therefore it takes twice as many fits to =
transmit a flit.  When one talks about QPI speed (for example, 8.0 GT/s), t=
he transfers here refer to fits.  Therefore, in L0, the system will transfe=
r 1 flit at the rate of 1/4th the QPI speed.  One can calculate the bandwid=
th of the link by taking: flits*80b/time.  Note that this is not the same a=
s data bandwidth.  For example, when we are transferring a 64B cacheline ac=
ross QPI, we will break it into 9 flits -- 1 with header information and 8 =
with 64 bits of actual data and an additional 16 bits of other information.=
  To calculate data bandwidth, one should therefore do: data flits * 8B / t=
ime.; Counts the total number of flits transmitted over the NDR (Non-Data R=
esponse) channel.  This channel is used to send a variety of protocol flits=
 including grants and completions.  This is only for NDR packets to the loc=
al socket which use the AK ring.",
+        "UMask": "0x1",
         "Unit": "QPI LL"
     },
     {
-        "BriefDescription": "Flits Transferred - Group 2; Non-Coherent sta=
ndard Tx Flits",
-        "Counter": "0,1,2,3",
+        "BriefDescription": "Flits Transferred - Group 2; Non-Data Respons=
e Tx Flits - AK",
         "EventCode": "0x1",
-        "EventName": "UNC_Q_TxL_FLITS_G2.NCS",
-        "ExtSel": "1",
+        "EventName": "UNC_Q_TxL_FLITS_G2.NDR_AK",
         "PerPkg": "1",
-        "UMask": "0x10",
+        "PublicDescription": "Counts the number of flits trasmitted across=
 the QPI Link.  This is one of three groups that allow us to track flits.  =
It includes filters for NDR, NCB, and NCS message classes.  Each flit is ma=
de up of 80 bits of information (in addition to some ECC data).  In full-wi=
dth (L0) mode, flits are made up of four fits, each of which contains 20 bi=
ts of data (along with some additional ECC data).   In half-width (L0p) mod=
e, the fits are only 10 bits, and therefore it takes twice as many fits to =
transmit a flit.  When one talks about QPI speed (for example, 8.0 GT/s), t=
he transfers here refer to fits.  Therefore, in L0, the system will transfe=
r 1 flit at the rate of 1/4th the QPI speed.  One can calculate the bandwid=
th of the link by taking: flits*80b/time.  Note that this is not the same a=
s data bandwidth.  For example, when we are transferring a 64B cacheline ac=
ross QPI, we will break it into 9 flits -- 1 with header information and 8 =
with 64 bits of actual data and an additional 16 bits of other information.=
  To calculate data bandwidth, one should therefore do: data flits * 8B / t=
ime.; Counts the total number of flits transmitted over the NDR (Non-Data R=
esponse) channel.  This channel is used to send a variety of protocol flits=
 including grants and completions.  This is only for NDR packets destined f=
or Route-thru to a remote socket.",
+        "UMask": "0x2",
         "Unit": "QPI LL"
     },
     {
         "BriefDescription": "Tx Flit Buffer Allocations",
-        "Counter": "0,1,2,3",
         "EventCode": "0x4",
         "EventName": "UNC_Q_TxL_INSERTS",
         "PerPkg": "1",
+        "PublicDescription": "Number of allocations into the QPI Tx Flit B=
uffer.  Generally, when data is transmitted across QPI, it will bypass the =
TxQ and pass directly to the link.  However, the TxQ will be used with L0p =
and when LLR occurs, increasing latency to transfer out to the link.  This =
event can be used in conjunction with the Flit Buffer Occupancy event in or=
der to calculate the average flit buffer lifetime.",
         "Unit": "QPI LL"
     },
     {
         "BriefDescription": "Tx Flit Buffer Occupancy",
-        "Counter": "0,1,2,3",
         "EventCode": "0x7",
         "EventName": "UNC_Q_TxL_OCCUPANCY",
         "PerPkg": "1",
+        "PublicDescription": "Accumulates the number of flits in the TxQ. =
 Generally, when data is transmitted across QPI, it will bypass the TxQ and=
 pass directly to the link.  However, the TxQ will be used with L0p and whe=
n LLR occurs, increasing latency to transfer out to the link. This can be u=
sed with the cycles not empty event to track average occupancy, or the allo=
cations event to track average lifetime in the TxQ.",
         "Unit": "QPI LL"
     },
     {
         "BriefDescription": "R3QPI Egress Credit Occupancy - HOM; for VN0"=
,
-        "Counter": "0,1,2,3",
         "EventCode": "0x26",
         "EventName": "UNC_Q_TxR_AD_HOM_CREDIT_ACQUIRED.VN0",
-        "ExtSel": "1",
         "PerPkg": "1",
+        "PublicDescription": "Number of link layer credits into the R3 (fo=
r transactions across the BGF) acquired each cycle. Flow Control FIFO for H=
ome messages on AD.",
         "UMask": "0x1",
         "Unit": "QPI LL"
     },
     {
         "BriefDescription": "R3QPI Egress Credit Occupancy - HOM; for VN1"=
,
-        "Counter": "0,1,2,3",
         "EventCode": "0x26",
         "EventName": "UNC_Q_TxR_AD_HOM_CREDIT_ACQUIRED.VN1",
-        "ExtSel": "1",
         "PerPkg": "1",
+        "PublicDescription": "Number of link layer credits into the R3 (fo=
r transactions across the BGF) acquired each cycle. Flow Control FIFO for H=
ome messages on AD.",
         "UMask": "0x2",
         "Unit": "QPI LL"
     },
     {
         "BriefDescription": "R3QPI Egress Credit Occupancy - AD HOM; for V=
N0",
-        "Counter": "0,1,2,3",
         "EventCode": "0x22",
         "EventName": "UNC_Q_TxR_AD_HOM_CREDIT_OCCUPANCY.VN0",
-        "ExtSel": "1",
         "PerPkg": "1",
+        "PublicDescription": "Occupancy event that tracks the number of li=
nk layer credits into the R3 (for transactions across the BGF) available in=
 each cycle.  Flow Control FIFO for HOM messages on AD.",
         "UMask": "0x1",
         "Unit": "QPI LL"
     },
     {
         "BriefDescription": "R3QPI Egress Credit Occupancy - AD HOM; for V=
N1",
-        "Counter": "0,1,2,3",
         "EventCode": "0x22",
         "EventName": "UNC_Q_TxR_AD_HOM_CREDIT_OCCUPANCY.VN1",
-        "ExtSel": "1",
         "PerPkg": "1",
+        "PublicDescription": "Occupancy event that tracks the number of li=
nk layer credits into the R3 (for transactions across the BGF) available in=
 each cycle.  Flow Control FIFO for HOM messages on AD.",
         "UMask": "0x2",
         "Unit": "QPI LL"
     },
     {
         "BriefDescription": "R3QPI Egress Credit Occupancy - AD NDR; for V=
N0",
-        "Counter": "0,1,2,3",
         "EventCode": "0x28",
         "EventName": "UNC_Q_TxR_AD_NDR_CREDIT_ACQUIRED.VN0",
-        "ExtSel": "1",
         "PerPkg": "1",
+        "PublicDescription": "Number of link layer credits into the R3 (fo=
r transactions across the BGF) acquired each cycle.  Flow Control FIFO for =
NDR messages on AD.",
         "UMask": "0x1",
         "Unit": "QPI LL"
     },
     {
         "BriefDescription": "R3QPI Egress Credit Occupancy - AD NDR; for V=
N1",
-        "Counter": "0,1,2,3",
         "EventCode": "0x28",
         "EventName": "UNC_Q_TxR_AD_NDR_CREDIT_ACQUIRED.VN1",
-        "ExtSel": "1",
         "PerPkg": "1",
+        "PublicDescription": "Number of link layer credits into the R3 (fo=
r transactions across the BGF) acquired each cycle.  Flow Control FIFO for =
NDR messages on AD.",
         "UMask": "0x2",
         "Unit": "QPI LL"
     },
     {
         "BriefDescription": "R3QPI Egress Credit Occupancy - AD NDR; for V=
N0",
-        "Counter": "0,1,2,3",
         "EventCode": "0x24",
         "EventName": "UNC_Q_TxR_AD_NDR_CREDIT_OCCUPANCY.VN0",
-        "ExtSel": "1",
         "PerPkg": "1",
+        "PublicDescription": "Occupancy event that tracks the number of li=
nk layer credits into the R3 (for transactions across the BGF) available in=
 each cycle. Flow Control FIFO  for NDR messages on AD.",
         "UMask": "0x1",
         "Unit": "QPI LL"
     },
     {
         "BriefDescription": "R3QPI Egress Credit Occupancy - AD NDR; for V=
N1",
-        "Counter": "0,1,2,3",
         "EventCode": "0x24",
         "EventName": "UNC_Q_TxR_AD_NDR_CREDIT_OCCUPANCY.VN1",
-        "ExtSel": "1",
         "PerPkg": "1",
+        "PublicDescription": "Occupancy event that tracks the number of li=
nk layer credits into the R3 (for transactions across the BGF) available in=
 each cycle. Flow Control FIFO  for NDR messages on AD.",
         "UMask": "0x2",
         "Unit": "QPI LL"
     },
     {
         "BriefDescription": "R3QPI Egress Credit Occupancy - SNP; for VN0"=
,
-        "Counter": "0,1,2,3",
         "EventCode": "0x27",
         "EventName": "UNC_Q_TxR_AD_SNP_CREDIT_ACQUIRED.VN0",
-        "ExtSel": "1",
         "PerPkg": "1",
+        "PublicDescription": "Number of link layer credits into the R3 (fo=
r transactions across the BGF) acquired each cycle.  Flow Control FIFO for =
Snoop messages on AD.",
         "UMask": "0x1",
         "Unit": "QPI LL"
     },
     {
         "BriefDescription": "R3QPI Egress Credit Occupancy - SNP; for VN1"=
,
-        "Counter": "0,1,2,3",
         "EventCode": "0x27",
         "EventName": "UNC_Q_TxR_AD_SNP_CREDIT_ACQUIRED.VN1",
-        "ExtSel": "1",
         "PerPkg": "1",
+        "PublicDescription": "Number of link layer credits into the R3 (fo=
r transactions across the BGF) acquired each cycle.  Flow Control FIFO for =
Snoop messages on AD.",
         "UMask": "0x2",
         "Unit": "QPI LL"
     },
     {
         "BriefDescription": "R3QPI Egress Credit Occupancy - AD SNP; for V=
N0",
-        "Counter": "0,1,2,3",
         "EventCode": "0x23",
         "EventName": "UNC_Q_TxR_AD_SNP_CREDIT_OCCUPANCY.VN0",
-        "ExtSel": "1",
         "PerPkg": "1",
+        "PublicDescription": "Occupancy event that tracks the number of li=
nk layer credits into the R3 (for transactions across the BGF) available in=
 each cycle.  Flow Control FIFO fro Snoop messages on AD.",
         "UMask": "0x1",
         "Unit": "QPI LL"
     },
     {
         "BriefDescription": "R3QPI Egress Credit Occupancy - AD SNP; for V=
N1",
-        "Counter": "0,1,2,3",
         "EventCode": "0x23",
         "EventName": "UNC_Q_TxR_AD_SNP_CREDIT_OCCUPANCY.VN1",
-        "ExtSel": "1",
         "PerPkg": "1",
+        "PublicDescription": "Occupancy event that tracks the number of li=
nk layer credits into the R3 (for transactions across the BGF) available in=
 each cycle.  Flow Control FIFO fro Snoop messages on AD.",
         "UMask": "0x2",
         "Unit": "QPI LL"
     },
     {
         "BriefDescription": "R3QPI Egress Credit Occupancy - AK NDR",
-        "Counter": "0,1,2,3",
         "EventCode": "0x29",
         "EventName": "UNC_Q_TxR_AK_NDR_CREDIT_ACQUIRED",
-        "ExtSel": "1",
         "PerPkg": "1",
+        "PublicDescription": "Number of credits into the R3 (for transacti=
ons across the BGF) acquired each cycle. Local NDR message class to AK Egre=
ss.",
         "Unit": "QPI LL"
     },
     {
         "BriefDescription": "R3QPI Egress Credit Occupancy - AK NDR",
-        "Counter": "0,1,2,3",
         "EventCode": "0x25",
         "EventName": "UNC_Q_TxR_AK_NDR_CREDIT_OCCUPANCY",
-        "ExtSel": "1",
         "PerPkg": "1",
+        "PublicDescription": "Occupancy event that tracks the number of cr=
edits into the R3 (for transactions across the BGF) available in each cycle=
.  Local NDR message class to AK Egress.",
         "Unit": "QPI LL"
     },
     {
         "BriefDescription": "R3QPI Egress Credit Occupancy - DRS; for VN0"=
,
-        "Counter": "0,1,2,3",
         "EventCode": "0x2A",
         "EventName": "UNC_Q_TxR_BL_DRS_CREDIT_ACQUIRED.VN0",
-        "ExtSel": "1",
         "PerPkg": "1",
+        "PublicDescription": "Number of credits into the R3 (for transacti=
ons across the BGF) acquired each cycle. DRS message class to BL Egress.",
         "UMask": "0x1",
         "Unit": "QPI LL"
     },
     {
         "BriefDescription": "R3QPI Egress Credit Occupancy - DRS; for VN1"=
,
-        "Counter": "0,1,2,3",
         "EventCode": "0x2A",
         "EventName": "UNC_Q_TxR_BL_DRS_CREDIT_ACQUIRED.VN1",
-        "ExtSel": "1",
         "PerPkg": "1",
+        "PublicDescription": "Number of credits into the R3 (for transacti=
ons across the BGF) acquired each cycle. DRS message class to BL Egress.",
         "UMask": "0x2",
         "Unit": "QPI LL"
     },
     {
         "BriefDescription": "R3QPI Egress Credit Occupancy - DRS; for Shar=
ed VN",
-        "Counter": "0,1,2,3",
         "EventCode": "0x2A",
         "EventName": "UNC_Q_TxR_BL_DRS_CREDIT_ACQUIRED.VN_SHR",
-        "ExtSel": "1",
         "PerPkg": "1",
+        "PublicDescription": "Number of credits into the R3 (for transacti=
ons across the BGF) acquired each cycle. DRS message class to BL Egress.",
         "UMask": "0x4",
         "Unit": "QPI LL"
     },
     {
         "BriefDescription": "R3QPI Egress Credit Occupancy - BL DRS; for V=
N0",
-        "Counter": "0,1,2,3",
         "EventCode": "0x1F",
         "EventName": "UNC_Q_TxR_BL_DRS_CREDIT_OCCUPANCY.VN0",
-        "ExtSel": "1",
         "PerPkg": "1",
+        "PublicDescription": "Occupancy event that tracks the number of cr=
edits into the R3 (for transactions across the BGF) available in each cycle=
.  DRS message class to BL Egress.",
         "UMask": "0x1",
         "Unit": "QPI LL"
     },
     {
         "BriefDescription": "R3QPI Egress Credit Occupancy - BL DRS; for V=
N1",
-        "Counter": "0,1,2,3",
         "EventCode": "0x1F",
         "EventName": "UNC_Q_TxR_BL_DRS_CREDIT_OCCUPANCY.VN1",
-        "ExtSel": "1",
         "PerPkg": "1",
+        "PublicDescription": "Occupancy event that tracks the number of cr=
edits into the R3 (for transactions across the BGF) available in each cycle=
.  DRS message class to BL Egress.",
         "UMask": "0x2",
         "Unit": "QPI LL"
     },
     {
         "BriefDescription": "R3QPI Egress Credit Occupancy - BL DRS; for S=
hared VN",
-        "Counter": "0,1,2,3",
         "EventCode": "0x1F",
         "EventName": "UNC_Q_TxR_BL_DRS_CREDIT_OCCUPANCY.VN_SHR",
-        "ExtSel": "1",
         "PerPkg": "1",
+        "PublicDescription": "Occupancy event that tracks the number of cr=
edits into the R3 (for transactions across the BGF) available in each cycle=
.  DRS message class to BL Egress.",
         "UMask": "0x4",
         "Unit": "QPI LL"
     },
     {
         "BriefDescription": "R3QPI Egress Credit Occupancy - NCB; for VN0"=
,
-        "Counter": "0,1,2,3",
         "EventCode": "0x2B",
         "EventName": "UNC_Q_TxR_BL_NCB_CREDIT_ACQUIRED.VN0",
-        "ExtSel": "1",
         "PerPkg": "1",
+        "PublicDescription": "Number of credits into the R3 (for transacti=
ons across the BGF) acquired each cycle. NCB message class to BL Egress.",
         "UMask": "0x1",
         "Unit": "QPI LL"
     },
     {
         "BriefDescription": "R3QPI Egress Credit Occupancy - NCB; for VN1"=
,
-        "Counter": "0,1,2,3",
         "EventCode": "0x2B",
         "EventName": "UNC_Q_TxR_BL_NCB_CREDIT_ACQUIRED.VN1",
-        "ExtSel": "1",
         "PerPkg": "1",
+        "PublicDescription": "Number of credits into the R3 (for transacti=
ons across the BGF) acquired each cycle. NCB message class to BL Egress.",
         "UMask": "0x2",
         "Unit": "QPI LL"
     },
     {
         "BriefDescription": "R3QPI Egress Credit Occupancy - BL NCB; for V=
N0",
-        "Counter": "0,1,2,3",
         "EventCode": "0x20",
         "EventName": "UNC_Q_TxR_BL_NCB_CREDIT_OCCUPANCY.VN0",
-        "ExtSel": "1",
         "PerPkg": "1",
+        "PublicDescription": "Occupancy event that tracks the number of cr=
edits into the R3 (for transactions across the BGF) available in each cycle=
.  NCB message class to BL Egress.",
         "UMask": "0x1",
         "Unit": "QPI LL"
     },
     {
         "BriefDescription": "R3QPI Egress Credit Occupancy - BL NCB; for V=
N1",
-        "Counter": "0,1,2,3",
         "EventCode": "0x20",
         "EventName": "UNC_Q_TxR_BL_NCB_CREDIT_OCCUPANCY.VN1",
-        "ExtSel": "1",
         "PerPkg": "1",
+        "PublicDescription": "Occupancy event that tracks the number of cr=
edits into the R3 (for transactions across the BGF) available in each cycle=
.  NCB message class to BL Egress.",
         "UMask": "0x2",
         "Unit": "QPI LL"
     },
     {
         "BriefDescription": "R3QPI Egress Credit Occupancy - NCS; for VN0"=
,
-        "Counter": "0,1,2,3",
         "EventCode": "0x2C",
         "EventName": "UNC_Q_TxR_BL_NCS_CREDIT_ACQUIRED.VN0",
-        "ExtSel": "1",
         "PerPkg": "1",
+        "PublicDescription": "Number of credits into the R3 (for transacti=
ons across the BGF) acquired each cycle. NCS message class to BL Egress.",
         "UMask": "0x1",
         "Unit": "QPI LL"
     },
     {
         "BriefDescription": "R3QPI Egress Credit Occupancy - NCS; for VN1"=
,
-        "Counter": "0,1,2,3",
         "EventCode": "0x2C",
         "EventName": "UNC_Q_TxR_BL_NCS_CREDIT_ACQUIRED.VN1",
-        "ExtSel": "1",
         "PerPkg": "1",
+        "PublicDescription": "Number of credits into the R3 (for transacti=
ons across the BGF) acquired each cycle. NCS message class to BL Egress.",
         "UMask": "0x2",
         "Unit": "QPI LL"
     },
     {
         "BriefDescription": "R3QPI Egress Credit Occupancy - BL NCS; for V=
N0",
-        "Counter": "0,1,2,3",
         "EventCode": "0x21",
         "EventName": "UNC_Q_TxR_BL_NCS_CREDIT_OCCUPANCY.VN0",
-        "ExtSel": "1",
         "PerPkg": "1",
+        "PublicDescription": "Occupancy event that tracks the number of cr=
edits into the R3 (for transactions across the BGF) available in each cycle=
.  NCS message class to BL Egress.",
         "UMask": "0x1",
         "Unit": "QPI LL"
     },
     {
         "BriefDescription": "R3QPI Egress Credit Occupancy - BL NCS; for V=
N1",
-        "Counter": "0,1,2,3",
         "EventCode": "0x21",
         "EventName": "UNC_Q_TxR_BL_NCS_CREDIT_OCCUPANCY.VN1",
-        "ExtSel": "1",
         "PerPkg": "1",
+        "PublicDescription": "Occupancy event that tracks the number of cr=
edits into the R3 (for transactions across the BGF) available in each cycle=
.  NCS message class to BL Egress.",
         "UMask": "0x2",
         "Unit": "QPI LL"
     },
     {
         "BriefDescription": "VNA Credits Returned",
-        "Counter": "0,1,2,3",
         "EventCode": "0x1C",
         "EventName": "UNC_Q_VNA_CREDIT_RETURNS",
-        "ExtSel": "1",
         "PerPkg": "1",
+        "PublicDescription": "Number of VNA credits returned.",
         "Unit": "QPI LL"
     },
     {
         "BriefDescription": "VNA Credits Pending Return - Occupancy",
-        "Counter": "0,1,2,3",
         "EventCode": "0x1B",
         "EventName": "UNC_Q_VNA_CREDIT_RETURN_OCCUPANCY",
-        "ExtSel": "1",
-        "PerPkg": "1",
-        "Unit": "QPI LL"
-    },
-    {
-        "BriefDescription": "CRC Errors Detected; LinkInit",
-        "Counter": "0,1,2,3",
-        "EventCode": "0x3",
-        "EventName": "UNC_Q_RxL_CRC_ERRORS.LINK_INIT",
-        "PerPkg": "1",
-        "UMask": "0x1",
-        "Unit": "QPI LL"
-    },
-    {
-        "BriefDescription": "UNC_Q_RxL_CRC_ERRORS.NORMAL_OP",
-        "Counter": "0,1,2,3",
-        "EventCode": "0x3",
-        "EventName": "UNC_Q_RxL_CRC_ERRORS.NORMAL_OP",
-        "PerPkg": "1",
-        "UMask": "0x2",
-        "Unit": "QPI LL"
-    },
-    {
-        "BriefDescription": "RxQ Cycles Not Empty - DRS; for VN0",
-        "Counter": "0,1,2,3",
-        "EventCode": "0xF",
-        "EventName": "UNC_Q_RxL_CYCLES_NE_DRS.VN0",
-        "ExtSel": "1",
-        "PerPkg": "1",
-        "UMask": "0x1",
-        "Unit": "QPI LL"
-    },
-    {
-        "BriefDescription": "RxQ Cycles Not Empty - DRS; for VN1",
-        "Counter": "0,1,2,3",
-        "EventCode": "0xF",
-        "EventName": "UNC_Q_RxL_CYCLES_NE_DRS.VN1",
-        "ExtSel": "1",
-        "PerPkg": "1",
-        "UMask": "0x2",
-        "Unit": "QPI LL"
-    },
-    {
-        "BriefDescription": "RxQ Cycles Not Empty - HOM; for VN0",
-        "Counter": "0,1,2,3",
-        "EventCode": "0x12",
-        "EventName": "UNC_Q_RxL_CYCLES_NE_HOM.VN0",
-        "ExtSel": "1",
-        "PerPkg": "1",
-        "UMask": "0x1",
-        "Unit": "QPI LL"
-    },
-    {
-        "BriefDescription": "RxQ Cycles Not Empty - HOM; for VN1",
-        "Counter": "0,1,2,3",
-        "EventCode": "0x12",
-        "EventName": "UNC_Q_RxL_CYCLES_NE_HOM.VN1",
-        "ExtSel": "1",
-        "PerPkg": "1",
-        "UMask": "0x2",
-        "Unit": "QPI LL"
-    },
-    {
-        "BriefDescription": "RxQ Cycles Not Empty - NCB; for VN0",
-        "Counter": "0,1,2,3",
-        "EventCode": "0x10",
-        "EventName": "UNC_Q_RxL_CYCLES_NE_NCB.VN0",
-        "ExtSel": "1",
-        "PerPkg": "1",
-        "UMask": "0x1",
-        "Unit": "QPI LL"
-    },
-    {
-        "BriefDescription": "RxQ Cycles Not Empty - NCB; for VN1",
-        "Counter": "0,1,2,3",
-        "EventCode": "0x10",
-        "EventName": "UNC_Q_RxL_CYCLES_NE_NCB.VN1",
-        "ExtSel": "1",
-        "PerPkg": "1",
-        "UMask": "0x2",
-        "Unit": "QPI LL"
-    },
-    {
-        "BriefDescription": "RxQ Cycles Not Empty - NCS; for VN0",
-        "Counter": "0,1,2,3",
-        "EventCode": "0x11",
-        "EventName": "UNC_Q_RxL_CYCLES_NE_NCS.VN0",
-        "ExtSel": "1",
-        "PerPkg": "1",
-        "UMask": "0x1",
-        "Unit": "QPI LL"
-    },
-    {
-        "BriefDescription": "RxQ Cycles Not Empty - NCS; for VN1",
-        "Counter": "0,1,2,3",
-        "EventCode": "0x11",
-        "EventName": "UNC_Q_RxL_CYCLES_NE_NCS.VN1",
-        "ExtSel": "1",
-        "PerPkg": "1",
-        "UMask": "0x2",
-        "Unit": "QPI LL"
-    },
-    {
-        "BriefDescription": "RxQ Cycles Not Empty - NDR; for VN0",
-        "Counter": "0,1,2,3",
-        "EventCode": "0x14",
-        "EventName": "UNC_Q_RxL_CYCLES_NE_NDR.VN0",
-        "ExtSel": "1",
-        "PerPkg": "1",
-        "UMask": "0x1",
-        "Unit": "QPI LL"
-    },
-    {
-        "BriefDescription": "RxQ Cycles Not Empty - NDR; for VN1",
-        "Counter": "0,1,2,3",
-        "EventCode": "0x14",
-        "EventName": "UNC_Q_RxL_CYCLES_NE_NDR.VN1",
-        "ExtSel": "1",
-        "PerPkg": "1",
-        "UMask": "0x2",
-        "Unit": "QPI LL"
-    },
-    {
-        "BriefDescription": "RxQ Cycles Not Empty - SNP; for VN0",
-        "Counter": "0,1,2,3",
-        "EventCode": "0x13",
-        "EventName": "UNC_Q_RxL_CYCLES_NE_SNP.VN0",
-        "ExtSel": "1",
-        "PerPkg": "1",
-        "UMask": "0x1",
-        "Unit": "QPI LL"
-    },
-    {
-        "BriefDescription": "RxQ Cycles Not Empty - SNP; for VN1",
-        "Counter": "0,1,2,3",
-        "EventCode": "0x13",
-        "EventName": "UNC_Q_RxL_CYCLES_NE_SNP.VN1",
-        "ExtSel": "1",
-        "PerPkg": "1",
-        "UMask": "0x2",
-        "Unit": "QPI LL"
-    },
-    {
-        "BriefDescription": "Stalls Sending to R3QPI on VN0; BGF Stall - H=
OM",
-        "Counter": "0,1,2,3",
-        "EventCode": "0x35",
-        "EventName": "UNC_Q_RxL_STALLS_VN0.BGF_DRS",
-        "ExtSel": "1",
-        "PerPkg": "1",
-        "UMask": "0x1",
-        "Unit": "QPI LL"
-    },
-    {
-        "BriefDescription": "Stalls Sending to R3QPI on VN0; BGF Stall - S=
NP",
-        "Counter": "0,1,2,3",
-        "EventCode": "0x35",
-        "EventName": "UNC_Q_RxL_STALLS_VN0.BGF_NCB",
-        "ExtSel": "1",
-        "PerPkg": "1",
-        "UMask": "0x2",
-        "Unit": "QPI LL"
-    },
-    {
-        "BriefDescription": "Stalls Sending to R3QPI on VN0; BGF Stall - N=
DR",
-        "Counter": "0,1,2,3",
-        "EventCode": "0x35",
-        "EventName": "UNC_Q_RxL_STALLS_VN0.BGF_NCS",
-        "ExtSel": "1",
-        "PerPkg": "1",
-        "UMask": "0x4",
-        "Unit": "QPI LL"
-    },
-    {
-        "BriefDescription": "Stalls Sending to R3QPI on VN0; BGF Stall - D=
RS",
-        "Counter": "0,1,2,3",
-        "EventCode": "0x35",
-        "EventName": "UNC_Q_RxL_STALLS_VN0.BGF_HOM",
-        "ExtSel": "1",
-        "PerPkg": "1",
-        "UMask": "0x8",
-        "Unit": "QPI LL"
-    },
-    {
-        "BriefDescription": "Stalls Sending to R3QPI on VN0; BGF Stall - N=
CB",
-        "Counter": "0,1,2,3",
-        "EventCode": "0x35",
-        "EventName": "UNC_Q_RxL_STALLS_VN0.BGF_SNP",
-        "ExtSel": "1",
-        "PerPkg": "1",
-        "UMask": "0x10",
-        "Unit": "QPI LL"
-    },
-    {
-        "BriefDescription": "Stalls Sending to R3QPI on VN0; BGF Stall - N=
CS",
-        "Counter": "0,1,2,3",
-        "EventCode": "0x35",
-        "EventName": "UNC_Q_RxL_STALLS_VN0.BGF_NDR",
-        "ExtSel": "1",
-        "PerPkg": "1",
-        "UMask": "0x20",
-        "Unit": "QPI LL"
-    },
-    {
-        "BriefDescription": "Stalls Sending to R3QPI on VN0; Egress Credit=
s",
-        "Counter": "0,1,2,3",
-        "EventCode": "0x35",
-        "EventName": "UNC_Q_RxL_STALLS_VN0.EGRESS_CREDITS",
-        "ExtSel": "1",
-        "PerPkg": "1",
-        "UMask": "0x40",
-        "Unit": "QPI LL"
-    },
-    {
-        "BriefDescription": "Stalls Sending to R3QPI on VN0; GV",
-        "Counter": "0,1,2,3",
-        "EventCode": "0x35",
-        "EventName": "UNC_Q_RxL_STALLS_VN0.GV",
-        "ExtSel": "1",
-        "PerPkg": "1",
-        "UMask": "0x80",
-        "Unit": "QPI LL"
-    },
-    {
-        "BriefDescription": "Stalls Sending to R3QPI on VN1; BGF Stall - H=
OM",
-        "Counter": "0,1,2,3",
-        "EventCode": "0x3A",
-        "EventName": "UNC_Q_RxL_STALLS_VN1.BGF_DRS",
-        "ExtSel": "1",
-        "PerPkg": "1",
-        "UMask": "0x1",
-        "Unit": "QPI LL"
-    },
-    {
-        "BriefDescription": "Stalls Sending to R3QPI on VN1; BGF Stall - S=
NP",
-        "Counter": "0,1,2,3",
-        "EventCode": "0x3A",
-        "EventName": "UNC_Q_RxL_STALLS_VN1.BGF_NCB",
-        "ExtSel": "1",
-        "PerPkg": "1",
-        "UMask": "0x2",
-        "Unit": "QPI LL"
-    },
-    {
-        "BriefDescription": "Stalls Sending to R3QPI on VN1; BGF Stall - N=
DR",
-        "Counter": "0,1,2,3",
-        "EventCode": "0x3A",
-        "EventName": "UNC_Q_RxL_STALLS_VN1.BGF_NCS",
-        "ExtSel": "1",
-        "PerPkg": "1",
-        "UMask": "0x4",
-        "Unit": "QPI LL"
-    },
-    {
-        "BriefDescription": "Stalls Sending to R3QPI on VN1; BGF Stall - D=
RS",
-        "Counter": "0,1,2,3",
-        "EventCode": "0x3A",
-        "EventName": "UNC_Q_RxL_STALLS_VN1.BGF_HOM",
-        "ExtSel": "1",
-        "PerPkg": "1",
-        "UMask": "0x8",
-        "Unit": "QPI LL"
-    },
-    {
-        "BriefDescription": "Stalls Sending to R3QPI on VN1; BGF Stall - N=
CB",
-        "Counter": "0,1,2,3",
-        "EventCode": "0x3A",
-        "EventName": "UNC_Q_RxL_STALLS_VN1.BGF_SNP",
-        "ExtSel": "1",
-        "PerPkg": "1",
-        "UMask": "0x10",
-        "Unit": "QPI LL"
-    },
-    {
-        "BriefDescription": "Stalls Sending to R3QPI on VN1; BGF Stall - N=
CS",
-        "Counter": "0,1,2,3",
-        "EventCode": "0x3A",
-        "EventName": "UNC_Q_RxL_STALLS_VN1.BGF_NDR",
-        "ExtSel": "1",
-        "PerPkg": "1",
-        "UMask": "0x20",
-        "Unit": "QPI LL"
-    },
-    {
-        "BriefDescription": "Cycles Stalled with no LLR Credits; LLR is fu=
ll",
-        "Counter": "0,1,2,3",
-        "EventCode": "0x2",
-        "EventName": "UNC_Q_TxL_CRC_NO_CREDITS.FULL",
-        "PerPkg": "1",
-        "UMask": "0x1",
-        "Unit": "QPI LL"
-    },
-    {
-        "BriefDescription": "Cycles Stalled with no LLR Credits; LLR is al=
most full",
-        "Counter": "0,1,2,3",
-        "EventCode": "0x2",
-        "EventName": "UNC_Q_TxL_CRC_NO_CREDITS.ALMOST_FULL",
         "PerPkg": "1",
-        "UMask": "0x2",
+        "PublicDescription": "Number of VNA credits in the Rx side that ar=
e waitng to be returned back across the link.",
         "Unit": "QPI LL"
     }
 ]
diff --git a/tools/perf/pmu-events/arch/x86/broadwellx/uncore-memory.json b=
/tools/perf/pmu-events/arch/x86/broadwellx/uncore-memory.json
index 05fab7d2723e..34dfc3cf22ef 100644
--- a/tools/perf/pmu-events/arch/x86/broadwellx/uncore-memory.json
+++ b/tools/perf/pmu-events/arch/x86/broadwellx/uncore-memory.json
@@ -1,335 +1,344 @@
 [
     {
-        "BriefDescription": "DRAM Activate Count; Activate due to Read",
-        "Counter": "0,1,2,3",
-        "EventCode": "0x1",
-        "EventName": "UNC_M_ACT_COUNT.RD",
+        "BriefDescription": "read requests to memory controller. Derived f=
rom unc_m_cas_count.rd",
+        "EventCode": "0x4",
+        "EventName": "LLC_MISSES.MEM_READ",
         "PerPkg": "1",
-        "UMask": "0x1",
+        "PublicDescription": "DRAM RD_CAS and WR_CAS Commands; Counts the =
total number of DRAM Read CAS commands issued on this channel (including un=
derfills).",
+        "ScaleUnit": "64Bytes",
+        "UMask": "0x3",
         "Unit": "iMC"
     },
     {
-        "BriefDescription": "DRAM Activate Count; Activate due to Write",
-        "Counter": "0,1,2,3",
-        "EventCode": "0x1",
-        "EventName": "UNC_M_ACT_COUNT.WR",
+        "BriefDescription": "write requests to memory controller. Derived =
from unc_m_cas_count.wr",
+        "EventCode": "0x4",
+        "EventName": "LLC_MISSES.MEM_WRITE",
         "PerPkg": "1",
-        "UMask": "0x2",
+        "PublicDescription": "DRAM RD_CAS and WR_CAS Commands; Counts the =
total number of DRAM Write CAS commands issued on this channel.",
+        "ScaleUnit": "64Bytes",
+        "UMask": "0xc",
         "Unit": "iMC"
     },
     {
         "BriefDescription": "DRAM Activate Count; Activate due to Write",
-        "Counter": "0,1,2,3",
         "EventCode": "0x1",
         "EventName": "UNC_M_ACT_COUNT.BYP",
         "PerPkg": "1",
+        "PublicDescription": "Counts the number of DRAM Activate commands =
sent on this channel.  Activate commands are issued to open up a page on th=
e DRAM devices so that it can be read or written to with a CAS.  One can ca=
lculate the number of Page Misses by subtracting the number of Page Miss pr=
echarges from the number of Activates.",
         "UMask": "0x8",
         "Unit": "iMC"
     },
+    {
+        "BriefDescription": "DRAM Activate Count; Activate due to Read",
+        "EventCode": "0x1",
+        "EventName": "UNC_M_ACT_COUNT.RD",
+        "PerPkg": "1",
+        "PublicDescription": "Counts the number of DRAM Activate commands =
sent on this channel.  Activate commands are issued to open up a page on th=
e DRAM devices so that it can be read or written to with a CAS.  One can ca=
lculate the number of Page Misses by subtracting the number of Page Miss pr=
echarges from the number of Activates.",
+        "UMask": "0x1",
+        "Unit": "iMC"
+    },
+    {
+        "BriefDescription": "DRAM Activate Count; Activate due to Write",
+        "EventCode": "0x1",
+        "EventName": "UNC_M_ACT_COUNT.WR",
+        "PerPkg": "1",
+        "PublicDescription": "Counts the number of DRAM Activate commands =
sent on this channel.  Activate commands are issued to open up a page on th=
e DRAM devices so that it can be read or written to with a CAS.  One can ca=
lculate the number of Page Misses by subtracting the number of Page Miss pr=
echarges from the number of Activates.",
+        "UMask": "0x2",
+        "Unit": "iMC"
+    },
     {
         "BriefDescription": "ACT command issued by 2 cycle bypass",
-        "Counter": "0,1,2,3",
         "EventCode": "0xA1",
         "EventName": "UNC_M_BYP_CMDS.ACT",
         "PerPkg": "1",
+        "PublicDescription": "UNC_M_BYP_CMDS.ACT",
         "UMask": "0x1",
         "Unit": "iMC"
     },
     {
         "BriefDescription": "CAS command issued by 2 cycle bypass",
-        "Counter": "0,1,2,3",
         "EventCode": "0xA1",
         "EventName": "UNC_M_BYP_CMDS.CAS",
         "PerPkg": "1",
+        "PublicDescription": "UNC_M_BYP_CMDS.CAS",
         "UMask": "0x2",
         "Unit": "iMC"
     },
     {
         "BriefDescription": "PRE command issued by 2 cycle bypass",
-        "Counter": "0,1,2,3",
         "EventCode": "0xA1",
         "EventName": "UNC_M_BYP_CMDS.PRE",
         "PerPkg": "1",
+        "PublicDescription": "UNC_M_BYP_CMDS.PRE",
         "UMask": "0x4",
         "Unit": "iMC"
     },
     {
-        "BriefDescription": "DRAM RD_CAS and WR_CAS Commands.; All DRAM RD=
_CAS (w/ and w/out auto-pre)",
-        "Counter": "0,1,2,3",
+        "BriefDescription": "DRAM RD_CAS and WR_CAS Commands.; All DRAM WR=
_CAS (w/ and w/out auto-pre)",
         "EventCode": "0x4",
-        "EventName": "UNC_M_CAS_COUNT.RD_REG",
+        "EventName": "UNC_M_CAS_COUNT.ALL",
         "PerPkg": "1",
-        "UMask": "0x1",
+        "PublicDescription": "DRAM RD_CAS and WR_CAS Commands; Counts the =
total number of DRAM CAS commands issued on this channel.",
+        "UMask": "0xf",
         "Unit": "iMC"
     },
     {
-        "BriefDescription": "DRAM RD_CAS and WR_CAS Commands.; Underfill R=
ead Issued",
-        "Counter": "0,1,2,3",
+        "BriefDescription": "DRAM RD_CAS and WR_CAS Commands.; All DRAM Re=
ads (RD_CAS + Underfills)",
         "EventCode": "0x4",
-        "EventName": "UNC_M_CAS_COUNT.RD_UNDERFILL",
+        "EventName": "UNC_M_CAS_COUNT.RD",
         "PerPkg": "1",
-        "UMask": "0x2",
+        "PublicDescription": "DRAM RD_CAS and WR_CAS Commands; Counts the =
total number of DRAM Read CAS commands issued on this channel (including un=
derfills).",
+        "UMask": "0x3",
         "Unit": "iMC"
     },
     {
-        "BriefDescription": "DRAM RD_CAS and WR_CAS Commands.; All DRAM Re=
ads (RD_CAS + Underfills)",
-        "Counter": "0,1,2,3",
+        "BriefDescription": "DRAM RD_CAS and WR_CAS Commands.; All DRAM RD=
_CAS (w/ and w/out auto-pre)",
         "EventCode": "0x4",
-        "EventName": "UNC_M_CAS_COUNT.RD",
+        "EventName": "UNC_M_CAS_COUNT.RD_REG",
         "PerPkg": "1",
-        "UMask": "0x3",
+        "PublicDescription": "DRAM RD_CAS and WR_CAS Commands; Counts the =
total number or DRAM Read CAS commands issued on this channel.  This includ=
es both regular RD CAS commands as well as those with implicit Precharge.  =
AutoPre is only used in systems that are using closed page policy.  We do n=
ot filter based on major mode, as RD_CAS is not issued during WMM (with the=
 exception of underfills).",
+        "UMask": "0x1",
         "Unit": "iMC"
     },
     {
-        "BriefDescription": "read requests to memory controller. Derived f=
rom unc_m_cas_count.rd",
-        "Counter": "0,1,2,3",
+        "BriefDescription": "DRAM RD_CAS and WR_CAS Commands.; Read CAS is=
sued in RMM",
         "EventCode": "0x4",
-        "EventName": "LLC_MISSES.MEM_READ",
+        "EventName": "UNC_M_CAS_COUNT.RD_RMM",
         "PerPkg": "1",
-        "ScaleUnit": "64Bytes",
-        "UMask": "0x3",
+        "UMask": "0x20",
         "Unit": "iMC"
     },
     {
-        "BriefDescription": "DRAM RD_CAS and WR_CAS Commands.; DRAM WR_CAS=
 (w/ and w/out auto-pre) in Write Major Mode",
-        "Counter": "0,1,2,3",
+        "BriefDescription": "DRAM RD_CAS and WR_CAS Commands.; Underfill R=
ead Issued",
         "EventCode": "0x4",
-        "EventName": "UNC_M_CAS_COUNT.WR_WMM",
+        "EventName": "UNC_M_CAS_COUNT.RD_UNDERFILL",
         "PerPkg": "1",
-        "UMask": "0x4",
+        "PublicDescription": "DRAM RD_CAS and WR_CAS Commands; Counts the =
number of underfill reads that are issued by the memory controller.  This w=
ill generally be about the same as the number of partial writes, but may be=
 slightly less because of partials hitting in the WPQ.  While it is possibl=
e for underfills to be issed in both WMM and RMM, this event counts both.",
+        "UMask": "0x2",
         "Unit": "iMC"
     },
     {
-        "BriefDescription": "DRAM RD_CAS and WR_CAS Commands.; DRAM WR_CAS=
 (w/ and w/out auto-pre) in Read Major Mode",
-        "Counter": "0,1,2,3",
+        "BriefDescription": "DRAM RD_CAS and WR_CAS Commands.; Read CAS is=
sued in WMM",
         "EventCode": "0x4",
-        "EventName": "UNC_M_CAS_COUNT.WR_RMM",
+        "EventName": "UNC_M_CAS_COUNT.RD_WMM",
         "PerPkg": "1",
-        "UMask": "0x8",
+        "UMask": "0x10",
         "Unit": "iMC"
     },
     {
         "BriefDescription": "DRAM RD_CAS and WR_CAS Commands.; All DRAM WR=
_CAS (both Modes)",
-        "Counter": "0,1,2,3",
         "EventCode": "0x4",
         "EventName": "UNC_M_CAS_COUNT.WR",
         "PerPkg": "1",
-        "UMask": "0xC",
+        "PublicDescription": "DRAM RD_CAS and WR_CAS Commands; Counts the =
total number of DRAM Write CAS commands issued on this channel.",
+        "UMask": "0xc",
         "Unit": "iMC"
     },
     {
-        "BriefDescription": "write requests to memory controller. Derived =
from unc_m_cas_count.wr",
-        "Counter": "0,1,2,3",
+        "BriefDescription": "DRAM RD_CAS and WR_CAS Commands.; DRAM WR_CAS=
 (w/ and w/out auto-pre) in Read Major Mode",
         "EventCode": "0x4",
-        "EventName": "LLC_MISSES.MEM_WRITE",
+        "EventName": "UNC_M_CAS_COUNT.WR_RMM",
         "PerPkg": "1",
-        "ScaleUnit": "64Bytes",
-        "UMask": "0xC",
+        "PublicDescription": "DRAM RD_CAS and WR_CAS Commands; Counts the =
total number of Opportunistic DRAM Write CAS commands issued on this channe=
l while in Read-Major-Mode.",
+        "UMask": "0x8",
         "Unit": "iMC"
     },
     {
-        "BriefDescription": "DRAM RD_CAS and WR_CAS Commands.; All DRAM WR=
_CAS (w/ and w/out auto-pre)",
-        "Counter": "0,1,2,3",
+        "BriefDescription": "DRAM RD_CAS and WR_CAS Commands.; DRAM WR_CAS=
 (w/ and w/out auto-pre) in Write Major Mode",
         "EventCode": "0x4",
-        "EventName": "UNC_M_CAS_COUNT.ALL",
+        "EventName": "UNC_M_CAS_COUNT.WR_WMM",
         "PerPkg": "1",
-        "UMask": "0xF",
+        "PublicDescription": "DRAM RD_CAS and WR_CAS Commands; Counts the =
total number or DRAM Write CAS commands issued on this channel while in Wri=
te-Major-Mode.",
+        "UMask": "0x4",
         "Unit": "iMC"
     },
     {
-        "BriefDescription": "DRAM RD_CAS and WR_CAS Commands.; Read CAS is=
sued in WMM",
-        "Counter": "0,1,2,3",
-        "EventCode": "0x4",
-        "EventName": "UNC_M_CAS_COUNT.RD_WMM",
+        "BriefDescription": "Clockticks in the Memory Controller using a d=
edicated 48-bit Fixed Counter",
+        "EventCode": "0xff",
+        "EventName": "UNC_M_CLOCKTICKS",
         "PerPkg": "1",
-        "UMask": "0x10",
         "Unit": "iMC"
     },
     {
-        "BriefDescription": "DRAM RD_CAS and WR_CAS Commands.; Read CAS is=
sued in RMM",
-        "Counter": "0,1,2,3",
-        "EventCode": "0x4",
-        "EventName": "UNC_M_CAS_COUNT.RD_RMM",
+        "BriefDescription": "Clockticks in the Memory Controller using one=
 of the programmable counters",
+        "EventName": "UNC_M_CLOCKTICKS_P",
         "PerPkg": "1",
-        "UMask": "0x20",
         "Unit": "iMC"
     },
     {
         "BriefDescription": "This event is deprecated. Refer to new event =
UNC_M_CLOCKTICKS_P",
-        "Counter": "0,1,2,3",
         "EventName": "UNC_M_DCLOCKTICKS",
         "PerPkg": "1",
         "Unit": "iMC"
     },
     {
         "BriefDescription": "DRAM Precharge All Commands",
-        "Counter": "0,1,2,3",
         "EventCode": "0x6",
         "EventName": "UNC_M_DRAM_PRE_ALL",
         "PerPkg": "1",
+        "PublicDescription": "Counts the number of times that the precharg=
e all command was sent.",
         "Unit": "iMC"
     },
     {
         "BriefDescription": "Number of DRAM Refreshes Issued",
-        "Counter": "0,1,2,3",
         "EventCode": "0x5",
-        "EventName": "UNC_M_DRAM_REFRESH.PANIC",
+        "EventName": "UNC_M_DRAM_REFRESH.HIGH",
         "PerPkg": "1",
-        "UMask": "0x2",
+        "PublicDescription": "Counts the number of refreshes issued.",
+        "UMask": "0x4",
         "Unit": "iMC"
     },
     {
         "BriefDescription": "Number of DRAM Refreshes Issued",
-        "Counter": "0,1,2,3",
         "EventCode": "0x5",
-        "EventName": "UNC_M_DRAM_REFRESH.HIGH",
+        "EventName": "UNC_M_DRAM_REFRESH.PANIC",
         "PerPkg": "1",
-        "UMask": "0x4",
+        "PublicDescription": "Counts the number of refreshes issued.",
+        "UMask": "0x2",
         "Unit": "iMC"
     },
     {
         "BriefDescription": "ECC Correctable Errors",
-        "Counter": "0,1,2,3",
         "EventCode": "0x9",
         "EventName": "UNC_M_ECC_CORRECTABLE_ERRORS",
         "PerPkg": "1",
+        "PublicDescription": "Counts the number of ECC errors detected and=
 corrected by the iMC on this channel.  This counter is only useful with EC=
C DRAM devices.  This count will increment one time for each correction reg=
ardless of the number of bits corrected.  The iMC can correct up to 4 bit e=
rrors in independent channel mode and 8 bit erros in lockstep mode.",
         "Unit": "iMC"
     },
     {
-        "BriefDescription": "Cycles in a Major Mode; Read Major Mode",
-        "Counter": "0,1,2,3",
+        "BriefDescription": "Cycles in a Major Mode; Isoch Major Mode",
         "EventCode": "0x7",
-        "EventName": "UNC_M_MAJOR_MODES.READ",
+        "EventName": "UNC_M_MAJOR_MODES.ISOCH",
         "PerPkg": "1",
-        "UMask": "0x1",
+        "PublicDescription": "Counts the total number of cycles spent in a=
 major mode (selected by a filter) on the given channel.   Major modea are =
channel-wide, and not a per-rank (or dimm or bank) mode.; We group these tw=
o modes together so that we can use four counters to track each of the majo=
r modes at one time.  These major modes are used whenever there is an ISOCH=
 txn in the memory controller.  In these mode, only ISOCH transactions are =
processed.",
+        "UMask": "0x8",
         "Unit": "iMC"
     },
     {
-        "BriefDescription": "Cycles in a Major Mode; Write Major Mode",
-        "Counter": "0,1,2,3",
+        "BriefDescription": "Cycles in a Major Mode; Partial Major Mode",
         "EventCode": "0x7",
-        "EventName": "UNC_M_MAJOR_MODES.WRITE",
+        "EventName": "UNC_M_MAJOR_MODES.PARTIAL",
         "PerPkg": "1",
-        "UMask": "0x2",
+        "PublicDescription": "Counts the total number of cycles spent in a=
 major mode (selected by a filter) on the given channel.   Major modea are =
channel-wide, and not a per-rank (or dimm or bank) mode.; This major mode i=
s used to drain starved underfill reads.  Regular reads and writes are bloc=
ked and only underfill reads will be processed.",
+        "UMask": "0x4",
         "Unit": "iMC"
     },
     {
-        "BriefDescription": "Cycles in a Major Mode; Partial Major Mode",
-        "Counter": "0,1,2,3",
+        "BriefDescription": "Cycles in a Major Mode; Read Major Mode",
         "EventCode": "0x7",
-        "EventName": "UNC_M_MAJOR_MODES.PARTIAL",
+        "EventName": "UNC_M_MAJOR_MODES.READ",
         "PerPkg": "1",
-        "UMask": "0x4",
+        "PublicDescription": "Counts the total number of cycles spent in a=
 major mode (selected by a filter) on the given channel.   Major modea are =
channel-wide, and not a per-rank (or dimm or bank) mode.; Read Major Mode i=
s the default mode for the iMC, as reads are generally more critical to for=
ward progress than writes.",
+        "UMask": "0x1",
         "Unit": "iMC"
     },
     {
-        "BriefDescription": "Cycles in a Major Mode; Isoch Major Mode",
-        "Counter": "0,1,2,3",
+        "BriefDescription": "Cycles in a Major Mode; Write Major Mode",
         "EventCode": "0x7",
-        "EventName": "UNC_M_MAJOR_MODES.ISOCH",
+        "EventName": "UNC_M_MAJOR_MODES.WRITE",
         "PerPkg": "1",
-        "UMask": "0x8",
+        "PublicDescription": "Counts the total number of cycles spent in a=
 major mode (selected by a filter) on the given channel.   Major modea are =
channel-wide, and not a per-rank (or dimm or bank) mode.; This mode is trig=
gered when the WPQ hits high occupancy and causes writes to be higher prior=
ity than reads.  This can cause blips in the available read bandwidth in th=
e system and temporarily increase read latencies in order to achieve better=
 bus utilizations and higher bandwidth.",
+        "UMask": "0x2",
         "Unit": "iMC"
     },
     {
         "BriefDescription": "Channel DLLOFF Cycles",
-        "Counter": "0,1,2,3",
         "EventCode": "0x84",
         "EventName": "UNC_M_POWER_CHANNEL_DLLOFF",
         "PerPkg": "1",
+        "PublicDescription": "Number of cycles when all the ranks in the c=
hannel are in CKE Slow (DLLOFF) mode.",
         "Unit": "iMC"
     },
     {
         "BriefDescription": "Channel PPD Cycles",
-        "Counter": "0,1,2,3",
         "EventCode": "0x85",
         "EventName": "UNC_M_POWER_CHANNEL_PPD",
         "PerPkg": "1",
+        "PublicDescription": "Number of cycles when all the ranks in the c=
hannel are in PPD mode.  If IBT=3Doff is enabled, then this can be used to =
count those cycles.  If it is not enabled, then this can count the number o=
f cycles when that could have been taken advantage of.",
         "Unit": "iMC"
     },
     {
         "BriefDescription": "CKE_ON_CYCLES by Rank; DIMM ID",
-        "Counter": "0,1,2,3",
         "EventCode": "0x83",
         "EventName": "UNC_M_POWER_CKE_CYCLES.RANK0",
         "PerPkg": "1",
+        "PublicDescription": "Number of cycles spent in CKE ON mode.  The =
filter allows you to select a rank to monitor.  If multiple ranks are in CK=
E ON mode at one time, the counter will ONLY increment by one rather than d=
oing accumulation.  Multiple counters will need to be used to track multipl=
e ranks simultaneously.  There is no distinction between the different CKE =
modes (APD, PPDS, PPDF).  This can be determined based on the system progra=
mming.  These events should commonly be used with Invert to get the number =
of cycles in power saving mode.  Edge Detect is also useful here.  Make sur=
e that you do NOT use Invert with Edge Detect (this just confuses the syste=
m and is not necessary).",
         "UMask": "0x1",
         "Unit": "iMC"
     },
     {
         "BriefDescription": "CKE_ON_CYCLES by Rank; DIMM ID",
-        "Counter": "0,1,2,3",
         "EventCode": "0x83",
         "EventName": "UNC_M_POWER_CKE_CYCLES.RANK1",
         "PerPkg": "1",
+        "PublicDescription": "Number of cycles spent in CKE ON mode.  The =
filter allows you to select a rank to monitor.  If multiple ranks are in CK=
E ON mode at one time, the counter will ONLY increment by one rather than d=
oing accumulation.  Multiple counters will need to be used to track multipl=
e ranks simultaneously.  There is no distinction between the different CKE =
modes (APD, PPDS, PPDF).  This can be determined based on the system progra=
mming.  These events should commonly be used with Invert to get the number =
of cycles in power saving mode.  Edge Detect is also useful here.  Make sur=
e that you do NOT use Invert with Edge Detect (this just confuses the syste=
m and is not necessary).",
         "UMask": "0x2",
         "Unit": "iMC"
     },
     {
         "BriefDescription": "CKE_ON_CYCLES by Rank; DIMM ID",
-        "Counter": "0,1,2,3",
         "EventCode": "0x83",
         "EventName": "UNC_M_POWER_CKE_CYCLES.RANK2",
         "PerPkg": "1",
+        "PublicDescription": "Number of cycles spent in CKE ON mode.  The =
filter allows you to select a rank to monitor.  If multiple ranks are in CK=
E ON mode at one time, the counter will ONLY increment by one rather than d=
oing accumulation.  Multiple counters will need to be used to track multipl=
e ranks simultaneously.  There is no distinction between the different CKE =
modes (APD, PPDS, PPDF).  This can be determined based on the system progra=
mming.  These events should commonly be used with Invert to get the number =
of cycles in power saving mode.  Edge Detect is also useful here.  Make sur=
e that you do NOT use Invert with Edge Detect (this just confuses the syste=
m and is not necessary).",
         "UMask": "0x4",
         "Unit": "iMC"
     },
     {
         "BriefDescription": "CKE_ON_CYCLES by Rank; DIMM ID",
-        "Counter": "0,1,2,3",
         "EventCode": "0x83",
         "EventName": "UNC_M_POWER_CKE_CYCLES.RANK3",
         "PerPkg": "1",
+        "PublicDescription": "Number of cycles spent in CKE ON mode.  The =
filter allows you to select a rank to monitor.  If multiple ranks are in CK=
E ON mode at one time, the counter will ONLY increment by one rather than d=
oing accumulation.  Multiple counters will need to be used to track multipl=
e ranks simultaneously.  There is no distinction between the different CKE =
modes (APD, PPDS, PPDF).  This can be determined based on the system progra=
mming.  These events should commonly be used with Invert to get the number =
of cycles in power saving mode.  Edge Detect is also useful here.  Make sur=
e that you do NOT use Invert with Edge Detect (this just confuses the syste=
m and is not necessary).",
         "UMask": "0x8",
         "Unit": "iMC"
     },
     {
         "BriefDescription": "CKE_ON_CYCLES by Rank; DIMM ID",
-        "Counter": "0,1,2,3",
         "EventCode": "0x83",
         "EventName": "UNC_M_POWER_CKE_CYCLES.RANK4",
         "PerPkg": "1",
+        "PublicDescription": "Number of cycles spent in CKE ON mode.  The =
filter allows you to select a rank to monitor.  If multiple ranks are in CK=
E ON mode at one time, the counter will ONLY increment by one rather than d=
oing accumulation.  Multiple counters will need to be used to track multipl=
e ranks simultaneously.  There is no distinction between the different CKE =
modes (APD, PPDS, PPDF).  This can be determined based on the system progra=
mming.  These events should commonly be used with Invert to get the number =
of cycles in power saving mode.  Edge Detect is also useful here.  Make sur=
e that you do NOT use Invert with Edge Detect (this just confuses the syste=
m and is not necessary).",
         "UMask": "0x10",
         "Unit": "iMC"
     },
     {
         "BriefDescription": "CKE_ON_CYCLES by Rank; DIMM ID",
-        "Counter": "0,1,2,3",
         "EventCode": "0x83",
         "EventName": "UNC_M_POWER_CKE_CYCLES.RANK5",
         "PerPkg": "1",
+        "PublicDescription": "Number of cycles spent in CKE ON mode.  The =
filter allows you to select a rank to monitor.  If multiple ranks are in CK=
E ON mode at one time, the counter will ONLY increment by one rather than d=
oing accumulation.  Multiple counters will need to be used to track multipl=
e ranks simultaneously.  There is no distinction between the different CKE =
modes (APD, PPDS, PPDF).  This can be determined based on the system progra=
mming.  These events should commonly be used with Invert to get the number =
of cycles in power saving mode.  Edge Detect is also useful here.  Make sur=
e that you do NOT use Invert with Edge Detect (this just confuses the syste=
m and is not necessary).",
         "UMask": "0x20",
         "Unit": "iMC"
     },
     {
         "BriefDescription": "CKE_ON_CYCLES by Rank; DIMM ID",
-        "Counter": "0,1,2,3",
         "EventCode": "0x83",
         "EventName": "UNC_M_POWER_CKE_CYCLES.RANK6",
         "PerPkg": "1",
+        "PublicDescription": "Number of cycles spent in CKE ON mode.  The =
filter allows you to select a rank to monitor.  If multiple ranks are in CK=
E ON mode at one time, the counter will ONLY increment by one rather than d=
oing accumulation.  Multiple counters will need to be used to track multipl=
e ranks simultaneously.  There is no distinction between the different CKE =
modes (APD, PPDS, PPDF).  This can be determined based on the system progra=
mming.  These events should commonly be used with Invert to get the number =
of cycles in power saving mode.  Edge Detect is also useful here.  Make sur=
e that you do NOT use Invert with Edge Detect (this just confuses the syste=
m and is not necessary).",
         "UMask": "0x40",
         "Unit": "iMC"
     },
     {
         "BriefDescription": "CKE_ON_CYCLES by Rank; DIMM ID",
-        "Counter": "0,1,2,3",
         "EventCode": "0x83",
         "EventName": "UNC_M_POWER_CKE_CYCLES.RANK7",
         "PerPkg": "1",
+        "PublicDescription": "Number of cycles spent in CKE ON mode.  The =
filter allows you to select a rank to monitor.  If multiple ranks are in CK=
E ON mode at one time, the counter will ONLY increment by one rather than d=
oing accumulation.  Multiple counters will need to be used to track multipl=
e ranks simultaneously.  There is no distinction between the different CKE =
modes (APD, PPDS, PPDF).  This can be determined based on the system progra=
mming.  These events should commonly be used with Invert to get the number =
of cycles in power saving mode.  Edge Detect is also useful here.  Make sur=
e that you do NOT use Invert with Edge Detect (this just confuses the syste=
m and is not necessary).",
         "UMask": "0x80",
         "Unit": "iMC"
     },
     {
         "BriefDescription": "Critical Throttle Cycles",
-        "Counter": "0,1,2,3",
         "EventCode": "0x86",
         "EventName": "UNC_M_POWER_CRITICAL_THROTTLE_CYCLES",
         "PerPkg": "1",
+        "PublicDescription": "Counts the number of cycles when the iMC is =
in critical thermal throttling.  When this happens, all traffic is blocked.=
  This should be rare unless something bad is going on in the platform.  Th=
ere is no filtering by rank for this event.",
         "Unit": "iMC"
     },
     {
         "BriefDescription": "UNC_M_POWER_PCU_THROTTLING",
-        "Counter": "0,1,2,3",
         "EventCode": "0x42",
         "EventName": "UNC_M_POWER_PCU_THROTTLING",
         "PerPkg": "1",
@@ -337,2569 +346,2554 @@
     },
     {
         "BriefDescription": "Clock-Enabled Self-Refresh",
-        "Counter": "0,1,2,3",
         "EventCode": "0x43",
         "EventName": "UNC_M_POWER_SELF_REFRESH",
         "PerPkg": "1",
+        "PublicDescription": "Counts the number of cycles when the iMC is =
in self-refresh and the iMC still has a clock.  This happens in some packag=
e C-states.  For example, the PCU may ask the iMC to enter self-refresh eve=
n though some of the cores are still processing.  One use of this is for Mo=
nroe technology.  Self-refresh is required during package C3 and C6, but th=
ere is no clock in the iMC at this time, so it is not possible to count the=
se cases.",
         "Unit": "iMC"
     },
     {
         "BriefDescription": "Throttle Cycles for Rank 0; DIMM ID",
-        "Counter": "0,1,2,3",
         "EventCode": "0x41",
         "EventName": "UNC_M_POWER_THROTTLE_CYCLES.RANK0",
         "PerPkg": "1",
+        "PublicDescription": "Counts the number of cycles while the iMC is=
 being throttled by either thermal constraints or by the PCU throttling.  I=
t is not possible to distinguish between the two.  This can be filtered by =
rank.  If multiple ranks are selected and are being throttled at the same t=
ime, the counter will only increment by 1.; Thermal throttling is performed=
 per DIMM.  We support 3 DIMMs per channel.  This ID allows us to filter by=
 ID.",
         "UMask": "0x1",
         "Unit": "iMC"
     },
     {
         "BriefDescription": "Throttle Cycles for Rank 0; DIMM ID",
-        "Counter": "0,1,2,3",
         "EventCode": "0x41",
         "EventName": "UNC_M_POWER_THROTTLE_CYCLES.RANK1",
         "PerPkg": "1",
+        "PublicDescription": "Counts the number of cycles while the iMC is=
 being throttled by either thermal constraints or by the PCU throttling.  I=
t is not possible to distinguish between the two.  This can be filtered by =
rank.  If multiple ranks are selected and are being throttled at the same t=
ime, the counter will only increment by 1.",
         "UMask": "0x2",
         "Unit": "iMC"
     },
     {
         "BriefDescription": "Throttle Cycles for Rank 0; DIMM ID",
-        "Counter": "0,1,2,3",
         "EventCode": "0x41",
         "EventName": "UNC_M_POWER_THROTTLE_CYCLES.RANK2",
         "PerPkg": "1",
+        "PublicDescription": "Counts the number of cycles while the iMC is=
 being throttled by either thermal constraints or by the PCU throttling.  I=
t is not possible to distinguish between the two.  This can be filtered by =
rank.  If multiple ranks are selected and are being throttled at the same t=
ime, the counter will only increment by 1.",
         "UMask": "0x4",
         "Unit": "iMC"
     },
     {
         "BriefDescription": "Throttle Cycles for Rank 0; DIMM ID",
-        "Counter": "0,1,2,3",
         "EventCode": "0x41",
         "EventName": "UNC_M_POWER_THROTTLE_CYCLES.RANK3",
         "PerPkg": "1",
+        "PublicDescription": "Counts the number of cycles while the iMC is=
 being throttled by either thermal constraints or by the PCU throttling.  I=
t is not possible to distinguish between the two.  This can be filtered by =
rank.  If multiple ranks are selected and are being throttled at the same t=
ime, the counter will only increment by 1.",
         "UMask": "0x8",
         "Unit": "iMC"
     },
     {
         "BriefDescription": "Throttle Cycles for Rank 0; DIMM ID",
-        "Counter": "0,1,2,3",
         "EventCode": "0x41",
         "EventName": "UNC_M_POWER_THROTTLE_CYCLES.RANK4",
         "PerPkg": "1",
+        "PublicDescription": "Counts the number of cycles while the iMC is=
 being throttled by either thermal constraints or by the PCU throttling.  I=
t is not possible to distinguish between the two.  This can be filtered by =
rank.  If multiple ranks are selected and are being throttled at the same t=
ime, the counter will only increment by 1.",
         "UMask": "0x10",
         "Unit": "iMC"
     },
     {
         "BriefDescription": "Throttle Cycles for Rank 0; DIMM ID",
-        "Counter": "0,1,2,3",
         "EventCode": "0x41",
         "EventName": "UNC_M_POWER_THROTTLE_CYCLES.RANK5",
         "PerPkg": "1",
+        "PublicDescription": "Counts the number of cycles while the iMC is=
 being throttled by either thermal constraints or by the PCU throttling.  I=
t is not possible to distinguish between the two.  This can be filtered by =
rank.  If multiple ranks are selected and are being throttled at the same t=
ime, the counter will only increment by 1.",
         "UMask": "0x20",
         "Unit": "iMC"
     },
     {
         "BriefDescription": "Throttle Cycles for Rank 0; DIMM ID",
-        "Counter": "0,1,2,3",
         "EventCode": "0x41",
         "EventName": "UNC_M_POWER_THROTTLE_CYCLES.RANK6",
         "PerPkg": "1",
+        "PublicDescription": "Counts the number of cycles while the iMC is=
 being throttled by either thermal constraints or by the PCU throttling.  I=
t is not possible to distinguish between the two.  This can be filtered by =
rank.  If multiple ranks are selected and are being throttled at the same t=
ime, the counter will only increment by 1.",
         "UMask": "0x40",
         "Unit": "iMC"
     },
     {
         "BriefDescription": "Throttle Cycles for Rank 0; DIMM ID",
-        "Counter": "0,1,2,3",
         "EventCode": "0x41",
         "EventName": "UNC_M_POWER_THROTTLE_CYCLES.RANK7",
         "PerPkg": "1",
+        "PublicDescription": "Counts the number of cycles while the iMC is=
 being throttled by either thermal constraints or by the PCU throttling.  I=
t is not possible to distinguish between the two.  This can be filtered by =
rank.  If multiple ranks are selected and are being throttled at the same t=
ime, the counter will only increment by 1.",
         "UMask": "0x80",
         "Unit": "iMC"
     },
     {
         "BriefDescription": "Read Preemption Count; Read over Read Preempt=
ion",
-        "Counter": "0,1,2,3",
         "EventCode": "0x8",
         "EventName": "UNC_M_PREEMPTION.RD_PREEMPT_RD",
         "PerPkg": "1",
+        "PublicDescription": "Counts the number of times a read in the iMC=
 preempts another read or write.  Generally reads to an open page are issue=
d ahead of requests to closed pages.  This improves the page hit rate of th=
e system.  However, high priority requests can cause pages of active reques=
ts to be closed in order to get them out.  This will reduce the latency of =
the high-priority request at the expense of lower bandwidth and increased o=
verall average latency.; Filter for when a read preempts another read.",
         "UMask": "0x1",
         "Unit": "iMC"
     },
     {
         "BriefDescription": "Read Preemption Count; Read over Write Preemp=
tion",
-        "Counter": "0,1,2,3",
         "EventCode": "0x8",
         "EventName": "UNC_M_PREEMPTION.RD_PREEMPT_WR",
         "PerPkg": "1",
+        "PublicDescription": "Counts the number of times a read in the iMC=
 preempts another read or write.  Generally reads to an open page are issue=
d ahead of requests to closed pages.  This improves the page hit rate of th=
e system.  However, high priority requests can cause pages of active reques=
ts to be closed in order to get them out.  This will reduce the latency of =
the high-priority request at the expense of lower bandwidth and increased o=
verall average latency.; Filter for when a read preempts a write.",
         "UMask": "0x2",
         "Unit": "iMC"
     },
     {
-        "BriefDescription": "DRAM Precharge commands.; Precharges due to p=
age miss",
-        "Counter": "0,1,2,3",
+        "BriefDescription": "DRAM Precharge commands.; Precharge due to by=
pass",
         "EventCode": "0x2",
-        "EventName": "UNC_M_PRE_COUNT.PAGE_MISS",
+        "EventName": "UNC_M_PRE_COUNT.BYP",
         "PerPkg": "1",
-        "UMask": "0x1",
+        "PublicDescription": "Counts the number of DRAM Precharge commands=
 sent on this channel.",
+        "UMask": "0x10",
         "Unit": "iMC"
     },
     {
         "BriefDescription": "DRAM Precharge commands.; Precharge due to ti=
mer expiration",
-        "Counter": "0,1,2,3",
         "EventCode": "0x2",
         "EventName": "UNC_M_PRE_COUNT.PAGE_CLOSE",
         "PerPkg": "1",
+        "PublicDescription": "Counts the number of DRAM Precharge commands=
 sent on this channel.; Counts the number of DRAM Precharge commands sent o=
n this channel as a result of the page close counter expiring.  This does n=
ot include implicit precharge commands sent in auto-precharge mode.",
         "UMask": "0x2",
         "Unit": "iMC"
     },
+    {
+        "BriefDescription": "DRAM Precharge commands.; Precharges due to p=
age miss",
+        "EventCode": "0x2",
+        "EventName": "UNC_M_PRE_COUNT.PAGE_MISS",
+        "PerPkg": "1",
+        "PublicDescription": "Counts the number of DRAM Precharge commands=
 sent on this channel.; Counts the number of DRAM Precharge commands sent o=
n this channel as a result of page misses.  This does not include explicit =
precharge commands sent with CAS commands in Auto-Precharge mode.  This doe=
s not include PRE commands sent as a result of the page close counter expir=
ation.",
+        "UMask": "0x1",
+        "Unit": "iMC"
+    },
     {
         "BriefDescription": "DRAM Precharge commands.; Precharge due to re=
ad",
-        "Counter": "0,1,2,3",
         "EventCode": "0x2",
         "EventName": "UNC_M_PRE_COUNT.RD",
         "PerPkg": "1",
+        "PublicDescription": "Counts the number of DRAM Precharge commands=
 sent on this channel.",
         "UMask": "0x4",
         "Unit": "iMC"
     },
     {
         "BriefDescription": "DRAM Precharge commands.; Precharge due to wr=
ite",
-        "Counter": "0,1,2,3",
         "EventCode": "0x2",
         "EventName": "UNC_M_PRE_COUNT.WR",
         "PerPkg": "1",
+        "PublicDescription": "Counts the number of DRAM Precharge commands=
 sent on this channel.",
         "UMask": "0x8",
         "Unit": "iMC"
     },
     {
-        "BriefDescription": "DRAM Precharge commands.; Precharge due to by=
pass",
-        "Counter": "0,1,2,3",
-        "EventCode": "0x2",
-        "EventName": "UNC_M_PRE_COUNT.BYP",
+        "BriefDescription": "Read CAS issued with HIGH priority",
+        "EventCode": "0xA0",
+        "EventName": "UNC_M_RD_CAS_PRIO.HIGH",
         "PerPkg": "1",
-        "UMask": "0x10",
+        "PublicDescription": "UNC_M_RD_CAS_PRIO.HIGH",
+        "UMask": "0x4",
         "Unit": "iMC"
     },
     {
         "BriefDescription": "Read CAS issued with LOW priority",
-        "Counter": "0,1,2,3",
         "EventCode": "0xA0",
         "EventName": "UNC_M_RD_CAS_PRIO.LOW",
         "PerPkg": "1",
+        "PublicDescription": "UNC_M_RD_CAS_PRIO.LOW",
         "UMask": "0x1",
         "Unit": "iMC"
     },
     {
         "BriefDescription": "Read CAS issued with MEDIUM priority",
-        "Counter": "0,1,2,3",
         "EventCode": "0xA0",
         "EventName": "UNC_M_RD_CAS_PRIO.MED",
         "PerPkg": "1",
+        "PublicDescription": "UNC_M_RD_CAS_PRIO.MED",
         "UMask": "0x2",
         "Unit": "iMC"
     },
-    {
-        "BriefDescription": "Read CAS issued with HIGH priority",
-        "Counter": "0,1,2,3",
-        "EventCode": "0xA0",
-        "EventName": "UNC_M_RD_CAS_PRIO.HIGH",
-        "PerPkg": "1",
-        "UMask": "0x4",
-        "Unit": "iMC"
-    },
     {
         "BriefDescription": "Read CAS issued with PANIC NON ISOCH priority=
 (starved)",
-        "Counter": "0,1,2,3",
         "EventCode": "0xA0",
         "EventName": "UNC_M_RD_CAS_PRIO.PANIC",
         "PerPkg": "1",
+        "PublicDescription": "UNC_M_RD_CAS_PRIO.PANIC",
         "UMask": "0x8",
         "Unit": "iMC"
     },
     {
-        "BriefDescription": "RD_CAS Access to Rank 0; Bank 1",
-        "Counter": "0,1,2,3",
+        "BriefDescription": "RD_CAS Access to Rank 0; All Banks",
         "EventCode": "0xB0",
-        "EventName": "UNC_M_RD_CAS_RANK0.BANK1",
+        "EventName": "UNC_M_RD_CAS_RANK0.ALLBANKS",
         "PerPkg": "1",
-        "UMask": "0x1",
+        "PublicDescription": "UNC_M_RD_CAS_RANK0.ALLBANKS",
+        "UMask": "0x10",
         "Unit": "iMC"
     },
     {
-        "BriefDescription": "RD_CAS Access to Rank 0; Bank 2",
-        "Counter": "0,1,2,3",
+        "BriefDescription": "RD_CAS Access to Rank 0; Bank 0",
         "EventCode": "0xB0",
-        "EventName": "UNC_M_RD_CAS_RANK0.BANK2",
+        "EventName": "UNC_M_RD_CAS_RANK0.BANK0",
         "PerPkg": "1",
-        "UMask": "0x2",
+        "PublicDescription": "UNC_M_RD_CAS_RANK0.BANK0",
         "Unit": "iMC"
     },
     {
-        "BriefDescription": "RD_CAS Access to Rank 0; Bank 4",
-        "Counter": "0,1,2,3",
+        "BriefDescription": "RD_CAS Access to Rank 0; Bank 1",
         "EventCode": "0xB0",
-        "EventName": "UNC_M_RD_CAS_RANK0.BANK4",
+        "EventName": "UNC_M_RD_CAS_RANK0.BANK1",
         "PerPkg": "1",
-        "UMask": "0x4",
+        "PublicDescription": "UNC_M_RD_CAS_RANK0.BANK1",
+        "UMask": "0x1",
         "Unit": "iMC"
     },
     {
-        "BriefDescription": "RD_CAS Access to Rank 0; Bank 8",
-        "Counter": "0,1,2,3",
+        "BriefDescription": "RD_CAS Access to Rank 0; Bank 10",
         "EventCode": "0xB0",
-        "EventName": "UNC_M_RD_CAS_RANK0.BANK8",
+        "EventName": "UNC_M_RD_CAS_RANK0.BANK10",
         "PerPkg": "1",
-        "UMask": "0x8",
+        "PublicDescription": "UNC_M_RD_CAS_RANK0.BANK10",
+        "UMask": "0xa",
         "Unit": "iMC"
     },
     {
-        "BriefDescription": "RD_CAS Access to Rank 0; All Banks",
-        "Counter": "0,1,2,3",
+        "BriefDescription": "RD_CAS Access to Rank 0; Bank 11",
         "EventCode": "0xB0",
-        "EventName": "UNC_M_RD_CAS_RANK0.ALLBANKS",
+        "EventName": "UNC_M_RD_CAS_RANK0.BANK11",
         "PerPkg": "1",
-        "UMask": "0x10",
+        "PublicDescription": "UNC_M_RD_CAS_RANK0.BANK11",
+        "UMask": "0xb",
         "Unit": "iMC"
     },
     {
-        "BriefDescription": "RD_CAS Access to Rank 0; Bank 0",
-        "Counter": "0,1,2,3",
+        "BriefDescription": "RD_CAS Access to Rank 0; Bank 12",
         "EventCode": "0xB0",
-        "EventName": "UNC_M_RD_CAS_RANK0.BANK0",
+        "EventName": "UNC_M_RD_CAS_RANK0.BANK12",
         "PerPkg": "1",
+        "PublicDescription": "UNC_M_RD_CAS_RANK0.BANK12",
+        "UMask": "0xc",
         "Unit": "iMC"
     },
     {
-        "BriefDescription": "RD_CAS Access to Rank 0; Bank 3",
-        "Counter": "0,1,2,3",
+        "BriefDescription": "RD_CAS Access to Rank 0; Bank 13",
         "EventCode": "0xB0",
-        "EventName": "UNC_M_RD_CAS_RANK0.BANK3",
+        "EventName": "UNC_M_RD_CAS_RANK0.BANK13",
         "PerPkg": "1",
-        "UMask": "0x3",
+        "PublicDescription": "UNC_M_RD_CAS_RANK0.BANK13",
+        "UMask": "0xd",
         "Unit": "iMC"
     },
     {
-        "BriefDescription": "RD_CAS Access to Rank 0; Bank 5",
-        "Counter": "0,1,2,3",
+        "BriefDescription": "RD_CAS Access to Rank 0; Bank 14",
         "EventCode": "0xB0",
-        "EventName": "UNC_M_RD_CAS_RANK0.BANK5",
+        "EventName": "UNC_M_RD_CAS_RANK0.BANK14",
         "PerPkg": "1",
-        "UMask": "0x5",
+        "PublicDescription": "UNC_M_RD_CAS_RANK0.BANK14",
+        "UMask": "0xe",
         "Unit": "iMC"
     },
     {
-        "BriefDescription": "RD_CAS Access to Rank 0; Bank 6",
-        "Counter": "0,1,2,3",
+        "BriefDescription": "RD_CAS Access to Rank 0; Bank 15",
         "EventCode": "0xB0",
-        "EventName": "UNC_M_RD_CAS_RANK0.BANK6",
+        "EventName": "UNC_M_RD_CAS_RANK0.BANK15",
         "PerPkg": "1",
-        "UMask": "0x6",
+        "PublicDescription": "UNC_M_RD_CAS_RANK0.BANK15",
+        "UMask": "0xf",
         "Unit": "iMC"
     },
     {
-        "BriefDescription": "RD_CAS Access to Rank 0; Bank 7",
-        "Counter": "0,1,2,3",
+        "BriefDescription": "RD_CAS Access to Rank 0; Bank 2",
         "EventCode": "0xB0",
-        "EventName": "UNC_M_RD_CAS_RANK0.BANK7",
+        "EventName": "UNC_M_RD_CAS_RANK0.BANK2",
         "PerPkg": "1",
-        "UMask": "0x7",
+        "PublicDescription": "UNC_M_RD_CAS_RANK0.BANK2",
+        "UMask": "0x2",
         "Unit": "iMC"
     },
     {
-        "BriefDescription": "RD_CAS Access to Rank 0; Bank 9",
-        "Counter": "0,1,2,3",
+        "BriefDescription": "RD_CAS Access to Rank 0; Bank 3",
         "EventCode": "0xB0",
-        "EventName": "UNC_M_RD_CAS_RANK0.BANK9",
+        "EventName": "UNC_M_RD_CAS_RANK0.BANK3",
         "PerPkg": "1",
-        "UMask": "0x9",
+        "PublicDescription": "UNC_M_RD_CAS_RANK0.BANK3",
+        "UMask": "0x3",
         "Unit": "iMC"
     },
     {
-        "BriefDescription": "RD_CAS Access to Rank 0; Bank 10",
-        "Counter": "0,1,2,3",
+        "BriefDescription": "RD_CAS Access to Rank 0; Bank 4",
         "EventCode": "0xB0",
-        "EventName": "UNC_M_RD_CAS_RANK0.BANK10",
+        "EventName": "UNC_M_RD_CAS_RANK0.BANK4",
         "PerPkg": "1",
-        "UMask": "0xA",
+        "PublicDescription": "UNC_M_RD_CAS_RANK0.BANK4",
+        "UMask": "0x4",
         "Unit": "iMC"
     },
     {
-        "BriefDescription": "RD_CAS Access to Rank 0; Bank 11",
-        "Counter": "0,1,2,3",
+        "BriefDescription": "RD_CAS Access to Rank 0; Bank 5",
         "EventCode": "0xB0",
-        "EventName": "UNC_M_RD_CAS_RANK0.BANK11",
+        "EventName": "UNC_M_RD_CAS_RANK0.BANK5",
         "PerPkg": "1",
-        "UMask": "0xB",
+        "PublicDescription": "UNC_M_RD_CAS_RANK0.BANK5",
+        "UMask": "0x5",
         "Unit": "iMC"
     },
     {
-        "BriefDescription": "RD_CAS Access to Rank 0; Bank 12",
-        "Counter": "0,1,2,3",
+        "BriefDescription": "RD_CAS Access to Rank 0; Bank 6",
         "EventCode": "0xB0",
-        "EventName": "UNC_M_RD_CAS_RANK0.BANK12",
+        "EventName": "UNC_M_RD_CAS_RANK0.BANK6",
         "PerPkg": "1",
-        "UMask": "0xC",
+        "PublicDescription": "UNC_M_RD_CAS_RANK0.BANK6",
+        "UMask": "0x6",
         "Unit": "iMC"
     },
     {
-        "BriefDescription": "RD_CAS Access to Rank 0; Bank 13",
-        "Counter": "0,1,2,3",
+        "BriefDescription": "RD_CAS Access to Rank 0; Bank 7",
         "EventCode": "0xB0",
-        "EventName": "UNC_M_RD_CAS_RANK0.BANK13",
+        "EventName": "UNC_M_RD_CAS_RANK0.BANK7",
         "PerPkg": "1",
-        "UMask": "0xD",
+        "PublicDescription": "UNC_M_RD_CAS_RANK0.BANK7",
+        "UMask": "0x7",
         "Unit": "iMC"
     },
     {
-        "BriefDescription": "RD_CAS Access to Rank 0; Bank 14",
-        "Counter": "0,1,2,3",
+        "BriefDescription": "RD_CAS Access to Rank 0; Bank 8",
         "EventCode": "0xB0",
-        "EventName": "UNC_M_RD_CAS_RANK0.BANK14",
+        "EventName": "UNC_M_RD_CAS_RANK0.BANK8",
         "PerPkg": "1",
-        "UMask": "0xE",
+        "PublicDescription": "UNC_M_RD_CAS_RANK0.BANK8",
+        "UMask": "0x8",
         "Unit": "iMC"
     },
     {
-        "BriefDescription": "RD_CAS Access to Rank 0; Bank 15",
-        "Counter": "0,1,2,3",
+        "BriefDescription": "RD_CAS Access to Rank 0; Bank 9",
         "EventCode": "0xB0",
-        "EventName": "UNC_M_RD_CAS_RANK0.BANK15",
+        "EventName": "UNC_M_RD_CAS_RANK0.BANK9",
         "PerPkg": "1",
-        "UMask": "0xF",
+        "PublicDescription": "UNC_M_RD_CAS_RANK0.BANK9",
+        "UMask": "0x9",
         "Unit": "iMC"
     },
     {
         "BriefDescription": "RD_CAS Access to Rank 0; Bank Group 0 (Banks =
0-3)",
-        "Counter": "0,1,2,3",
         "EventCode": "0xB0",
         "EventName": "UNC_M_RD_CAS_RANK0.BANKG0",
         "PerPkg": "1",
+        "PublicDescription": "UNC_M_RD_CAS_RANK0.BANKG0",
         "UMask": "0x11",
         "Unit": "iMC"
     },
     {
         "BriefDescription": "RD_CAS Access to Rank 0; Bank Group 1 (Banks =
4-7)",
-        "Counter": "0,1,2,3",
         "EventCode": "0xB0",
         "EventName": "UNC_M_RD_CAS_RANK0.BANKG1",
         "PerPkg": "1",
+        "PublicDescription": "UNC_M_RD_CAS_RANK0.BANKG1",
         "UMask": "0x12",
         "Unit": "iMC"
     },
     {
         "BriefDescription": "RD_CAS Access to Rank 0; Bank Group 2 (Banks =
8-11)",
-        "Counter": "0,1,2,3",
         "EventCode": "0xB0",
         "EventName": "UNC_M_RD_CAS_RANK0.BANKG2",
         "PerPkg": "1",
+        "PublicDescription": "UNC_M_RD_CAS_RANK0.BANKG2",
         "UMask": "0x13",
         "Unit": "iMC"
     },
     {
         "BriefDescription": "RD_CAS Access to Rank 0; Bank Group 3 (Banks =
12-15)",
-        "Counter": "0,1,2,3",
         "EventCode": "0xB0",
         "EventName": "UNC_M_RD_CAS_RANK0.BANKG3",
         "PerPkg": "1",
+        "PublicDescription": "UNC_M_RD_CAS_RANK0.BANKG3",
         "UMask": "0x14",
         "Unit": "iMC"
     },
     {
-        "BriefDescription": "RD_CAS Access to Rank 1; Bank 1",
-        "Counter": "0,1,2,3",
+        "BriefDescription": "RD_CAS Access to Rank 1; All Banks",
         "EventCode": "0xB1",
-        "EventName": "UNC_M_RD_CAS_RANK1.BANK1",
+        "EventName": "UNC_M_RD_CAS_RANK1.ALLBANKS",
         "PerPkg": "1",
-        "UMask": "0x1",
+        "PublicDescription": "UNC_M_RD_CAS_RANK1.ALLBANKS",
+        "UMask": "0x10",
         "Unit": "iMC"
     },
     {
-        "BriefDescription": "RD_CAS Access to Rank 1; Bank 2",
-        "Counter": "0,1,2,3",
+        "BriefDescription": "RD_CAS Access to Rank 1; Bank 0",
         "EventCode": "0xB1",
-        "EventName": "UNC_M_RD_CAS_RANK1.BANK2",
+        "EventName": "UNC_M_RD_CAS_RANK1.BANK0",
         "PerPkg": "1",
-        "UMask": "0x2",
+        "PublicDescription": "UNC_M_RD_CAS_RANK1.BANK0",
         "Unit": "iMC"
     },
     {
-        "BriefDescription": "RD_CAS Access to Rank 1; Bank 4",
-        "Counter": "0,1,2,3",
+        "BriefDescription": "RD_CAS Access to Rank 1; Bank 1",
         "EventCode": "0xB1",
-        "EventName": "UNC_M_RD_CAS_RANK1.BANK4",
+        "EventName": "UNC_M_RD_CAS_RANK1.BANK1",
         "PerPkg": "1",
-        "UMask": "0x4",
+        "PublicDescription": "UNC_M_RD_CAS_RANK1.BANK1",
+        "UMask": "0x1",
         "Unit": "iMC"
     },
     {
-        "BriefDescription": "RD_CAS Access to Rank 1; Bank 8",
-        "Counter": "0,1,2,3",
+        "BriefDescription": "RD_CAS Access to Rank 1; Bank 10",
         "EventCode": "0xB1",
-        "EventName": "UNC_M_RD_CAS_RANK1.BANK8",
+        "EventName": "UNC_M_RD_CAS_RANK1.BANK10",
         "PerPkg": "1",
-        "UMask": "0x8",
+        "PublicDescription": "UNC_M_RD_CAS_RANK1.BANK10",
+        "UMask": "0xa",
         "Unit": "iMC"
     },
     {
-        "BriefDescription": "RD_CAS Access to Rank 1; All Banks",
-        "Counter": "0,1,2,3",
+        "BriefDescription": "RD_CAS Access to Rank 1; Bank 11",
         "EventCode": "0xB1",
-        "EventName": "UNC_M_RD_CAS_RANK1.ALLBANKS",
+        "EventName": "UNC_M_RD_CAS_RANK1.BANK11",
         "PerPkg": "1",
-        "UMask": "0x10",
+        "PublicDescription": "UNC_M_RD_CAS_RANK1.BANK11",
+        "UMask": "0xb",
         "Unit": "iMC"
     },
     {
-        "BriefDescription": "RD_CAS Access to Rank 1; Bank 0",
-        "Counter": "0,1,2,3",
+        "BriefDescription": "RD_CAS Access to Rank 1; Bank 12",
         "EventCode": "0xB1",
-        "EventName": "UNC_M_RD_CAS_RANK1.BANK0",
+        "EventName": "UNC_M_RD_CAS_RANK1.BANK12",
         "PerPkg": "1",
+        "PublicDescription": "UNC_M_RD_CAS_RANK1.BANK12",
+        "UMask": "0xc",
         "Unit": "iMC"
     },
     {
-        "BriefDescription": "RD_CAS Access to Rank 1; Bank 3",
-        "Counter": "0,1,2,3",
+        "BriefDescription": "RD_CAS Access to Rank 1; Bank 13",
         "EventCode": "0xB1",
-        "EventName": "UNC_M_RD_CAS_RANK1.BANK3",
+        "EventName": "UNC_M_RD_CAS_RANK1.BANK13",
         "PerPkg": "1",
-        "UMask": "0x3",
+        "PublicDescription": "UNC_M_RD_CAS_RANK1.BANK13",
+        "UMask": "0xd",
         "Unit": "iMC"
     },
     {
-        "BriefDescription": "RD_CAS Access to Rank 1; Bank 5",
-        "Counter": "0,1,2,3",
+        "BriefDescription": "RD_CAS Access to Rank 1; Bank 14",
         "EventCode": "0xB1",
-        "EventName": "UNC_M_RD_CAS_RANK1.BANK5",
+        "EventName": "UNC_M_RD_CAS_RANK1.BANK14",
         "PerPkg": "1",
-        "UMask": "0x5",
+        "PublicDescription": "UNC_M_RD_CAS_RANK1.BANK14",
+        "UMask": "0xe",
         "Unit": "iMC"
     },
     {
-        "BriefDescription": "RD_CAS Access to Rank 1; Bank 6",
-        "Counter": "0,1,2,3",
+        "BriefDescription": "RD_CAS Access to Rank 1; Bank 15",
         "EventCode": "0xB1",
-        "EventName": "UNC_M_RD_CAS_RANK1.BANK6",
+        "EventName": "UNC_M_RD_CAS_RANK1.BANK15",
         "PerPkg": "1",
-        "UMask": "0x6",
+        "PublicDescription": "UNC_M_RD_CAS_RANK1.BANK15",
+        "UMask": "0xf",
         "Unit": "iMC"
     },
     {
-        "BriefDescription": "RD_CAS Access to Rank 1; Bank 7",
-        "Counter": "0,1,2,3",
+        "BriefDescription": "RD_CAS Access to Rank 1; Bank 2",
         "EventCode": "0xB1",
-        "EventName": "UNC_M_RD_CAS_RANK1.BANK7",
+        "EventName": "UNC_M_RD_CAS_RANK1.BANK2",
         "PerPkg": "1",
-        "UMask": "0x7",
+        "PublicDescription": "UNC_M_RD_CAS_RANK1.BANK2",
+        "UMask": "0x2",
         "Unit": "iMC"
     },
     {
-        "BriefDescription": "RD_CAS Access to Rank 1; Bank 9",
-        "Counter": "0,1,2,3",
+        "BriefDescription": "RD_CAS Access to Rank 1; Bank 3",
         "EventCode": "0xB1",
-        "EventName": "UNC_M_RD_CAS_RANK1.BANK9",
+        "EventName": "UNC_M_RD_CAS_RANK1.BANK3",
         "PerPkg": "1",
-        "UMask": "0x9",
+        "PublicDescription": "UNC_M_RD_CAS_RANK1.BANK3",
+        "UMask": "0x3",
         "Unit": "iMC"
     },
     {
-        "BriefDescription": "RD_CAS Access to Rank 1; Bank 10",
-        "Counter": "0,1,2,3",
+        "BriefDescription": "RD_CAS Access to Rank 1; Bank 4",
         "EventCode": "0xB1",
-        "EventName": "UNC_M_RD_CAS_RANK1.BANK10",
+        "EventName": "UNC_M_RD_CAS_RANK1.BANK4",
         "PerPkg": "1",
-        "UMask": "0xA",
+        "PublicDescription": "UNC_M_RD_CAS_RANK1.BANK4",
+        "UMask": "0x4",
         "Unit": "iMC"
     },
     {
-        "BriefDescription": "RD_CAS Access to Rank 1; Bank 11",
-        "Counter": "0,1,2,3",
+        "BriefDescription": "RD_CAS Access to Rank 1; Bank 5",
         "EventCode": "0xB1",
-        "EventName": "UNC_M_RD_CAS_RANK1.BANK11",
+        "EventName": "UNC_M_RD_CAS_RANK1.BANK5",
         "PerPkg": "1",
-        "UMask": "0xB",
+        "PublicDescription": "UNC_M_RD_CAS_RANK1.BANK5",
+        "UMask": "0x5",
         "Unit": "iMC"
     },
     {
-        "BriefDescription": "RD_CAS Access to Rank 1; Bank 12",
-        "Counter": "0,1,2,3",
+        "BriefDescription": "RD_CAS Access to Rank 1; Bank 6",
         "EventCode": "0xB1",
-        "EventName": "UNC_M_RD_CAS_RANK1.BANK12",
+        "EventName": "UNC_M_RD_CAS_RANK1.BANK6",
         "PerPkg": "1",
-        "UMask": "0xC",
+        "PublicDescription": "UNC_M_RD_CAS_RANK1.BANK6",
+        "UMask": "0x6",
         "Unit": "iMC"
     },
     {
-        "BriefDescription": "RD_CAS Access to Rank 1; Bank 13",
-        "Counter": "0,1,2,3",
+        "BriefDescription": "RD_CAS Access to Rank 1; Bank 7",
         "EventCode": "0xB1",
-        "EventName": "UNC_M_RD_CAS_RANK1.BANK13",
+        "EventName": "UNC_M_RD_CAS_RANK1.BANK7",
         "PerPkg": "1",
-        "UMask": "0xD",
+        "PublicDescription": "UNC_M_RD_CAS_RANK1.BANK7",
+        "UMask": "0x7",
         "Unit": "iMC"
     },
     {
-        "BriefDescription": "RD_CAS Access to Rank 1; Bank 14",
-        "Counter": "0,1,2,3",
+        "BriefDescription": "RD_CAS Access to Rank 1; Bank 8",
         "EventCode": "0xB1",
-        "EventName": "UNC_M_RD_CAS_RANK1.BANK14",
+        "EventName": "UNC_M_RD_CAS_RANK1.BANK8",
         "PerPkg": "1",
-        "UMask": "0xE",
+        "PublicDescription": "UNC_M_RD_CAS_RANK1.BANK8",
+        "UMask": "0x8",
         "Unit": "iMC"
     },
     {
-        "BriefDescription": "RD_CAS Access to Rank 1; Bank 15",
-        "Counter": "0,1,2,3",
+        "BriefDescription": "RD_CAS Access to Rank 1; Bank 9",
         "EventCode": "0xB1",
-        "EventName": "UNC_M_RD_CAS_RANK1.BANK15",
+        "EventName": "UNC_M_RD_CAS_RANK1.BANK9",
         "PerPkg": "1",
-        "UMask": "0xF",
+        "PublicDescription": "UNC_M_RD_CAS_RANK1.BANK9",
+        "UMask": "0x9",
         "Unit": "iMC"
     },
     {
         "BriefDescription": "RD_CAS Access to Rank 1; Bank Group 0 (Banks =
0-3)",
-        "Counter": "0,1,2,3",
         "EventCode": "0xB1",
         "EventName": "UNC_M_RD_CAS_RANK1.BANKG0",
         "PerPkg": "1",
+        "PublicDescription": "UNC_M_RD_CAS_RANK1.BANKG0",
         "UMask": "0x11",
         "Unit": "iMC"
     },
     {
         "BriefDescription": "RD_CAS Access to Rank 1; Bank Group 1 (Banks =
4-7)",
-        "Counter": "0,1,2,3",
         "EventCode": "0xB1",
         "EventName": "UNC_M_RD_CAS_RANK1.BANKG1",
         "PerPkg": "1",
+        "PublicDescription": "UNC_M_RD_CAS_RANK1.BANKG1",
         "UMask": "0x12",
         "Unit": "iMC"
     },
     {
         "BriefDescription": "RD_CAS Access to Rank 1; Bank Group 2 (Banks =
8-11)",
-        "Counter": "0,1,2,3",
         "EventCode": "0xB1",
         "EventName": "UNC_M_RD_CAS_RANK1.BANKG2",
         "PerPkg": "1",
+        "PublicDescription": "UNC_M_RD_CAS_RANK1.BANKG2",
         "UMask": "0x13",
         "Unit": "iMC"
     },
     {
         "BriefDescription": "RD_CAS Access to Rank 1; Bank Group 3 (Banks =
12-15)",
-        "Counter": "0,1,2,3",
         "EventCode": "0xB1",
         "EventName": "UNC_M_RD_CAS_RANK1.BANKG3",
         "PerPkg": "1",
+        "PublicDescription": "UNC_M_RD_CAS_RANK1.BANKG3",
         "UMask": "0x14",
         "Unit": "iMC"
     },
     {
         "BriefDescription": "RD_CAS Access to Rank 2; Bank 0",
-        "Counter": "0,1,2,3",
         "EventCode": "0xB2",
         "EventName": "UNC_M_RD_CAS_RANK2.BANK0",
         "PerPkg": "1",
+        "PublicDescription": "UNC_M_RD_CAS_RANK2.BANK0",
         "Unit": "iMC"
     },
     {
-        "BriefDescription": "RD_CAS Access to Rank 4; Bank 1",
-        "Counter": "0,1,2,3",
+        "BriefDescription": "RD_CAS Access to Rank 4; All Banks",
         "EventCode": "0xB4",
-        "EventName": "UNC_M_RD_CAS_RANK4.BANK1",
+        "EventName": "UNC_M_RD_CAS_RANK4.ALLBANKS",
         "PerPkg": "1",
-        "UMask": "0x1",
+        "PublicDescription": "UNC_M_RD_CAS_RANK4.ALLBANKS",
+        "UMask": "0x10",
         "Unit": "iMC"
     },
     {
-        "BriefDescription": "RD_CAS Access to Rank 4; Bank 2",
-        "Counter": "0,1,2,3",
+        "BriefDescription": "RD_CAS Access to Rank 4; Bank 0",
         "EventCode": "0xB4",
-        "EventName": "UNC_M_RD_CAS_RANK4.BANK2",
+        "EventName": "UNC_M_RD_CAS_RANK4.BANK0",
         "PerPkg": "1",
-        "UMask": "0x2",
+        "PublicDescription": "UNC_M_RD_CAS_RANK4.BANK0",
         "Unit": "iMC"
     },
     {
-        "BriefDescription": "RD_CAS Access to Rank 4; Bank 4",
-        "Counter": "0,1,2,3",
+        "BriefDescription": "RD_CAS Access to Rank 4; Bank 1",
         "EventCode": "0xB4",
-        "EventName": "UNC_M_RD_CAS_RANK4.BANK4",
+        "EventName": "UNC_M_RD_CAS_RANK4.BANK1",
         "PerPkg": "1",
-        "UMask": "0x4",
+        "PublicDescription": "UNC_M_RD_CAS_RANK4.BANK1",
+        "UMask": "0x1",
         "Unit": "iMC"
     },
     {
-        "BriefDescription": "RD_CAS Access to Rank 4; Bank 8",
-        "Counter": "0,1,2,3",
+        "BriefDescription": "RD_CAS Access to Rank 4; Bank 10",
         "EventCode": "0xB4",
-        "EventName": "UNC_M_RD_CAS_RANK4.BANK8",
+        "EventName": "UNC_M_RD_CAS_RANK4.BANK10",
         "PerPkg": "1",
-        "UMask": "0x8",
+        "PublicDescription": "UNC_M_RD_CAS_RANK4.BANK10",
+        "UMask": "0xa",
         "Unit": "iMC"
     },
     {
-        "BriefDescription": "RD_CAS Access to Rank 4; All Banks",
-        "Counter": "0,1,2,3",
+        "BriefDescription": "RD_CAS Access to Rank 4; Bank 11",
         "EventCode": "0xB4",
-        "EventName": "UNC_M_RD_CAS_RANK4.ALLBANKS",
+        "EventName": "UNC_M_RD_CAS_RANK4.BANK11",
         "PerPkg": "1",
-        "UMask": "0x10",
+        "PublicDescription": "UNC_M_RD_CAS_RANK4.BANK11",
+        "UMask": "0xb",
         "Unit": "iMC"
     },
     {
-        "BriefDescription": "RD_CAS Access to Rank 4; Bank 0",
-        "Counter": "0,1,2,3",
+        "BriefDescription": "RD_CAS Access to Rank 4; Bank 12",
         "EventCode": "0xB4",
-        "EventName": "UNC_M_RD_CAS_RANK4.BANK0",
+        "EventName": "UNC_M_RD_CAS_RANK4.BANK12",
         "PerPkg": "1",
+        "PublicDescription": "UNC_M_RD_CAS_RANK4.BANK12",
+        "UMask": "0xc",
         "Unit": "iMC"
     },
     {
-        "BriefDescription": "RD_CAS Access to Rank 4; Bank 3",
-        "Counter": "0,1,2,3",
+        "BriefDescription": "RD_CAS Access to Rank 4; Bank 13",
         "EventCode": "0xB4",
-        "EventName": "UNC_M_RD_CAS_RANK4.BANK3",
+        "EventName": "UNC_M_RD_CAS_RANK4.BANK13",
         "PerPkg": "1",
-        "UMask": "0x3",
+        "PublicDescription": "UNC_M_RD_CAS_RANK4.BANK13",
+        "UMask": "0xd",
         "Unit": "iMC"
     },
     {
-        "BriefDescription": "RD_CAS Access to Rank 4; Bank 5",
-        "Counter": "0,1,2,3",
+        "BriefDescription": "RD_CAS Access to Rank 4; Bank 14",
         "EventCode": "0xB4",
-        "EventName": "UNC_M_RD_CAS_RANK4.BANK5",
+        "EventName": "UNC_M_RD_CAS_RANK4.BANK14",
         "PerPkg": "1",
-        "UMask": "0x5",
+        "PublicDescription": "UNC_M_RD_CAS_RANK4.BANK14",
+        "UMask": "0xe",
         "Unit": "iMC"
     },
     {
-        "BriefDescription": "RD_CAS Access to Rank 4; Bank 6",
-        "Counter": "0,1,2,3",
+        "BriefDescription": "RD_CAS Access to Rank 4; Bank 15",
         "EventCode": "0xB4",
-        "EventName": "UNC_M_RD_CAS_RANK4.BANK6",
+        "EventName": "UNC_M_RD_CAS_RANK4.BANK15",
         "PerPkg": "1",
-        "UMask": "0x6",
+        "PublicDescription": "UNC_M_RD_CAS_RANK4.BANK15",
+        "UMask": "0xf",
         "Unit": "iMC"
     },
     {
-        "BriefDescription": "RD_CAS Access to Rank 4; Bank 7",
-        "Counter": "0,1,2,3",
+        "BriefDescription": "RD_CAS Access to Rank 4; Bank 2",
         "EventCode": "0xB4",
-        "EventName": "UNC_M_RD_CAS_RANK4.BANK7",
+        "EventName": "UNC_M_RD_CAS_RANK4.BANK2",
         "PerPkg": "1",
-        "UMask": "0x7",
+        "PublicDescription": "UNC_M_RD_CAS_RANK4.BANK2",
+        "UMask": "0x2",
         "Unit": "iMC"
     },
     {
-        "BriefDescription": "RD_CAS Access to Rank 4; Bank 9",
-        "Counter": "0,1,2,3",
+        "BriefDescription": "RD_CAS Access to Rank 4; Bank 3",
         "EventCode": "0xB4",
-        "EventName": "UNC_M_RD_CAS_RANK4.BANK9",
+        "EventName": "UNC_M_RD_CAS_RANK4.BANK3",
         "PerPkg": "1",
-        "UMask": "0x9",
+        "PublicDescription": "UNC_M_RD_CAS_RANK4.BANK3",
+        "UMask": "0x3",
         "Unit": "iMC"
     },
     {
-        "BriefDescription": "RD_CAS Access to Rank 4; Bank 10",
-        "Counter": "0,1,2,3",
+        "BriefDescription": "RD_CAS Access to Rank 4; Bank 4",
         "EventCode": "0xB4",
-        "EventName": "UNC_M_RD_CAS_RANK4.BANK10",
+        "EventName": "UNC_M_RD_CAS_RANK4.BANK4",
         "PerPkg": "1",
-        "UMask": "0xA",
+        "PublicDescription": "UNC_M_RD_CAS_RANK4.BANK4",
+        "UMask": "0x4",
         "Unit": "iMC"
     },
     {
-        "BriefDescription": "RD_CAS Access to Rank 4; Bank 11",
-        "Counter": "0,1,2,3",
+        "BriefDescription": "RD_CAS Access to Rank 4; Bank 5",
         "EventCode": "0xB4",
-        "EventName": "UNC_M_RD_CAS_RANK4.BANK11",
+        "EventName": "UNC_M_RD_CAS_RANK4.BANK5",
         "PerPkg": "1",
-        "UMask": "0xB",
+        "PublicDescription": "UNC_M_RD_CAS_RANK4.BANK5",
+        "UMask": "0x5",
         "Unit": "iMC"
     },
     {
-        "BriefDescription": "RD_CAS Access to Rank 4; Bank 12",
-        "Counter": "0,1,2,3",
+        "BriefDescription": "RD_CAS Access to Rank 4; Bank 6",
         "EventCode": "0xB4",
-        "EventName": "UNC_M_RD_CAS_RANK4.BANK12",
+        "EventName": "UNC_M_RD_CAS_RANK4.BANK6",
         "PerPkg": "1",
-        "UMask": "0xC",
+        "PublicDescription": "UNC_M_RD_CAS_RANK4.BANK6",
+        "UMask": "0x6",
         "Unit": "iMC"
     },
     {
-        "BriefDescription": "RD_CAS Access to Rank 4; Bank 13",
-        "Counter": "0,1,2,3",
+        "BriefDescription": "RD_CAS Access to Rank 4; Bank 7",
         "EventCode": "0xB4",
-        "EventName": "UNC_M_RD_CAS_RANK4.BANK13",
+        "EventName": "UNC_M_RD_CAS_RANK4.BANK7",
         "PerPkg": "1",
-        "UMask": "0xD",
+        "PublicDescription": "UNC_M_RD_CAS_RANK4.BANK7",
+        "UMask": "0x7",
         "Unit": "iMC"
     },
     {
-        "BriefDescription": "RD_CAS Access to Rank 4; Bank 14",
-        "Counter": "0,1,2,3",
+        "BriefDescription": "RD_CAS Access to Rank 4; Bank 8",
         "EventCode": "0xB4",
-        "EventName": "UNC_M_RD_CAS_RANK4.BANK14",
+        "EventName": "UNC_M_RD_CAS_RANK4.BANK8",
         "PerPkg": "1",
-        "UMask": "0xE",
+        "PublicDescription": "UNC_M_RD_CAS_RANK4.BANK8",
+        "UMask": "0x8",
         "Unit": "iMC"
     },
     {
-        "BriefDescription": "RD_CAS Access to Rank 4; Bank 15",
-        "Counter": "0,1,2,3",
+        "BriefDescription": "RD_CAS Access to Rank 4; Bank 9",
         "EventCode": "0xB4",
-        "EventName": "UNC_M_RD_CAS_RANK4.BANK15",
+        "EventName": "UNC_M_RD_CAS_RANK4.BANK9",
         "PerPkg": "1",
-        "UMask": "0xF",
+        "PublicDescription": "UNC_M_RD_CAS_RANK4.BANK9",
+        "UMask": "0x9",
         "Unit": "iMC"
     },
     {
         "BriefDescription": "RD_CAS Access to Rank 4; Bank Group 0 (Banks =
0-3)",
-        "Counter": "0,1,2,3",
         "EventCode": "0xB4",
         "EventName": "UNC_M_RD_CAS_RANK4.BANKG0",
         "PerPkg": "1",
+        "PublicDescription": "UNC_M_RD_CAS_RANK4.BANKG0",
         "UMask": "0x11",
         "Unit": "iMC"
     },
     {
         "BriefDescription": "RD_CAS Access to Rank 4; Bank Group 1 (Banks =
4-7)",
-        "Counter": "0,1,2,3",
         "EventCode": "0xB4",
         "EventName": "UNC_M_RD_CAS_RANK4.BANKG1",
         "PerPkg": "1",
+        "PublicDescription": "UNC_M_RD_CAS_RANK4.BANKG1",
         "UMask": "0x12",
         "Unit": "iMC"
     },
     {
         "BriefDescription": "RD_CAS Access to Rank 4; Bank Group 2 (Banks =
8-11)",
-        "Counter": "0,1,2,3",
         "EventCode": "0xB4",
         "EventName": "UNC_M_RD_CAS_RANK4.BANKG2",
         "PerPkg": "1",
+        "PublicDescription": "UNC_M_RD_CAS_RANK4.BANKG2",
         "UMask": "0x13",
         "Unit": "iMC"
     },
     {
         "BriefDescription": "RD_CAS Access to Rank 4; Bank Group 3 (Banks =
12-15)",
-        "Counter": "0,1,2,3",
         "EventCode": "0xB4",
         "EventName": "UNC_M_RD_CAS_RANK4.BANKG3",
         "PerPkg": "1",
+        "PublicDescription": "UNC_M_RD_CAS_RANK4.BANKG3",
         "UMask": "0x14",
         "Unit": "iMC"
     },
     {
-        "BriefDescription": "RD_CAS Access to Rank 5; Bank 1",
-        "Counter": "0,1,2,3",
+        "BriefDescription": "RD_CAS Access to Rank 5; All Banks",
         "EventCode": "0xB5",
-        "EventName": "UNC_M_RD_CAS_RANK5.BANK1",
+        "EventName": "UNC_M_RD_CAS_RANK5.ALLBANKS",
         "PerPkg": "1",
-        "UMask": "0x1",
+        "PublicDescription": "UNC_M_RD_CAS_RANK5.ALLBANKS",
+        "UMask": "0x10",
         "Unit": "iMC"
     },
     {
-        "BriefDescription": "RD_CAS Access to Rank 5; Bank 2",
-        "Counter": "0,1,2,3",
+        "BriefDescription": "RD_CAS Access to Rank 5; Bank 0",
         "EventCode": "0xB5",
-        "EventName": "UNC_M_RD_CAS_RANK5.BANK2",
+        "EventName": "UNC_M_RD_CAS_RANK5.BANK0",
         "PerPkg": "1",
-        "UMask": "0x2",
+        "PublicDescription": "UNC_M_RD_CAS_RANK5.BANK0",
         "Unit": "iMC"
     },
     {
-        "BriefDescription": "RD_CAS Access to Rank 5; Bank 4",
-        "Counter": "0,1,2,3",
+        "BriefDescription": "RD_CAS Access to Rank 5; Bank 1",
         "EventCode": "0xB5",
-        "EventName": "UNC_M_RD_CAS_RANK5.BANK4",
+        "EventName": "UNC_M_RD_CAS_RANK5.BANK1",
         "PerPkg": "1",
-        "UMask": "0x4",
+        "PublicDescription": "UNC_M_RD_CAS_RANK5.BANK1",
+        "UMask": "0x1",
         "Unit": "iMC"
     },
     {
-        "BriefDescription": "RD_CAS Access to Rank 5; Bank 8",
-        "Counter": "0,1,2,3",
+        "BriefDescription": "RD_CAS Access to Rank 5; Bank 10",
         "EventCode": "0xB5",
-        "EventName": "UNC_M_RD_CAS_RANK5.BANK8",
+        "EventName": "UNC_M_RD_CAS_RANK5.BANK10",
         "PerPkg": "1",
-        "UMask": "0x8",
+        "PublicDescription": "UNC_M_RD_CAS_RANK5.BANK10",
+        "UMask": "0xa",
         "Unit": "iMC"
     },
     {
-        "BriefDescription": "RD_CAS Access to Rank 5; All Banks",
-        "Counter": "0,1,2,3",
+        "BriefDescription": "RD_CAS Access to Rank 5; Bank 11",
         "EventCode": "0xB5",
-        "EventName": "UNC_M_RD_CAS_RANK5.ALLBANKS",
+        "EventName": "UNC_M_RD_CAS_RANK5.BANK11",
         "PerPkg": "1",
-        "UMask": "0x10",
+        "PublicDescription": "UNC_M_RD_CAS_RANK5.BANK11",
+        "UMask": "0xb",
         "Unit": "iMC"
     },
     {
-        "BriefDescription": "RD_CAS Access to Rank 5; Bank 0",
-        "Counter": "0,1,2,3",
+        "BriefDescription": "RD_CAS Access to Rank 5; Bank 12",
         "EventCode": "0xB5",
-        "EventName": "UNC_M_RD_CAS_RANK5.BANK0",
+        "EventName": "UNC_M_RD_CAS_RANK5.BANK12",
         "PerPkg": "1",
+        "PublicDescription": "UNC_M_RD_CAS_RANK5.BANK12",
+        "UMask": "0xc",
         "Unit": "iMC"
     },
     {
-        "BriefDescription": "RD_CAS Access to Rank 5; Bank 3",
-        "Counter": "0,1,2,3",
+        "BriefDescription": "RD_CAS Access to Rank 5; Bank 13",
         "EventCode": "0xB5",
-        "EventName": "UNC_M_RD_CAS_RANK5.BANK3",
+        "EventName": "UNC_M_RD_CAS_RANK5.BANK13",
         "PerPkg": "1",
-        "UMask": "0x3",
+        "PublicDescription": "UNC_M_RD_CAS_RANK5.BANK13",
+        "UMask": "0xd",
         "Unit": "iMC"
     },
     {
-        "BriefDescription": "RD_CAS Access to Rank 5; Bank 5",
-        "Counter": "0,1,2,3",
+        "BriefDescription": "RD_CAS Access to Rank 5; Bank 14",
         "EventCode": "0xB5",
-        "EventName": "UNC_M_RD_CAS_RANK5.BANK5",
+        "EventName": "UNC_M_RD_CAS_RANK5.BANK14",
         "PerPkg": "1",
-        "UMask": "0x5",
+        "PublicDescription": "UNC_M_RD_CAS_RANK5.BANK14",
+        "UMask": "0xe",
         "Unit": "iMC"
     },
     {
-        "BriefDescription": "RD_CAS Access to Rank 5; Bank 6",
-        "Counter": "0,1,2,3",
+        "BriefDescription": "RD_CAS Access to Rank 5; Bank 15",
         "EventCode": "0xB5",
-        "EventName": "UNC_M_RD_CAS_RANK5.BANK6",
+        "EventName": "UNC_M_RD_CAS_RANK5.BANK15",
         "PerPkg": "1",
-        "UMask": "0x6",
+        "PublicDescription": "UNC_M_RD_CAS_RANK5.BANK15",
+        "UMask": "0xf",
         "Unit": "iMC"
     },
     {
-        "BriefDescription": "RD_CAS Access to Rank 5; Bank 7",
-        "Counter": "0,1,2,3",
+        "BriefDescription": "RD_CAS Access to Rank 5; Bank 2",
         "EventCode": "0xB5",
-        "EventName": "UNC_M_RD_CAS_RANK5.BANK7",
+        "EventName": "UNC_M_RD_CAS_RANK5.BANK2",
         "PerPkg": "1",
-        "UMask": "0x7",
+        "PublicDescription": "UNC_M_RD_CAS_RANK5.BANK2",
+        "UMask": "0x2",
         "Unit": "iMC"
     },
     {
-        "BriefDescription": "RD_CAS Access to Rank 5; Bank 9",
-        "Counter": "0,1,2,3",
+        "BriefDescription": "RD_CAS Access to Rank 5; Bank 3",
         "EventCode": "0xB5",
-        "EventName": "UNC_M_RD_CAS_RANK5.BANK9",
+        "EventName": "UNC_M_RD_CAS_RANK5.BANK3",
         "PerPkg": "1",
-        "UMask": "0x9",
+        "PublicDescription": "UNC_M_RD_CAS_RANK5.BANK3",
+        "UMask": "0x3",
         "Unit": "iMC"
     },
     {
-        "BriefDescription": "RD_CAS Access to Rank 5; Bank 10",
-        "Counter": "0,1,2,3",
+        "BriefDescription": "RD_CAS Access to Rank 5; Bank 4",
         "EventCode": "0xB5",
-        "EventName": "UNC_M_RD_CAS_RANK5.BANK10",
+        "EventName": "UNC_M_RD_CAS_RANK5.BANK4",
         "PerPkg": "1",
-        "UMask": "0xA",
+        "PublicDescription": "UNC_M_RD_CAS_RANK5.BANK4",
+        "UMask": "0x4",
         "Unit": "iMC"
     },
     {
-        "BriefDescription": "RD_CAS Access to Rank 5; Bank 11",
-        "Counter": "0,1,2,3",
+        "BriefDescription": "RD_CAS Access to Rank 5; Bank 5",
         "EventCode": "0xB5",
-        "EventName": "UNC_M_RD_CAS_RANK5.BANK11",
+        "EventName": "UNC_M_RD_CAS_RANK5.BANK5",
         "PerPkg": "1",
-        "UMask": "0xB",
+        "PublicDescription": "UNC_M_RD_CAS_RANK5.BANK5",
+        "UMask": "0x5",
         "Unit": "iMC"
     },
     {
-        "BriefDescription": "RD_CAS Access to Rank 5; Bank 12",
-        "Counter": "0,1,2,3",
+        "BriefDescription": "RD_CAS Access to Rank 5; Bank 6",
         "EventCode": "0xB5",
-        "EventName": "UNC_M_RD_CAS_RANK5.BANK12",
+        "EventName": "UNC_M_RD_CAS_RANK5.BANK6",
         "PerPkg": "1",
-        "UMask": "0xC",
+        "PublicDescription": "UNC_M_RD_CAS_RANK5.BANK6",
+        "UMask": "0x6",
         "Unit": "iMC"
     },
     {
-        "BriefDescription": "RD_CAS Access to Rank 5; Bank 13",
-        "Counter": "0,1,2,3",
+        "BriefDescription": "RD_CAS Access to Rank 5; Bank 7",
         "EventCode": "0xB5",
-        "EventName": "UNC_M_RD_CAS_RANK5.BANK13",
+        "EventName": "UNC_M_RD_CAS_RANK5.BANK7",
         "PerPkg": "1",
-        "UMask": "0xD",
+        "PublicDescription": "UNC_M_RD_CAS_RANK5.BANK7",
+        "UMask": "0x7",
         "Unit": "iMC"
     },
     {
-        "BriefDescription": "RD_CAS Access to Rank 5; Bank 14",
-        "Counter": "0,1,2,3",
+        "BriefDescription": "RD_CAS Access to Rank 5; Bank 8",
         "EventCode": "0xB5",
-        "EventName": "UNC_M_RD_CAS_RANK5.BANK14",
+        "EventName": "UNC_M_RD_CAS_RANK5.BANK8",
         "PerPkg": "1",
-        "UMask": "0xE",
+        "PublicDescription": "UNC_M_RD_CAS_RANK5.BANK8",
+        "UMask": "0x8",
         "Unit": "iMC"
     },
     {
-        "BriefDescription": "RD_CAS Access to Rank 5; Bank 15",
-        "Counter": "0,1,2,3",
+        "BriefDescription": "RD_CAS Access to Rank 5; Bank 9",
         "EventCode": "0xB5",
-        "EventName": "UNC_M_RD_CAS_RANK5.BANK15",
+        "EventName": "UNC_M_RD_CAS_RANK5.BANK9",
         "PerPkg": "1",
-        "UMask": "0xF",
+        "PublicDescription": "UNC_M_RD_CAS_RANK5.BANK9",
+        "UMask": "0x9",
         "Unit": "iMC"
     },
     {
         "BriefDescription": "RD_CAS Access to Rank 5; Bank Group 0 (Banks =
0-3)",
-        "Counter": "0,1,2,3",
         "EventCode": "0xB5",
         "EventName": "UNC_M_RD_CAS_RANK5.BANKG0",
         "PerPkg": "1",
+        "PublicDescription": "UNC_M_RD_CAS_RANK5.BANKG0",
         "UMask": "0x11",
         "Unit": "iMC"
     },
     {
         "BriefDescription": "RD_CAS Access to Rank 5; Bank Group 1 (Banks =
4-7)",
-        "Counter": "0,1,2,3",
         "EventCode": "0xB5",
         "EventName": "UNC_M_RD_CAS_RANK5.BANKG1",
         "PerPkg": "1",
+        "PublicDescription": "UNC_M_RD_CAS_RANK5.BANKG1",
         "UMask": "0x12",
         "Unit": "iMC"
     },
     {
         "BriefDescription": "RD_CAS Access to Rank 5; Bank Group 2 (Banks =
8-11)",
-        "Counter": "0,1,2,3",
         "EventCode": "0xB5",
         "EventName": "UNC_M_RD_CAS_RANK5.BANKG2",
         "PerPkg": "1",
+        "PublicDescription": "UNC_M_RD_CAS_RANK5.BANKG2",
         "UMask": "0x13",
         "Unit": "iMC"
     },
     {
         "BriefDescription": "RD_CAS Access to Rank 5; Bank Group 3 (Banks =
12-15)",
-        "Counter": "0,1,2,3",
         "EventCode": "0xB5",
         "EventName": "UNC_M_RD_CAS_RANK5.BANKG3",
         "PerPkg": "1",
+        "PublicDescription": "UNC_M_RD_CAS_RANK5.BANKG3",
         "UMask": "0x14",
         "Unit": "iMC"
     },
     {
-        "BriefDescription": "RD_CAS Access to Rank 6; Bank 1",
-        "Counter": "0,1,2,3",
+        "BriefDescription": "RD_CAS Access to Rank 6; All Banks",
         "EventCode": "0xB6",
-        "EventName": "UNC_M_RD_CAS_RANK6.BANK1",
+        "EventName": "UNC_M_RD_CAS_RANK6.ALLBANKS",
         "PerPkg": "1",
-        "UMask": "0x1",
+        "PublicDescription": "UNC_M_RD_CAS_RANK6.ALLBANKS",
+        "UMask": "0x10",
         "Unit": "iMC"
     },
     {
-        "BriefDescription": "RD_CAS Access to Rank 6; Bank 2",
-        "Counter": "0,1,2,3",
+        "BriefDescription": "RD_CAS Access to Rank 6; Bank 0",
         "EventCode": "0xB6",
-        "EventName": "UNC_M_RD_CAS_RANK6.BANK2",
+        "EventName": "UNC_M_RD_CAS_RANK6.BANK0",
         "PerPkg": "1",
-        "UMask": "0x2",
+        "PublicDescription": "UNC_M_RD_CAS_RANK6.BANK0",
         "Unit": "iMC"
     },
     {
-        "BriefDescription": "RD_CAS Access to Rank 6; Bank 4",
-        "Counter": "0,1,2,3",
+        "BriefDescription": "RD_CAS Access to Rank 6; Bank 1",
         "EventCode": "0xB6",
-        "EventName": "UNC_M_RD_CAS_RANK6.BANK4",
+        "EventName": "UNC_M_RD_CAS_RANK6.BANK1",
         "PerPkg": "1",
-        "UMask": "0x4",
+        "PublicDescription": "UNC_M_RD_CAS_RANK6.BANK1",
+        "UMask": "0x1",
         "Unit": "iMC"
     },
     {
-        "BriefDescription": "RD_CAS Access to Rank 6; Bank 8",
-        "Counter": "0,1,2,3",
+        "BriefDescription": "RD_CAS Access to Rank 6; Bank 10",
         "EventCode": "0xB6",
-        "EventName": "UNC_M_RD_CAS_RANK6.BANK8",
+        "EventName": "UNC_M_RD_CAS_RANK6.BANK10",
         "PerPkg": "1",
-        "UMask": "0x8",
+        "PublicDescription": "UNC_M_RD_CAS_RANK6.BANK10",
+        "UMask": "0xa",
         "Unit": "iMC"
     },
     {
-        "BriefDescription": "RD_CAS Access to Rank 6; All Banks",
-        "Counter": "0,1,2,3",
+        "BriefDescription": "RD_CAS Access to Rank 6; Bank 11",
         "EventCode": "0xB6",
-        "EventName": "UNC_M_RD_CAS_RANK6.ALLBANKS",
+        "EventName": "UNC_M_RD_CAS_RANK6.BANK11",
         "PerPkg": "1",
-        "UMask": "0x10",
+        "PublicDescription": "UNC_M_RD_CAS_RANK6.BANK11",
+        "UMask": "0xb",
         "Unit": "iMC"
     },
     {
-        "BriefDescription": "RD_CAS Access to Rank 6; Bank 0",
-        "Counter": "0,1,2,3",
+        "BriefDescription": "RD_CAS Access to Rank 6; Bank 12",
         "EventCode": "0xB6",
-        "EventName": "UNC_M_RD_CAS_RANK6.BANK0",
+        "EventName": "UNC_M_RD_CAS_RANK6.BANK12",
         "PerPkg": "1",
+        "PublicDescription": "UNC_M_RD_CAS_RANK6.BANK12",
+        "UMask": "0xc",
         "Unit": "iMC"
     },
     {
-        "BriefDescription": "RD_CAS Access to Rank 6; Bank 3",
-        "Counter": "0,1,2,3",
+        "BriefDescription": "RD_CAS Access to Rank 6; Bank 13",
         "EventCode": "0xB6",
-        "EventName": "UNC_M_RD_CAS_RANK6.BANK3",
+        "EventName": "UNC_M_RD_CAS_RANK6.BANK13",
         "PerPkg": "1",
-        "UMask": "0x3",
+        "PublicDescription": "UNC_M_RD_CAS_RANK6.BANK13",
+        "UMask": "0xd",
         "Unit": "iMC"
     },
     {
-        "BriefDescription": "RD_CAS Access to Rank 6; Bank 5",
-        "Counter": "0,1,2,3",
+        "BriefDescription": "RD_CAS Access to Rank 6; Bank 14",
         "EventCode": "0xB6",
-        "EventName": "UNC_M_RD_CAS_RANK6.BANK5",
+        "EventName": "UNC_M_RD_CAS_RANK6.BANK14",
         "PerPkg": "1",
-        "UMask": "0x5",
+        "PublicDescription": "UNC_M_RD_CAS_RANK6.BANK14",
+        "UMask": "0xe",
         "Unit": "iMC"
     },
     {
-        "BriefDescription": "RD_CAS Access to Rank 6; Bank 6",
-        "Counter": "0,1,2,3",
+        "BriefDescription": "RD_CAS Access to Rank 6; Bank 15",
         "EventCode": "0xB6",
-        "EventName": "UNC_M_RD_CAS_RANK6.BANK6",
+        "EventName": "UNC_M_RD_CAS_RANK6.BANK15",
         "PerPkg": "1",
-        "UMask": "0x6",
+        "PublicDescription": "UNC_M_RD_CAS_RANK6.BANK15",
+        "UMask": "0xf",
         "Unit": "iMC"
     },
     {
-        "BriefDescription": "RD_CAS Access to Rank 6; Bank 7",
-        "Counter": "0,1,2,3",
+        "BriefDescription": "RD_CAS Access to Rank 6; Bank 2",
         "EventCode": "0xB6",
-        "EventName": "UNC_M_RD_CAS_RANK6.BANK7",
+        "EventName": "UNC_M_RD_CAS_RANK6.BANK2",
         "PerPkg": "1",
-        "UMask": "0x7",
+        "PublicDescription": "UNC_M_RD_CAS_RANK6.BANK2",
+        "UMask": "0x2",
         "Unit": "iMC"
     },
     {
-        "BriefDescription": "RD_CAS Access to Rank 6; Bank 9",
-        "Counter": "0,1,2,3",
+        "BriefDescription": "RD_CAS Access to Rank 6; Bank 3",
         "EventCode": "0xB6",
-        "EventName": "UNC_M_RD_CAS_RANK6.BANK9",
+        "EventName": "UNC_M_RD_CAS_RANK6.BANK3",
         "PerPkg": "1",
-        "UMask": "0x9",
+        "PublicDescription": "UNC_M_RD_CAS_RANK6.BANK3",
+        "UMask": "0x3",
         "Unit": "iMC"
     },
     {
-        "BriefDescription": "RD_CAS Access to Rank 6; Bank 10",
-        "Counter": "0,1,2,3",
+        "BriefDescription": "RD_CAS Access to Rank 6; Bank 4",
         "EventCode": "0xB6",
-        "EventName": "UNC_M_RD_CAS_RANK6.BANK10",
+        "EventName": "UNC_M_RD_CAS_RANK6.BANK4",
         "PerPkg": "1",
-        "UMask": "0xA",
+        "PublicDescription": "UNC_M_RD_CAS_RANK6.BANK4",
+        "UMask": "0x4",
         "Unit": "iMC"
     },
     {
-        "BriefDescription": "RD_CAS Access to Rank 6; Bank 11",
-        "Counter": "0,1,2,3",
+        "BriefDescription": "RD_CAS Access to Rank 6; Bank 5",
         "EventCode": "0xB6",
-        "EventName": "UNC_M_RD_CAS_RANK6.BANK11",
+        "EventName": "UNC_M_RD_CAS_RANK6.BANK5",
         "PerPkg": "1",
-        "UMask": "0xB",
+        "PublicDescription": "UNC_M_RD_CAS_RANK6.BANK5",
+        "UMask": "0x5",
         "Unit": "iMC"
     },
     {
-        "BriefDescription": "RD_CAS Access to Rank 6; Bank 12",
-        "Counter": "0,1,2,3",
+        "BriefDescription": "RD_CAS Access to Rank 6; Bank 6",
         "EventCode": "0xB6",
-        "EventName": "UNC_M_RD_CAS_RANK6.BANK12",
+        "EventName": "UNC_M_RD_CAS_RANK6.BANK6",
         "PerPkg": "1",
-        "UMask": "0xC",
+        "PublicDescription": "UNC_M_RD_CAS_RANK6.BANK6",
+        "UMask": "0x6",
         "Unit": "iMC"
     },
     {
-        "BriefDescription": "RD_CAS Access to Rank 6; Bank 13",
-        "Counter": "0,1,2,3",
+        "BriefDescription": "RD_CAS Access to Rank 6; Bank 7",
         "EventCode": "0xB6",
-        "EventName": "UNC_M_RD_CAS_RANK6.BANK13",
+        "EventName": "UNC_M_RD_CAS_RANK6.BANK7",
         "PerPkg": "1",
-        "UMask": "0xD",
+        "PublicDescription": "UNC_M_RD_CAS_RANK6.BANK7",
+        "UMask": "0x7",
         "Unit": "iMC"
     },
     {
-        "BriefDescription": "RD_CAS Access to Rank 6; Bank 14",
-        "Counter": "0,1,2,3",
+        "BriefDescription": "RD_CAS Access to Rank 6; Bank 8",
         "EventCode": "0xB6",
-        "EventName": "UNC_M_RD_CAS_RANK6.BANK14",
+        "EventName": "UNC_M_RD_CAS_RANK6.BANK8",
         "PerPkg": "1",
-        "UMask": "0xE",
+        "PublicDescription": "UNC_M_RD_CAS_RANK6.BANK8",
+        "UMask": "0x8",
         "Unit": "iMC"
     },
     {
-        "BriefDescription": "RD_CAS Access to Rank 6; Bank 15",
-        "Counter": "0,1,2,3",
+        "BriefDescription": "RD_CAS Access to Rank 6; Bank 9",
         "EventCode": "0xB6",
-        "EventName": "UNC_M_RD_CAS_RANK6.BANK15",
+        "EventName": "UNC_M_RD_CAS_RANK6.BANK9",
         "PerPkg": "1",
-        "UMask": "0xF",
+        "PublicDescription": "UNC_M_RD_CAS_RANK6.BANK9",
+        "UMask": "0x9",
         "Unit": "iMC"
     },
     {
         "BriefDescription": "RD_CAS Access to Rank 6; Bank Group 0 (Banks =
0-3)",
-        "Counter": "0,1,2,3",
         "EventCode": "0xB6",
         "EventName": "UNC_M_RD_CAS_RANK6.BANKG0",
         "PerPkg": "1",
+        "PublicDescription": "UNC_M_RD_CAS_RANK6.BANKG0",
         "UMask": "0x11",
         "Unit": "iMC"
     },
     {
         "BriefDescription": "RD_CAS Access to Rank 6; Bank Group 1 (Banks =
4-7)",
-        "Counter": "0,1,2,3",
         "EventCode": "0xB6",
         "EventName": "UNC_M_RD_CAS_RANK6.BANKG1",
         "PerPkg": "1",
+        "PublicDescription": "UNC_M_RD_CAS_RANK6.BANKG1",
         "UMask": "0x12",
         "Unit": "iMC"
     },
     {
         "BriefDescription": "RD_CAS Access to Rank 6; Bank Group 2 (Banks =
8-11)",
-        "Counter": "0,1,2,3",
         "EventCode": "0xB6",
         "EventName": "UNC_M_RD_CAS_RANK6.BANKG2",
         "PerPkg": "1",
+        "PublicDescription": "UNC_M_RD_CAS_RANK6.BANKG2",
         "UMask": "0x13",
         "Unit": "iMC"
     },
     {
         "BriefDescription": "RD_CAS Access to Rank 6; Bank Group 3 (Banks =
12-15)",
-        "Counter": "0,1,2,3",
         "EventCode": "0xB6",
         "EventName": "UNC_M_RD_CAS_RANK6.BANKG3",
         "PerPkg": "1",
+        "PublicDescription": "UNC_M_RD_CAS_RANK6.BANKG3",
         "UMask": "0x14",
         "Unit": "iMC"
     },
     {
-        "BriefDescription": "RD_CAS Access to Rank 7; Bank 1",
-        "Counter": "0,1,2,3",
+        "BriefDescription": "RD_CAS Access to Rank 7; All Banks",
         "EventCode": "0xB7",
-        "EventName": "UNC_M_RD_CAS_RANK7.BANK1",
+        "EventName": "UNC_M_RD_CAS_RANK7.ALLBANKS",
         "PerPkg": "1",
-        "UMask": "0x1",
+        "PublicDescription": "UNC_M_RD_CAS_RANK7.ALLBANKS",
+        "UMask": "0x10",
         "Unit": "iMC"
     },
     {
-        "BriefDescription": "RD_CAS Access to Rank 7; Bank 2",
-        "Counter": "0,1,2,3",
+        "BriefDescription": "RD_CAS Access to Rank 7; Bank 0",
         "EventCode": "0xB7",
-        "EventName": "UNC_M_RD_CAS_RANK7.BANK2",
+        "EventName": "UNC_M_RD_CAS_RANK7.BANK0",
         "PerPkg": "1",
-        "UMask": "0x2",
+        "PublicDescription": "UNC_M_RD_CAS_RANK7.BANK0",
         "Unit": "iMC"
     },
     {
-        "BriefDescription": "RD_CAS Access to Rank 7; Bank 4",
-        "Counter": "0,1,2,3",
+        "BriefDescription": "RD_CAS Access to Rank 7; Bank 1",
         "EventCode": "0xB7",
-        "EventName": "UNC_M_RD_CAS_RANK7.BANK4",
+        "EventName": "UNC_M_RD_CAS_RANK7.BANK1",
         "PerPkg": "1",
-        "UMask": "0x4",
+        "PublicDescription": "UNC_M_RD_CAS_RANK7.BANK1",
+        "UMask": "0x1",
         "Unit": "iMC"
     },
     {
-        "BriefDescription": "RD_CAS Access to Rank 7; Bank 8",
-        "Counter": "0,1,2,3",
+        "BriefDescription": "RD_CAS Access to Rank 7; Bank 10",
         "EventCode": "0xB7",
-        "EventName": "UNC_M_RD_CAS_RANK7.BANK8",
+        "EventName": "UNC_M_RD_CAS_RANK7.BANK10",
         "PerPkg": "1",
-        "UMask": "0x8",
+        "PublicDescription": "UNC_M_RD_CAS_RANK7.BANK10",
+        "UMask": "0xa",
         "Unit": "iMC"
     },
     {
-        "BriefDescription": "RD_CAS Access to Rank 7; All Banks",
-        "Counter": "0,1,2,3",
+        "BriefDescription": "RD_CAS Access to Rank 7; Bank 11",
         "EventCode": "0xB7",
-        "EventName": "UNC_M_RD_CAS_RANK7.ALLBANKS",
+        "EventName": "UNC_M_RD_CAS_RANK7.BANK11",
         "PerPkg": "1",
-        "UMask": "0x10",
+        "PublicDescription": "UNC_M_RD_CAS_RANK7.BANK11",
+        "UMask": "0xb",
         "Unit": "iMC"
     },
     {
-        "BriefDescription": "RD_CAS Access to Rank 7; Bank 0",
-        "Counter": "0,1,2,3",
+        "BriefDescription": "RD_CAS Access to Rank 7; Bank 12",
         "EventCode": "0xB7",
-        "EventName": "UNC_M_RD_CAS_RANK7.BANK0",
+        "EventName": "UNC_M_RD_CAS_RANK7.BANK12",
         "PerPkg": "1",
+        "PublicDescription": "UNC_M_RD_CAS_RANK7.BANK12",
+        "UMask": "0xc",
         "Unit": "iMC"
     },
     {
-        "BriefDescription": "RD_CAS Access to Rank 7; Bank 3",
-        "Counter": "0,1,2,3",
+        "BriefDescription": "RD_CAS Access to Rank 7; Bank 13",
         "EventCode": "0xB7",
-        "EventName": "UNC_M_RD_CAS_RANK7.BANK3",
+        "EventName": "UNC_M_RD_CAS_RANK7.BANK13",
         "PerPkg": "1",
-        "UMask": "0x3",
+        "PublicDescription": "UNC_M_RD_CAS_RANK7.BANK13",
+        "UMask": "0xd",
         "Unit": "iMC"
     },
     {
-        "BriefDescription": "RD_CAS Access to Rank 7; Bank 5",
-        "Counter": "0,1,2,3",
+        "BriefDescription": "RD_CAS Access to Rank 7; Bank 14",
         "EventCode": "0xB7",
-        "EventName": "UNC_M_RD_CAS_RANK7.BANK5",
+        "EventName": "UNC_M_RD_CAS_RANK7.BANK14",
         "PerPkg": "1",
-        "UMask": "0x5",
+        "PublicDescription": "UNC_M_RD_CAS_RANK7.BANK14",
+        "UMask": "0xe",
         "Unit": "iMC"
     },
     {
-        "BriefDescription": "RD_CAS Access to Rank 7; Bank 6",
-        "Counter": "0,1,2,3",
+        "BriefDescription": "RD_CAS Access to Rank 7; Bank 15",
         "EventCode": "0xB7",
-        "EventName": "UNC_M_RD_CAS_RANK7.BANK6",
+        "EventName": "UNC_M_RD_CAS_RANK7.BANK15",
         "PerPkg": "1",
-        "UMask": "0x6",
+        "PublicDescription": "UNC_M_RD_CAS_RANK7.BANK15",
+        "UMask": "0xf",
         "Unit": "iMC"
     },
     {
-        "BriefDescription": "RD_CAS Access to Rank 7; Bank 7",
-        "Counter": "0,1,2,3",
+        "BriefDescription": "RD_CAS Access to Rank 7; Bank 2",
         "EventCode": "0xB7",
-        "EventName": "UNC_M_RD_CAS_RANK7.BANK7",
+        "EventName": "UNC_M_RD_CAS_RANK7.BANK2",
         "PerPkg": "1",
-        "UMask": "0x7",
+        "PublicDescription": "UNC_M_RD_CAS_RANK7.BANK2",
+        "UMask": "0x2",
         "Unit": "iMC"
     },
     {
-        "BriefDescription": "RD_CAS Access to Rank 7; Bank 9",
-        "Counter": "0,1,2,3",
+        "BriefDescription": "RD_CAS Access to Rank 7; Bank 3",
         "EventCode": "0xB7",
-        "EventName": "UNC_M_RD_CAS_RANK7.BANK9",
+        "EventName": "UNC_M_RD_CAS_RANK7.BANK3",
         "PerPkg": "1",
-        "UMask": "0x9",
+        "PublicDescription": "UNC_M_RD_CAS_RANK7.BANK3",
+        "UMask": "0x3",
         "Unit": "iMC"
     },
     {
-        "BriefDescription": "RD_CAS Access to Rank 7; Bank 10",
-        "Counter": "0,1,2,3",
+        "BriefDescription": "RD_CAS Access to Rank 7; Bank 4",
         "EventCode": "0xB7",
-        "EventName": "UNC_M_RD_CAS_RANK7.BANK10",
+        "EventName": "UNC_M_RD_CAS_RANK7.BANK4",
         "PerPkg": "1",
-        "UMask": "0xA",
+        "PublicDescription": "UNC_M_RD_CAS_RANK7.BANK4",
+        "UMask": "0x4",
         "Unit": "iMC"
     },
     {
-        "BriefDescription": "RD_CAS Access to Rank 7; Bank 11",
-        "Counter": "0,1,2,3",
+        "BriefDescription": "RD_CAS Access to Rank 7; Bank 5",
         "EventCode": "0xB7",
-        "EventName": "UNC_M_RD_CAS_RANK7.BANK11",
+        "EventName": "UNC_M_RD_CAS_RANK7.BANK5",
         "PerPkg": "1",
-        "UMask": "0xB",
+        "PublicDescription": "UNC_M_RD_CAS_RANK7.BANK5",
+        "UMask": "0x5",
         "Unit": "iMC"
     },
     {
-        "BriefDescription": "RD_CAS Access to Rank 7; Bank 12",
-        "Counter": "0,1,2,3",
+        "BriefDescription": "RD_CAS Access to Rank 7; Bank 6",
         "EventCode": "0xB7",
-        "EventName": "UNC_M_RD_CAS_RANK7.BANK12",
+        "EventName": "UNC_M_RD_CAS_RANK7.BANK6",
         "PerPkg": "1",
-        "UMask": "0xC",
+        "PublicDescription": "UNC_M_RD_CAS_RANK7.BANK6",
+        "UMask": "0x6",
         "Unit": "iMC"
     },
     {
-        "BriefDescription": "RD_CAS Access to Rank 7; Bank 13",
-        "Counter": "0,1,2,3",
+        "BriefDescription": "RD_CAS Access to Rank 7; Bank 7",
         "EventCode": "0xB7",
-        "EventName": "UNC_M_RD_CAS_RANK7.BANK13",
+        "EventName": "UNC_M_RD_CAS_RANK7.BANK7",
         "PerPkg": "1",
-        "UMask": "0xD",
+        "PublicDescription": "UNC_M_RD_CAS_RANK7.BANK7",
+        "UMask": "0x7",
         "Unit": "iMC"
     },
     {
-        "BriefDescription": "RD_CAS Access to Rank 7; Bank 14",
-        "Counter": "0,1,2,3",
+        "BriefDescription": "RD_CAS Access to Rank 7; Bank 8",
         "EventCode": "0xB7",
-        "EventName": "UNC_M_RD_CAS_RANK7.BANK14",
+        "EventName": "UNC_M_RD_CAS_RANK7.BANK8",
         "PerPkg": "1",
-        "UMask": "0xE",
+        "PublicDescription": "UNC_M_RD_CAS_RANK7.BANK8",
+        "UMask": "0x8",
         "Unit": "iMC"
     },
     {
-        "BriefDescription": "RD_CAS Access to Rank 7; Bank 15",
-        "Counter": "0,1,2,3",
+        "BriefDescription": "RD_CAS Access to Rank 7; Bank 9",
         "EventCode": "0xB7",
-        "EventName": "UNC_M_RD_CAS_RANK7.BANK15",
+        "EventName": "UNC_M_RD_CAS_RANK7.BANK9",
         "PerPkg": "1",
-        "UMask": "0xF",
+        "PublicDescription": "UNC_M_RD_CAS_RANK7.BANK9",
+        "UMask": "0x9",
         "Unit": "iMC"
     },
     {
         "BriefDescription": "RD_CAS Access to Rank 7; Bank Group 0 (Banks =
0-3)",
-        "Counter": "0,1,2,3",
         "EventCode": "0xB7",
         "EventName": "UNC_M_RD_CAS_RANK7.BANKG0",
         "PerPkg": "1",
+        "PublicDescription": "UNC_M_RD_CAS_RANK7.BANKG0",
         "UMask": "0x11",
         "Unit": "iMC"
     },
     {
         "BriefDescription": "RD_CAS Access to Rank 7; Bank Group 1 (Banks =
4-7)",
-        "Counter": "0,1,2,3",
         "EventCode": "0xB7",
         "EventName": "UNC_M_RD_CAS_RANK7.BANKG1",
         "PerPkg": "1",
+        "PublicDescription": "UNC_M_RD_CAS_RANK7.BANKG1",
         "UMask": "0x12",
         "Unit": "iMC"
     },
     {
         "BriefDescription": "RD_CAS Access to Rank 7; Bank Group 2 (Banks =
8-11)",
-        "Counter": "0,1,2,3",
         "EventCode": "0xB7",
         "EventName": "UNC_M_RD_CAS_RANK7.BANKG2",
         "PerPkg": "1",
+        "PublicDescription": "UNC_M_RD_CAS_RANK7.BANKG2",
         "UMask": "0x13",
         "Unit": "iMC"
     },
     {
         "BriefDescription": "RD_CAS Access to Rank 7; Bank Group 3 (Banks =
12-15)",
-        "Counter": "0,1,2,3",
         "EventCode": "0xB7",
         "EventName": "UNC_M_RD_CAS_RANK7.BANKG3",
         "PerPkg": "1",
+        "PublicDescription": "UNC_M_RD_CAS_RANK7.BANKG3",
         "UMask": "0x14",
         "Unit": "iMC"
     },
     {
         "BriefDescription": "Read Pending Queue Not Empty",
-        "Counter": "0,1,2,3",
         "EventCode": "0x11",
         "EventName": "UNC_M_RPQ_CYCLES_NE",
         "PerPkg": "1",
+        "PublicDescription": "Counts the number of cycles that the Read Pe=
nding Queue is not empty.  This can then be used to calculate the average o=
ccupancy (in conjunction with the Read Pending Queue Occupancy count).  The=
 RPQ is used to schedule reads out to the memory controller and to track th=
e requests.  Requests allocate into the RPQ soon after they enter the memor=
y controller, and need credits for an entry in this buffer before being sen=
t from the HA to the iMC.  They deallocate after the CAS command has been i=
ssued to memory.  This filter is to be used in conjunction with the occupan=
cy filter so that one can correctly track the average occupancies for sched=
ulable entries and scheduled requests.",
         "Unit": "iMC"
     },
     {
         "BriefDescription": "Read Pending Queue Allocations",
-        "Counter": "0,1,2,3",
         "EventCode": "0x10",
         "EventName": "UNC_M_RPQ_INSERTS",
         "PerPkg": "1",
+        "PublicDescription": "Counts the number of allocations into the Re=
ad Pending Queue.  This queue is used to schedule reads out to the memory c=
ontroller and to track the requests.  Requests allocate into the RPQ soon a=
fter they enter the memory controller, and need credits for an entry in thi=
s buffer before being sent from the HA to the iMC.  They deallocate after t=
he CAS command has been issued to memory.  This includes both ISOCH and non=
-ISOCH requests.",
         "Unit": "iMC"
     },
     {
         "BriefDescription": "VMSE MXB write buffer occupancy",
-        "Counter": "0,1,2,3",
         "EventCode": "0x91",
         "EventName": "UNC_M_VMSE_MXB_WR_OCCUPANCY",
         "PerPkg": "1",
+        "PublicDescription": "UNC_M_VMSE_MXB_WR_OCCUPANCY",
         "Unit": "iMC"
     },
     {
-        "BriefDescription": "VMSE WR PUSH issued; VMSE write PUSH issued i=
n WMM",
-        "Counter": "0,1,2,3",
+        "BriefDescription": "VMSE WR PUSH issued; VMSE write PUSH issued i=
n RMM",
         "EventCode": "0x90",
-        "EventName": "UNC_M_VMSE_WR_PUSH.WMM",
+        "EventName": "UNC_M_VMSE_WR_PUSH.RMM",
         "PerPkg": "1",
-        "UMask": "0x1",
+        "PublicDescription": "UNC_M_VMSE_WR_PUSH.RMM",
+        "UMask": "0x2",
         "Unit": "iMC"
     },
     {
-        "BriefDescription": "VMSE WR PUSH issued; VMSE write PUSH issued i=
n RMM",
-        "Counter": "0,1,2,3",
+        "BriefDescription": "VMSE WR PUSH issued; VMSE write PUSH issued i=
n WMM",
         "EventCode": "0x90",
-        "EventName": "UNC_M_VMSE_WR_PUSH.RMM",
+        "EventName": "UNC_M_VMSE_WR_PUSH.WMM",
         "PerPkg": "1",
-        "UMask": "0x2",
+        "PublicDescription": "UNC_M_VMSE_WR_PUSH.WMM",
+        "UMask": "0x1",
         "Unit": "iMC"
     },
     {
         "BriefDescription": "Transition from WMM to RMM because of low thr=
eshold; Transition from WMM to RMM because of starve counter",
-        "Counter": "0,1,2,3",
         "EventCode": "0xC0",
         "EventName": "UNC_M_WMM_TO_RMM.LOW_THRESH",
         "PerPkg": "1",
+        "PublicDescription": "UNC_M_WMM_TO_RMM.LOW_THRESH",
         "UMask": "0x1",
         "Unit": "iMC"
     },
     {
         "BriefDescription": "Transition from WMM to RMM because of low thr=
eshold",
-        "Counter": "0,1,2,3",
         "EventCode": "0xC0",
         "EventName": "UNC_M_WMM_TO_RMM.STARVE",
         "PerPkg": "1",
+        "PublicDescription": "UNC_M_WMM_TO_RMM.STARVE",
         "UMask": "0x2",
         "Unit": "iMC"
     },
     {
         "BriefDescription": "Transition from WMM to RMM because of low thr=
eshold",
-        "Counter": "0,1,2,3",
         "EventCode": "0xC0",
         "EventName": "UNC_M_WMM_TO_RMM.VMSE_RETRY",
         "PerPkg": "1",
+        "PublicDescription": "UNC_M_WMM_TO_RMM.VMSE_RETRY",
         "UMask": "0x4",
         "Unit": "iMC"
     },
     {
         "BriefDescription": "Write Pending Queue Full Cycles",
-        "Counter": "0,1,2,3",
         "EventCode": "0x22",
         "EventName": "UNC_M_WPQ_CYCLES_FULL",
         "PerPkg": "1",
+        "PublicDescription": "Counts the number of cycles when the Write P=
ending Queue is full.  When the WPQ is full, the HA will not be able to iss=
ue any additional read requests into the iMC.  This count should be similar=
 count in the HA which tracks the number of cycles that the HA has no WPQ c=
redits, just somewhat smaller to account for the credit return overhead.",
         "Unit": "iMC"
     },
     {
         "BriefDescription": "Write Pending Queue Not Empty",
-        "Counter": "0,1,2,3",
         "EventCode": "0x21",
         "EventName": "UNC_M_WPQ_CYCLES_NE",
         "PerPkg": "1",
+        "PublicDescription": "Counts the number of cycles that the Write P=
ending Queue is not empty.  This can then be used to calculate the average =
queue occupancy (in conjunction with the WPQ Occupancy Accumulation count).=
  The WPQ is used to schedule write out to the memory controller and to tra=
ck the writes.  Requests allocate into the WPQ soon after they enter the me=
mory controller, and need credits for an entry in this buffer before being =
sent from the HA to the iMC.  They deallocate after being issued to DRAM.  =
Write requests themselves are able to complete (from the perspective of the=
 rest of the system) as soon they have posted to the iMC.  This is not to b=
e confused with actually performing the write to DRAM.  Therefore, the aver=
age latency for this queue is actually not useful for deconstruction interm=
ediate write latencies.",
         "Unit": "iMC"
     },
     {
         "BriefDescription": "Write Pending Queue CAM Match",
-        "Counter": "0,1,2,3",
         "EventCode": "0x23",
         "EventName": "UNC_M_WPQ_READ_HIT",
         "PerPkg": "1",
+        "PublicDescription": "Counts the number of times a request hits in=
 the WPQ (write-pending queue).  The iMC allows writes and reads to pass up=
 other writes to different addresses.  Before a read or a write is issued, =
it will first CAM the WPQ to see if there is a write pending to that addres=
s.  When reads hit, they are able to directly pull their data from the WPQ =
instead of going to memory.  Writes that hit will overwrite the existing da=
ta.  Partial writes that hit will not need to do underfill reads and will s=
imply update their relevant sections.",
         "Unit": "iMC"
     },
     {
         "BriefDescription": "Write Pending Queue CAM Match",
-        "Counter": "0,1,2,3",
         "EventCode": "0x24",
         "EventName": "UNC_M_WPQ_WRITE_HIT",
         "PerPkg": "1",
+        "PublicDescription": "Counts the number of times a request hits in=
 the WPQ (write-pending queue).  The iMC allows writes and reads to pass up=
 other writes to different addresses.  Before a read or a write is issued, =
it will first CAM the WPQ to see if there is a write pending to that addres=
s.  When reads hit, they are able to directly pull their data from the WPQ =
instead of going to memory.  Writes that hit will overwrite the existing da=
ta.  Partial writes that hit will not need to do underfill reads and will s=
imply update their relevant sections.",
         "Unit": "iMC"
     },
     {
         "BriefDescription": "Not getting the requested Major Mode",
-        "Counter": "0,1,2,3",
         "EventCode": "0xC1",
         "EventName": "UNC_M_WRONG_MM",
         "PerPkg": "1",
+        "PublicDescription": "UNC_M_WRONG_MM",
+        "Unit": "iMC"
+    },
+    {
+        "BriefDescription": "WR_CAS Access to Rank 0; All Banks",
+        "EventCode": "0xB8",
+        "EventName": "UNC_M_WR_CAS_RANK0.ALLBANKS",
+        "PerPkg": "1",
+        "PublicDescription": "UNC_M_WR_CAS_RANK0.ALLBANKS",
+        "UMask": "0x10",
+        "Unit": "iMC"
+    },
+    {
+        "BriefDescription": "WR_CAS Access to Rank 0; Bank 0",
+        "EventCode": "0xB8",
+        "EventName": "UNC_M_WR_CAS_RANK0.BANK0",
+        "PerPkg": "1",
+        "PublicDescription": "UNC_M_WR_CAS_RANK0.BANK0",
         "Unit": "iMC"
     },
     {
         "BriefDescription": "WR_CAS Access to Rank 0; Bank 1",
-        "Counter": "0,1,2,3",
         "EventCode": "0xB8",
         "EventName": "UNC_M_WR_CAS_RANK0.BANK1",
         "PerPkg": "1",
+        "PublicDescription": "UNC_M_WR_CAS_RANK0.BANK1",
         "UMask": "0x1",
         "Unit": "iMC"
     },
     {
-        "BriefDescription": "WR_CAS Access to Rank 0; Bank 2",
-        "Counter": "0,1,2,3",
+        "BriefDescription": "WR_CAS Access to Rank 0; Bank 10",
         "EventCode": "0xB8",
-        "EventName": "UNC_M_WR_CAS_RANK0.BANK2",
+        "EventName": "UNC_M_WR_CAS_RANK0.BANK10",
         "PerPkg": "1",
-        "UMask": "0x2",
+        "PublicDescription": "UNC_M_WR_CAS_RANK0.BANK10",
+        "UMask": "0xa",
         "Unit": "iMC"
     },
     {
-        "BriefDescription": "WR_CAS Access to Rank 0; Bank 4",
-        "Counter": "0,1,2,3",
+        "BriefDescription": "WR_CAS Access to Rank 0; Bank 11",
         "EventCode": "0xB8",
-        "EventName": "UNC_M_WR_CAS_RANK0.BANK4",
+        "EventName": "UNC_M_WR_CAS_RANK0.BANK11",
         "PerPkg": "1",
-        "UMask": "0x4",
+        "PublicDescription": "UNC_M_WR_CAS_RANK0.BANK11",
+        "UMask": "0xb",
         "Unit": "iMC"
     },
     {
-        "BriefDescription": "WR_CAS Access to Rank 0; Bank 8",
-        "Counter": "0,1,2,3",
+        "BriefDescription": "WR_CAS Access to Rank 0; Bank 12",
         "EventCode": "0xB8",
-        "EventName": "UNC_M_WR_CAS_RANK0.BANK8",
+        "EventName": "UNC_M_WR_CAS_RANK0.BANK12",
         "PerPkg": "1",
-        "UMask": "0x8",
+        "PublicDescription": "UNC_M_WR_CAS_RANK0.BANK12",
+        "UMask": "0xc",
         "Unit": "iMC"
     },
     {
-        "BriefDescription": "WR_CAS Access to Rank 0; All Banks",
-        "Counter": "0,1,2,3",
+        "BriefDescription": "WR_CAS Access to Rank 0; Bank 13",
         "EventCode": "0xB8",
-        "EventName": "UNC_M_WR_CAS_RANK0.ALLBANKS",
+        "EventName": "UNC_M_WR_CAS_RANK0.BANK13",
         "PerPkg": "1",
-        "UMask": "0x10",
+        "PublicDescription": "UNC_M_WR_CAS_RANK0.BANK13",
+        "UMask": "0xd",
         "Unit": "iMC"
     },
     {
-        "BriefDescription": "WR_CAS Access to Rank 0; Bank 0",
-        "Counter": "0,1,2,3",
+        "BriefDescription": "WR_CAS Access to Rank 0; Bank 14",
         "EventCode": "0xB8",
-        "EventName": "UNC_M_WR_CAS_RANK0.BANK0",
+        "EventName": "UNC_M_WR_CAS_RANK0.BANK14",
+        "PerPkg": "1",
+        "PublicDescription": "UNC_M_WR_CAS_RANK0.BANK14",
+        "UMask": "0xe",
+        "Unit": "iMC"
+    },
+    {
+        "BriefDescription": "WR_CAS Access to Rank 0; Bank 15",
+        "EventCode": "0xB8",
+        "EventName": "UNC_M_WR_CAS_RANK0.BANK15",
+        "PerPkg": "1",
+        "PublicDescription": "UNC_M_WR_CAS_RANK0.BANK15",
+        "UMask": "0xf",
+        "Unit": "iMC"
+    },
+    {
+        "BriefDescription": "WR_CAS Access to Rank 0; Bank 2",
+        "EventCode": "0xB8",
+        "EventName": "UNC_M_WR_CAS_RANK0.BANK2",
         "PerPkg": "1",
+        "PublicDescription": "UNC_M_WR_CAS_RANK0.BANK2",
+        "UMask": "0x2",
         "Unit": "iMC"
     },
     {
         "BriefDescription": "WR_CAS Access to Rank 0; Bank 3",
-        "Counter": "0,1,2,3",
         "EventCode": "0xB8",
         "EventName": "UNC_M_WR_CAS_RANK0.BANK3",
         "PerPkg": "1",
+        "PublicDescription": "UNC_M_WR_CAS_RANK0.BANK3",
         "UMask": "0x3",
         "Unit": "iMC"
     },
+    {
+        "BriefDescription": "WR_CAS Access to Rank 0; Bank 4",
+        "EventCode": "0xB8",
+        "EventName": "UNC_M_WR_CAS_RANK0.BANK4",
+        "PerPkg": "1",
+        "PublicDescription": "UNC_M_WR_CAS_RANK0.BANK4",
+        "UMask": "0x4",
+        "Unit": "iMC"
+    },
     {
         "BriefDescription": "WR_CAS Access to Rank 0; Bank 5",
-        "Counter": "0,1,2,3",
         "EventCode": "0xB8",
         "EventName": "UNC_M_WR_CAS_RANK0.BANK5",
         "PerPkg": "1",
+        "PublicDescription": "UNC_M_WR_CAS_RANK0.BANK5",
         "UMask": "0x5",
         "Unit": "iMC"
     },
     {
         "BriefDescription": "WR_CAS Access to Rank 0; Bank 6",
-        "Counter": "0,1,2,3",
         "EventCode": "0xB8",
         "EventName": "UNC_M_WR_CAS_RANK0.BANK6",
         "PerPkg": "1",
+        "PublicDescription": "UNC_M_WR_CAS_RANK0.BANK6",
         "UMask": "0x6",
         "Unit": "iMC"
     },
     {
         "BriefDescription": "WR_CAS Access to Rank 0; Bank 7",
-        "Counter": "0,1,2,3",
         "EventCode": "0xB8",
         "EventName": "UNC_M_WR_CAS_RANK0.BANK7",
         "PerPkg": "1",
+        "PublicDescription": "UNC_M_WR_CAS_RANK0.BANK7",
         "UMask": "0x7",
         "Unit": "iMC"
     },
     {
-        "BriefDescription": "WR_CAS Access to Rank 0; Bank 9",
-        "Counter": "0,1,2,3",
+        "BriefDescription": "WR_CAS Access to Rank 0; Bank 8",
         "EventCode": "0xB8",
-        "EventName": "UNC_M_WR_CAS_RANK0.BANK9",
+        "EventName": "UNC_M_WR_CAS_RANK0.BANK8",
         "PerPkg": "1",
-        "UMask": "0x9",
+        "PublicDescription": "UNC_M_WR_CAS_RANK0.BANK8",
+        "UMask": "0x8",
         "Unit": "iMC"
     },
     {
-        "BriefDescription": "WR_CAS Access to Rank 0; Bank 10",
-        "Counter": "0,1,2,3",
+        "BriefDescription": "WR_CAS Access to Rank 0; Bank 9",
         "EventCode": "0xB8",
-        "EventName": "UNC_M_WR_CAS_RANK0.BANK10",
+        "EventName": "UNC_M_WR_CAS_RANK0.BANK9",
         "PerPkg": "1",
-        "UMask": "0xA",
-        "Unit": "iMC"
-    },
-    {
-        "BriefDescription": "WR_CAS Access to Rank 0; Bank 11",
-        "Counter": "0,1,2,3",
-        "EventCode": "0xB8",
-        "EventName": "UNC_M_WR_CAS_RANK0.BANK11",
-        "PerPkg": "1",
-        "UMask": "0xB",
-        "Unit": "iMC"
-    },
-    {
-        "BriefDescription": "WR_CAS Access to Rank 0; Bank 12",
-        "Counter": "0,1,2,3",
-        "EventCode": "0xB8",
-        "EventName": "UNC_M_WR_CAS_RANK0.BANK12",
-        "PerPkg": "1",
-        "UMask": "0xC",
-        "Unit": "iMC"
-    },
-    {
-        "BriefDescription": "WR_CAS Access to Rank 0; Bank 13",
-        "Counter": "0,1,2,3",
-        "EventCode": "0xB8",
-        "EventName": "UNC_M_WR_CAS_RANK0.BANK13",
-        "PerPkg": "1",
-        "UMask": "0xD",
-        "Unit": "iMC"
-    },
-    {
-        "BriefDescription": "WR_CAS Access to Rank 0; Bank 14",
-        "Counter": "0,1,2,3",
-        "EventCode": "0xB8",
-        "EventName": "UNC_M_WR_CAS_RANK0.BANK14",
-        "PerPkg": "1",
-        "UMask": "0xE",
-        "Unit": "iMC"
-    },
-    {
-        "BriefDescription": "WR_CAS Access to Rank 0; Bank 15",
-        "Counter": "0,1,2,3",
-        "EventCode": "0xB8",
-        "EventName": "UNC_M_WR_CAS_RANK0.BANK15",
-        "PerPkg": "1",
-        "UMask": "0xF",
+        "PublicDescription": "UNC_M_WR_CAS_RANK0.BANK9",
+        "UMask": "0x9",
         "Unit": "iMC"
     },
     {
         "BriefDescription": "WR_CAS Access to Rank 0; Bank Group 0 (Banks =
0-3)",
-        "Counter": "0,1,2,3",
         "EventCode": "0xB8",
         "EventName": "UNC_M_WR_CAS_RANK0.BANKG0",
         "PerPkg": "1",
+        "PublicDescription": "UNC_M_WR_CAS_RANK0.BANKG0",
         "UMask": "0x11",
         "Unit": "iMC"
     },
     {
         "BriefDescription": "WR_CAS Access to Rank 0; Bank Group 1 (Banks =
4-7)",
-        "Counter": "0,1,2,3",
         "EventCode": "0xB8",
         "EventName": "UNC_M_WR_CAS_RANK0.BANKG1",
         "PerPkg": "1",
+        "PublicDescription": "UNC_M_WR_CAS_RANK0.BANKG1",
         "UMask": "0x12",
         "Unit": "iMC"
     },
     {
         "BriefDescription": "WR_CAS Access to Rank 0; Bank Group 2 (Banks =
8-11)",
-        "Counter": "0,1,2,3",
         "EventCode": "0xB8",
         "EventName": "UNC_M_WR_CAS_RANK0.BANKG2",
         "PerPkg": "1",
+        "PublicDescription": "UNC_M_WR_CAS_RANK0.BANKG2",
         "UMask": "0x13",
         "Unit": "iMC"
     },
     {
         "BriefDescription": "WR_CAS Access to Rank 0; Bank Group 3 (Banks =
12-15)",
-        "Counter": "0,1,2,3",
         "EventCode": "0xB8",
         "EventName": "UNC_M_WR_CAS_RANK0.BANKG3",
         "PerPkg": "1",
+        "PublicDescription": "UNC_M_WR_CAS_RANK0.BANKG3",
         "UMask": "0x14",
         "Unit": "iMC"
     },
     {
-        "BriefDescription": "WR_CAS Access to Rank 1; Bank 1",
-        "Counter": "0,1,2,3",
+        "BriefDescription": "WR_CAS Access to Rank 1; All Banks",
         "EventCode": "0xB9",
-        "EventName": "UNC_M_WR_CAS_RANK1.BANK1",
+        "EventName": "UNC_M_WR_CAS_RANK1.ALLBANKS",
         "PerPkg": "1",
-        "UMask": "0x1",
+        "PublicDescription": "UNC_M_WR_CAS_RANK1.ALLBANKS",
+        "UMask": "0x10",
         "Unit": "iMC"
     },
     {
-        "BriefDescription": "WR_CAS Access to Rank 1; Bank 2",
-        "Counter": "0,1,2,3",
+        "BriefDescription": "WR_CAS Access to Rank 1; Bank 0",
         "EventCode": "0xB9",
-        "EventName": "UNC_M_WR_CAS_RANK1.BANK2",
+        "EventName": "UNC_M_WR_CAS_RANK1.BANK0",
         "PerPkg": "1",
-        "UMask": "0x2",
+        "PublicDescription": "UNC_M_WR_CAS_RANK1.BANK0",
         "Unit": "iMC"
     },
     {
-        "BriefDescription": "WR_CAS Access to Rank 1; Bank 4",
-        "Counter": "0,1,2,3",
+        "BriefDescription": "WR_CAS Access to Rank 1; Bank 1",
         "EventCode": "0xB9",
-        "EventName": "UNC_M_WR_CAS_RANK1.BANK4",
+        "EventName": "UNC_M_WR_CAS_RANK1.BANK1",
         "PerPkg": "1",
-        "UMask": "0x4",
+        "PublicDescription": "UNC_M_WR_CAS_RANK1.BANK1",
+        "UMask": "0x1",
         "Unit": "iMC"
     },
     {
-        "BriefDescription": "WR_CAS Access to Rank 1; Bank 8",
-        "Counter": "0,1,2,3",
+        "BriefDescription": "WR_CAS Access to Rank 1; Bank 10",
         "EventCode": "0xB9",
-        "EventName": "UNC_M_WR_CAS_RANK1.BANK8",
+        "EventName": "UNC_M_WR_CAS_RANK1.BANK10",
         "PerPkg": "1",
-        "UMask": "0x8",
+        "PublicDescription": "UNC_M_WR_CAS_RANK1.BANK10",
+        "UMask": "0xa",
         "Unit": "iMC"
     },
     {
-        "BriefDescription": "WR_CAS Access to Rank 1; All Banks",
-        "Counter": "0,1,2,3",
+        "BriefDescription": "WR_CAS Access to Rank 1; Bank 11",
         "EventCode": "0xB9",
-        "EventName": "UNC_M_WR_CAS_RANK1.ALLBANKS",
+        "EventName": "UNC_M_WR_CAS_RANK1.BANK11",
         "PerPkg": "1",
-        "UMask": "0x10",
+        "PublicDescription": "UNC_M_WR_CAS_RANK1.BANK11",
+        "UMask": "0xb",
         "Unit": "iMC"
     },
     {
-        "BriefDescription": "WR_CAS Access to Rank 1; Bank 0",
-        "Counter": "0,1,2,3",
+        "BriefDescription": "WR_CAS Access to Rank 1; Bank 12",
         "EventCode": "0xB9",
-        "EventName": "UNC_M_WR_CAS_RANK1.BANK0",
+        "EventName": "UNC_M_WR_CAS_RANK1.BANK12",
         "PerPkg": "1",
+        "PublicDescription": "UNC_M_WR_CAS_RANK1.BANK12",
+        "UMask": "0xc",
         "Unit": "iMC"
     },
     {
-        "BriefDescription": "WR_CAS Access to Rank 1; Bank 3",
-        "Counter": "0,1,2,3",
+        "BriefDescription": "WR_CAS Access to Rank 1; Bank 13",
         "EventCode": "0xB9",
-        "EventName": "UNC_M_WR_CAS_RANK1.BANK3",
+        "EventName": "UNC_M_WR_CAS_RANK1.BANK13",
         "PerPkg": "1",
-        "UMask": "0x3",
+        "PublicDescription": "UNC_M_WR_CAS_RANK1.BANK13",
+        "UMask": "0xd",
         "Unit": "iMC"
     },
     {
-        "BriefDescription": "WR_CAS Access to Rank 1; Bank 5",
-        "Counter": "0,1,2,3",
+        "BriefDescription": "WR_CAS Access to Rank 1; Bank 14",
         "EventCode": "0xB9",
-        "EventName": "UNC_M_WR_CAS_RANK1.BANK5",
+        "EventName": "UNC_M_WR_CAS_RANK1.BANK14",
         "PerPkg": "1",
-        "UMask": "0x5",
+        "PublicDescription": "UNC_M_WR_CAS_RANK1.BANK14",
+        "UMask": "0xe",
         "Unit": "iMC"
     },
     {
-        "BriefDescription": "WR_CAS Access to Rank 1; Bank 6",
-        "Counter": "0,1,2,3",
+        "BriefDescription": "WR_CAS Access to Rank 1; Bank 15",
         "EventCode": "0xB9",
-        "EventName": "UNC_M_WR_CAS_RANK1.BANK6",
+        "EventName": "UNC_M_WR_CAS_RANK1.BANK15",
         "PerPkg": "1",
-        "UMask": "0x6",
+        "PublicDescription": "UNC_M_WR_CAS_RANK1.BANK15",
+        "UMask": "0xf",
         "Unit": "iMC"
     },
     {
-        "BriefDescription": "WR_CAS Access to Rank 1; Bank 7",
-        "Counter": "0,1,2,3",
+        "BriefDescription": "WR_CAS Access to Rank 1; Bank 2",
         "EventCode": "0xB9",
-        "EventName": "UNC_M_WR_CAS_RANK1.BANK7",
+        "EventName": "UNC_M_WR_CAS_RANK1.BANK2",
         "PerPkg": "1",
-        "UMask": "0x7",
+        "PublicDescription": "UNC_M_WR_CAS_RANK1.BANK2",
+        "UMask": "0x2",
         "Unit": "iMC"
     },
     {
-        "BriefDescription": "WR_CAS Access to Rank 1; Bank 9",
-        "Counter": "0,1,2,3",
+        "BriefDescription": "WR_CAS Access to Rank 1; Bank 3",
         "EventCode": "0xB9",
-        "EventName": "UNC_M_WR_CAS_RANK1.BANK9",
+        "EventName": "UNC_M_WR_CAS_RANK1.BANK3",
         "PerPkg": "1",
-        "UMask": "0x9",
+        "PublicDescription": "UNC_M_WR_CAS_RANK1.BANK3",
+        "UMask": "0x3",
         "Unit": "iMC"
     },
     {
-        "BriefDescription": "WR_CAS Access to Rank 1; Bank 10",
-        "Counter": "0,1,2,3",
+        "BriefDescription": "WR_CAS Access to Rank 1; Bank 4",
         "EventCode": "0xB9",
-        "EventName": "UNC_M_WR_CAS_RANK1.BANK10",
+        "EventName": "UNC_M_WR_CAS_RANK1.BANK4",
         "PerPkg": "1",
-        "UMask": "0xA",
+        "PublicDescription": "UNC_M_WR_CAS_RANK1.BANK4",
+        "UMask": "0x4",
         "Unit": "iMC"
     },
     {
-        "BriefDescription": "WR_CAS Access to Rank 1; Bank 11",
-        "Counter": "0,1,2,3",
+        "BriefDescription": "WR_CAS Access to Rank 1; Bank 5",
         "EventCode": "0xB9",
-        "EventName": "UNC_M_WR_CAS_RANK1.BANK11",
+        "EventName": "UNC_M_WR_CAS_RANK1.BANK5",
         "PerPkg": "1",
-        "UMask": "0xB",
+        "PublicDescription": "UNC_M_WR_CAS_RANK1.BANK5",
+        "UMask": "0x5",
         "Unit": "iMC"
     },
     {
-        "BriefDescription": "WR_CAS Access to Rank 1; Bank 12",
-        "Counter": "0,1,2,3",
+        "BriefDescription": "WR_CAS Access to Rank 1; Bank 6",
         "EventCode": "0xB9",
-        "EventName": "UNC_M_WR_CAS_RANK1.BANK12",
+        "EventName": "UNC_M_WR_CAS_RANK1.BANK6",
         "PerPkg": "1",
-        "UMask": "0xC",
+        "PublicDescription": "UNC_M_WR_CAS_RANK1.BANK6",
+        "UMask": "0x6",
         "Unit": "iMC"
     },
     {
-        "BriefDescription": "WR_CAS Access to Rank 1; Bank 13",
-        "Counter": "0,1,2,3",
+        "BriefDescription": "WR_CAS Access to Rank 1; Bank 7",
         "EventCode": "0xB9",
-        "EventName": "UNC_M_WR_CAS_RANK1.BANK13",
+        "EventName": "UNC_M_WR_CAS_RANK1.BANK7",
         "PerPkg": "1",
-        "UMask": "0xD",
+        "PublicDescription": "UNC_M_WR_CAS_RANK1.BANK7",
+        "UMask": "0x7",
         "Unit": "iMC"
     },
     {
-        "BriefDescription": "WR_CAS Access to Rank 1; Bank 14",
-        "Counter": "0,1,2,3",
+        "BriefDescription": "WR_CAS Access to Rank 1; Bank 8",
         "EventCode": "0xB9",
-        "EventName": "UNC_M_WR_CAS_RANK1.BANK14",
+        "EventName": "UNC_M_WR_CAS_RANK1.BANK8",
         "PerPkg": "1",
-        "UMask": "0xE",
+        "PublicDescription": "UNC_M_WR_CAS_RANK1.BANK8",
+        "UMask": "0x8",
         "Unit": "iMC"
     },
     {
-        "BriefDescription": "WR_CAS Access to Rank 1; Bank 15",
-        "Counter": "0,1,2,3",
+        "BriefDescription": "WR_CAS Access to Rank 1; Bank 9",
         "EventCode": "0xB9",
-        "EventName": "UNC_M_WR_CAS_RANK1.BANK15",
+        "EventName": "UNC_M_WR_CAS_RANK1.BANK9",
         "PerPkg": "1",
-        "UMask": "0xF",
+        "PublicDescription": "UNC_M_WR_CAS_RANK1.BANK9",
+        "UMask": "0x9",
         "Unit": "iMC"
     },
     {
         "BriefDescription": "WR_CAS Access to Rank 1; Bank Group 0 (Banks =
0-3)",
-        "Counter": "0,1,2,3",
         "EventCode": "0xB9",
         "EventName": "UNC_M_WR_CAS_RANK1.BANKG0",
         "PerPkg": "1",
+        "PublicDescription": "UNC_M_WR_CAS_RANK1.BANKG0",
         "UMask": "0x11",
         "Unit": "iMC"
     },
     {
         "BriefDescription": "WR_CAS Access to Rank 1; Bank Group 1 (Banks =
4-7)",
-        "Counter": "0,1,2,3",
         "EventCode": "0xB9",
         "EventName": "UNC_M_WR_CAS_RANK1.BANKG1",
         "PerPkg": "1",
+        "PublicDescription": "UNC_M_WR_CAS_RANK1.BANKG1",
         "UMask": "0x12",
         "Unit": "iMC"
     },
     {
         "BriefDescription": "WR_CAS Access to Rank 1; Bank Group 2 (Banks =
8-11)",
-        "Counter": "0,1,2,3",
         "EventCode": "0xB9",
         "EventName": "UNC_M_WR_CAS_RANK1.BANKG2",
         "PerPkg": "1",
+        "PublicDescription": "UNC_M_WR_CAS_RANK1.BANKG2",
         "UMask": "0x13",
         "Unit": "iMC"
     },
     {
         "BriefDescription": "WR_CAS Access to Rank 1; Bank Group 3 (Banks =
12-15)",
-        "Counter": "0,1,2,3",
         "EventCode": "0xB9",
         "EventName": "UNC_M_WR_CAS_RANK1.BANKG3",
         "PerPkg": "1",
+        "PublicDescription": "UNC_M_WR_CAS_RANK1.BANKG3",
         "UMask": "0x14",
         "Unit": "iMC"
     },
     {
-        "BriefDescription": "WR_CAS Access to Rank 4; Bank 1",
-        "Counter": "0,1,2,3",
+        "BriefDescription": "WR_CAS Access to Rank 4; All Banks",
         "EventCode": "0xBC",
-        "EventName": "UNC_M_WR_CAS_RANK4.BANK1",
+        "EventName": "UNC_M_WR_CAS_RANK4.ALLBANKS",
         "PerPkg": "1",
-        "UMask": "0x1",
+        "PublicDescription": "UNC_M_WR_CAS_RANK4.ALLBANKS",
+        "UMask": "0x10",
         "Unit": "iMC"
     },
     {
-        "BriefDescription": "WR_CAS Access to Rank 4; Bank 2",
-        "Counter": "0,1,2,3",
+        "BriefDescription": "WR_CAS Access to Rank 4; Bank 0",
         "EventCode": "0xBC",
-        "EventName": "UNC_M_WR_CAS_RANK4.BANK2",
+        "EventName": "UNC_M_WR_CAS_RANK4.BANK0",
         "PerPkg": "1",
-        "UMask": "0x2",
+        "PublicDescription": "UNC_M_WR_CAS_RANK4.BANK0",
         "Unit": "iMC"
     },
     {
-        "BriefDescription": "WR_CAS Access to Rank 4; Bank 4",
-        "Counter": "0,1,2,3",
+        "BriefDescription": "WR_CAS Access to Rank 4; Bank 1",
         "EventCode": "0xBC",
-        "EventName": "UNC_M_WR_CAS_RANK4.BANK4",
+        "EventName": "UNC_M_WR_CAS_RANK4.BANK1",
         "PerPkg": "1",
-        "UMask": "0x4",
+        "PublicDescription": "UNC_M_WR_CAS_RANK4.BANK1",
+        "UMask": "0x1",
         "Unit": "iMC"
     },
     {
-        "BriefDescription": "WR_CAS Access to Rank 4; Bank 8",
-        "Counter": "0,1,2,3",
+        "BriefDescription": "WR_CAS Access to Rank 4; Bank 10",
         "EventCode": "0xBC",
-        "EventName": "UNC_M_WR_CAS_RANK4.BANK8",
+        "EventName": "UNC_M_WR_CAS_RANK4.BANK10",
         "PerPkg": "1",
-        "UMask": "0x8",
+        "PublicDescription": "UNC_M_WR_CAS_RANK4.BANK10",
+        "UMask": "0xa",
         "Unit": "iMC"
     },
     {
-        "BriefDescription": "WR_CAS Access to Rank 4; All Banks",
-        "Counter": "0,1,2,3",
+        "BriefDescription": "WR_CAS Access to Rank 4; Bank 11",
         "EventCode": "0xBC",
-        "EventName": "UNC_M_WR_CAS_RANK4.ALLBANKS",
+        "EventName": "UNC_M_WR_CAS_RANK4.BANK11",
         "PerPkg": "1",
-        "UMask": "0x10",
+        "PublicDescription": "UNC_M_WR_CAS_RANK4.BANK11",
+        "UMask": "0xb",
         "Unit": "iMC"
     },
     {
-        "BriefDescription": "WR_CAS Access to Rank 4; Bank 0",
-        "Counter": "0,1,2,3",
+        "BriefDescription": "WR_CAS Access to Rank 4; Bank 12",
         "EventCode": "0xBC",
-        "EventName": "UNC_M_WR_CAS_RANK4.BANK0",
+        "EventName": "UNC_M_WR_CAS_RANK4.BANK12",
         "PerPkg": "1",
+        "PublicDescription": "UNC_M_WR_CAS_RANK4.BANK12",
+        "UMask": "0xc",
         "Unit": "iMC"
     },
     {
-        "BriefDescription": "WR_CAS Access to Rank 4; Bank 3",
-        "Counter": "0,1,2,3",
+        "BriefDescription": "WR_CAS Access to Rank 4; Bank 13",
         "EventCode": "0xBC",
-        "EventName": "UNC_M_WR_CAS_RANK4.BANK3",
+        "EventName": "UNC_M_WR_CAS_RANK4.BANK13",
         "PerPkg": "1",
-        "UMask": "0x3",
+        "PublicDescription": "UNC_M_WR_CAS_RANK4.BANK13",
+        "UMask": "0xd",
         "Unit": "iMC"
     },
     {
-        "BriefDescription": "WR_CAS Access to Rank 4; Bank 5",
-        "Counter": "0,1,2,3",
+        "BriefDescription": "WR_CAS Access to Rank 4; Bank 14",
         "EventCode": "0xBC",
-        "EventName": "UNC_M_WR_CAS_RANK4.BANK5",
+        "EventName": "UNC_M_WR_CAS_RANK4.BANK14",
         "PerPkg": "1",
-        "UMask": "0x5",
+        "PublicDescription": "UNC_M_WR_CAS_RANK4.BANK14",
+        "UMask": "0xe",
         "Unit": "iMC"
     },
     {
-        "BriefDescription": "WR_CAS Access to Rank 4; Bank 6",
-        "Counter": "0,1,2,3",
+        "BriefDescription": "WR_CAS Access to Rank 4; Bank 15",
         "EventCode": "0xBC",
-        "EventName": "UNC_M_WR_CAS_RANK4.BANK6",
+        "EventName": "UNC_M_WR_CAS_RANK4.BANK15",
         "PerPkg": "1",
-        "UMask": "0x6",
+        "PublicDescription": "UNC_M_WR_CAS_RANK4.BANK15",
+        "UMask": "0xf",
         "Unit": "iMC"
     },
     {
-        "BriefDescription": "WR_CAS Access to Rank 4; Bank 7",
-        "Counter": "0,1,2,3",
+        "BriefDescription": "WR_CAS Access to Rank 4; Bank 2",
         "EventCode": "0xBC",
-        "EventName": "UNC_M_WR_CAS_RANK4.BANK7",
+        "EventName": "UNC_M_WR_CAS_RANK4.BANK2",
         "PerPkg": "1",
-        "UMask": "0x7",
+        "PublicDescription": "UNC_M_WR_CAS_RANK4.BANK2",
+        "UMask": "0x2",
         "Unit": "iMC"
     },
     {
-        "BriefDescription": "WR_CAS Access to Rank 4; Bank 9",
-        "Counter": "0,1,2,3",
+        "BriefDescription": "WR_CAS Access to Rank 4; Bank 3",
         "EventCode": "0xBC",
-        "EventName": "UNC_M_WR_CAS_RANK4.BANK9",
+        "EventName": "UNC_M_WR_CAS_RANK4.BANK3",
         "PerPkg": "1",
-        "UMask": "0x9",
+        "PublicDescription": "UNC_M_WR_CAS_RANK4.BANK3",
+        "UMask": "0x3",
         "Unit": "iMC"
     },
     {
-        "BriefDescription": "WR_CAS Access to Rank 4; Bank 10",
-        "Counter": "0,1,2,3",
+        "BriefDescription": "WR_CAS Access to Rank 4; Bank 4",
         "EventCode": "0xBC",
-        "EventName": "UNC_M_WR_CAS_RANK4.BANK10",
+        "EventName": "UNC_M_WR_CAS_RANK4.BANK4",
         "PerPkg": "1",
-        "UMask": "0xA",
+        "PublicDescription": "UNC_M_WR_CAS_RANK4.BANK4",
+        "UMask": "0x4",
         "Unit": "iMC"
     },
     {
-        "BriefDescription": "WR_CAS Access to Rank 4; Bank 11",
-        "Counter": "0,1,2,3",
+        "BriefDescription": "WR_CAS Access to Rank 4; Bank 5",
         "EventCode": "0xBC",
-        "EventName": "UNC_M_WR_CAS_RANK4.BANK11",
+        "EventName": "UNC_M_WR_CAS_RANK4.BANK5",
         "PerPkg": "1",
-        "UMask": "0xB",
+        "PublicDescription": "UNC_M_WR_CAS_RANK4.BANK5",
+        "UMask": "0x5",
         "Unit": "iMC"
     },
     {
-        "BriefDescription": "WR_CAS Access to Rank 4; Bank 12",
-        "Counter": "0,1,2,3",
+        "BriefDescription": "WR_CAS Access to Rank 4; Bank 6",
         "EventCode": "0xBC",
-        "EventName": "UNC_M_WR_CAS_RANK4.BANK12",
+        "EventName": "UNC_M_WR_CAS_RANK4.BANK6",
         "PerPkg": "1",
-        "UMask": "0xC",
+        "PublicDescription": "UNC_M_WR_CAS_RANK4.BANK6",
+        "UMask": "0x6",
         "Unit": "iMC"
     },
     {
-        "BriefDescription": "WR_CAS Access to Rank 4; Bank 13",
-        "Counter": "0,1,2,3",
+        "BriefDescription": "WR_CAS Access to Rank 4; Bank 7",
         "EventCode": "0xBC",
-        "EventName": "UNC_M_WR_CAS_RANK4.BANK13",
+        "EventName": "UNC_M_WR_CAS_RANK4.BANK7",
         "PerPkg": "1",
-        "UMask": "0xD",
+        "PublicDescription": "UNC_M_WR_CAS_RANK4.BANK7",
+        "UMask": "0x7",
         "Unit": "iMC"
     },
     {
-        "BriefDescription": "WR_CAS Access to Rank 4; Bank 14",
-        "Counter": "0,1,2,3",
+        "BriefDescription": "WR_CAS Access to Rank 4; Bank 8",
         "EventCode": "0xBC",
-        "EventName": "UNC_M_WR_CAS_RANK4.BANK14",
+        "EventName": "UNC_M_WR_CAS_RANK4.BANK8",
         "PerPkg": "1",
-        "UMask": "0xE",
+        "PublicDescription": "UNC_M_WR_CAS_RANK4.BANK8",
+        "UMask": "0x8",
         "Unit": "iMC"
     },
     {
-        "BriefDescription": "WR_CAS Access to Rank 4; Bank 15",
-        "Counter": "0,1,2,3",
+        "BriefDescription": "WR_CAS Access to Rank 4; Bank 9",
         "EventCode": "0xBC",
-        "EventName": "UNC_M_WR_CAS_RANK4.BANK15",
+        "EventName": "UNC_M_WR_CAS_RANK4.BANK9",
         "PerPkg": "1",
-        "UMask": "0xF",
+        "PublicDescription": "UNC_M_WR_CAS_RANK4.BANK9",
+        "UMask": "0x9",
         "Unit": "iMC"
     },
     {
         "BriefDescription": "WR_CAS Access to Rank 4; Bank Group 0 (Banks =
0-3)",
-        "Counter": "0,1,2,3",
         "EventCode": "0xBC",
         "EventName": "UNC_M_WR_CAS_RANK4.BANKG0",
         "PerPkg": "1",
+        "PublicDescription": "UNC_M_WR_CAS_RANK4.BANKG0",
         "UMask": "0x11",
         "Unit": "iMC"
     },
     {
         "BriefDescription": "WR_CAS Access to Rank 4; Bank Group 1 (Banks =
4-7)",
-        "Counter": "0,1,2,3",
         "EventCode": "0xBC",
         "EventName": "UNC_M_WR_CAS_RANK4.BANKG1",
         "PerPkg": "1",
+        "PublicDescription": "UNC_M_WR_CAS_RANK4.BANKG1",
         "UMask": "0x12",
         "Unit": "iMC"
     },
     {
         "BriefDescription": "WR_CAS Access to Rank 4; Bank Group 2 (Banks =
8-11)",
-        "Counter": "0,1,2,3",
         "EventCode": "0xBC",
         "EventName": "UNC_M_WR_CAS_RANK4.BANKG2",
         "PerPkg": "1",
+        "PublicDescription": "UNC_M_WR_CAS_RANK4.BANKG2",
         "UMask": "0x13",
         "Unit": "iMC"
     },
     {
         "BriefDescription": "WR_CAS Access to Rank 4; Bank Group 3 (Banks =
12-15)",
-        "Counter": "0,1,2,3",
         "EventCode": "0xBC",
         "EventName": "UNC_M_WR_CAS_RANK4.BANKG3",
         "PerPkg": "1",
+        "PublicDescription": "UNC_M_WR_CAS_RANK4.BANKG3",
         "UMask": "0x14",
         "Unit": "iMC"
     },
     {
-        "BriefDescription": "WR_CAS Access to Rank 5; Bank 1",
-        "Counter": "0,1,2,3",
+        "BriefDescription": "WR_CAS Access to Rank 5; All Banks",
         "EventCode": "0xBD",
-        "EventName": "UNC_M_WR_CAS_RANK5.BANK1",
+        "EventName": "UNC_M_WR_CAS_RANK5.ALLBANKS",
         "PerPkg": "1",
-        "UMask": "0x1",
+        "PublicDescription": "UNC_M_WR_CAS_RANK5.ALLBANKS",
+        "UMask": "0x10",
         "Unit": "iMC"
     },
     {
-        "BriefDescription": "WR_CAS Access to Rank 5; Bank 2",
-        "Counter": "0,1,2,3",
+        "BriefDescription": "WR_CAS Access to Rank 5; Bank 0",
         "EventCode": "0xBD",
-        "EventName": "UNC_M_WR_CAS_RANK5.BANK2",
+        "EventName": "UNC_M_WR_CAS_RANK5.BANK0",
         "PerPkg": "1",
-        "UMask": "0x2",
+        "PublicDescription": "UNC_M_WR_CAS_RANK5.BANK0",
         "Unit": "iMC"
     },
     {
-        "BriefDescription": "WR_CAS Access to Rank 5; Bank 4",
-        "Counter": "0,1,2,3",
+        "BriefDescription": "WR_CAS Access to Rank 5; Bank 1",
         "EventCode": "0xBD",
-        "EventName": "UNC_M_WR_CAS_RANK5.BANK4",
+        "EventName": "UNC_M_WR_CAS_RANK5.BANK1",
         "PerPkg": "1",
-        "UMask": "0x4",
+        "PublicDescription": "UNC_M_WR_CAS_RANK5.BANK1",
+        "UMask": "0x1",
         "Unit": "iMC"
     },
     {
-        "BriefDescription": "WR_CAS Access to Rank 5; Bank 8",
-        "Counter": "0,1,2,3",
+        "BriefDescription": "WR_CAS Access to Rank 5; Bank 10",
         "EventCode": "0xBD",
-        "EventName": "UNC_M_WR_CAS_RANK5.BANK8",
+        "EventName": "UNC_M_WR_CAS_RANK5.BANK10",
         "PerPkg": "1",
-        "UMask": "0x8",
+        "PublicDescription": "UNC_M_WR_CAS_RANK5.BANK10",
+        "UMask": "0xa",
         "Unit": "iMC"
     },
     {
-        "BriefDescription": "WR_CAS Access to Rank 5; All Banks",
-        "Counter": "0,1,2,3",
+        "BriefDescription": "WR_CAS Access to Rank 5; Bank 11",
         "EventCode": "0xBD",
-        "EventName": "UNC_M_WR_CAS_RANK5.ALLBANKS",
+        "EventName": "UNC_M_WR_CAS_RANK5.BANK11",
         "PerPkg": "1",
-        "UMask": "0x10",
+        "PublicDescription": "UNC_M_WR_CAS_RANK5.BANK11",
+        "UMask": "0xb",
         "Unit": "iMC"
     },
     {
-        "BriefDescription": "WR_CAS Access to Rank 5; Bank 0",
-        "Counter": "0,1,2,3",
+        "BriefDescription": "WR_CAS Access to Rank 5; Bank 12",
         "EventCode": "0xBD",
-        "EventName": "UNC_M_WR_CAS_RANK5.BANK0",
+        "EventName": "UNC_M_WR_CAS_RANK5.BANK12",
         "PerPkg": "1",
+        "PublicDescription": "UNC_M_WR_CAS_RANK5.BANK12",
+        "UMask": "0xc",
         "Unit": "iMC"
     },
     {
-        "BriefDescription": "WR_CAS Access to Rank 5; Bank 3",
-        "Counter": "0,1,2,3",
+        "BriefDescription": "WR_CAS Access to Rank 5; Bank 13",
         "EventCode": "0xBD",
-        "EventName": "UNC_M_WR_CAS_RANK5.BANK3",
+        "EventName": "UNC_M_WR_CAS_RANK5.BANK13",
         "PerPkg": "1",
-        "UMask": "0x3",
+        "PublicDescription": "UNC_M_WR_CAS_RANK5.BANK13",
+        "UMask": "0xd",
         "Unit": "iMC"
     },
     {
-        "BriefDescription": "WR_CAS Access to Rank 5; Bank 5",
-        "Counter": "0,1,2,3",
+        "BriefDescription": "WR_CAS Access to Rank 5; Bank 14",
         "EventCode": "0xBD",
-        "EventName": "UNC_M_WR_CAS_RANK5.BANK5",
+        "EventName": "UNC_M_WR_CAS_RANK5.BANK14",
         "PerPkg": "1",
-        "UMask": "0x5",
+        "PublicDescription": "UNC_M_WR_CAS_RANK5.BANK14",
+        "UMask": "0xe",
         "Unit": "iMC"
     },
     {
-        "BriefDescription": "WR_CAS Access to Rank 5; Bank 6",
-        "Counter": "0,1,2,3",
+        "BriefDescription": "WR_CAS Access to Rank 5; Bank 15",
         "EventCode": "0xBD",
-        "EventName": "UNC_M_WR_CAS_RANK5.BANK6",
+        "EventName": "UNC_M_WR_CAS_RANK5.BANK15",
         "PerPkg": "1",
-        "UMask": "0x6",
+        "PublicDescription": "UNC_M_WR_CAS_RANK5.BANK15",
+        "UMask": "0xf",
         "Unit": "iMC"
     },
     {
-        "BriefDescription": "WR_CAS Access to Rank 5; Bank 7",
-        "Counter": "0,1,2,3",
+        "BriefDescription": "WR_CAS Access to Rank 5; Bank 2",
         "EventCode": "0xBD",
-        "EventName": "UNC_M_WR_CAS_RANK5.BANK7",
+        "EventName": "UNC_M_WR_CAS_RANK5.BANK2",
         "PerPkg": "1",
-        "UMask": "0x7",
+        "PublicDescription": "UNC_M_WR_CAS_RANK5.BANK2",
+        "UMask": "0x2",
         "Unit": "iMC"
     },
     {
-        "BriefDescription": "WR_CAS Access to Rank 5; Bank 9",
-        "Counter": "0,1,2,3",
+        "BriefDescription": "WR_CAS Access to Rank 5; Bank 3",
         "EventCode": "0xBD",
-        "EventName": "UNC_M_WR_CAS_RANK5.BANK9",
+        "EventName": "UNC_M_WR_CAS_RANK5.BANK3",
         "PerPkg": "1",
-        "UMask": "0x9",
+        "PublicDescription": "UNC_M_WR_CAS_RANK5.BANK3",
+        "UMask": "0x3",
         "Unit": "iMC"
     },
     {
-        "BriefDescription": "WR_CAS Access to Rank 5; Bank 10",
-        "Counter": "0,1,2,3",
+        "BriefDescription": "WR_CAS Access to Rank 5; Bank 4",
         "EventCode": "0xBD",
-        "EventName": "UNC_M_WR_CAS_RANK5.BANK10",
+        "EventName": "UNC_M_WR_CAS_RANK5.BANK4",
         "PerPkg": "1",
-        "UMask": "0xA",
+        "PublicDescription": "UNC_M_WR_CAS_RANK5.BANK4",
+        "UMask": "0x4",
         "Unit": "iMC"
     },
     {
-        "BriefDescription": "WR_CAS Access to Rank 5; Bank 11",
-        "Counter": "0,1,2,3",
+        "BriefDescription": "WR_CAS Access to Rank 5; Bank 5",
         "EventCode": "0xBD",
-        "EventName": "UNC_M_WR_CAS_RANK5.BANK11",
+        "EventName": "UNC_M_WR_CAS_RANK5.BANK5",
         "PerPkg": "1",
-        "UMask": "0xB",
+        "PublicDescription": "UNC_M_WR_CAS_RANK5.BANK5",
+        "UMask": "0x5",
         "Unit": "iMC"
     },
     {
-        "BriefDescription": "WR_CAS Access to Rank 5; Bank 12",
-        "Counter": "0,1,2,3",
+        "BriefDescription": "WR_CAS Access to Rank 5; Bank 6",
         "EventCode": "0xBD",
-        "EventName": "UNC_M_WR_CAS_RANK5.BANK12",
+        "EventName": "UNC_M_WR_CAS_RANK5.BANK6",
         "PerPkg": "1",
-        "UMask": "0xC",
+        "PublicDescription": "UNC_M_WR_CAS_RANK5.BANK6",
+        "UMask": "0x6",
         "Unit": "iMC"
     },
     {
-        "BriefDescription": "WR_CAS Access to Rank 5; Bank 13",
-        "Counter": "0,1,2,3",
+        "BriefDescription": "WR_CAS Access to Rank 5; Bank 7",
         "EventCode": "0xBD",
-        "EventName": "UNC_M_WR_CAS_RANK5.BANK13",
+        "EventName": "UNC_M_WR_CAS_RANK5.BANK7",
         "PerPkg": "1",
-        "UMask": "0xD",
+        "PublicDescription": "UNC_M_WR_CAS_RANK5.BANK7",
+        "UMask": "0x7",
         "Unit": "iMC"
     },
     {
-        "BriefDescription": "WR_CAS Access to Rank 5; Bank 14",
-        "Counter": "0,1,2,3",
+        "BriefDescription": "WR_CAS Access to Rank 5; Bank 8",
         "EventCode": "0xBD",
-        "EventName": "UNC_M_WR_CAS_RANK5.BANK14",
+        "EventName": "UNC_M_WR_CAS_RANK5.BANK8",
         "PerPkg": "1",
-        "UMask": "0xE",
+        "PublicDescription": "UNC_M_WR_CAS_RANK5.BANK8",
+        "UMask": "0x8",
         "Unit": "iMC"
     },
     {
-        "BriefDescription": "WR_CAS Access to Rank 5; Bank 15",
-        "Counter": "0,1,2,3",
+        "BriefDescription": "WR_CAS Access to Rank 5; Bank 9",
         "EventCode": "0xBD",
-        "EventName": "UNC_M_WR_CAS_RANK5.BANK15",
+        "EventName": "UNC_M_WR_CAS_RANK5.BANK9",
         "PerPkg": "1",
-        "UMask": "0xF",
+        "PublicDescription": "UNC_M_WR_CAS_RANK5.BANK9",
+        "UMask": "0x9",
         "Unit": "iMC"
     },
     {
         "BriefDescription": "WR_CAS Access to Rank 5; Bank Group 0 (Banks =
0-3)",
-        "Counter": "0,1,2,3",
         "EventCode": "0xBD",
         "EventName": "UNC_M_WR_CAS_RANK5.BANKG0",
         "PerPkg": "1",
+        "PublicDescription": "UNC_M_WR_CAS_RANK5.BANKG0",
         "UMask": "0x11",
         "Unit": "iMC"
     },
     {
         "BriefDescription": "WR_CAS Access to Rank 5; Bank Group 1 (Banks =
4-7)",
-        "Counter": "0,1,2,3",
         "EventCode": "0xBD",
         "EventName": "UNC_M_WR_CAS_RANK5.BANKG1",
         "PerPkg": "1",
+        "PublicDescription": "UNC_M_WR_CAS_RANK5.BANKG1",
         "UMask": "0x12",
         "Unit": "iMC"
     },
     {
         "BriefDescription": "WR_CAS Access to Rank 5; Bank Group 2 (Banks =
8-11)",
-        "Counter": "0,1,2,3",
         "EventCode": "0xBD",
         "EventName": "UNC_M_WR_CAS_RANK5.BANKG2",
         "PerPkg": "1",
+        "PublicDescription": "UNC_M_WR_CAS_RANK5.BANKG2",
         "UMask": "0x13",
         "Unit": "iMC"
     },
     {
         "BriefDescription": "WR_CAS Access to Rank 5; Bank Group 3 (Banks =
12-15)",
-        "Counter": "0,1,2,3",
         "EventCode": "0xBD",
         "EventName": "UNC_M_WR_CAS_RANK5.BANKG3",
         "PerPkg": "1",
+        "PublicDescription": "UNC_M_WR_CAS_RANK5.BANKG3",
         "UMask": "0x14",
         "Unit": "iMC"
     },
     {
-        "BriefDescription": "WR_CAS Access to Rank 6; Bank 1",
-        "Counter": "0,1,2,3",
+        "BriefDescription": "WR_CAS Access to Rank 6; All Banks",
         "EventCode": "0xBE",
-        "EventName": "UNC_M_WR_CAS_RANK6.BANK1",
+        "EventName": "UNC_M_WR_CAS_RANK6.ALLBANKS",
         "PerPkg": "1",
-        "UMask": "0x1",
+        "PublicDescription": "UNC_M_WR_CAS_RANK6.ALLBANKS",
+        "UMask": "0x10",
         "Unit": "iMC"
     },
     {
-        "BriefDescription": "WR_CAS Access to Rank 6; Bank 2",
-        "Counter": "0,1,2,3",
+        "BriefDescription": "WR_CAS Access to Rank 6; Bank 0",
         "EventCode": "0xBE",
-        "EventName": "UNC_M_WR_CAS_RANK6.BANK2",
+        "EventName": "UNC_M_WR_CAS_RANK6.BANK0",
         "PerPkg": "1",
-        "UMask": "0x2",
+        "PublicDescription": "UNC_M_WR_CAS_RANK6.BANK0",
         "Unit": "iMC"
     },
     {
-        "BriefDescription": "WR_CAS Access to Rank 6; Bank 4",
-        "Counter": "0,1,2,3",
+        "BriefDescription": "WR_CAS Access to Rank 6; Bank 1",
         "EventCode": "0xBE",
-        "EventName": "UNC_M_WR_CAS_RANK6.BANK4",
+        "EventName": "UNC_M_WR_CAS_RANK6.BANK1",
         "PerPkg": "1",
-        "UMask": "0x4",
+        "PublicDescription": "UNC_M_WR_CAS_RANK6.BANK1",
+        "UMask": "0x1",
         "Unit": "iMC"
     },
     {
-        "BriefDescription": "WR_CAS Access to Rank 6; Bank 8",
-        "Counter": "0,1,2,3",
+        "BriefDescription": "WR_CAS Access to Rank 6; Bank 10",
         "EventCode": "0xBE",
-        "EventName": "UNC_M_WR_CAS_RANK6.BANK8",
+        "EventName": "UNC_M_WR_CAS_RANK6.BANK10",
         "PerPkg": "1",
-        "UMask": "0x8",
+        "PublicDescription": "UNC_M_WR_CAS_RANK6.BANK10",
+        "UMask": "0xa",
         "Unit": "iMC"
     },
     {
-        "BriefDescription": "WR_CAS Access to Rank 6; All Banks",
-        "Counter": "0,1,2,3",
+        "BriefDescription": "WR_CAS Access to Rank 6; Bank 11",
         "EventCode": "0xBE",
-        "EventName": "UNC_M_WR_CAS_RANK6.ALLBANKS",
+        "EventName": "UNC_M_WR_CAS_RANK6.BANK11",
         "PerPkg": "1",
-        "UMask": "0x10",
+        "PublicDescription": "UNC_M_WR_CAS_RANK6.BANK11",
+        "UMask": "0xb",
         "Unit": "iMC"
     },
     {
-        "BriefDescription": "WR_CAS Access to Rank 6; Bank 0",
-        "Counter": "0,1,2,3",
+        "BriefDescription": "WR_CAS Access to Rank 6; Bank 12",
         "EventCode": "0xBE",
-        "EventName": "UNC_M_WR_CAS_RANK6.BANK0",
+        "EventName": "UNC_M_WR_CAS_RANK6.BANK12",
         "PerPkg": "1",
+        "PublicDescription": "UNC_M_WR_CAS_RANK6.BANK12",
+        "UMask": "0xc",
         "Unit": "iMC"
     },
     {
-        "BriefDescription": "WR_CAS Access to Rank 6; Bank 3",
-        "Counter": "0,1,2,3",
+        "BriefDescription": "WR_CAS Access to Rank 6; Bank 13",
         "EventCode": "0xBE",
-        "EventName": "UNC_M_WR_CAS_RANK6.BANK3",
+        "EventName": "UNC_M_WR_CAS_RANK6.BANK13",
         "PerPkg": "1",
-        "UMask": "0x3",
+        "PublicDescription": "UNC_M_WR_CAS_RANK6.BANK13",
+        "UMask": "0xd",
         "Unit": "iMC"
     },
     {
-        "BriefDescription": "WR_CAS Access to Rank 6; Bank 5",
-        "Counter": "0,1,2,3",
+        "BriefDescription": "WR_CAS Access to Rank 6; Bank 14",
         "EventCode": "0xBE",
-        "EventName": "UNC_M_WR_CAS_RANK6.BANK5",
+        "EventName": "UNC_M_WR_CAS_RANK6.BANK14",
         "PerPkg": "1",
-        "UMask": "0x5",
+        "PublicDescription": "UNC_M_WR_CAS_RANK6.BANK14",
+        "UMask": "0xe",
         "Unit": "iMC"
     },
     {
-        "BriefDescription": "WR_CAS Access to Rank 6; Bank 6",
-        "Counter": "0,1,2,3",
+        "BriefDescription": "WR_CAS Access to Rank 6; Bank 15",
         "EventCode": "0xBE",
-        "EventName": "UNC_M_WR_CAS_RANK6.BANK6",
+        "EventName": "UNC_M_WR_CAS_RANK6.BANK15",
         "PerPkg": "1",
-        "UMask": "0x6",
+        "PublicDescription": "UNC_M_WR_CAS_RANK6.BANK15",
+        "UMask": "0xf",
         "Unit": "iMC"
     },
     {
-        "BriefDescription": "WR_CAS Access to Rank 6; Bank 7",
-        "Counter": "0,1,2,3",
+        "BriefDescription": "WR_CAS Access to Rank 6; Bank 2",
         "EventCode": "0xBE",
-        "EventName": "UNC_M_WR_CAS_RANK6.BANK7",
+        "EventName": "UNC_M_WR_CAS_RANK6.BANK2",
         "PerPkg": "1",
-        "UMask": "0x7",
+        "PublicDescription": "UNC_M_WR_CAS_RANK6.BANK2",
+        "UMask": "0x2",
         "Unit": "iMC"
     },
     {
-        "BriefDescription": "WR_CAS Access to Rank 6; Bank 9",
-        "Counter": "0,1,2,3",
+        "BriefDescription": "WR_CAS Access to Rank 6; Bank 3",
         "EventCode": "0xBE",
-        "EventName": "UNC_M_WR_CAS_RANK6.BANK9",
+        "EventName": "UNC_M_WR_CAS_RANK6.BANK3",
         "PerPkg": "1",
-        "UMask": "0x9",
+        "PublicDescription": "UNC_M_WR_CAS_RANK6.BANK3",
+        "UMask": "0x3",
         "Unit": "iMC"
     },
     {
-        "BriefDescription": "WR_CAS Access to Rank 6; Bank 10",
-        "Counter": "0,1,2,3",
+        "BriefDescription": "WR_CAS Access to Rank 6; Bank 4",
         "EventCode": "0xBE",
-        "EventName": "UNC_M_WR_CAS_RANK6.BANK10",
+        "EventName": "UNC_M_WR_CAS_RANK6.BANK4",
         "PerPkg": "1",
-        "UMask": "0xA",
+        "PublicDescription": "UNC_M_WR_CAS_RANK6.BANK4",
+        "UMask": "0x4",
         "Unit": "iMC"
     },
     {
-        "BriefDescription": "WR_CAS Access to Rank 6; Bank 11",
-        "Counter": "0,1,2,3",
+        "BriefDescription": "WR_CAS Access to Rank 6; Bank 5",
         "EventCode": "0xBE",
-        "EventName": "UNC_M_WR_CAS_RANK6.BANK11",
+        "EventName": "UNC_M_WR_CAS_RANK6.BANK5",
         "PerPkg": "1",
-        "UMask": "0xB",
+        "PublicDescription": "UNC_M_WR_CAS_RANK6.BANK5",
+        "UMask": "0x5",
         "Unit": "iMC"
     },
     {
-        "BriefDescription": "WR_CAS Access to Rank 6; Bank 12",
-        "Counter": "0,1,2,3",
+        "BriefDescription": "WR_CAS Access to Rank 6; Bank 6",
         "EventCode": "0xBE",
-        "EventName": "UNC_M_WR_CAS_RANK6.BANK12",
+        "EventName": "UNC_M_WR_CAS_RANK6.BANK6",
         "PerPkg": "1",
-        "UMask": "0xC",
+        "PublicDescription": "UNC_M_WR_CAS_RANK6.BANK6",
+        "UMask": "0x6",
         "Unit": "iMC"
     },
     {
-        "BriefDescription": "WR_CAS Access to Rank 6; Bank 13",
-        "Counter": "0,1,2,3",
+        "BriefDescription": "WR_CAS Access to Rank 6; Bank 7",
         "EventCode": "0xBE",
-        "EventName": "UNC_M_WR_CAS_RANK6.BANK13",
+        "EventName": "UNC_M_WR_CAS_RANK6.BANK7",
         "PerPkg": "1",
-        "UMask": "0xD",
+        "PublicDescription": "UNC_M_WR_CAS_RANK6.BANK7",
+        "UMask": "0x7",
         "Unit": "iMC"
     },
     {
-        "BriefDescription": "WR_CAS Access to Rank 6; Bank 14",
-        "Counter": "0,1,2,3",
+        "BriefDescription": "WR_CAS Access to Rank 6; Bank 8",
         "EventCode": "0xBE",
-        "EventName": "UNC_M_WR_CAS_RANK6.BANK14",
+        "EventName": "UNC_M_WR_CAS_RANK6.BANK8",
         "PerPkg": "1",
-        "UMask": "0xE",
+        "PublicDescription": "UNC_M_WR_CAS_RANK6.BANK8",
+        "UMask": "0x8",
         "Unit": "iMC"
     },
     {
-        "BriefDescription": "WR_CAS Access to Rank 6; Bank 15",
-        "Counter": "0,1,2,3",
+        "BriefDescription": "WR_CAS Access to Rank 6; Bank 9",
         "EventCode": "0xBE",
-        "EventName": "UNC_M_WR_CAS_RANK6.BANK15",
+        "EventName": "UNC_M_WR_CAS_RANK6.BANK9",
         "PerPkg": "1",
-        "UMask": "0xF",
+        "PublicDescription": "UNC_M_WR_CAS_RANK6.BANK9",
+        "UMask": "0x9",
         "Unit": "iMC"
     },
     {
         "BriefDescription": "WR_CAS Access to Rank 6; Bank Group 0 (Banks =
0-3)",
-        "Counter": "0,1,2,3",
         "EventCode": "0xBE",
         "EventName": "UNC_M_WR_CAS_RANK6.BANKG0",
         "PerPkg": "1",
+        "PublicDescription": "UNC_M_WR_CAS_RANK6.BANKG0",
         "UMask": "0x11",
         "Unit": "iMC"
     },
     {
         "BriefDescription": "WR_CAS Access to Rank 6; Bank Group 1 (Banks =
4-7)",
-        "Counter": "0,1,2,3",
         "EventCode": "0xBE",
         "EventName": "UNC_M_WR_CAS_RANK6.BANKG1",
         "PerPkg": "1",
+        "PublicDescription": "UNC_M_WR_CAS_RANK6.BANKG1",
         "UMask": "0x12",
         "Unit": "iMC"
     },
     {
         "BriefDescription": "WR_CAS Access to Rank 6; Bank Group 2 (Banks =
8-11)",
-        "Counter": "0,1,2,3",
         "EventCode": "0xBE",
         "EventName": "UNC_M_WR_CAS_RANK6.BANKG2",
         "PerPkg": "1",
+        "PublicDescription": "UNC_M_WR_CAS_RANK6.BANKG2",
         "UMask": "0x13",
         "Unit": "iMC"
     },
     {
         "BriefDescription": "WR_CAS Access to Rank 6; Bank Group 3 (Banks =
12-15)",
-        "Counter": "0,1,2,3",
         "EventCode": "0xBE",
         "EventName": "UNC_M_WR_CAS_RANK6.BANKG3",
         "PerPkg": "1",
+        "PublicDescription": "UNC_M_WR_CAS_RANK6.BANKG3",
         "UMask": "0x14",
         "Unit": "iMC"
     },
     {
-        "BriefDescription": "WR_CAS Access to Rank 7; Bank 1",
-        "Counter": "0,1,2,3",
+        "BriefDescription": "WR_CAS Access to Rank 7; All Banks",
         "EventCode": "0xBF",
-        "EventName": "UNC_M_WR_CAS_RANK7.BANK1",
+        "EventName": "UNC_M_WR_CAS_RANK7.ALLBANKS",
         "PerPkg": "1",
-        "UMask": "0x1",
+        "PublicDescription": "UNC_M_WR_CAS_RANK7.ALLBANKS",
+        "UMask": "0x10",
         "Unit": "iMC"
     },
     {
-        "BriefDescription": "WR_CAS Access to Rank 7; Bank 2",
-        "Counter": "0,1,2,3",
+        "BriefDescription": "WR_CAS Access to Rank 7; Bank 0",
         "EventCode": "0xBF",
-        "EventName": "UNC_M_WR_CAS_RANK7.BANK2",
+        "EventName": "UNC_M_WR_CAS_RANK7.BANK0",
         "PerPkg": "1",
-        "UMask": "0x2",
+        "PublicDescription": "UNC_M_WR_CAS_RANK7.BANK0",
         "Unit": "iMC"
     },
     {
-        "BriefDescription": "WR_CAS Access to Rank 7; Bank 4",
-        "Counter": "0,1,2,3",
+        "BriefDescription": "WR_CAS Access to Rank 7; Bank 1",
         "EventCode": "0xBF",
-        "EventName": "UNC_M_WR_CAS_RANK7.BANK4",
+        "EventName": "UNC_M_WR_CAS_RANK7.BANK1",
         "PerPkg": "1",
-        "UMask": "0x4",
+        "PublicDescription": "UNC_M_WR_CAS_RANK7.BANK1",
+        "UMask": "0x1",
         "Unit": "iMC"
     },
     {
-        "BriefDescription": "WR_CAS Access to Rank 7; Bank 8",
-        "Counter": "0,1,2,3",
+        "BriefDescription": "WR_CAS Access to Rank 7; Bank 10",
         "EventCode": "0xBF",
-        "EventName": "UNC_M_WR_CAS_RANK7.BANK8",
+        "EventName": "UNC_M_WR_CAS_RANK7.BANK10",
         "PerPkg": "1",
-        "UMask": "0x8",
+        "PublicDescription": "UNC_M_WR_CAS_RANK7.BANK10",
+        "UMask": "0xa",
         "Unit": "iMC"
     },
     {
-        "BriefDescription": "WR_CAS Access to Rank 7; All Banks",
-        "Counter": "0,1,2,3",
+        "BriefDescription": "WR_CAS Access to Rank 7; Bank 11",
         "EventCode": "0xBF",
-        "EventName": "UNC_M_WR_CAS_RANK7.ALLBANKS",
+        "EventName": "UNC_M_WR_CAS_RANK7.BANK11",
         "PerPkg": "1",
-        "UMask": "0x10",
+        "PublicDescription": "UNC_M_WR_CAS_RANK7.BANK11",
+        "UMask": "0xb",
         "Unit": "iMC"
     },
     {
-        "BriefDescription": "WR_CAS Access to Rank 7; Bank 0",
-        "Counter": "0,1,2,3",
+        "BriefDescription": "WR_CAS Access to Rank 7; Bank 12",
         "EventCode": "0xBF",
-        "EventName": "UNC_M_WR_CAS_RANK7.BANK0",
+        "EventName": "UNC_M_WR_CAS_RANK7.BANK12",
         "PerPkg": "1",
+        "PublicDescription": "UNC_M_WR_CAS_RANK7.BANK12",
+        "UMask": "0xc",
         "Unit": "iMC"
     },
     {
-        "BriefDescription": "WR_CAS Access to Rank 7; Bank 3",
-        "Counter": "0,1,2,3",
+        "BriefDescription": "WR_CAS Access to Rank 7; Bank 13",
         "EventCode": "0xBF",
-        "EventName": "UNC_M_WR_CAS_RANK7.BANK3",
+        "EventName": "UNC_M_WR_CAS_RANK7.BANK13",
         "PerPkg": "1",
-        "UMask": "0x3",
+        "PublicDescription": "UNC_M_WR_CAS_RANK7.BANK13",
+        "UMask": "0xd",
         "Unit": "iMC"
     },
     {
-        "BriefDescription": "WR_CAS Access to Rank 7; Bank 5",
-        "Counter": "0,1,2,3",
+        "BriefDescription": "WR_CAS Access to Rank 7; Bank 14",
         "EventCode": "0xBF",
-        "EventName": "UNC_M_WR_CAS_RANK7.BANK5",
+        "EventName": "UNC_M_WR_CAS_RANK7.BANK14",
         "PerPkg": "1",
-        "UMask": "0x5",
+        "PublicDescription": "UNC_M_WR_CAS_RANK7.BANK14",
+        "UMask": "0xe",
         "Unit": "iMC"
     },
     {
-        "BriefDescription": "WR_CAS Access to Rank 7; Bank 6",
-        "Counter": "0,1,2,3",
+        "BriefDescription": "WR_CAS Access to Rank 7; Bank 15",
         "EventCode": "0xBF",
-        "EventName": "UNC_M_WR_CAS_RANK7.BANK6",
+        "EventName": "UNC_M_WR_CAS_RANK7.BANK15",
         "PerPkg": "1",
-        "UMask": "0x6",
+        "PublicDescription": "UNC_M_WR_CAS_RANK7.BANK15",
+        "UMask": "0xf",
         "Unit": "iMC"
     },
     {
-        "BriefDescription": "WR_CAS Access to Rank 7; Bank 7",
-        "Counter": "0,1,2,3",
+        "BriefDescription": "WR_CAS Access to Rank 7; Bank 2",
         "EventCode": "0xBF",
-        "EventName": "UNC_M_WR_CAS_RANK7.BANK7",
+        "EventName": "UNC_M_WR_CAS_RANK7.BANK2",
         "PerPkg": "1",
-        "UMask": "0x7",
+        "PublicDescription": "UNC_M_WR_CAS_RANK7.BANK2",
+        "UMask": "0x2",
         "Unit": "iMC"
     },
     {
-        "BriefDescription": "WR_CAS Access to Rank 7; Bank 9",
-        "Counter": "0,1,2,3",
+        "BriefDescription": "WR_CAS Access to Rank 7; Bank 3",
         "EventCode": "0xBF",
-        "EventName": "UNC_M_WR_CAS_RANK7.BANK9",
+        "EventName": "UNC_M_WR_CAS_RANK7.BANK3",
         "PerPkg": "1",
-        "UMask": "0x9",
+        "PublicDescription": "UNC_M_WR_CAS_RANK7.BANK3",
+        "UMask": "0x3",
         "Unit": "iMC"
     },
     {
-        "BriefDescription": "WR_CAS Access to Rank 7; Bank 10",
-        "Counter": "0,1,2,3",
+        "BriefDescription": "WR_CAS Access to Rank 7; Bank 4",
         "EventCode": "0xBF",
-        "EventName": "UNC_M_WR_CAS_RANK7.BANK10",
+        "EventName": "UNC_M_WR_CAS_RANK7.BANK4",
         "PerPkg": "1",
-        "UMask": "0xA",
+        "PublicDescription": "UNC_M_WR_CAS_RANK7.BANK4",
+        "UMask": "0x4",
         "Unit": "iMC"
     },
     {
-        "BriefDescription": "WR_CAS Access to Rank 7; Bank 11",
-        "Counter": "0,1,2,3",
+        "BriefDescription": "WR_CAS Access to Rank 7; Bank 5",
         "EventCode": "0xBF",
-        "EventName": "UNC_M_WR_CAS_RANK7.BANK11",
+        "EventName": "UNC_M_WR_CAS_RANK7.BANK5",
         "PerPkg": "1",
-        "UMask": "0xB",
+        "PublicDescription": "UNC_M_WR_CAS_RANK7.BANK5",
+        "UMask": "0x5",
         "Unit": "iMC"
     },
     {
-        "BriefDescription": "WR_CAS Access to Rank 7; Bank 12",
-        "Counter": "0,1,2,3",
+        "BriefDescription": "WR_CAS Access to Rank 7; Bank 6",
         "EventCode": "0xBF",
-        "EventName": "UNC_M_WR_CAS_RANK7.BANK12",
+        "EventName": "UNC_M_WR_CAS_RANK7.BANK6",
         "PerPkg": "1",
-        "UMask": "0xC",
+        "PublicDescription": "UNC_M_WR_CAS_RANK7.BANK6",
+        "UMask": "0x6",
         "Unit": "iMC"
     },
     {
-        "BriefDescription": "WR_CAS Access to Rank 7; Bank 13",
-        "Counter": "0,1,2,3",
+        "BriefDescription": "WR_CAS Access to Rank 7; Bank 7",
         "EventCode": "0xBF",
-        "EventName": "UNC_M_WR_CAS_RANK7.BANK13",
+        "EventName": "UNC_M_WR_CAS_RANK7.BANK7",
         "PerPkg": "1",
-        "UMask": "0xD",
+        "PublicDescription": "UNC_M_WR_CAS_RANK7.BANK7",
+        "UMask": "0x7",
         "Unit": "iMC"
     },
     {
-        "BriefDescription": "WR_CAS Access to Rank 7; Bank 14",
-        "Counter": "0,1,2,3",
+        "BriefDescription": "WR_CAS Access to Rank 7; Bank 8",
         "EventCode": "0xBF",
-        "EventName": "UNC_M_WR_CAS_RANK7.BANK14",
+        "EventName": "UNC_M_WR_CAS_RANK7.BANK8",
         "PerPkg": "1",
-        "UMask": "0xE",
+        "PublicDescription": "UNC_M_WR_CAS_RANK7.BANK8",
+        "UMask": "0x8",
         "Unit": "iMC"
     },
     {
-        "BriefDescription": "WR_CAS Access to Rank 7; Bank 15",
-        "Counter": "0,1,2,3",
+        "BriefDescription": "WR_CAS Access to Rank 7; Bank 9",
         "EventCode": "0xBF",
-        "EventName": "UNC_M_WR_CAS_RANK7.BANK15",
+        "EventName": "UNC_M_WR_CAS_RANK7.BANK9",
         "PerPkg": "1",
-        "UMask": "0xF",
+        "PublicDescription": "UNC_M_WR_CAS_RANK7.BANK9",
+        "UMask": "0x9",
         "Unit": "iMC"
     },
     {
         "BriefDescription": "WR_CAS Access to Rank 7; Bank Group 0 (Banks =
0-3)",
-        "Counter": "0,1,2,3",
         "EventCode": "0xBF",
         "EventName": "UNC_M_WR_CAS_RANK7.BANKG0",
         "PerPkg": "1",
+        "PublicDescription": "UNC_M_WR_CAS_RANK7.BANKG0",
         "UMask": "0x11",
         "Unit": "iMC"
     },
     {
         "BriefDescription": "WR_CAS Access to Rank 7; Bank Group 1 (Banks =
4-7)",
-        "Counter": "0,1,2,3",
         "EventCode": "0xBF",
         "EventName": "UNC_M_WR_CAS_RANK7.BANKG1",
         "PerPkg": "1",
+        "PublicDescription": "UNC_M_WR_CAS_RANK7.BANKG1",
         "UMask": "0x12",
         "Unit": "iMC"
     },
     {
         "BriefDescription": "WR_CAS Access to Rank 7; Bank Group 2 (Banks =
8-11)",
-        "Counter": "0,1,2,3",
         "EventCode": "0xBF",
         "EventName": "UNC_M_WR_CAS_RANK7.BANKG2",
         "PerPkg": "1",
+        "PublicDescription": "UNC_M_WR_CAS_RANK7.BANKG2",
         "UMask": "0x13",
         "Unit": "iMC"
     },
     {
         "BriefDescription": "WR_CAS Access to Rank 7; Bank Group 3 (Banks =
12-15)",
-        "Counter": "0,1,2,3",
         "EventCode": "0xBF",
         "EventName": "UNC_M_WR_CAS_RANK7.BANKG3",
         "PerPkg": "1",
+        "PublicDescription": "UNC_M_WR_CAS_RANK7.BANKG3",
         "UMask": "0x14",
         "Unit": "iMC"
-    },
-    {
-        "BriefDescription": "Clockticks in the Memory Controller using one=
 of the programmable counters",
-        "Counter": "0,1,2,3",
-        "EventName": "UNC_M_CLOCKTICKS_P",
-        "PerPkg": "1",
-        "Unit": "iMC"
-    },
-    {
-        "BriefDescription": "Clockticks in the Memory Controller using a d=
edicated 48-bit Fixed Counter",
-        "Counter": "FIXED",
-        "EventCode": "0xff",
-        "EventName": "UNC_M_CLOCKTICKS",
-        "PerPkg": "1",
-        "Unit": "iMC"
     }
 ]
diff --git a/tools/perf/pmu-events/arch/x86/broadwellx/uncore-other.json b/=
tools/perf/pmu-events/arch/x86/broadwellx/uncore-other.json
index 289a726c9ac3..a80d931dc3d5 100644
--- a/tools/perf/pmu-events/arch/x86/broadwellx/uncore-other.json
+++ b/tools/perf/pmu-events/arch/x86/broadwellx/uncore-other.json
@@ -1,502 +1,508 @@
 [
     {
         "BriefDescription": "Total Write Cache Occupancy; Any Source",
-        "Counter": "0,1",
         "EventCode": "0x12",
         "EventName": "UNC_I_CACHE_TOTAL_OCCUPANCY.ANY",
         "PerPkg": "1",
+        "PublicDescription": "Accumulates the number of reads and writes t=
hat are outstanding in the uncore in each cycle.  This is effectively the s=
um of the READ_OCCUPANCY and WRITE_OCCUPANCY events.; Tracks all requests f=
rom any source port.",
         "UMask": "0x1",
         "Unit": "IRP"
     },
     {
         "BriefDescription": "Total Write Cache Occupancy; Select Source",
-        "Counter": "0,1",
         "EventCode": "0x12",
         "EventName": "UNC_I_CACHE_TOTAL_OCCUPANCY.SOURCE",
         "PerPkg": "1",
+        "PublicDescription": "Accumulates the number of reads and writes t=
hat are outstanding in the uncore in each cycle.  This is effectively the s=
um of the READ_OCCUPANCY and WRITE_OCCUPANCY events.; Tracks only those req=
uests that come from the port specified in the IRP_PmonFilter.OrderingQ reg=
ister.  This register allows one to select one specific queue.  It is not p=
ossible to monitor multiple queues at a time.",
         "UMask": "0x2",
         "Unit": "IRP"
     },
     {
         "BriefDescription": "Clocks in the IRP",
-        "Counter": "0,1",
         "EventName": "UNC_I_CLOCKTICKS",
         "PerPkg": "1",
+        "PublicDescription": "Number of clocks in the IRP.",
         "Unit": "IRP"
     },
     {
-        "BriefDescription": "Coherent Ops; PCIRdCur",
-        "Counter": "0,1",
+        "BriefDescription": "Coherent Ops; CLFlush",
         "EventCode": "0x13",
-        "EventName": "UNC_I_COHERENT_OPS.PCIRDCUR",
+        "EventName": "UNC_I_COHERENT_OPS.CLFLUSH",
         "PerPkg": "1",
-        "UMask": "0x1",
+        "PublicDescription": "Counts the number of coherency related opera=
tions servied by the IRP",
+        "UMask": "0x80",
         "Unit": "IRP"
     },
     {
         "BriefDescription": "Coherent Ops; CRd",
-        "Counter": "0,1",
         "EventCode": "0x13",
         "EventName": "UNC_I_COHERENT_OPS.CRD",
         "PerPkg": "1",
+        "PublicDescription": "Counts the number of coherency related opera=
tions servied by the IRP",
         "UMask": "0x2",
         "Unit": "IRP"
     },
     {
         "BriefDescription": "Coherent Ops; DRd",
-        "Counter": "0,1",
         "EventCode": "0x13",
         "EventName": "UNC_I_COHERENT_OPS.DRD",
         "PerPkg": "1",
+        "PublicDescription": "Counts the number of coherency related opera=
tions servied by the IRP",
         "UMask": "0x4",
         "Unit": "IRP"
     },
     {
-        "BriefDescription": "Coherent Ops; RFO",
-        "Counter": "0,1",
+        "BriefDescription": "Coherent Ops; PCIDCAHin5t",
         "EventCode": "0x13",
-        "EventName": "UNC_I_COHERENT_OPS.RFO",
+        "EventName": "UNC_I_COHERENT_OPS.PCIDCAHINT",
         "PerPkg": "1",
-        "UMask": "0x8",
+        "PublicDescription": "Counts the number of coherency related opera=
tions servied by the IRP",
+        "UMask": "0x20",
+        "Unit": "IRP"
+    },
+    {
+        "BriefDescription": "Coherent Ops; PCIRdCur",
+        "EventCode": "0x13",
+        "EventName": "UNC_I_COHERENT_OPS.PCIRDCUR",
+        "PerPkg": "1",
+        "PublicDescription": "Counts the number of coherency related opera=
tions servied by the IRP",
+        "UMask": "0x1",
         "Unit": "IRP"
     },
     {
         "BriefDescription": "Coherent Ops; PCIItoM",
-        "Counter": "0,1",
         "EventCode": "0x13",
         "EventName": "UNC_I_COHERENT_OPS.PCITOM",
         "PerPkg": "1",
+        "PublicDescription": "Counts the number of coherency related opera=
tions servied by the IRP",
         "UMask": "0x10",
         "Unit": "IRP"
     },
     {
-        "BriefDescription": "Coherent Ops; PCIDCAHin5t",
-        "Counter": "0,1",
+        "BriefDescription": "Coherent Ops; RFO",
         "EventCode": "0x13",
-        "EventName": "UNC_I_COHERENT_OPS.PCIDCAHINT",
+        "EventName": "UNC_I_COHERENT_OPS.RFO",
         "PerPkg": "1",
-        "UMask": "0x20",
+        "PublicDescription": "Counts the number of coherency related opera=
tions servied by the IRP",
+        "UMask": "0x8",
         "Unit": "IRP"
     },
     {
         "BriefDescription": "Coherent Ops; WbMtoI",
-        "Counter": "0,1",
         "EventCode": "0x13",
         "EventName": "UNC_I_COHERENT_OPS.WBMTOI",
         "PerPkg": "1",
+        "PublicDescription": "Counts the number of coherency related opera=
tions servied by the IRP",
         "UMask": "0x40",
         "Unit": "IRP"
     },
     {
-        "BriefDescription": "Coherent Ops; CLFlush",
-        "Counter": "0,1",
-        "EventCode": "0x13",
-        "EventName": "UNC_I_COHERENT_OPS.CLFLUSH",
-        "PerPkg": "1",
-        "UMask": "0x80",
-        "Unit": "IRP"
-    },
-    {
-        "BriefDescription": "Misc Events - Set 0; Fastpath Requests",
-        "Counter": "0,1",
-        "EventCode": "0x14",
-        "EventName": "UNC_I_MISC0.FAST_REQ",
-        "PerPkg": "1",
-        "UMask": "0x1",
-        "Unit": "IRP"
-    },
-    {
-        "BriefDescription": "Misc Events - Set 0; Fastpath Rejects",
-        "Counter": "0,1",
+        "BriefDescription": "Misc Events - Set 0; Cache Inserts of Atomic =
Transactions as Secondary",
         "EventCode": "0x14",
-        "EventName": "UNC_I_MISC0.FAST_REJ",
+        "EventName": "UNC_I_MISC0.2ND_ATOMIC_INSERT",
         "PerPkg": "1",
-        "UMask": "0x2",
+        "PublicDescription": "UNC_I_MISC0.2ND_ATOMIC_INSERT",
+        "UMask": "0x10",
         "Unit": "IRP"
     },
     {
         "BriefDescription": "Misc Events - Set 0; Cache Inserts of Read Tr=
ansactions as Secondary",
-        "Counter": "0,1",
         "EventCode": "0x14",
         "EventName": "UNC_I_MISC0.2ND_RD_INSERT",
         "PerPkg": "1",
+        "PublicDescription": "UNC_I_MISC0.2ND_RD_INSERT",
         "UMask": "0x4",
         "Unit": "IRP"
     },
     {
         "BriefDescription": "Misc Events - Set 0; Cache Inserts of Write T=
ransactions as Secondary",
-        "Counter": "0,1",
         "EventCode": "0x14",
         "EventName": "UNC_I_MISC0.2ND_WR_INSERT",
         "PerPkg": "1",
+        "PublicDescription": "UNC_I_MISC0.2ND_WR_INSERT",
         "UMask": "0x8",
         "Unit": "IRP"
     },
     {
-        "BriefDescription": "Misc Events - Set 0; Cache Inserts of Atomic =
Transactions as Secondary",
-        "Counter": "0,1",
+        "BriefDescription": "Misc Events - Set 0; Fastpath Rejects",
         "EventCode": "0x14",
-        "EventName": "UNC_I_MISC0.2ND_ATOMIC_INSERT",
+        "EventName": "UNC_I_MISC0.FAST_REJ",
         "PerPkg": "1",
-        "UMask": "0x10",
+        "PublicDescription": "UNC_I_MISC0.FAST_REJ",
+        "UMask": "0x2",
+        "Unit": "IRP"
+    },
+    {
+        "BriefDescription": "Misc Events - Set 0; Fastpath Requests",
+        "EventCode": "0x14",
+        "EventName": "UNC_I_MISC0.FAST_REQ",
+        "PerPkg": "1",
+        "PublicDescription": "UNC_I_MISC0.FAST_REQ",
+        "UMask": "0x1",
         "Unit": "IRP"
     },
     {
         "BriefDescription": "Misc Events - Set 0; Fastpath Transfers From =
Primary to Secondary",
-        "Counter": "0,1",
         "EventCode": "0x14",
         "EventName": "UNC_I_MISC0.FAST_XFER",
         "PerPkg": "1",
+        "PublicDescription": "UNC_I_MISC0.FAST_XFER",
         "UMask": "0x20",
         "Unit": "IRP"
     },
     {
         "BriefDescription": "Misc Events - Set 0; Prefetch Ack Hints From =
Primary to Secondary",
-        "Counter": "0,1",
         "EventCode": "0x14",
         "EventName": "UNC_I_MISC0.PF_ACK_HINT",
         "PerPkg": "1",
+        "PublicDescription": "UNC_I_MISC0.PF_ACK_HINT",
         "UMask": "0x40",
         "Unit": "IRP"
     },
     {
         "BriefDescription": "Misc Events - Set 0; Prefetch TimeOut",
-        "Counter": "0,1",
         "EventCode": "0x14",
         "EventName": "UNC_I_MISC0.PF_TIMEOUT",
         "PerPkg": "1",
+        "PublicDescription": "Indicates the fetch for a previous prefetch =
wasn't accepted by the prefetch.   This happens in the case of a prefetch T=
imeOut",
         "UMask": "0x80",
         "Unit": "IRP"
     },
     {
-        "BriefDescription": "Misc Events - Set 1; Slow Transfer of I Line"=
,
-        "Counter": "0,1",
+        "BriefDescription": "Misc Events - Set 1; Data Throttled",
         "EventCode": "0x15",
-        "EventName": "UNC_I_MISC1.SLOW_I",
+        "EventName": "UNC_I_MISC1.DATA_THROTTLE",
         "PerPkg": "1",
-        "UMask": "0x1",
+        "PublicDescription": "IRP throttled switch data",
+        "UMask": "0x80",
         "Unit": "IRP"
     },
     {
-        "BriefDescription": "Misc Events - Set 1; Slow Transfer of S Line"=
,
-        "Counter": "0,1",
+        "BriefDescription": "Misc Events - Set 1",
         "EventCode": "0x15",
-        "EventName": "UNC_I_MISC1.SLOW_S",
+        "EventName": "UNC_I_MISC1.LOST_FWD",
         "PerPkg": "1",
-        "UMask": "0x2",
+        "PublicDescription": "UNC_I_MISC1.LOST_FWD",
+        "UMask": "0x10",
         "Unit": "IRP"
     },
     {
-        "BriefDescription": "Misc Events - Set 1; Slow Transfer of E Line"=
,
-        "Counter": "0,1",
+        "BriefDescription": "Misc Events - Set 1; Received Invalid",
         "EventCode": "0x15",
-        "EventName": "UNC_I_MISC1.SLOW_E",
+        "EventName": "UNC_I_MISC1.SEC_RCVD_INVLD",
         "PerPkg": "1",
-        "UMask": "0x4",
+        "PublicDescription": "Secondary received a transfer that did not h=
ave sufficient MESI state",
+        "UMask": "0x20",
         "Unit": "IRP"
     },
     {
-        "BriefDescription": "Misc Events - Set 1; Slow Transfer of M Line"=
,
-        "Counter": "0,1",
+        "BriefDescription": "Misc Events - Set 1; Received Valid",
         "EventCode": "0x15",
-        "EventName": "UNC_I_MISC1.SLOW_M",
+        "EventName": "UNC_I_MISC1.SEC_RCVD_VLD",
         "PerPkg": "1",
-        "UMask": "0x8",
+        "PublicDescription": "Secondary received a transfer that did have =
sufficient MESI state",
+        "UMask": "0x40",
         "Unit": "IRP"
     },
     {
-        "BriefDescription": "Misc Events - Set 1",
-        "Counter": "0,1",
+        "BriefDescription": "Misc Events - Set 1; Slow Transfer of E Line"=
,
         "EventCode": "0x15",
-        "EventName": "UNC_I_MISC1.LOST_FWD",
+        "EventName": "UNC_I_MISC1.SLOW_E",
         "PerPkg": "1",
-        "UMask": "0x10",
+        "PublicDescription": "Secondary received a transfer that did have =
sufficient MESI state",
+        "UMask": "0x4",
         "Unit": "IRP"
     },
     {
-        "BriefDescription": "Misc Events - Set 1; Received Invalid",
-        "Counter": "0,1",
+        "BriefDescription": "Misc Events - Set 1; Slow Transfer of I Line"=
,
         "EventCode": "0x15",
-        "EventName": "UNC_I_MISC1.SEC_RCVD_INVLD",
+        "EventName": "UNC_I_MISC1.SLOW_I",
         "PerPkg": "1",
-        "UMask": "0x20",
+        "PublicDescription": "Snoop took cacheline ownership before write =
from data was committed.",
+        "UMask": "0x1",
         "Unit": "IRP"
     },
     {
-        "BriefDescription": "Misc Events - Set 1; Received Valid",
-        "Counter": "0,1",
+        "BriefDescription": "Misc Events - Set 1; Slow Transfer of M Line"=
,
         "EventCode": "0x15",
-        "EventName": "UNC_I_MISC1.SEC_RCVD_VLD",
+        "EventName": "UNC_I_MISC1.SLOW_M",
         "PerPkg": "1",
-        "UMask": "0x40",
+        "PublicDescription": "Snoop took cacheline ownership before write =
from data was committed.",
+        "UMask": "0x8",
         "Unit": "IRP"
     },
     {
-        "BriefDescription": "Misc Events - Set 1; Data Throttled",
-        "Counter": "0,1",
+        "BriefDescription": "Misc Events - Set 1; Slow Transfer of S Line"=
,
         "EventCode": "0x15",
-        "EventName": "UNC_I_MISC1.DATA_THROTTLE",
+        "EventName": "UNC_I_MISC1.SLOW_S",
         "PerPkg": "1",
-        "UMask": "0x80",
+        "PublicDescription": "Secondary received a transfer that did not h=
ave sufficient MESI state",
+        "UMask": "0x2",
         "Unit": "IRP"
     },
     {
         "BriefDescription": "AK Ingress Occupancy",
-        "Counter": "0,1",
         "EventCode": "0xA",
         "EventName": "UNC_I_RxR_AK_INSERTS",
         "PerPkg": "1",
+        "PublicDescription": "Counts the number of allocations into the AK=
 Ingress.  This queue is where the IRP receives responses from R2PCIe (the =
ring).",
         "Unit": "IRP"
     },
     {
         "BriefDescription": "UNC_I_RxR_BL_DRS_CYCLES_FULL",
-        "Counter": "0,1",
         "EventCode": "0x4",
         "EventName": "UNC_I_RxR_BL_DRS_CYCLES_FULL",
         "PerPkg": "1",
+        "PublicDescription": "Counts the number of cycles when the BL Ingr=
ess is full.  This queue is where the IRP receives data from R2PCIe (the ri=
ng).  It is used for data returns from read requets as well as outbound MMI=
O writes.",
         "Unit": "IRP"
     },
     {
         "BriefDescription": "BL Ingress Occupancy - DRS",
-        "Counter": "0,1",
         "EventCode": "0x1",
         "EventName": "UNC_I_RxR_BL_DRS_INSERTS",
         "PerPkg": "1",
+        "PublicDescription": "Counts the number of allocations into the BL=
 Ingress.  This queue is where the IRP receives data from R2PCIe (the ring)=
.  It is used for data returns from read requets as well as outbound MMIO w=
rites.",
         "Unit": "IRP"
     },
     {
         "BriefDescription": "UNC_I_RxR_BL_DRS_OCCUPANCY",
-        "Counter": "0,1",
         "EventCode": "0x7",
         "EventName": "UNC_I_RxR_BL_DRS_OCCUPANCY",
         "PerPkg": "1",
+        "PublicDescription": "Accumulates the occupancy of the BL Ingress =
in each cycles.  This queue is where the IRP receives data from R2PCIe (the=
 ring).  It is used for data returns from read requets as well as outbound =
MMIO writes.",
         "Unit": "IRP"
     },
     {
         "BriefDescription": "UNC_I_RxR_BL_NCB_CYCLES_FULL",
-        "Counter": "0,1",
         "EventCode": "0x5",
         "EventName": "UNC_I_RxR_BL_NCB_CYCLES_FULL",
         "PerPkg": "1",
+        "PublicDescription": "Counts the number of cycles when the BL Ingr=
ess is full.  This queue is where the IRP receives data from R2PCIe (the ri=
ng).  It is used for data returns from read requets as well as outbound MMI=
O writes.",
         "Unit": "IRP"
     },
     {
         "BriefDescription": "BL Ingress Occupancy - NCB",
-        "Counter": "0,1",
         "EventCode": "0x2",
         "EventName": "UNC_I_RxR_BL_NCB_INSERTS",
         "PerPkg": "1",
+        "PublicDescription": "Counts the number of allocations into the BL=
 Ingress.  This queue is where the IRP receives data from R2PCIe (the ring)=
.  It is used for data returns from read requets as well as outbound MMIO w=
rites.",
         "Unit": "IRP"
     },
     {
         "BriefDescription": "UNC_I_RxR_BL_NCB_OCCUPANCY",
-        "Counter": "0,1",
         "EventCode": "0x8",
         "EventName": "UNC_I_RxR_BL_NCB_OCCUPANCY",
         "PerPkg": "1",
+        "PublicDescription": "Accumulates the occupancy of the BL Ingress =
in each cycles.  This queue is where the IRP receives data from R2PCIe (the=
 ring).  It is used for data returns from read requets as well as outbound =
MMIO writes.",
         "Unit": "IRP"
     },
     {
         "BriefDescription": "UNC_I_RxR_BL_NCS_CYCLES_FULL",
-        "Counter": "0,1",
         "EventCode": "0x6",
         "EventName": "UNC_I_RxR_BL_NCS_CYCLES_FULL",
         "PerPkg": "1",
+        "PublicDescription": "Counts the number of cycles when the BL Ingr=
ess is full.  This queue is where the IRP receives data from R2PCIe (the ri=
ng).  It is used for data returns from read requets as well as outbound MMI=
O writes.",
         "Unit": "IRP"
     },
     {
         "BriefDescription": "BL Ingress Occupancy - NCS",
-        "Counter": "0,1",
         "EventCode": "0x3",
         "EventName": "UNC_I_RxR_BL_NCS_INSERTS",
         "PerPkg": "1",
+        "PublicDescription": "Counts the number of allocations into the BL=
 Ingress.  This queue is where the IRP receives data from R2PCIe (the ring)=
.  It is used for data returns from read requets as well as outbound MMIO w=
rites.",
         "Unit": "IRP"
     },
     {
         "BriefDescription": "UNC_I_RxR_BL_NCS_OCCUPANCY",
-        "Counter": "0,1",
         "EventCode": "0x9",
         "EventName": "UNC_I_RxR_BL_NCS_OCCUPANCY",
         "PerPkg": "1",
+        "PublicDescription": "Accumulates the occupancy of the BL Ingress =
in each cycles.  This queue is where the IRP receives data from R2PCIe (the=
 ring).  It is used for data returns from read requets as well as outbound =
MMIO writes.",
         "Unit": "IRP"
     },
     {
-        "BriefDescription": "Snoop Responses; Miss",
-        "Counter": "0,1",
+        "BriefDescription": "Snoop Responses; Hit E or S",
         "EventCode": "0x17",
-        "EventName": "UNC_I_SNOOP_RESP.MISS",
+        "EventName": "UNC_I_SNOOP_RESP.HIT_ES",
         "PerPkg": "1",
-        "UMask": "0x1",
+        "PublicDescription": "UNC_I_SNOOP_RESP.HIT_ES",
+        "UMask": "0x4",
         "Unit": "IRP"
     },
     {
         "BriefDescription": "Snoop Responses; Hit I",
-        "Counter": "0,1",
         "EventCode": "0x17",
         "EventName": "UNC_I_SNOOP_RESP.HIT_I",
         "PerPkg": "1",
+        "PublicDescription": "UNC_I_SNOOP_RESP.HIT_I",
         "UMask": "0x2",
         "Unit": "IRP"
     },
     {
-        "BriefDescription": "Snoop Responses; Hit E or S",
-        "Counter": "0,1",
+        "BriefDescription": "Snoop Responses; Hit M",
         "EventCode": "0x17",
-        "EventName": "UNC_I_SNOOP_RESP.HIT_ES",
+        "EventName": "UNC_I_SNOOP_RESP.HIT_M",
         "PerPkg": "1",
-        "UMask": "0x4",
+        "PublicDescription": "UNC_I_SNOOP_RESP.HIT_M",
+        "UMask": "0x8",
         "Unit": "IRP"
     },
     {
-        "BriefDescription": "Snoop Responses; Hit M",
-        "Counter": "0,1",
+        "BriefDescription": "Snoop Responses; Miss",
         "EventCode": "0x17",
-        "EventName": "UNC_I_SNOOP_RESP.HIT_M",
+        "EventName": "UNC_I_SNOOP_RESP.MISS",
         "PerPkg": "1",
-        "UMask": "0x8",
+        "PublicDescription": "UNC_I_SNOOP_RESP.MISS",
+        "UMask": "0x1",
         "Unit": "IRP"
     },
     {
         "BriefDescription": "Snoop Responses; SnpCode",
-        "Counter": "0,1",
         "EventCode": "0x17",
         "EventName": "UNC_I_SNOOP_RESP.SNPCODE",
         "PerPkg": "1",
+        "PublicDescription": "UNC_I_SNOOP_RESP.SNPCODE",
         "UMask": "0x10",
         "Unit": "IRP"
     },
     {
         "BriefDescription": "Snoop Responses; SnpData",
-        "Counter": "0,1",
         "EventCode": "0x17",
         "EventName": "UNC_I_SNOOP_RESP.SNPDATA",
         "PerPkg": "1",
+        "PublicDescription": "UNC_I_SNOOP_RESP.SNPDATA",
         "UMask": "0x20",
         "Unit": "IRP"
     },
     {
         "BriefDescription": "Snoop Responses; SnpInv",
-        "Counter": "0,1",
         "EventCode": "0x17",
         "EventName": "UNC_I_SNOOP_RESP.SNPINV",
         "PerPkg": "1",
+        "PublicDescription": "UNC_I_SNOOP_RESP.SNPINV",
         "UMask": "0x40",
         "Unit": "IRP"
     },
     {
-        "BriefDescription": "Inbound Transaction Count; Reads",
-        "Counter": "0,1",
+        "BriefDescription": "Inbound Transaction Count; Atomic",
         "EventCode": "0x16",
-        "EventName": "UNC_I_TRANSACTIONS.READS",
+        "EventName": "UNC_I_TRANSACTIONS.ATOMIC",
         "PerPkg": "1",
-        "UMask": "0x1",
+        "PublicDescription": "Counts the number of Inbound transactions fr=
om the IRP to the Uncore.  This can be filtered based on request type in ad=
dition to the source queue.  Note the special filtering equation.  We do OR=
-reduction on the request type.  If the SOURCE bit is set, then we also do =
AND qualification based on the source portID.; Tracks the number of atomic =
transactions",
+        "UMask": "0x10",
         "Unit": "IRP"
     },
     {
-        "BriefDescription": "Inbound Transaction Count; Writes",
-        "Counter": "0,1",
+        "BriefDescription": "Inbound Transaction Count; Other",
         "EventCode": "0x16",
-        "EventName": "UNC_I_TRANSACTIONS.WRITES",
+        "EventName": "UNC_I_TRANSACTIONS.OTHER",
         "PerPkg": "1",
-        "UMask": "0x2",
+        "PublicDescription": "Counts the number of Inbound transactions fr=
om the IRP to the Uncore.  This can be filtered based on request type in ad=
dition to the source queue.  Note the special filtering equation.  We do OR=
-reduction on the request type.  If the SOURCE bit is set, then we also do =
AND qualification based on the source portID.; Tracks the number of 'other'=
 kinds of transactions.",
+        "UMask": "0x20",
         "Unit": "IRP"
     },
     {
         "BriefDescription": "Inbound Transaction Count; Read Prefetches",
-        "Counter": "0,1",
         "EventCode": "0x16",
         "EventName": "UNC_I_TRANSACTIONS.RD_PREF",
         "PerPkg": "1",
+        "PublicDescription": "Counts the number of Inbound transactions fr=
om the IRP to the Uncore.  This can be filtered based on request type in ad=
dition to the source queue.  Note the special filtering equation.  We do OR=
-reduction on the request type.  If the SOURCE bit is set, then we also do =
AND qualification based on the source portID.; Tracks the number of read pr=
efetches.",
         "UMask": "0x4",
         "Unit": "IRP"
     },
     {
-        "BriefDescription": "Inbound Transaction Count; Write Prefetches",
-        "Counter": "0,1",
-        "EventCode": "0x16",
-        "EventName": "UNC_I_TRANSACTIONS.WR_PREF",
-        "PerPkg": "1",
-        "UMask": "0x8",
-        "Unit": "IRP"
-    },
-    {
-        "BriefDescription": "Inbound Transaction Count; Atomic",
-        "Counter": "0,1",
+        "BriefDescription": "Inbound Transaction Count; Reads",
         "EventCode": "0x16",
-        "EventName": "UNC_I_TRANSACTIONS.ATOMIC",
+        "EventName": "UNC_I_TRANSACTIONS.READS",
         "PerPkg": "1",
-        "UMask": "0x10",
+        "PublicDescription": "Counts the number of Inbound transactions fr=
om the IRP to the Uncore.  This can be filtered based on request type in ad=
dition to the source queue.  Note the special filtering equation.  We do OR=
-reduction on the request type.  If the SOURCE bit is set, then we also do =
AND qualification based on the source portID.; Tracks only read requests (n=
ot including read prefetches).",
+        "UMask": "0x1",
         "Unit": "IRP"
     },
     {
-        "BriefDescription": "Inbound Transaction Count; Other",
-        "Counter": "0,1",
+        "BriefDescription": "Inbound Transaction Count; Writes",
         "EventCode": "0x16",
-        "EventName": "UNC_I_TRANSACTIONS.OTHER",
+        "EventName": "UNC_I_TRANSACTIONS.WRITES",
         "PerPkg": "1",
-        "UMask": "0x20",
+        "PublicDescription": "Counts the number of Inbound transactions fr=
om the IRP to the Uncore.  This can be filtered based on request type in ad=
dition to the source queue.  Note the special filtering equation.  We do OR=
-reduction on the request type.  If the SOURCE bit is set, then we also do =
AND qualification based on the source portID.; Tracks only write requests. =
 Each write request should have a prefetch, so there is no need to explicit=
ly track these requests.",
+        "UMask": "0x2",
         "Unit": "IRP"
     },
     {
-        "BriefDescription": "Inbound Transaction Count; Select Source",
-        "Counter": "0,1",
+        "BriefDescription": "Inbound Transaction Count; Write Prefetches",
         "EventCode": "0x16",
-        "EventName": "UNC_I_TRANSACTIONS.ORDERINGQ",
+        "EventName": "UNC_I_TRANSACTIONS.WR_PREF",
         "PerPkg": "1",
-        "UMask": "0x40",
+        "PublicDescription": "Counts the number of Inbound transactions fr=
om the IRP to the Uncore.  This can be filtered based on request type in ad=
dition to the source queue.  Note the special filtering equation.  We do OR=
-reduction on the request type.  If the SOURCE bit is set, then we also do =
AND qualification based on the source portID.; Tracks the number of write p=
refetches.",
+        "UMask": "0x8",
         "Unit": "IRP"
     },
     {
         "BriefDescription": "No AD Egress Credit Stalls",
-        "Counter": "0,1",
         "EventCode": "0x18",
         "EventName": "UNC_I_TxR_AD_STALL_CREDIT_CYCLES",
         "PerPkg": "1",
+        "PublicDescription": "Counts the number times when it is not possi=
ble to issue a request to the R2PCIe because there are no AD Egress Credits=
 available.",
         "Unit": "IRP"
     },
     {
         "BriefDescription": "No BL Egress Credit Stalls",
-        "Counter": "0,1",
         "EventCode": "0x19",
         "EventName": "UNC_I_TxR_BL_STALL_CREDIT_CYCLES",
         "PerPkg": "1",
+        "PublicDescription": "Counts the number times when it is not possi=
ble to issue data to the R2PCIe because there are no BL Egress Credits avai=
lable.",
         "Unit": "IRP"
     },
     {
         "BriefDescription": "Outbound Read Requests",
-        "Counter": "0,1",
         "EventCode": "0xE",
         "EventName": "UNC_I_TxR_DATA_INSERTS_NCB",
         "PerPkg": "1",
+        "PublicDescription": "Counts the number of requests issued to the =
switch (towards the devices).",
         "Unit": "IRP"
     },
     {
         "BriefDescription": "Outbound Read Requests",
-        "Counter": "0,1",
         "EventCode": "0xF",
         "EventName": "UNC_I_TxR_DATA_INSERTS_NCS",
         "PerPkg": "1",
+        "PublicDescription": "Counts the number of requests issued to the =
switch (towards the devices).",
         "Unit": "IRP"
     },
     {
         "BriefDescription": "Outbound Request Queue Occupancy",
-        "Counter": "0,1",
         "EventCode": "0xD",
         "EventName": "UNC_I_TxR_REQUEST_OCCUPANCY",
         "PerPkg": "1",
+        "PublicDescription": "Accumultes the number of outstanding outboun=
d requests from the IRP to the switch (towards the devices).  This can be u=
sed in conjuection with the allocations event in order to calculate average=
 latency of outbound requests.",
         "Unit": "IRP"
     },
     {
         "BriefDescription": "Number of uclks in domain",
-        "Counter": "0,1,2,3",
         "EventCode": "0x1",
         "EventName": "UNC_R2_CLOCKTICKS",
         "PerPkg": "1",
+        "PublicDescription": "Counts the number of uclks in the R2PCIe ucl=
k domain.  This could be slightly different than the count in the Ubox beca=
use of enable/freeze delays.  However, because the R2PCIe is close to the U=
box, they generally should not diverge by more than a handful of cycles.",
+        "Unit": "R2PCIe"
+    },
+    {
+        "BriefDescription": "UNC_R2_IIO_CREDIT.ISOCH_QPI0",
+        "EventCode": "0x2D",
+        "EventName": "UNC_R2_IIO_CREDIT.ISOCH_QPI0",
+        "PerPkg": "1",
+        "UMask": "0x4",
+        "Unit": "R2PCIe"
+    },
+    {
+        "BriefDescription": "UNC_R2_IIO_CREDIT.ISOCH_QPI1",
+        "EventCode": "0x2D",
+        "EventName": "UNC_R2_IIO_CREDIT.ISOCH_QPI1",
+        "PerPkg": "1",
+        "UMask": "0x8",
         "Unit": "R2PCIe"
     },
     {
         "BriefDescription": "UNC_R2_IIO_CREDIT.PRQ_QPI0",
-        "Counter": "0,1",
         "EventCode": "0x2D",
         "EventName": "UNC_R2_IIO_CREDIT.PRQ_QPI0",
         "PerPkg": "1",
@@ -505,7 +511,6 @@
     },
     {
         "BriefDescription": "UNC_R2_IIO_CREDIT.PRQ_QPI1",
-        "Counter": "0,1",
         "EventCode": "0x2D",
         "EventName": "UNC_R2_IIO_CREDIT.PRQ_QPI1",
         "PerPkg": "1",
@@ -513,263 +518,326 @@
         "Unit": "R2PCIe"
     },
     {
-        "BriefDescription": "UNC_R2_IIO_CREDIT.ISOCH_QPI0",
-        "Counter": "0,1",
-        "EventCode": "0x2D",
-        "EventName": "UNC_R2_IIO_CREDIT.ISOCH_QPI0",
+        "BriefDescription": "R2PCIe IIO Credit Acquired; DRS",
+        "EventCode": "0x33",
+        "EventName": "UNC_R2_IIO_CREDITS_ACQUIRED.DRS",
         "PerPkg": "1",
-        "UMask": "0x4",
+        "PublicDescription": "Counts the number of credits that are acquir=
ed in the R2PCIe agent for sending transactions into the IIO on either NCB =
or NCS are in use.  Transactions from the BL ring going into the IIO Agent =
must first acquire a credit.  These credits are for either the NCB or NCS m=
essage classes.  NCB, or non-coherent bypass messages are used to transmit =
data without coherency (and are common).  NCS is used for reads to PCIe (an=
d should be used sparingly).; Credits to the IIO for the DRS message class.=
",
+        "UMask": "0x8",
         "Unit": "R2PCIe"
     },
     {
-        "BriefDescription": "UNC_R2_IIO_CREDIT.ISOCH_QPI1",
-        "Counter": "0,1",
-        "EventCode": "0x2D",
-        "EventName": "UNC_R2_IIO_CREDIT.ISOCH_QPI1",
+        "BriefDescription": "R2PCIe IIO Credit Acquired; NCB",
+        "EventCode": "0x33",
+        "EventName": "UNC_R2_IIO_CREDITS_ACQUIRED.NCB",
+        "PerPkg": "1",
+        "PublicDescription": "Counts the number of credits that are acquir=
ed in the R2PCIe agent for sending transactions into the IIO on either NCB =
or NCS are in use.  Transactions from the BL ring going into the IIO Agent =
must first acquire a credit.  These credits are for either the NCB or NCS m=
essage classes.  NCB, or non-coherent bypass messages are used to transmit =
data without coherency (and are common).  NCS is used for reads to PCIe (an=
d should be used sparingly).; Credits to the IIO for the NCB message class.=
",
+        "UMask": "0x10",
+        "Unit": "R2PCIe"
+    },
+    {
+        "BriefDescription": "R2PCIe IIO Credit Acquired; NCS",
+        "EventCode": "0x33",
+        "EventName": "UNC_R2_IIO_CREDITS_ACQUIRED.NCS",
+        "PerPkg": "1",
+        "PublicDescription": "Counts the number of credits that are acquir=
ed in the R2PCIe agent for sending transactions into the IIO on either NCB =
or NCS are in use.  Transactions from the BL ring going into the IIO Agent =
must first acquire a credit.  These credits are for either the NCB or NCS m=
essage classes.  NCB, or non-coherent bypass messages are used to transmit =
data without coherency (and are common).  NCS is used for reads to PCIe (an=
d should be used sparingly).; Credits to the IIO for the NCS message class.=
",
+        "UMask": "0x20",
+        "Unit": "R2PCIe"
+    },
+    {
+        "BriefDescription": "R2PCIe IIO Credits in Use; DRS",
+        "EventCode": "0x32",
+        "EventName": "UNC_R2_IIO_CREDITS_USED.DRS",
         "PerPkg": "1",
+        "PublicDescription": "Counts the number of cycles when one or more=
 credits in the R2PCIe agent for sending transactions into the IIO on eithe=
r NCB or NCS are in use.  Transactions from the BL ring going into the IIO =
Agent must first acquire a credit.  These credits are for either the NCB or=
 NCS message classes.  NCB, or non-coherent bypass messages are used to tra=
nsmit data without coherency (and are common).  NCS is used for reads to PC=
Ie (and should be used sparingly).; Credits to the IIO for the DRS message =
class.",
         "UMask": "0x8",
         "Unit": "R2PCIe"
     },
     {
-        "BriefDescription": "R2 AD Ring in Use; Clockwise and Even",
-        "Counter": "0,1,2,3",
+        "BriefDescription": "R2PCIe IIO Credits in Use; NCB",
+        "EventCode": "0x32",
+        "EventName": "UNC_R2_IIO_CREDITS_USED.NCB",
+        "PerPkg": "1",
+        "PublicDescription": "Counts the number of cycles when one or more=
 credits in the R2PCIe agent for sending transactions into the IIO on eithe=
r NCB or NCS are in use.  Transactions from the BL ring going into the IIO =
Agent must first acquire a credit.  These credits are for either the NCB or=
 NCS message classes.  NCB, or non-coherent bypass messages are used to tra=
nsmit data without coherency (and are common).  NCS is used for reads to PC=
Ie (and should be used sparingly).; Credits to the IIO for the NCB message =
class.",
+        "UMask": "0x10",
+        "Unit": "R2PCIe"
+    },
+    {
+        "BriefDescription": "R2PCIe IIO Credits in Use; NCS",
+        "EventCode": "0x32",
+        "EventName": "UNC_R2_IIO_CREDITS_USED.NCS",
+        "PerPkg": "1",
+        "PublicDescription": "Counts the number of cycles when one or more=
 credits in the R2PCIe agent for sending transactions into the IIO on eithe=
r NCB or NCS are in use.  Transactions from the BL ring going into the IIO =
Agent must first acquire a credit.  These credits are for either the NCB or=
 NCS message classes.  NCB, or non-coherent bypass messages are used to tra=
nsmit data without coherency (and are common).  NCS is used for reads to PC=
Ie (and should be used sparingly).; Credits to the IIO for the NCS message =
class.",
+        "UMask": "0x20",
+        "Unit": "R2PCIe"
+    },
+    {
+        "BriefDescription": "R2 AD Ring in Use; All",
         "EventCode": "0x7",
-        "EventName": "UNC_R2_RING_AD_USED.CW_EVEN",
+        "EventName": "UNC_R2_RING_AD_USED.ALL",
         "PerPkg": "1",
-        "UMask": "0x1",
+        "PublicDescription": "Counts the number of cycles that the AD ring=
 is being used at this ring stop.  This includes when packets are passing b=
y and when packets are being sunk, but does not include when packets are be=
ing sent from the ring stop.",
+        "UMask": "0xf",
         "Unit": "R2PCIe"
     },
     {
-        "BriefDescription": "R2 AD Ring in Use; Clockwise and Odd",
-        "Counter": "0,1,2,3",
+        "BriefDescription": "R2 AD Ring in Use; Counterclockwise",
         "EventCode": "0x7",
-        "EventName": "UNC_R2_RING_AD_USED.CW_ODD",
+        "EventName": "UNC_R2_RING_AD_USED.CCW",
         "PerPkg": "1",
-        "UMask": "0x2",
+        "PublicDescription": "Counts the number of cycles that the AD ring=
 is being used at this ring stop.  This includes when packets are passing b=
y and when packets are being sunk, but does not include when packets are be=
ing sent from the ring stop.",
+        "UMask": "0xc",
         "Unit": "R2PCIe"
     },
     {
         "BriefDescription": "R2 AD Ring in Use; Counterclockwise and Even"=
,
-        "Counter": "0,1,2,3",
         "EventCode": "0x7",
         "EventName": "UNC_R2_RING_AD_USED.CCW_EVEN",
         "PerPkg": "1",
+        "PublicDescription": "Counts the number of cycles that the AD ring=
 is being used at this ring stop.  This includes when packets are passing b=
y and when packets are being sunk, but does not include when packets are be=
ing sent from the ring stop.; Filters for the Counterclockwise and Even rin=
g polarity.",
         "UMask": "0x4",
         "Unit": "R2PCIe"
     },
     {
         "BriefDescription": "R2 AD Ring in Use; Counterclockwise and Odd",
-        "Counter": "0,1,2,3",
         "EventCode": "0x7",
         "EventName": "UNC_R2_RING_AD_USED.CCW_ODD",
         "PerPkg": "1",
+        "PublicDescription": "Counts the number of cycles that the AD ring=
 is being used at this ring stop.  This includes when packets are passing b=
y and when packets are being sunk, but does not include when packets are be=
ing sent from the ring stop.; Filters for the Counterclockwise and Odd ring=
 polarity.",
         "UMask": "0x8",
         "Unit": "R2PCIe"
     },
     {
         "BriefDescription": "R2 AD Ring in Use; Clockwise",
-        "Counter": "0,1,2,3",
         "EventCode": "0x7",
         "EventName": "UNC_R2_RING_AD_USED.CW",
         "PerPkg": "1",
+        "PublicDescription": "Counts the number of cycles that the AD ring=
 is being used at this ring stop.  This includes when packets are passing b=
y and when packets are being sunk, but does not include when packets are be=
ing sent from the ring stop.",
         "UMask": "0x3",
         "Unit": "R2PCIe"
     },
     {
-        "BriefDescription": "R2 AD Ring in Use; Counterclockwise",
-        "Counter": "0,1,2,3",
+        "BriefDescription": "R2 AD Ring in Use; Clockwise and Even",
         "EventCode": "0x7",
-        "EventName": "UNC_R2_RING_AD_USED.CCW",
+        "EventName": "UNC_R2_RING_AD_USED.CW_EVEN",
         "PerPkg": "1",
-        "UMask": "0xC",
+        "PublicDescription": "Counts the number of cycles that the AD ring=
 is being used at this ring stop.  This includes when packets are passing b=
y and when packets are being sunk, but does not include when packets are be=
ing sent from the ring stop.; Filters for the Clockwise and Even ring polar=
ity.",
+        "UMask": "0x1",
         "Unit": "R2PCIe"
     },
     {
-        "BriefDescription": "AK Ingress Bounced; Up",
-        "Counter": "0,1,2,3",
-        "EventCode": "0x12",
-        "EventName": "UNC_R2_RING_AK_BOUNCES.UP",
+        "BriefDescription": "R2 AD Ring in Use; Clockwise and Odd",
+        "EventCode": "0x7",
+        "EventName": "UNC_R2_RING_AD_USED.CW_ODD",
         "PerPkg": "1",
-        "UMask": "0x1",
+        "PublicDescription": "Counts the number of cycles that the AD ring=
 is being used at this ring stop.  This includes when packets are passing b=
y and when packets are being sunk, but does not include when packets are be=
ing sent from the ring stop.; Filters for the Clockwise and Odd ring polari=
ty.",
+        "UMask": "0x2",
         "Unit": "R2PCIe"
     },
     {
         "BriefDescription": "AK Ingress Bounced; Dn",
-        "Counter": "0,1,2,3",
         "EventCode": "0x12",
         "EventName": "UNC_R2_RING_AK_BOUNCES.DN",
         "PerPkg": "1",
+        "PublicDescription": "Counts the number of times when a request de=
stined for the AK ingress bounced.",
         "UMask": "0x2",
         "Unit": "R2PCIe"
     },
     {
-        "BriefDescription": "R2 AK Ring in Use; Clockwise and Even",
-        "Counter": "0,1,2,3",
-        "EventCode": "0x8",
-        "EventName": "UNC_R2_RING_AK_USED.CW_EVEN",
+        "BriefDescription": "AK Ingress Bounced; Up",
+        "EventCode": "0x12",
+        "EventName": "UNC_R2_RING_AK_BOUNCES.UP",
         "PerPkg": "1",
+        "PublicDescription": "Counts the number of times when a request de=
stined for the AK ingress bounced.",
         "UMask": "0x1",
         "Unit": "R2PCIe"
     },
     {
-        "BriefDescription": "R2 AK Ring in Use; Clockwise and Odd",
-        "Counter": "0,1,2,3",
+        "BriefDescription": "R2 AK Ring in Use; All",
         "EventCode": "0x8",
-        "EventName": "UNC_R2_RING_AK_USED.CW_ODD",
+        "EventName": "UNC_R2_RING_AK_USED.ALL",
         "PerPkg": "1",
-        "UMask": "0x2",
+        "PublicDescription": "Counts the number of cycles that the AK ring=
 is being used at this ring stop.  This includes when packets are passing b=
y and when packets are being sunk, but does not include when packets are be=
ing sent from the ring stop.",
+        "UMask": "0xf",
+        "Unit": "R2PCIe"
+    },
+    {
+        "BriefDescription": "R2 AK Ring in Use; Counterclockwise",
+        "EventCode": "0x8",
+        "EventName": "UNC_R2_RING_AK_USED.CCW",
+        "PerPkg": "1",
+        "PublicDescription": "Counts the number of cycles that the AK ring=
 is being used at this ring stop.  This includes when packets are passing b=
y and when packets are being sunk, but does not include when packets are be=
ing sent from the ring stop.",
+        "UMask": "0xc",
         "Unit": "R2PCIe"
     },
     {
         "BriefDescription": "R2 AK Ring in Use; Counterclockwise and Even"=
,
-        "Counter": "0,1,2,3",
         "EventCode": "0x8",
         "EventName": "UNC_R2_RING_AK_USED.CCW_EVEN",
         "PerPkg": "1",
+        "PublicDescription": "Counts the number of cycles that the AK ring=
 is being used at this ring stop.  This includes when packets are passing b=
y and when packets are being sunk, but does not include when packets are be=
ing sent from the ring stop.; Filters for the Counterclockwise and Even rin=
g polarity.",
         "UMask": "0x4",
         "Unit": "R2PCIe"
     },
     {
         "BriefDescription": "R2 AK Ring in Use; Counterclockwise and Odd",
-        "Counter": "0,1,2,3",
         "EventCode": "0x8",
         "EventName": "UNC_R2_RING_AK_USED.CCW_ODD",
         "PerPkg": "1",
+        "PublicDescription": "Counts the number of cycles that the AK ring=
 is being used at this ring stop.  This includes when packets are passing b=
y and when packets are being sunk, but does not include when packets are be=
ing sent from the ring stop.; Filters for the Counterclockwise and Odd ring=
 polarity.",
         "UMask": "0x8",
         "Unit": "R2PCIe"
     },
     {
         "BriefDescription": "R2 AK Ring in Use; Clockwise",
-        "Counter": "0,1,2,3",
         "EventCode": "0x8",
         "EventName": "UNC_R2_RING_AK_USED.CW",
         "PerPkg": "1",
+        "PublicDescription": "Counts the number of cycles that the AK ring=
 is being used at this ring stop.  This includes when packets are passing b=
y and when packets are being sunk, but does not include when packets are be=
ing sent from the ring stop.",
         "UMask": "0x3",
         "Unit": "R2PCIe"
     },
     {
-        "BriefDescription": "R2 AK Ring in Use; Counterclockwise",
-        "Counter": "0,1,2,3",
+        "BriefDescription": "R2 AK Ring in Use; Clockwise and Even",
         "EventCode": "0x8",
-        "EventName": "UNC_R2_RING_AK_USED.CCW",
+        "EventName": "UNC_R2_RING_AK_USED.CW_EVEN",
+        "PerPkg": "1",
+        "PublicDescription": "Counts the number of cycles that the AK ring=
 is being used at this ring stop.  This includes when packets are passing b=
y and when packets are being sunk, but does not include when packets are be=
ing sent from the ring stop.; Filters for the Clockwise and Even ring polar=
ity.",
+        "UMask": "0x1",
+        "Unit": "R2PCIe"
+    },
+    {
+        "BriefDescription": "R2 AK Ring in Use; Clockwise and Odd",
+        "EventCode": "0x8",
+        "EventName": "UNC_R2_RING_AK_USED.CW_ODD",
         "PerPkg": "1",
-        "UMask": "0xC",
+        "PublicDescription": "Counts the number of cycles that the AK ring=
 is being used at this ring stop.  This includes when packets are passing b=
y and when packets are being sunk, but does not include when packets are be=
ing sent from the ring stop.; Filters for the Clockwise and Odd ring polari=
ty.",
+        "UMask": "0x2",
         "Unit": "R2PCIe"
     },
     {
-        "BriefDescription": "R2 BL Ring in Use; Clockwise and Even",
-        "Counter": "0,1,2,3",
+        "BriefDescription": "R2 BL Ring in Use; All",
         "EventCode": "0x9",
-        "EventName": "UNC_R2_RING_BL_USED.CW_EVEN",
+        "EventName": "UNC_R2_RING_BL_USED.ALL",
         "PerPkg": "1",
-        "UMask": "0x1",
+        "PublicDescription": "Counts the number of cycles that the BL ring=
 is being used at this ring stop.  This includes when packets are passing b=
y and when packets are being sunk, but does not include when packets are be=
ing sent from the ring stop.",
+        "UMask": "0xf",
         "Unit": "R2PCIe"
     },
     {
-        "BriefDescription": "R2 BL Ring in Use; Clockwise and Odd",
-        "Counter": "0,1,2,3",
+        "BriefDescription": "R2 BL Ring in Use; Counterclockwise",
         "EventCode": "0x9",
-        "EventName": "UNC_R2_RING_BL_USED.CW_ODD",
+        "EventName": "UNC_R2_RING_BL_USED.CCW",
         "PerPkg": "1",
-        "UMask": "0x2",
+        "PublicDescription": "Counts the number of cycles that the BL ring=
 is being used at this ring stop.  This includes when packets are passing b=
y and when packets are being sunk, but does not include when packets are be=
ing sent from the ring stop.",
+        "UMask": "0xc",
         "Unit": "R2PCIe"
     },
     {
         "BriefDescription": "R2 BL Ring in Use; Counterclockwise and Even"=
,
-        "Counter": "0,1,2,3",
         "EventCode": "0x9",
         "EventName": "UNC_R2_RING_BL_USED.CCW_EVEN",
         "PerPkg": "1",
+        "PublicDescription": "Counts the number of cycles that the BL ring=
 is being used at this ring stop.  This includes when packets are passing b=
y and when packets are being sunk, but does not include when packets are be=
ing sent from the ring stop.; Filters for the Counterclockwise and Even rin=
g polarity.",
         "UMask": "0x4",
         "Unit": "R2PCIe"
     },
     {
         "BriefDescription": "R2 BL Ring in Use; Counterclockwise and Odd",
-        "Counter": "0,1,2,3",
         "EventCode": "0x9",
         "EventName": "UNC_R2_RING_BL_USED.CCW_ODD",
         "PerPkg": "1",
+        "PublicDescription": "Counts the number of cycles that the BL ring=
 is being used at this ring stop.  This includes when packets are passing b=
y and when packets are being sunk, but does not include when packets are be=
ing sent from the ring stop.; Filters for the Counterclockwise and Odd ring=
 polarity.",
         "UMask": "0x8",
         "Unit": "R2PCIe"
     },
     {
         "BriefDescription": "R2 BL Ring in Use; Clockwise",
-        "Counter": "0,1,2,3",
         "EventCode": "0x9",
         "EventName": "UNC_R2_RING_BL_USED.CW",
         "PerPkg": "1",
+        "PublicDescription": "Counts the number of cycles that the BL ring=
 is being used at this ring stop.  This includes when packets are passing b=
y and when packets are being sunk, but does not include when packets are be=
ing sent from the ring stop.",
         "UMask": "0x3",
         "Unit": "R2PCIe"
     },
     {
-        "BriefDescription": "R2 BL Ring in Use; Counterclockwise",
-        "Counter": "0,1,2,3",
+        "BriefDescription": "R2 BL Ring in Use; Clockwise and Even",
         "EventCode": "0x9",
-        "EventName": "UNC_R2_RING_BL_USED.CCW",
+        "EventName": "UNC_R2_RING_BL_USED.CW_EVEN",
         "PerPkg": "1",
-        "UMask": "0xC",
+        "PublicDescription": "Counts the number of cycles that the BL ring=
 is being used at this ring stop.  This includes when packets are passing b=
y and when packets are being sunk, but does not include when packets are be=
ing sent from the ring stop.; Filters for the Clockwise and Even ring polar=
ity.",
+        "UMask": "0x1",
         "Unit": "R2PCIe"
     },
     {
-        "BriefDescription": "R2 IV Ring in Use; Clockwise",
-        "Counter": "0,1,2,3",
+        "BriefDescription": "R2 BL Ring in Use; Clockwise and Odd",
+        "EventCode": "0x9",
+        "EventName": "UNC_R2_RING_BL_USED.CW_ODD",
+        "PerPkg": "1",
+        "PublicDescription": "Counts the number of cycles that the BL ring=
 is being used at this ring stop.  This includes when packets are passing b=
y and when packets are being sunk, but does not include when packets are be=
ing sent from the ring stop.; Filters for the Clockwise and Odd ring polari=
ty.",
+        "UMask": "0x2",
+        "Unit": "R2PCIe"
+    },
+    {
+        "BriefDescription": "R2 IV Ring in Use; Any",
         "EventCode": "0xA",
-        "EventName": "UNC_R2_RING_IV_USED.CW",
+        "EventName": "UNC_R2_RING_IV_USED.ANY",
         "PerPkg": "1",
-        "UMask": "0x3",
+        "PublicDescription": "Counts the number of cycles that the IV ring=
 is being used at this ring stop.  This includes when packets are passing b=
y and when packets are being sent, but does not include when packets are be=
ing sunk into the ring stop.",
+        "UMask": "0xf",
         "Unit": "R2PCIe"
     },
     {
         "BriefDescription": "R2 IV Ring in Use; Counterclockwise",
-        "Counter": "0,1,2,3",
         "EventCode": "0xA",
         "EventName": "UNC_R2_RING_IV_USED.CCW",
         "PerPkg": "1",
-        "UMask": "0xC",
+        "PublicDescription": "Counts the number of cycles that the IV ring=
 is being used at this ring stop.  This includes when packets are passing b=
y and when packets are being sent, but does not include when packets are be=
ing sunk into the ring stop.",
+        "UMask": "0xc",
         "Unit": "R2PCIe"
     },
     {
-        "BriefDescription": "R2 IV Ring in Use; Any",
-        "Counter": "0,1,2,3",
+        "BriefDescription": "R2 IV Ring in Use; Clockwise",
         "EventCode": "0xA",
-        "EventName": "UNC_R2_RING_IV_USED.ANY",
+        "EventName": "UNC_R2_RING_IV_USED.CW",
         "PerPkg": "1",
-        "UMask": "0xF",
+        "PublicDescription": "Counts the number of cycles that the IV ring=
 is being used at this ring stop.  This includes when packets are passing b=
y and when packets are being sent, but does not include when packets are be=
ing sunk into the ring stop.",
+        "UMask": "0x3",
         "Unit": "R2PCIe"
     },
     {
         "BriefDescription": "Ingress Cycles Not Empty; NCB",
-        "Counter": "0,1",
         "EventCode": "0x10",
         "EventName": "UNC_R2_RxR_CYCLES_NE.NCB",
         "PerPkg": "1",
+        "PublicDescription": "Counts the number of cycles when the R2PCIe =
Ingress is not empty.  This tracks one of the three rings that are used by =
the R2PCIe agent.  This can be used in conjunction with the R2PCIe Ingress =
Occupancy Accumulator event in order to calculate average queue occupancy. =
 Multiple ingress buffers can be tracked at a given time using multiple cou=
nters.; NCB Ingress Queue",
         "UMask": "0x10",
         "Unit": "R2PCIe"
     },
     {
         "BriefDescription": "Ingress Cycles Not Empty; NCS",
-        "Counter": "0,1",
         "EventCode": "0x10",
         "EventName": "UNC_R2_RxR_CYCLES_NE.NCS",
         "PerPkg": "1",
+        "PublicDescription": "Counts the number of cycles when the R2PCIe =
Ingress is not empty.  This tracks one of the three rings that are used by =
the R2PCIe agent.  This can be used in conjunction with the R2PCIe Ingress =
Occupancy Accumulator event in order to calculate average queue occupancy. =
 Multiple ingress buffers can be tracked at a given time using multiple cou=
nters.; NCS Ingress Queue",
         "UMask": "0x20",
         "Unit": "R2PCIe"
     },
     {
         "BriefDescription": "Ingress Allocations; NCB",
-        "Counter": "0,1",
         "EventCode": "0x11",
         "EventName": "UNC_R2_RxR_INSERTS.NCB",
         "PerPkg": "1",
+        "PublicDescription": "Counts the number of allocations into the R2=
PCIe Ingress.  This tracks one of the three rings that are used by the R2PC=
Ie agent.  This can be used in conjunction with the R2PCIe Ingress Occupanc=
y Accumulator event in order to calculate average queue latency.  Multiple =
ingress buffers can be tracked at a given time using multiple counters.; NC=
B Ingress Queue",
         "UMask": "0x10",
         "Unit": "R2PCIe"
     },
     {
         "BriefDescription": "Ingress Allocations; NCS",
-        "Counter": "0,1",
         "EventCode": "0x11",
         "EventName": "UNC_R2_RxR_INSERTS.NCS",
         "PerPkg": "1",
+        "PublicDescription": "Counts the number of allocations into the R2=
PCIe Ingress.  This tracks one of the three rings that are used by the R2PC=
Ie agent.  This can be used in conjunction with the R2PCIe Ingress Occupanc=
y Accumulator event in order to calculate average queue latency.  Multiple =
ingress buffers can be tracked at a given time using multiple counters.; NC=
S Ingress Queue",
         "UMask": "0x20",
         "Unit": "R2PCIe"
     },
@@ -778,60 +846,79 @@
         "EventCode": "0x13",
         "EventName": "UNC_R2_RxR_OCCUPANCY.DRS",
         "PerPkg": "1",
+        "PublicDescription": "Accumulates the occupancy of a given R2PCIe =
Ingress queue in each cycles.  This tracks one of the three ring Ingress bu=
ffers.  This can be used with the R2PCIe Ingress Not Empty event to calcula=
te average occupancy or the R2PCIe Ingress Allocations event in order to ca=
lculate average queuing latency.; DRS Ingress Queue",
         "UMask": "0x8",
         "Unit": "R2PCIe"
     },
     {
         "BriefDescription": "SBo0 Credits Acquired; For AD Ring",
-        "Counter": "0,1",
         "EventCode": "0x28",
         "EventName": "UNC_R2_SBO0_CREDITS_ACQUIRED.AD",
         "PerPkg": "1",
+        "PublicDescription": "Number of Sbo 0 credits acquired in a given =
cycle, per ring.",
         "UMask": "0x1",
         "Unit": "R2PCIe"
     },
     {
         "BriefDescription": "SBo0 Credits Acquired; For BL Ring",
-        "Counter": "0,1",
         "EventCode": "0x28",
         "EventName": "UNC_R2_SBO0_CREDITS_ACQUIRED.BL",
         "PerPkg": "1",
+        "PublicDescription": "Number of Sbo 0 credits acquired in a given =
cycle, per ring.",
         "UMask": "0x2",
         "Unit": "R2PCIe"
     },
     {
-        "BriefDescription": "Stall on No Sbo Credits; For SBo0, AD Ring",
-        "Counter": "0,1",
-        "EventCode": "0x2C",
-        "EventName": "UNC_R2_STALL_NO_SBO_CREDIT.SBO0_AD",
+        "BriefDescription": "SBo0 Credits Occupancy; For AD Ring",
+        "EventCode": "0x2A",
+        "EventName": "UNC_R2_SBO0_CREDIT_OCCUPANCY.AD",
         "PerPkg": "1",
+        "PublicDescription": "Number of Sbo 0 credits in use in a given cy=
cle, per ring.",
         "UMask": "0x1",
         "Unit": "R2PCIe"
     },
     {
-        "BriefDescription": "Stall on No Sbo Credits; For SBo1, AD Ring",
-        "Counter": "0,1",
-        "EventCode": "0x2C",
-        "EventName": "UNC_R2_STALL_NO_SBO_CREDIT.SBO1_AD",
+        "BriefDescription": "SBo0 Credits Occupancy; For BL Ring",
+        "EventCode": "0x2A",
+        "EventName": "UNC_R2_SBO0_CREDIT_OCCUPANCY.BL",
         "PerPkg": "1",
+        "PublicDescription": "Number of Sbo 0 credits in use in a given cy=
cle, per ring.",
         "UMask": "0x2",
         "Unit": "R2PCIe"
     },
+    {
+        "BriefDescription": "Stall on No Sbo Credits; For SBo0, AD Ring",
+        "EventCode": "0x2C",
+        "EventName": "UNC_R2_STALL_NO_SBO_CREDIT.SBO0_AD",
+        "PerPkg": "1",
+        "PublicDescription": "Number of cycles Egress is stalled waiting f=
or an Sbo credit to become available.  Per Sbo, per Ring.",
+        "UMask": "0x1",
+        "Unit": "R2PCIe"
+    },
     {
         "BriefDescription": "Stall on No Sbo Credits; For SBo0, BL Ring",
-        "Counter": "0,1",
         "EventCode": "0x2C",
         "EventName": "UNC_R2_STALL_NO_SBO_CREDIT.SBO0_BL",
         "PerPkg": "1",
+        "PublicDescription": "Number of cycles Egress is stalled waiting f=
or an Sbo credit to become available.  Per Sbo, per Ring.",
         "UMask": "0x4",
         "Unit": "R2PCIe"
     },
+    {
+        "BriefDescription": "Stall on No Sbo Credits; For SBo1, AD Ring",
+        "EventCode": "0x2C",
+        "EventName": "UNC_R2_STALL_NO_SBO_CREDIT.SBO1_AD",
+        "PerPkg": "1",
+        "PublicDescription": "Number of cycles Egress is stalled waiting f=
or an Sbo credit to become available.  Per Sbo, per Ring.",
+        "UMask": "0x2",
+        "Unit": "R2PCIe"
+    },
     {
         "BriefDescription": "Stall on No Sbo Credits; For SBo1, BL Ring",
-        "Counter": "0,1",
         "EventCode": "0x2C",
         "EventName": "UNC_R2_STALL_NO_SBO_CREDIT.SBO1_BL",
         "PerPkg": "1",
+        "PublicDescription": "Number of cycles Egress is stalled waiting f=
or an Sbo credit to become available.  Per Sbo, per Ring.",
         "UMask": "0x8",
         "Unit": "R2PCIe"
     },
@@ -840,6 +927,7 @@
         "EventCode": "0x25",
         "EventName": "UNC_R2_TxR_CYCLES_FULL.AD",
         "PerPkg": "1",
+        "PublicDescription": "Counts the number of cycles when the R2PCIe =
Egress buffer is full.; AD Egress Queue",
         "UMask": "0x1",
         "Unit": "R2PCIe"
     },
@@ -848,6 +936,7 @@
         "EventCode": "0x25",
         "EventName": "UNC_R2_TxR_CYCLES_FULL.AK",
         "PerPkg": "1",
+        "PublicDescription": "Counts the number of cycles when the R2PCIe =
Egress buffer is full.; AK Egress Queue",
         "UMask": "0x2",
         "Unit": "R2PCIe"
     },
@@ -856,6 +945,7 @@
         "EventCode": "0x25",
         "EventName": "UNC_R2_TxR_CYCLES_FULL.BL",
         "PerPkg": "1",
+        "PublicDescription": "Counts the number of cycles when the R2PCIe =
Egress buffer is full.; BL Egress Queue",
         "UMask": "0x4",
         "Unit": "R2PCIe"
     },
@@ -864,6 +954,7 @@
         "EventCode": "0x23",
         "EventName": "UNC_R2_TxR_CYCLES_NE.AD",
         "PerPkg": "1",
+        "PublicDescription": "Counts the number of cycles when the R2PCIe =
Egress is not empty.  This tracks one of the three rings that are used by t=
he R2PCIe agent.  This can be used in conjunction with the R2PCIe Egress Oc=
cupancy Accumulator event in order to calculate average queue occupancy.  O=
nly a single Egress queue can be tracked at any given time.  It is not poss=
ible to filter based on direction or polarity.; AD Egress Queue",
         "UMask": "0x1",
         "Unit": "R2PCIe"
     },
@@ -872,6 +963,7 @@
         "EventCode": "0x23",
         "EventName": "UNC_R2_TxR_CYCLES_NE.AK",
         "PerPkg": "1",
+        "PublicDescription": "Counts the number of cycles when the R2PCIe =
Egress is not empty.  This tracks one of the three rings that are used by t=
he R2PCIe agent.  This can be used in conjunction with the R2PCIe Egress Oc=
cupancy Accumulator event in order to calculate average queue occupancy.  O=
nly a single Egress queue can be tracked at any given time.  It is not poss=
ible to filter based on direction or polarity.; AK Egress Queue",
         "UMask": "0x2",
         "Unit": "R2PCIe"
     },
@@ -880,954 +972,925 @@
         "EventCode": "0x23",
         "EventName": "UNC_R2_TxR_CYCLES_NE.BL",
         "PerPkg": "1",
+        "PublicDescription": "Counts the number of cycles when the R2PCIe =
Egress is not empty.  This tracks one of the three rings that are used by t=
he R2PCIe agent.  This can be used in conjunction with the R2PCIe Egress Oc=
cupancy Accumulator event in order to calculate average queue occupancy.  O=
nly a single Egress queue can be tracked at any given time.  It is not poss=
ible to filter based on direction or polarity.; BL Egress Queue",
         "UMask": "0x4",
         "Unit": "R2PCIe"
     },
     {
         "BriefDescription": "Egress CCW NACK; AD CCW",
-        "Counter": "0,1",
         "EventCode": "0x26",
         "EventName": "UNC_R2_TxR_NACK_CW.DN_AD",
         "PerPkg": "1",
+        "PublicDescription": "AD CounterClockwise Egress Queue",
         "UMask": "0x1",
         "Unit": "R2PCIe"
     },
-    {
-        "BriefDescription": "Egress CCW NACK; BL CCW",
-        "Counter": "0,1",
-        "EventCode": "0x26",
-        "EventName": "UNC_R2_TxR_NACK_CW.DN_BL",
-        "PerPkg": "1",
-        "UMask": "0x2",
-        "Unit": "R2PCIe"
-    },
     {
         "BriefDescription": "Egress CCW NACK; AK CCW",
-        "Counter": "0,1",
         "EventCode": "0x26",
         "EventName": "UNC_R2_TxR_NACK_CW.DN_AK",
         "PerPkg": "1",
+        "PublicDescription": "AK CounterClockwise Egress Queue",
         "UMask": "0x4",
         "Unit": "R2PCIe"
     },
     {
-        "BriefDescription": "Egress CCW NACK; AK CCW",
-        "Counter": "0,1",
+        "BriefDescription": "Egress CCW NACK; BL CCW",
         "EventCode": "0x26",
-        "EventName": "UNC_R2_TxR_NACK_CW.UP_AD",
+        "EventName": "UNC_R2_TxR_NACK_CW.DN_BL",
         "PerPkg": "1",
-        "UMask": "0x8",
+        "PublicDescription": "BL CounterClockwise Egress Queue",
+        "UMask": "0x2",
         "Unit": "R2PCIe"
     },
     {
-        "BriefDescription": "Egress CCW NACK; BL CCW",
-        "Counter": "0,1",
+        "BriefDescription": "Egress CCW NACK; AK CCW",
         "EventCode": "0x26",
-        "EventName": "UNC_R2_TxR_NACK_CW.UP_BL",
+        "EventName": "UNC_R2_TxR_NACK_CW.UP_AD",
         "PerPkg": "1",
-        "UMask": "0x10",
+        "PublicDescription": "BL CounterClockwise Egress Queue",
+        "UMask": "0x8",
         "Unit": "R2PCIe"
     },
     {
         "BriefDescription": "Egress CCW NACK; BL CW",
-        "Counter": "0,1",
         "EventCode": "0x26",
         "EventName": "UNC_R2_TxR_NACK_CW.UP_AK",
         "PerPkg": "1",
+        "PublicDescription": "AD Clockwise Egress Queue",
         "UMask": "0x20",
         "Unit": "R2PCIe"
     },
     {
-        "BriefDescription": "R2PCIe IIO Credit Acquired; DRS",
-        "Counter": "0,1",
-        "EventCode": "0x33",
-        "EventName": "UNC_R2_IIO_CREDITS_ACQUIRED.DRS",
-        "PerPkg": "1",
-        "UMask": "0x8",
-        "Unit": "R2PCIe"
-    },
-    {
-        "BriefDescription": "R2PCIe IIO Credit Acquired; NCB",
-        "Counter": "0,1",
-        "EventCode": "0x33",
-        "EventName": "UNC_R2_IIO_CREDITS_ACQUIRED.NCB",
-        "PerPkg": "1",
-        "UMask": "0x10",
-        "Unit": "R2PCIe"
-    },
-    {
-        "BriefDescription": "R2PCIe IIO Credit Acquired; NCS",
-        "Counter": "0,1",
-        "EventCode": "0x33",
-        "EventName": "UNC_R2_IIO_CREDITS_ACQUIRED.NCS",
-        "PerPkg": "1",
-        "UMask": "0x20",
-        "Unit": "R2PCIe"
-    },
-    {
-        "BriefDescription": "R2PCIe IIO Credits in Use; DRS",
-        "Counter": "0,1",
-        "EventCode": "0x32",
-        "EventName": "UNC_R2_IIO_CREDITS_USED.DRS",
-        "PerPkg": "1",
-        "UMask": "0x8",
-        "Unit": "R2PCIe"
-    },
-    {
-        "BriefDescription": "R2PCIe IIO Credits in Use; NCB",
-        "Counter": "0,1",
-        "EventCode": "0x32",
-        "EventName": "UNC_R2_IIO_CREDITS_USED.NCB",
+        "BriefDescription": "Egress CCW NACK; BL CCW",
+        "EventCode": "0x26",
+        "EventName": "UNC_R2_TxR_NACK_CW.UP_BL",
         "PerPkg": "1",
+        "PublicDescription": "AD CounterClockwise Egress Queue",
         "UMask": "0x10",
         "Unit": "R2PCIe"
     },
-    {
-        "BriefDescription": "R2PCIe IIO Credits in Use; NCS",
-        "Counter": "0,1",
-        "EventCode": "0x32",
-        "EventName": "UNC_R2_IIO_CREDITS_USED.NCS",
-        "PerPkg": "1",
-        "UMask": "0x20",
-        "Unit": "R2PCIe"
-    },
-    {
-        "BriefDescription": "SBo0 Credits Occupancy; For AD Ring",
-        "EventCode": "0x2A",
-        "EventName": "UNC_R2_SBO0_CREDIT_OCCUPANCY.AD",
-        "PerPkg": "1",
-        "UMask": "0x1",
-        "Unit": "R2PCIe"
-    },
-    {
-        "BriefDescription": "SBo0 Credits Occupancy; For BL Ring",
-        "EventCode": "0x2A",
-        "EventName": "UNC_R2_SBO0_CREDIT_OCCUPANCY.BL",
-        "PerPkg": "1",
-        "UMask": "0x2",
-        "Unit": "R2PCIe"
-    },
-    {
-        "BriefDescription": "R2 AD Ring in Use; All",
-        "Counter": "0,1,2,3",
-        "EventCode": "0x7",
-        "EventName": "UNC_R2_RING_AD_USED.ALL",
-        "PerPkg": "1",
-        "UMask": "0xF",
-        "Unit": "R2PCIe"
-    },
-    {
-        "BriefDescription": "R2 AK Ring in Use; All",
-        "Counter": "0,1,2,3",
-        "EventCode": "0x8",
-        "EventName": "UNC_R2_RING_AK_USED.ALL",
-        "PerPkg": "1",
-        "UMask": "0xF",
-        "Unit": "R2PCIe"
-    },
-    {
-        "BriefDescription": "R2 BL Ring in Use; All",
-        "Counter": "0,1,2,3",
-        "EventCode": "0x9",
-        "EventName": "UNC_R2_RING_BL_USED.ALL",
-        "PerPkg": "1",
-        "UMask": "0xF",
-        "Unit": "R2PCIe"
-    },
     {
         "BriefDescription": "Number of uclks in domain",
-        "Counter": "0,1,2",
         "EventCode": "0x1",
         "EventName": "UNC_R3_CLOCKTICKS",
         "PerPkg": "1",
+        "PublicDescription": "Counts the number of uclks in the QPI uclk d=
omain.  This could be slightly different than the count in the Ubox because=
 of enable/freeze delays.  However, because the QPI Agent is close to the U=
box, they generally should not diverge by more than a handful of cycles.",
         "Unit": "R3QPI"
     },
     {
         "BriefDescription": "CBox AD Credits Empty",
-        "Counter": "0,1",
         "EventCode": "0x1F",
-        "EventName": "UNC_R3_C_HI_AD_CREDITS_EMPTY.CBO8",
+        "EventName": "UNC_R3_C_HI_AD_CREDITS_EMPTY.CBO10",
         "PerPkg": "1",
-        "UMask": "0x1",
+        "PublicDescription": "No credits available to send to Cbox on the =
AD Ring (covers higher CBoxes); Cbox 10",
+        "UMask": "0x4",
         "Unit": "R3QPI"
     },
     {
         "BriefDescription": "CBox AD Credits Empty",
-        "Counter": "0,1",
         "EventCode": "0x1F",
-        "EventName": "UNC_R3_C_HI_AD_CREDITS_EMPTY.CBO9",
+        "EventName": "UNC_R3_C_HI_AD_CREDITS_EMPTY.CBO11",
         "PerPkg": "1",
-        "UMask": "0x2",
+        "PublicDescription": "No credits available to send to Cbox on the =
AD Ring (covers higher CBoxes); Cbox 11",
+        "UMask": "0x8",
         "Unit": "R3QPI"
     },
     {
         "BriefDescription": "CBox AD Credits Empty",
-        "Counter": "0,1",
         "EventCode": "0x1F",
-        "EventName": "UNC_R3_C_HI_AD_CREDITS_EMPTY.CBO10",
+        "EventName": "UNC_R3_C_HI_AD_CREDITS_EMPTY.CBO12",
         "PerPkg": "1",
-        "UMask": "0x4",
+        "PublicDescription": "No credits available to send to Cbox on the =
AD Ring (covers higher CBoxes); Cbox 12",
+        "UMask": "0x10",
         "Unit": "R3QPI"
     },
     {
         "BriefDescription": "CBox AD Credits Empty",
-        "Counter": "0,1",
         "EventCode": "0x1F",
-        "EventName": "UNC_R3_C_HI_AD_CREDITS_EMPTY.CBO11",
+        "EventName": "UNC_R3_C_HI_AD_CREDITS_EMPTY.CBO13",
         "PerPkg": "1",
-        "UMask": "0x8",
+        "PublicDescription": "No credits available to send to Cbox on the =
AD Ring (covers higher CBoxes); Cbox 13",
+        "UMask": "0x20",
         "Unit": "R3QPI"
     },
     {
         "BriefDescription": "CBox AD Credits Empty",
-        "Counter": "0,1",
         "EventCode": "0x1F",
-        "EventName": "UNC_R3_C_HI_AD_CREDITS_EMPTY.CBO12",
+        "EventName": "UNC_R3_C_HI_AD_CREDITS_EMPTY.CBO14_16",
         "PerPkg": "1",
-        "UMask": "0x10",
+        "PublicDescription": "No credits available to send to Cbox on the =
AD Ring (covers higher CBoxes); Cbox 14&16",
+        "UMask": "0x40",
         "Unit": "R3QPI"
     },
     {
         "BriefDescription": "CBox AD Credits Empty",
-        "Counter": "0,1",
         "EventCode": "0x1F",
-        "EventName": "UNC_R3_C_HI_AD_CREDITS_EMPTY.CBO13",
+        "EventName": "UNC_R3_C_HI_AD_CREDITS_EMPTY.CBO8",
         "PerPkg": "1",
-        "UMask": "0x20",
+        "PublicDescription": "No credits available to send to Cbox on the =
AD Ring (covers higher CBoxes); Cbox 8",
+        "UMask": "0x1",
         "Unit": "R3QPI"
     },
     {
         "BriefDescription": "CBox AD Credits Empty",
-        "Counter": "0,1",
         "EventCode": "0x1F",
-        "EventName": "UNC_R3_C_HI_AD_CREDITS_EMPTY.CBO14_16",
+        "EventName": "UNC_R3_C_HI_AD_CREDITS_EMPTY.CBO9",
         "PerPkg": "1",
-        "UMask": "0x40",
+        "PublicDescription": "No credits available to send to Cbox on the =
AD Ring (covers higher CBoxes); Cbox 9",
+        "UMask": "0x2",
         "Unit": "R3QPI"
     },
     {
         "BriefDescription": "CBox AD Credits Empty",
-        "Counter": "0,1",
         "EventCode": "0x1F",
         "EventName": "UNC_R3_C_HI_AD_CREDITS_EMPTY.CBO_15_17",
         "PerPkg": "1",
+        "PublicDescription": "No credits available to send to Cbox on the =
AD Ring (covers higher CBoxes); Cbox 15&17",
         "UMask": "0x80",
         "Unit": "R3QPI"
     },
     {
         "BriefDescription": "CBox AD Credits Empty",
-        "Counter": "0,1",
         "EventCode": "0x22",
         "EventName": "UNC_R3_C_LO_AD_CREDITS_EMPTY.CBO0",
         "PerPkg": "1",
+        "PublicDescription": "No credits available to send to Cbox on the =
AD Ring (covers lower CBoxes); Cbox 0",
         "UMask": "0x1",
         "Unit": "R3QPI"
     },
     {
         "BriefDescription": "CBox AD Credits Empty",
-        "Counter": "0,1",
         "EventCode": "0x22",
         "EventName": "UNC_R3_C_LO_AD_CREDITS_EMPTY.CBO1",
         "PerPkg": "1",
+        "PublicDescription": "No credits available to send to Cbox on the =
AD Ring (covers lower CBoxes); Cbox 1",
         "UMask": "0x2",
         "Unit": "R3QPI"
     },
     {
         "BriefDescription": "CBox AD Credits Empty",
-        "Counter": "0,1",
         "EventCode": "0x22",
         "EventName": "UNC_R3_C_LO_AD_CREDITS_EMPTY.CBO2",
         "PerPkg": "1",
+        "PublicDescription": "No credits available to send to Cbox on the =
AD Ring (covers lower CBoxes); Cbox 2",
         "UMask": "0x4",
         "Unit": "R3QPI"
     },
     {
         "BriefDescription": "CBox AD Credits Empty",
-        "Counter": "0,1",
         "EventCode": "0x22",
         "EventName": "UNC_R3_C_LO_AD_CREDITS_EMPTY.CBO3",
         "PerPkg": "1",
+        "PublicDescription": "No credits available to send to Cbox on the =
AD Ring (covers lower CBoxes); Cbox 3",
         "UMask": "0x8",
         "Unit": "R3QPI"
     },
     {
         "BriefDescription": "CBox AD Credits Empty",
-        "Counter": "0,1",
         "EventCode": "0x22",
         "EventName": "UNC_R3_C_LO_AD_CREDITS_EMPTY.CBO4",
         "PerPkg": "1",
+        "PublicDescription": "No credits available to send to Cbox on the =
AD Ring (covers lower CBoxes); Cbox 4",
         "UMask": "0x10",
         "Unit": "R3QPI"
     },
     {
         "BriefDescription": "CBox AD Credits Empty",
-        "Counter": "0,1",
         "EventCode": "0x22",
         "EventName": "UNC_R3_C_LO_AD_CREDITS_EMPTY.CBO5",
         "PerPkg": "1",
+        "PublicDescription": "No credits available to send to Cbox on the =
AD Ring (covers lower CBoxes); Cbox 5",
         "UMask": "0x20",
         "Unit": "R3QPI"
     },
     {
         "BriefDescription": "CBox AD Credits Empty",
-        "Counter": "0,1",
         "EventCode": "0x22",
         "EventName": "UNC_R3_C_LO_AD_CREDITS_EMPTY.CBO6",
         "PerPkg": "1",
+        "PublicDescription": "No credits available to send to Cbox on the =
AD Ring (covers lower CBoxes); Cbox 6",
         "UMask": "0x40",
         "Unit": "R3QPI"
     },
     {
         "BriefDescription": "CBox AD Credits Empty",
-        "Counter": "0,1",
         "EventCode": "0x22",
         "EventName": "UNC_R3_C_LO_AD_CREDITS_EMPTY.CBO7",
         "PerPkg": "1",
+        "PublicDescription": "No credits available to send to Cbox on the =
AD Ring (covers lower CBoxes); Cbox 7",
         "UMask": "0x80",
         "Unit": "R3QPI"
     },
     {
         "BriefDescription": "HA/R2 AD Credits Empty",
-        "Counter": "0,1",
         "EventCode": "0x2D",
         "EventName": "UNC_R3_HA_R2_BL_CREDITS_EMPTY.HA0",
         "PerPkg": "1",
+        "PublicDescription": "No credits available to send to either HA or=
 R2 on the BL Ring; HA0",
         "UMask": "0x1",
         "Unit": "R3QPI"
     },
     {
         "BriefDescription": "HA/R2 AD Credits Empty",
-        "Counter": "0,1",
         "EventCode": "0x2D",
         "EventName": "UNC_R3_HA_R2_BL_CREDITS_EMPTY.HA1",
         "PerPkg": "1",
+        "PublicDescription": "No credits available to send to either HA or=
 R2 on the BL Ring; HA1",
         "UMask": "0x2",
         "Unit": "R3QPI"
     },
     {
         "BriefDescription": "HA/R2 AD Credits Empty",
-        "Counter": "0,1",
         "EventCode": "0x2D",
         "EventName": "UNC_R3_HA_R2_BL_CREDITS_EMPTY.R2_NCB",
         "PerPkg": "1",
+        "PublicDescription": "No credits available to send to either HA or=
 R2 on the BL Ring; R2 NCB Messages",
         "UMask": "0x4",
         "Unit": "R3QPI"
     },
     {
         "BriefDescription": "HA/R2 AD Credits Empty",
-        "Counter": "0,1",
         "EventCode": "0x2D",
         "EventName": "UNC_R3_HA_R2_BL_CREDITS_EMPTY.R2_NCS",
         "PerPkg": "1",
+        "PublicDescription": "No credits available to send to either HA or=
 R2 on the BL Ring; R2 NCS Messages",
         "UMask": "0x8",
         "Unit": "R3QPI"
     },
     {
-        "BriefDescription": "QPI0 AD Credits Empty",
-        "Counter": "0,1",
-        "EventCode": "0x20",
-        "EventName": "UNC_R3_QPI0_AD_CREDITS_EMPTY.VNA",
+        "BriefDescription": "IOT Backpressure",
+        "EventCode": "0xB",
+        "EventName": "UNC_R3_IOT_BACKPRESSURE.HUB",
         "PerPkg": "1",
-        "UMask": "0x1",
+        "PublicDescription": "UNC_R3_IOT_BACKPRESSURE.HUB",
+        "UMask": "0x2",
         "Unit": "R3QPI"
     },
     {
-        "BriefDescription": "QPI0 AD Credits Empty",
-        "Counter": "0,1",
-        "EventCode": "0x20",
-        "EventName": "UNC_R3_QPI0_AD_CREDITS_EMPTY.VN0_HOM",
+        "BriefDescription": "IOT Backpressure",
+        "EventCode": "0xB",
+        "EventName": "UNC_R3_IOT_BACKPRESSURE.SAT",
         "PerPkg": "1",
-        "UMask": "0x2",
+        "PublicDescription": "UNC_R3_IOT_BACKPRESSURE.SAT",
+        "UMask": "0x1",
         "Unit": "R3QPI"
     },
     {
-        "BriefDescription": "QPI0 AD Credits Empty",
-        "Counter": "0,1",
-        "EventCode": "0x20",
-        "EventName": "UNC_R3_QPI0_AD_CREDITS_EMPTY.VN0_SNP",
+        "BriefDescription": "IOT Common Trigger Sequencer - Hi",
+        "EventCode": "0xD",
+        "EventName": "UNC_R3_IOT_CTS_HI.CTS2",
         "PerPkg": "1",
-        "UMask": "0x4",
+        "PublicDescription": "Debug Mask/Match Tie-Ins",
+        "UMask": "0x1",
         "Unit": "R3QPI"
     },
     {
-        "BriefDescription": "QPI0 AD Credits Empty",
-        "Counter": "0,1",
-        "EventCode": "0x20",
-        "EventName": "UNC_R3_QPI0_AD_CREDITS_EMPTY.VN0_NDR",
+        "BriefDescription": "IOT Common Trigger Sequencer - Hi",
+        "EventCode": "0xD",
+        "EventName": "UNC_R3_IOT_CTS_HI.CTS3",
         "PerPkg": "1",
-        "UMask": "0x8",
+        "PublicDescription": "Debug Mask/Match Tie-Ins",
+        "UMask": "0x2",
         "Unit": "R3QPI"
     },
     {
-        "BriefDescription": "QPI0 AD Credits Empty",
-        "Counter": "0,1",
-        "EventCode": "0x20",
-        "EventName": "UNC_R3_QPI0_AD_CREDITS_EMPTY.VN1_HOM",
+        "BriefDescription": "IOT Common Trigger Sequencer - Lo",
+        "EventCode": "0xC",
+        "EventName": "UNC_R3_IOT_CTS_LO.CTS0",
         "PerPkg": "1",
-        "UMask": "0x10",
+        "PublicDescription": "Debug Mask/Match Tie-Ins",
+        "UMask": "0x1",
+        "Unit": "R3QPI"
+    },
+    {
+        "BriefDescription": "IOT Common Trigger Sequencer - Lo",
+        "EventCode": "0xC",
+        "EventName": "UNC_R3_IOT_CTS_LO.CTS1",
+        "PerPkg": "1",
+        "PublicDescription": "Debug Mask/Match Tie-Ins",
+        "UMask": "0x2",
         "Unit": "R3QPI"
     },
     {
         "BriefDescription": "QPI0 AD Credits Empty",
-        "Counter": "0,1",
         "EventCode": "0x20",
-        "EventName": "UNC_R3_QPI0_AD_CREDITS_EMPTY.VN1_SNP",
+        "EventName": "UNC_R3_QPI0_AD_CREDITS_EMPTY.VN0_HOM",
         "PerPkg": "1",
-        "UMask": "0x20",
+        "PublicDescription": "No credits available to send to QPI0 on the =
AD Ring; VN0 HOM Messages",
+        "UMask": "0x2",
+        "Unit": "R3QPI"
+    },
+    {
+        "BriefDescription": "QPI0 AD Credits Empty",
+        "EventCode": "0x20",
+        "EventName": "UNC_R3_QPI0_AD_CREDITS_EMPTY.VN0_NDR",
+        "PerPkg": "1",
+        "PublicDescription": "No credits available to send to QPI0 on the =
AD Ring; VN0 NDR Messages",
+        "UMask": "0x8",
+        "Unit": "R3QPI"
+    },
+    {
+        "BriefDescription": "QPI0 AD Credits Empty",
+        "EventCode": "0x20",
+        "EventName": "UNC_R3_QPI0_AD_CREDITS_EMPTY.VN0_SNP",
+        "PerPkg": "1",
+        "PublicDescription": "No credits available to send to QPI0 on the =
AD Ring; VN0 SNP Messages",
+        "UMask": "0x4",
+        "Unit": "R3QPI"
+    },
+    {
+        "BriefDescription": "QPI0 AD Credits Empty",
+        "EventCode": "0x20",
+        "EventName": "UNC_R3_QPI0_AD_CREDITS_EMPTY.VN1_HOM",
+        "PerPkg": "1",
+        "PublicDescription": "No credits available to send to QPI0 on the =
AD Ring; VN1 HOM Messages",
+        "UMask": "0x10",
         "Unit": "R3QPI"
     },
     {
         "BriefDescription": "QPI0 AD Credits Empty",
-        "Counter": "0,1",
         "EventCode": "0x20",
         "EventName": "UNC_R3_QPI0_AD_CREDITS_EMPTY.VN1_NDR",
         "PerPkg": "1",
+        "PublicDescription": "No credits available to send to QPI0 on the =
AD Ring; VN1 NDR Messages",
         "UMask": "0x40",
         "Unit": "R3QPI"
     },
     {
-        "BriefDescription": "QPI0 BL Credits Empty",
-        "Counter": "0,1",
-        "EventCode": "0x21",
-        "EventName": "UNC_R3_QPI0_BL_CREDITS_EMPTY.VNA",
+        "BriefDescription": "QPI0 AD Credits Empty",
+        "EventCode": "0x20",
+        "EventName": "UNC_R3_QPI0_AD_CREDITS_EMPTY.VN1_SNP",
+        "PerPkg": "1",
+        "PublicDescription": "No credits available to send to QPI0 on the =
AD Ring; VN1 SNP Messages",
+        "UMask": "0x20",
+        "Unit": "R3QPI"
+    },
+    {
+        "BriefDescription": "QPI0 AD Credits Empty",
+        "EventCode": "0x20",
+        "EventName": "UNC_R3_QPI0_AD_CREDITS_EMPTY.VNA",
         "PerPkg": "1",
+        "PublicDescription": "No credits available to send to QPI0 on the =
AD Ring; VNA",
         "UMask": "0x1",
         "Unit": "R3QPI"
     },
     {
         "BriefDescription": "QPI0 BL Credits Empty",
-        "Counter": "0,1",
         "EventCode": "0x21",
         "EventName": "UNC_R3_QPI0_BL_CREDITS_EMPTY.VN1_HOM",
         "PerPkg": "1",
+        "PublicDescription": "No credits available to send to QPI0 on the =
BL Ring; VN1 HOM Messages",
         "UMask": "0x10",
         "Unit": "R3QPI"
     },
     {
         "BriefDescription": "QPI0 BL Credits Empty",
-        "Counter": "0,1",
+        "EventCode": "0x21",
+        "EventName": "UNC_R3_QPI0_BL_CREDITS_EMPTY.VN1_NDR",
+        "PerPkg": "1",
+        "PublicDescription": "No credits available to send to QPI0 on the =
BL Ring; VN1 NDR Messages",
+        "UMask": "0x40",
+        "Unit": "R3QPI"
+    },
+    {
+        "BriefDescription": "QPI0 BL Credits Empty",
         "EventCode": "0x21",
         "EventName": "UNC_R3_QPI0_BL_CREDITS_EMPTY.VN1_SNP",
         "PerPkg": "1",
+        "PublicDescription": "No credits available to send to QPI0 on the =
BL Ring; VN1 SNP Messages",
         "UMask": "0x20",
         "Unit": "R3QPI"
     },
     {
         "BriefDescription": "QPI0 BL Credits Empty",
-        "Counter": "0,1",
         "EventCode": "0x21",
-        "EventName": "UNC_R3_QPI0_BL_CREDITS_EMPTY.VN1_NDR",
+        "EventName": "UNC_R3_QPI0_BL_CREDITS_EMPTY.VNA",
         "PerPkg": "1",
-        "UMask": "0x40",
+        "PublicDescription": "No credits available to send to QPI0 on the =
BL Ring; VNA",
+        "UMask": "0x1",
         "Unit": "R3QPI"
     },
     {
         "BriefDescription": "QPI1 AD Credits Empty",
-        "Counter": "0,1",
         "EventCode": "0x2E",
-        "EventName": "UNC_R3_QPI1_AD_CREDITS_EMPTY.VNA",
+        "EventName": "UNC_R3_QPI1_AD_CREDITS_EMPTY.VN1_HOM",
         "PerPkg": "1",
-        "UMask": "0x1",
+        "PublicDescription": "No credits available to send to QPI1 on the =
AD Ring; VN1 HOM Messages",
+        "UMask": "0x10",
         "Unit": "R3QPI"
     },
     {
         "BriefDescription": "QPI1 AD Credits Empty",
-        "Counter": "0,1",
         "EventCode": "0x2E",
-        "EventName": "UNC_R3_QPI1_AD_CREDITS_EMPTY.VN1_HOM",
+        "EventName": "UNC_R3_QPI1_AD_CREDITS_EMPTY.VN1_NDR",
         "PerPkg": "1",
-        "UMask": "0x10",
+        "PublicDescription": "No credits available to send to QPI1 on the =
AD Ring; VN1 NDR Messages",
+        "UMask": "0x40",
         "Unit": "R3QPI"
     },
     {
         "BriefDescription": "QPI1 AD Credits Empty",
-        "Counter": "0,1",
         "EventCode": "0x2E",
         "EventName": "UNC_R3_QPI1_AD_CREDITS_EMPTY.VN1_SNP",
         "PerPkg": "1",
+        "PublicDescription": "No credits available to send to QPI1 on the =
AD Ring; VN1 SNP Messages",
         "UMask": "0x20",
         "Unit": "R3QPI"
     },
     {
         "BriefDescription": "QPI1 AD Credits Empty",
-        "Counter": "0,1",
         "EventCode": "0x2E",
-        "EventName": "UNC_R3_QPI1_AD_CREDITS_EMPTY.VN1_NDR",
+        "EventName": "UNC_R3_QPI1_AD_CREDITS_EMPTY.VNA",
         "PerPkg": "1",
-        "UMask": "0x40",
+        "PublicDescription": "No credits available to send to QPI1 on the =
AD Ring; VNA",
+        "UMask": "0x1",
         "Unit": "R3QPI"
     },
     {
         "BriefDescription": "QPI1 BL Credits Empty",
-        "Counter": "0,1",
         "EventCode": "0x2F",
-        "EventName": "UNC_R3_QPI1_BL_CREDITS_EMPTY.VNA",
+        "EventName": "UNC_R3_QPI1_BL_CREDITS_EMPTY.VN0_HOM",
         "PerPkg": "1",
-        "UMask": "0x1",
+        "PublicDescription": "No credits available to send to QPI1 on the =
BL Ring; VN0 HOM Messages",
+        "UMask": "0x2",
         "Unit": "R3QPI"
     },
     {
         "BriefDescription": "QPI1 BL Credits Empty",
-        "Counter": "0,1",
         "EventCode": "0x2F",
-        "EventName": "UNC_R3_QPI1_BL_CREDITS_EMPTY.VN0_HOM",
+        "EventName": "UNC_R3_QPI1_BL_CREDITS_EMPTY.VN0_NDR",
         "PerPkg": "1",
-        "UMask": "0x2",
+        "PublicDescription": "No credits available to send to QPI1 on the =
BL Ring; VN0 NDR Messages",
+        "UMask": "0x8",
         "Unit": "R3QPI"
     },
     {
         "BriefDescription": "QPI1 BL Credits Empty",
-        "Counter": "0,1",
         "EventCode": "0x2F",
         "EventName": "UNC_R3_QPI1_BL_CREDITS_EMPTY.VN0_SNP",
         "PerPkg": "1",
+        "PublicDescription": "No credits available to send to QPI1 on the =
BL Ring; VN0 SNP Messages",
         "UMask": "0x4",
         "Unit": "R3QPI"
     },
     {
         "BriefDescription": "QPI1 BL Credits Empty",
-        "Counter": "0,1",
         "EventCode": "0x2F",
-        "EventName": "UNC_R3_QPI1_BL_CREDITS_EMPTY.VN0_NDR",
+        "EventName": "UNC_R3_QPI1_BL_CREDITS_EMPTY.VN1_HOM",
         "PerPkg": "1",
-        "UMask": "0x8",
+        "PublicDescription": "No credits available to send to QPI1 on the =
BL Ring; VN1 HOM Messages",
+        "UMask": "0x10",
         "Unit": "R3QPI"
     },
     {
         "BriefDescription": "QPI1 BL Credits Empty",
-        "Counter": "0,1",
         "EventCode": "0x2F",
-        "EventName": "UNC_R3_QPI1_BL_CREDITS_EMPTY.VN1_HOM",
+        "EventName": "UNC_R3_QPI1_BL_CREDITS_EMPTY.VN1_NDR",
         "PerPkg": "1",
-        "UMask": "0x10",
+        "PublicDescription": "No credits available to send to QPI1 on the =
BL Ring; VN1 NDR Messages",
+        "UMask": "0x40",
         "Unit": "R3QPI"
     },
     {
         "BriefDescription": "QPI1 BL Credits Empty",
-        "Counter": "0,1",
         "EventCode": "0x2F",
         "EventName": "UNC_R3_QPI1_BL_CREDITS_EMPTY.VN1_SNP",
         "PerPkg": "1",
+        "PublicDescription": "No credits available to send to QPI1 on the =
BL Ring; VN1 SNP Messages",
         "UMask": "0x20",
         "Unit": "R3QPI"
     },
     {
         "BriefDescription": "QPI1 BL Credits Empty",
-        "Counter": "0,1",
         "EventCode": "0x2F",
-        "EventName": "UNC_R3_QPI1_BL_CREDITS_EMPTY.VN1_NDR",
+        "EventName": "UNC_R3_QPI1_BL_CREDITS_EMPTY.VNA",
         "PerPkg": "1",
-        "UMask": "0x40",
+        "PublicDescription": "No credits available to send to QPI1 on the =
BL Ring; VNA",
+        "UMask": "0x1",
         "Unit": "R3QPI"
     },
     {
-        "BriefDescription": "R3 AD Ring in Use; Clockwise and Even",
-        "Counter": "0,1,2",
+        "BriefDescription": "R3 AD Ring in Use; All",
         "EventCode": "0x7",
-        "EventName": "UNC_R3_RING_AD_USED.CW_EVEN",
+        "EventName": "UNC_R3_RING_AD_USED.ALL",
         "PerPkg": "1",
-        "UMask": "0x1",
+        "PublicDescription": "Counts the number of cycles that the AD ring=
 is being used at this ring stop.  This includes when packets are passing b=
y and when packets are being sunk, but does not include when packets are be=
ing sent from the ring stop.",
+        "UMask": "0xf",
         "Unit": "R3QPI"
     },
     {
-        "BriefDescription": "R3 AD Ring in Use; Clockwise and Odd",
-        "Counter": "0,1,2",
+        "BriefDescription": "R3 AD Ring in Use; Counterclockwise",
         "EventCode": "0x7",
-        "EventName": "UNC_R3_RING_AD_USED.CW_ODD",
+        "EventName": "UNC_R3_RING_AD_USED.CCW",
         "PerPkg": "1",
-        "UMask": "0x2",
+        "PublicDescription": "Counts the number of cycles that the AD ring=
 is being used at this ring stop.  This includes when packets are passing b=
y and when packets are being sunk, but does not include when packets are be=
ing sent from the ring stop.",
+        "UMask": "0xc",
         "Unit": "R3QPI"
     },
     {
         "BriefDescription": "R3 AD Ring in Use; Counterclockwise and Even"=
,
-        "Counter": "0,1,2",
         "EventCode": "0x7",
         "EventName": "UNC_R3_RING_AD_USED.CCW_EVEN",
         "PerPkg": "1",
+        "PublicDescription": "Counts the number of cycles that the AD ring=
 is being used at this ring stop.  This includes when packets are passing b=
y and when packets are being sunk, but does not include when packets are be=
ing sent from the ring stop.; Filters for the Counterclockwise and Even rin=
g polarity.",
         "UMask": "0x4",
         "Unit": "R3QPI"
     },
     {
         "BriefDescription": "R3 AD Ring in Use; Counterclockwise and Odd",
-        "Counter": "0,1,2",
         "EventCode": "0x7",
         "EventName": "UNC_R3_RING_AD_USED.CCW_ODD",
         "PerPkg": "1",
+        "PublicDescription": "Counts the number of cycles that the AD ring=
 is being used at this ring stop.  This includes when packets are passing b=
y and when packets are being sunk, but does not include when packets are be=
ing sent from the ring stop.; Filters for the Counterclockwise and Odd ring=
 polarity.",
         "UMask": "0x8",
         "Unit": "R3QPI"
     },
     {
         "BriefDescription": "R3 AD Ring in Use; Clockwise",
-        "Counter": "0,1,2",
         "EventCode": "0x7",
         "EventName": "UNC_R3_RING_AD_USED.CW",
         "PerPkg": "1",
+        "PublicDescription": "Counts the number of cycles that the AD ring=
 is being used at this ring stop.  This includes when packets are passing b=
y and when packets are being sunk, but does not include when packets are be=
ing sent from the ring stop.",
         "UMask": "0x3",
         "Unit": "R3QPI"
     },
     {
-        "BriefDescription": "R3 AD Ring in Use; Counterclockwise",
-        "Counter": "0,1,2",
+        "BriefDescription": "R3 AD Ring in Use; Clockwise and Even",
         "EventCode": "0x7",
-        "EventName": "UNC_R3_RING_AD_USED.CCW",
+        "EventName": "UNC_R3_RING_AD_USED.CW_EVEN",
         "PerPkg": "1",
-        "UMask": "0xC",
+        "PublicDescription": "Counts the number of cycles that the AD ring=
 is being used at this ring stop.  This includes when packets are passing b=
y and when packets are being sunk, but does not include when packets are be=
ing sent from the ring stop.; Filters for the Clockwise and Even ring polar=
ity.",
+        "UMask": "0x1",
         "Unit": "R3QPI"
     },
     {
-        "BriefDescription": "R3 AK Ring in Use; Clockwise and Even",
-        "Counter": "0,1,2",
+        "BriefDescription": "R3 AD Ring in Use; Clockwise and Odd",
+        "EventCode": "0x7",
+        "EventName": "UNC_R3_RING_AD_USED.CW_ODD",
+        "PerPkg": "1",
+        "PublicDescription": "Counts the number of cycles that the AD ring=
 is being used at this ring stop.  This includes when packets are passing b=
y and when packets are being sunk, but does not include when packets are be=
ing sent from the ring stop.; Filters for the Clockwise and Odd ring polari=
ty.",
+        "UMask": "0x2",
+        "Unit": "R3QPI"
+    },
+    {
+        "BriefDescription": "R3 AK Ring in Use; All",
         "EventCode": "0x8",
-        "EventName": "UNC_R3_RING_AK_USED.CW_EVEN",
+        "EventName": "UNC_R3_RING_AK_USED.ALL",
         "PerPkg": "1",
-        "UMask": "0x1",
+        "PublicDescription": "Counts the number of cycles that the AK ring=
 is being used at this ring stop.  This includes when packets are passing b=
y and when packets are being sunk, but does not include when packets are be=
ing sent from the ring stop.",
+        "UMask": "0xf",
         "Unit": "R3QPI"
     },
     {
-        "BriefDescription": "R3 AK Ring in Use; Clockwise and Odd",
-        "Counter": "0,1,2",
+        "BriefDescription": "R3 AK Ring in Use; Counterclockwise",
         "EventCode": "0x8",
-        "EventName": "UNC_R3_RING_AK_USED.CW_ODD",
+        "EventName": "UNC_R3_RING_AK_USED.CCW",
         "PerPkg": "1",
-        "UMask": "0x2",
+        "PublicDescription": "Counts the number of cycles that the AK ring=
 is being used at this ring stop.  This includes when packets are passing b=
y and when packets are being sunk, but does not include when packets are be=
ing sent from the ring stop.",
+        "UMask": "0xc",
         "Unit": "R3QPI"
     },
     {
         "BriefDescription": "R3 AK Ring in Use; Counterclockwise and Even"=
,
-        "Counter": "0,1,2",
         "EventCode": "0x8",
         "EventName": "UNC_R3_RING_AK_USED.CCW_EVEN",
         "PerPkg": "1",
+        "PublicDescription": "Counts the number of cycles that the AK ring=
 is being used at this ring stop.  This includes when packets are passing b=
y and when packets are being sunk, but does not include when packets are be=
ing sent from the ring stop.; Filters for the Counterclockwise and Even rin=
g polarity.",
         "UMask": "0x4",
         "Unit": "R3QPI"
     },
     {
         "BriefDescription": "R3 AK Ring in Use; Counterclockwise and Odd",
-        "Counter": "0,1,2",
         "EventCode": "0x8",
         "EventName": "UNC_R3_RING_AK_USED.CCW_ODD",
         "PerPkg": "1",
+        "PublicDescription": "Counts the number of cycles that the AK ring=
 is being used at this ring stop.  This includes when packets are passing b=
y and when packets are being sunk, but does not include when packets are be=
ing sent from the ring stop.; Filters for the Counterclockwise and Odd ring=
 polarity.",
         "UMask": "0x8",
         "Unit": "R3QPI"
     },
     {
         "BriefDescription": "R3 AK Ring in Use; Clockwise",
-        "Counter": "0,1,2",
         "EventCode": "0x8",
         "EventName": "UNC_R3_RING_AK_USED.CW",
         "PerPkg": "1",
+        "PublicDescription": "Counts the number of cycles that the AK ring=
 is being used at this ring stop.  This includes when packets are passing b=
y and when packets are being sunk, but does not include when packets are be=
ing sent from the ring stop.",
         "UMask": "0x3",
         "Unit": "R3QPI"
     },
     {
-        "BriefDescription": "R3 AK Ring in Use; Counterclockwise",
-        "Counter": "0,1,2",
+        "BriefDescription": "R3 AK Ring in Use; Clockwise and Even",
         "EventCode": "0x8",
-        "EventName": "UNC_R3_RING_AK_USED.CCW",
+        "EventName": "UNC_R3_RING_AK_USED.CW_EVEN",
         "PerPkg": "1",
-        "UMask": "0xC",
+        "PublicDescription": "Counts the number of cycles that the AK ring=
 is being used at this ring stop.  This includes when packets are passing b=
y and when packets are being sunk, but does not include when packets are be=
ing sent from the ring stop.; Filters for the Clockwise and Even ring polar=
ity.",
+        "UMask": "0x1",
         "Unit": "R3QPI"
     },
     {
-        "BriefDescription": "R3 BL Ring in Use; Clockwise and Even",
-        "Counter": "0,1,2",
+        "BriefDescription": "R3 AK Ring in Use; Clockwise and Odd",
+        "EventCode": "0x8",
+        "EventName": "UNC_R3_RING_AK_USED.CW_ODD",
+        "PerPkg": "1",
+        "PublicDescription": "Counts the number of cycles that the AK ring=
 is being used at this ring stop.  This includes when packets are passing b=
y and when packets are being sunk, but does not include when packets are be=
ing sent from the ring stop.; Filters for the Clockwise and Odd ring polari=
ty.",
+        "UMask": "0x2",
+        "Unit": "R3QPI"
+    },
+    {
+        "BriefDescription": "R3 BL Ring in Use; All",
         "EventCode": "0x9",
-        "EventName": "UNC_R3_RING_BL_USED.CW_EVEN",
+        "EventName": "UNC_R3_RING_BL_USED.ALL",
         "PerPkg": "1",
-        "UMask": "0x1",
+        "PublicDescription": "Counts the number of cycles that the BL ring=
 is being used at this ring stop.  This includes when packets are passing b=
y and when packets are being sunk, but does not include when packets are be=
ing sent from the ring stop.",
+        "UMask": "0xf",
         "Unit": "R3QPI"
     },
     {
-        "BriefDescription": "R3 BL Ring in Use; Clockwise and Odd",
-        "Counter": "0,1,2",
+        "BriefDescription": "R3 BL Ring in Use; Counterclockwise",
         "EventCode": "0x9",
-        "EventName": "UNC_R3_RING_BL_USED.CW_ODD",
+        "EventName": "UNC_R3_RING_BL_USED.CCW",
         "PerPkg": "1",
-        "UMask": "0x2",
+        "PublicDescription": "Counts the number of cycles that the BL ring=
 is being used at this ring stop.  This includes when packets are passing b=
y and when packets are being sunk, but does not include when packets are be=
ing sent from the ring stop.",
+        "UMask": "0xc",
         "Unit": "R3QPI"
     },
     {
         "BriefDescription": "R3 BL Ring in Use; Counterclockwise and Even"=
,
-        "Counter": "0,1,2",
         "EventCode": "0x9",
         "EventName": "UNC_R3_RING_BL_USED.CCW_EVEN",
         "PerPkg": "1",
+        "PublicDescription": "Counts the number of cycles that the BL ring=
 is being used at this ring stop.  This includes when packets are passing b=
y and when packets are being sunk, but does not include when packets are be=
ing sent from the ring stop.; Filters for the Counterclockwise and Even rin=
g polarity.",
         "UMask": "0x4",
         "Unit": "R3QPI"
     },
     {
         "BriefDescription": "R3 BL Ring in Use; Counterclockwise and Odd",
-        "Counter": "0,1,2",
         "EventCode": "0x9",
         "EventName": "UNC_R3_RING_BL_USED.CCW_ODD",
         "PerPkg": "1",
+        "PublicDescription": "Counts the number of cycles that the BL ring=
 is being used at this ring stop.  This includes when packets are passing b=
y and when packets are being sunk, but does not include when packets are be=
ing sent from the ring stop.; Filters for the Counterclockwise and Odd ring=
 polarity.",
         "UMask": "0x8",
         "Unit": "R3QPI"
     },
     {
         "BriefDescription": "R3 BL Ring in Use; Clockwise",
-        "Counter": "0,1,2",
         "EventCode": "0x9",
         "EventName": "UNC_R3_RING_BL_USED.CW",
         "PerPkg": "1",
+        "PublicDescription": "Counts the number of cycles that the BL ring=
 is being used at this ring stop.  This includes when packets are passing b=
y and when packets are being sunk, but does not include when packets are be=
ing sent from the ring stop.",
         "UMask": "0x3",
         "Unit": "R3QPI"
     },
     {
-        "BriefDescription": "R3 BL Ring in Use; Counterclockwise",
-        "Counter": "0,1,2",
+        "BriefDescription": "R3 BL Ring in Use; Clockwise and Even",
         "EventCode": "0x9",
-        "EventName": "UNC_R3_RING_BL_USED.CCW",
+        "EventName": "UNC_R3_RING_BL_USED.CW_EVEN",
         "PerPkg": "1",
-        "UMask": "0xC",
+        "PublicDescription": "Counts the number of cycles that the BL ring=
 is being used at this ring stop.  This includes when packets are passing b=
y and when packets are being sunk, but does not include when packets are be=
ing sent from the ring stop.; Filters for the Clockwise and Even ring polar=
ity.",
+        "UMask": "0x1",
         "Unit": "R3QPI"
     },
     {
-        "BriefDescription": "R3 IV Ring in Use; Clockwise",
-        "Counter": "0,1,2",
-        "EventCode": "0xA",
-        "EventName": "UNC_R3_RING_IV_USED.CW",
+        "BriefDescription": "R3 BL Ring in Use; Clockwise and Odd",
+        "EventCode": "0x9",
+        "EventName": "UNC_R3_RING_BL_USED.CW_ODD",
         "PerPkg": "1",
-        "UMask": "0x3",
+        "PublicDescription": "Counts the number of cycles that the BL ring=
 is being used at this ring stop.  This includes when packets are passing b=
y and when packets are being sunk, but does not include when packets are be=
ing sent from the ring stop.; Filters for the Clockwise and Odd ring polari=
ty.",
+        "UMask": "0x2",
         "Unit": "R3QPI"
     },
     {
         "BriefDescription": "R3 IV Ring in Use; Any",
-        "Counter": "0,1,2",
         "EventCode": "0xA",
         "EventName": "UNC_R3_RING_IV_USED.ANY",
         "PerPkg": "1",
-        "UMask": "0xF",
+        "PublicDescription": "Counts the number of cycles that the IV ring=
 is being used at this ring stop.  This includes when packets are passing b=
y and when packets are being sent, but does not include when packets are be=
ing sunk into the ring stop.",
+        "UMask": "0xf",
+        "Unit": "R3QPI"
+    },
+    {
+        "BriefDescription": "R3 IV Ring in Use; Clockwise",
+        "EventCode": "0xA",
+        "EventName": "UNC_R3_RING_IV_USED.CW",
+        "PerPkg": "1",
+        "PublicDescription": "Counts the number of cycles that the IV ring=
 is being used at this ring stop.  This includes when packets are passing b=
y and when packets are being sent, but does not include when packets are be=
ing sunk into the ring stop.",
+        "UMask": "0x3",
         "Unit": "R3QPI"
     },
     {
         "BriefDescription": "Ring Stop Starved; AK",
-        "Counter": "0,1,2",
         "EventCode": "0xE",
         "EventName": "UNC_R3_RING_SINK_STARVED.AK",
         "PerPkg": "1",
+        "PublicDescription": "Number of cycles the ringstop is in starvati=
on (per ring)",
         "UMask": "0x2",
         "Unit": "R3QPI"
     },
     {
         "BriefDescription": "Ingress Cycles Not Empty; HOM",
-        "Counter": "0,1",
         "EventCode": "0x10",
         "EventName": "UNC_R3_RxR_CYCLES_NE.HOM",
         "PerPkg": "1",
+        "PublicDescription": "Counts the number of cycles when the QPI Ing=
ress is not empty.  This tracks one of the three rings that are used by the=
 QPI agent.  This can be used in conjunction with the QPI Ingress Occupancy=
 Accumulator event in order to calculate average queue occupancy.  Multiple=
 ingress buffers can be tracked at a given time using multiple counters.; H=
OM Ingress Queue",
         "UMask": "0x1",
         "Unit": "R3QPI"
     },
-    {
-        "BriefDescription": "Ingress Cycles Not Empty; SNP",
-        "Counter": "0,1",
-        "EventCode": "0x10",
-        "EventName": "UNC_R3_RxR_CYCLES_NE.SNP",
-        "PerPkg": "1",
-        "UMask": "0x2",
-        "Unit": "R3QPI"
-    },
     {
         "BriefDescription": "Ingress Cycles Not Empty; NDR",
-        "Counter": "0,1",
         "EventCode": "0x10",
         "EventName": "UNC_R3_RxR_CYCLES_NE.NDR",
         "PerPkg": "1",
+        "PublicDescription": "Counts the number of cycles when the QPI Ing=
ress is not empty.  This tracks one of the three rings that are used by the=
 QPI agent.  This can be used in conjunction with the QPI Ingress Occupancy=
 Accumulator event in order to calculate average queue occupancy.  Multiple=
 ingress buffers can be tracked at a given time using multiple counters.; N=
DR Ingress Queue",
         "UMask": "0x4",
         "Unit": "R3QPI"
     },
     {
-        "BriefDescription": "VN1 Ingress Cycles Not Empty; HOM",
-        "Counter": "0,1",
-        "EventCode": "0x14",
-        "EventName": "UNC_R3_RxR_CYCLES_NE_VN1.HOM",
-        "PerPkg": "1",
-        "UMask": "0x1",
-        "Unit": "R3QPI"
-    },
-    {
-        "BriefDescription": "VN1 Ingress Cycles Not Empty; SNP",
-        "Counter": "0,1",
-        "EventCode": "0x14",
-        "EventName": "UNC_R3_RxR_CYCLES_NE_VN1.SNP",
+        "BriefDescription": "Ingress Cycles Not Empty; SNP",
+        "EventCode": "0x10",
+        "EventName": "UNC_R3_RxR_CYCLES_NE.SNP",
         "PerPkg": "1",
+        "PublicDescription": "Counts the number of cycles when the QPI Ing=
ress is not empty.  This tracks one of the three rings that are used by the=
 QPI agent.  This can be used in conjunction with the QPI Ingress Occupancy=
 Accumulator event in order to calculate average queue occupancy.  Multiple=
 ingress buffers can be tracked at a given time using multiple counters.; S=
NP Ingress Queue",
         "UMask": "0x2",
         "Unit": "R3QPI"
     },
     {
-        "BriefDescription": "VN1 Ingress Cycles Not Empty; NDR",
-        "Counter": "0,1",
+        "BriefDescription": "VN1 Ingress Cycles Not Empty; DRS",
         "EventCode": "0x14",
-        "EventName": "UNC_R3_RxR_CYCLES_NE_VN1.NDR",
+        "EventName": "UNC_R3_RxR_CYCLES_NE_VN1.DRS",
         "PerPkg": "1",
-        "UMask": "0x4",
+        "PublicDescription": "Counts the number of cycles when the QPI VN1=
  Ingress is not empty.  This tracks one of the three rings that are used b=
y the QPI agent.  This can be used in conjunction with the QPI VN1  Ingress=
 Occupancy Accumulator event in order to calculate average queue occupancy.=
  Multiple ingress buffers can be tracked at a given time using multiple co=
unters.; DRS Ingress Queue",
+        "UMask": "0x8",
         "Unit": "R3QPI"
     },
     {
-        "BriefDescription": "VN1 Ingress Cycles Not Empty; DRS",
-        "Counter": "0,1",
+        "BriefDescription": "VN1 Ingress Cycles Not Empty; HOM",
         "EventCode": "0x14",
-        "EventName": "UNC_R3_RxR_CYCLES_NE_VN1.DRS",
+        "EventName": "UNC_R3_RxR_CYCLES_NE_VN1.HOM",
         "PerPkg": "1",
-        "UMask": "0x8",
+        "PublicDescription": "Counts the number of cycles when the QPI VN1=
  Ingress is not empty.  This tracks one of the three rings that are used b=
y the QPI agent.  This can be used in conjunction with the QPI VN1  Ingress=
 Occupancy Accumulator event in order to calculate average queue occupancy.=
  Multiple ingress buffers can be tracked at a given time using multiple co=
unters.; HOM Ingress Queue",
+        "UMask": "0x1",
         "Unit": "R3QPI"
     },
     {
         "BriefDescription": "VN1 Ingress Cycles Not Empty; NCB",
-        "Counter": "0,1",
         "EventCode": "0x14",
         "EventName": "UNC_R3_RxR_CYCLES_NE_VN1.NCB",
         "PerPkg": "1",
+        "PublicDescription": "Counts the number of cycles when the QPI VN1=
  Ingress is not empty.  This tracks one of the three rings that are used b=
y the QPI agent.  This can be used in conjunction with the QPI VN1  Ingress=
 Occupancy Accumulator event in order to calculate average queue occupancy.=
  Multiple ingress buffers can be tracked at a given time using multiple co=
unters.; NCB Ingress Queue",
         "UMask": "0x10",
         "Unit": "R3QPI"
     },
     {
         "BriefDescription": "VN1 Ingress Cycles Not Empty; NCS",
-        "Counter": "0,1",
         "EventCode": "0x14",
         "EventName": "UNC_R3_RxR_CYCLES_NE_VN1.NCS",
         "PerPkg": "1",
+        "PublicDescription": "Counts the number of cycles when the QPI VN1=
  Ingress is not empty.  This tracks one of the three rings that are used b=
y the QPI agent.  This can be used in conjunction with the QPI VN1  Ingress=
 Occupancy Accumulator event in order to calculate average queue occupancy.=
  Multiple ingress buffers can be tracked at a given time using multiple co=
unters.; NCS Ingress Queue",
         "UMask": "0x20",
         "Unit": "R3QPI"
     },
     {
-        "BriefDescription": "Ingress Allocations; HOM",
-        "Counter": "0,1",
-        "EventCode": "0x11",
-        "EventName": "UNC_R3_RxR_INSERTS.HOM",
+        "BriefDescription": "VN1 Ingress Cycles Not Empty; NDR",
+        "EventCode": "0x14",
+        "EventName": "UNC_R3_RxR_CYCLES_NE_VN1.NDR",
         "PerPkg": "1",
-        "UMask": "0x1",
+        "PublicDescription": "Counts the number of cycles when the QPI VN1=
  Ingress is not empty.  This tracks one of the three rings that are used b=
y the QPI agent.  This can be used in conjunction with the QPI VN1  Ingress=
 Occupancy Accumulator event in order to calculate average queue occupancy.=
  Multiple ingress buffers can be tracked at a given time using multiple co=
unters.; NDR Ingress Queue",
+        "UMask": "0x4",
         "Unit": "R3QPI"
     },
     {
-        "BriefDescription": "Ingress Allocations; SNP",
-        "Counter": "0,1",
-        "EventCode": "0x11",
-        "EventName": "UNC_R3_RxR_INSERTS.SNP",
+        "BriefDescription": "VN1 Ingress Cycles Not Empty; SNP",
+        "EventCode": "0x14",
+        "EventName": "UNC_R3_RxR_CYCLES_NE_VN1.SNP",
         "PerPkg": "1",
+        "PublicDescription": "Counts the number of cycles when the QPI VN1=
  Ingress is not empty.  This tracks one of the three rings that are used b=
y the QPI agent.  This can be used in conjunction with the QPI VN1  Ingress=
 Occupancy Accumulator event in order to calculate average queue occupancy.=
  Multiple ingress buffers can be tracked at a given time using multiple co=
unters.; SNP Ingress Queue",
         "UMask": "0x2",
         "Unit": "R3QPI"
     },
     {
-        "BriefDescription": "Ingress Allocations; NDR",
-        "Counter": "0,1",
+        "BriefDescription": "Ingress Allocations; DRS",
         "EventCode": "0x11",
-        "EventName": "UNC_R3_RxR_INSERTS.NDR",
+        "EventName": "UNC_R3_RxR_INSERTS.DRS",
         "PerPkg": "1",
-        "UMask": "0x4",
+        "PublicDescription": "Counts the number of allocations into the QP=
I Ingress.  This tracks one of the three rings that are used by the QPI age=
nt.  This can be used in conjunction with the QPI Ingress Occupancy Accumul=
ator event in order to calculate average queue latency.  Multiple ingress b=
uffers can be tracked at a given time using multiple counters.; DRS Ingress=
 Queue",
+        "UMask": "0x8",
         "Unit": "R3QPI"
     },
     {
-        "BriefDescription": "Ingress Allocations; DRS",
-        "Counter": "0,1",
+        "BriefDescription": "Ingress Allocations; HOM",
         "EventCode": "0x11",
-        "EventName": "UNC_R3_RxR_INSERTS.DRS",
+        "EventName": "UNC_R3_RxR_INSERTS.HOM",
         "PerPkg": "1",
-        "UMask": "0x8",
+        "PublicDescription": "Counts the number of allocations into the QP=
I Ingress.  This tracks one of the three rings that are used by the QPI age=
nt.  This can be used in conjunction with the QPI Ingress Occupancy Accumul=
ator event in order to calculate average queue latency.  Multiple ingress b=
uffers can be tracked at a given time using multiple counters.; HOM Ingress=
 Queue",
+        "UMask": "0x1",
         "Unit": "R3QPI"
     },
     {
         "BriefDescription": "Ingress Allocations; NCB",
-        "Counter": "0,1",
         "EventCode": "0x11",
         "EventName": "UNC_R3_RxR_INSERTS.NCB",
         "PerPkg": "1",
+        "PublicDescription": "Counts the number of allocations into the QP=
I Ingress.  This tracks one of the three rings that are used by the QPI age=
nt.  This can be used in conjunction with the QPI Ingress Occupancy Accumul=
ator event in order to calculate average queue latency.  Multiple ingress b=
uffers can be tracked at a given time using multiple counters.; NCB Ingress=
 Queue",
         "UMask": "0x10",
         "Unit": "R3QPI"
     },
     {
         "BriefDescription": "Ingress Allocations; NCS",
-        "Counter": "0,1",
         "EventCode": "0x11",
         "EventName": "UNC_R3_RxR_INSERTS.NCS",
         "PerPkg": "1",
+        "PublicDescription": "Counts the number of allocations into the QP=
I Ingress.  This tracks one of the three rings that are used by the QPI age=
nt.  This can be used in conjunction with the QPI Ingress Occupancy Accumul=
ator event in order to calculate average queue latency.  Multiple ingress b=
uffers can be tracked at a given time using multiple counters.; NCS Ingress=
 Queue",
         "UMask": "0x20",
         "Unit": "R3QPI"
     },
     {
-        "BriefDescription": "VN1 Ingress Allocations; HOM",
-        "Counter": "0,1",
-        "EventCode": "0x15",
-        "EventName": "UNC_R3_RxR_INSERTS_VN1.HOM",
+        "BriefDescription": "Ingress Allocations; NDR",
+        "EventCode": "0x11",
+        "EventName": "UNC_R3_RxR_INSERTS.NDR",
         "PerPkg": "1",
-        "UMask": "0x1",
+        "PublicDescription": "Counts the number of allocations into the QP=
I Ingress.  This tracks one of the three rings that are used by the QPI age=
nt.  This can be used in conjunction with the QPI Ingress Occupancy Accumul=
ator event in order to calculate average queue latency.  Multiple ingress b=
uffers can be tracked at a given time using multiple counters.; NDR Ingress=
 Queue",
+        "UMask": "0x4",
         "Unit": "R3QPI"
     },
     {
-        "BriefDescription": "VN1 Ingress Allocations; SNP",
-        "Counter": "0,1",
-        "EventCode": "0x15",
-        "EventName": "UNC_R3_RxR_INSERTS_VN1.SNP",
+        "BriefDescription": "Ingress Allocations; SNP",
+        "EventCode": "0x11",
+        "EventName": "UNC_R3_RxR_INSERTS.SNP",
         "PerPkg": "1",
+        "PublicDescription": "Counts the number of allocations into the QP=
I Ingress.  This tracks one of the three rings that are used by the QPI age=
nt.  This can be used in conjunction with the QPI Ingress Occupancy Accumul=
ator event in order to calculate average queue latency.  Multiple ingress b=
uffers can be tracked at a given time using multiple counters.; SNP Ingress=
 Queue",
         "UMask": "0x2",
         "Unit": "R3QPI"
     },
-    {
-        "BriefDescription": "VN1 Ingress Allocations; NDR",
-        "Counter": "0,1",
-        "EventCode": "0x15",
-        "EventName": "UNC_R3_RxR_INSERTS_VN1.NDR",
-        "PerPkg": "1",
-        "UMask": "0x4",
-        "Unit": "R3QPI"
-    },
     {
         "BriefDescription": "VN1 Ingress Allocations; DRS",
-        "Counter": "0,1",
         "EventCode": "0x15",
         "EventName": "UNC_R3_RxR_INSERTS_VN1.DRS",
         "PerPkg": "1",
+        "PublicDescription": "Counts the number of allocations into the QP=
I VN1  Ingress.  This tracks one of the three rings that are used by the QP=
I agent.  This can be used in conjunction with the QPI VN1  Ingress Occupan=
cy Accumulator event in order to calculate average queue latency.  Multiple=
 ingress buffers can be tracked at a given time using multiple counters.; D=
RS Ingress Queue",
         "UMask": "0x8",
         "Unit": "R3QPI"
     },
     {
-        "BriefDescription": "VN1 Ingress Allocations; NCB",
-        "Counter": "0,1",
+        "BriefDescription": "VN1 Ingress Allocations; HOM",
         "EventCode": "0x15",
-        "EventName": "UNC_R3_RxR_INSERTS_VN1.NCB",
+        "EventName": "UNC_R3_RxR_INSERTS_VN1.HOM",
+        "PerPkg": "1",
+        "PublicDescription": "Counts the number of allocations into the QP=
I VN1  Ingress.  This tracks one of the three rings that are used by the QP=
I agent.  This can be used in conjunction with the QPI VN1  Ingress Occupan=
cy Accumulator event in order to calculate average queue latency.  Multiple=
 ingress buffers can be tracked at a given time using multiple counters.; H=
OM Ingress Queue",
+        "UMask": "0x1",
+        "Unit": "R3QPI"
+    },
+    {
+        "BriefDescription": "VN1 Ingress Allocations; NCB",
+        "EventCode": "0x15",
+        "EventName": "UNC_R3_RxR_INSERTS_VN1.NCB",
         "PerPkg": "1",
+        "PublicDescription": "Counts the number of allocations into the QP=
I VN1  Ingress.  This tracks one of the three rings that are used by the QP=
I agent.  This can be used in conjunction with the QPI VN1  Ingress Occupan=
cy Accumulator event in order to calculate average queue latency.  Multiple=
 ingress buffers can be tracked at a given time using multiple counters.; N=
CB Ingress Queue",
         "UMask": "0x10",
         "Unit": "R3QPI"
     },
     {
         "BriefDescription": "VN1 Ingress Allocations; NCS",
-        "Counter": "0,1",
         "EventCode": "0x15",
         "EventName": "UNC_R3_RxR_INSERTS_VN1.NCS",
         "PerPkg": "1",
+        "PublicDescription": "Counts the number of allocations into the QP=
I VN1  Ingress.  This tracks one of the three rings that are used by the QP=
I agent.  This can be used in conjunction with the QPI VN1  Ingress Occupan=
cy Accumulator event in order to calculate average queue latency.  Multiple=
 ingress buffers can be tracked at a given time using multiple counters.; N=
CS Ingress Queue",
         "UMask": "0x20",
         "Unit": "R3QPI"
     },
     {
-        "BriefDescription": "VN1 Ingress Occupancy Accumulator; HOM",
-        "EventCode": "0x13",
-        "EventName": "UNC_R3_RxR_OCCUPANCY_VN1.HOM",
+        "BriefDescription": "VN1 Ingress Allocations; NDR",
+        "EventCode": "0x15",
+        "EventName": "UNC_R3_RxR_INSERTS_VN1.NDR",
         "PerPkg": "1",
-        "UMask": "0x1",
+        "PublicDescription": "Counts the number of allocations into the QP=
I VN1  Ingress.  This tracks one of the three rings that are used by the QP=
I agent.  This can be used in conjunction with the QPI VN1  Ingress Occupan=
cy Accumulator event in order to calculate average queue latency.  Multiple=
 ingress buffers can be tracked at a given time using multiple counters.; N=
DR Ingress Queue",
+        "UMask": "0x4",
         "Unit": "R3QPI"
     },
     {
-        "BriefDescription": "VN1 Ingress Occupancy Accumulator; SNP",
-        "EventCode": "0x13",
-        "EventName": "UNC_R3_RxR_OCCUPANCY_VN1.SNP",
+        "BriefDescription": "VN1 Ingress Allocations; SNP",
+        "EventCode": "0x15",
+        "EventName": "UNC_R3_RxR_INSERTS_VN1.SNP",
         "PerPkg": "1",
+        "PublicDescription": "Counts the number of allocations into the QP=
I VN1  Ingress.  This tracks one of the three rings that are used by the QP=
I agent.  This can be used in conjunction with the QPI VN1  Ingress Occupan=
cy Accumulator event in order to calculate average queue latency.  Multiple=
 ingress buffers can be tracked at a given time using multiple counters.; S=
NP Ingress Queue",
         "UMask": "0x2",
         "Unit": "R3QPI"
     },
     {
-        "BriefDescription": "VN1 Ingress Occupancy Accumulator; NDR",
+        "BriefDescription": "VN1 Ingress Occupancy Accumulator; DRS",
         "EventCode": "0x13",
-        "EventName": "UNC_R3_RxR_OCCUPANCY_VN1.NDR",
+        "EventName": "UNC_R3_RxR_OCCUPANCY_VN1.DRS",
         "PerPkg": "1",
-        "UMask": "0x4",
+        "PublicDescription": "Accumulates the occupancy of a given QPI VN1=
  Ingress queue in each cycles.  This tracks one of the three ring Ingress =
buffers.  This can be used with the QPI VN1  Ingress Not Empty event to cal=
culate average occupancy or the QPI VN1  Ingress Allocations event in order=
 to calculate average queuing latency.; DRS Ingress Queue",
+        "UMask": "0x8",
         "Unit": "R3QPI"
     },
     {
-        "BriefDescription": "VN1 Ingress Occupancy Accumulator; DRS",
+        "BriefDescription": "VN1 Ingress Occupancy Accumulator; HOM",
         "EventCode": "0x13",
-        "EventName": "UNC_R3_RxR_OCCUPANCY_VN1.DRS",
+        "EventName": "UNC_R3_RxR_OCCUPANCY_VN1.HOM",
         "PerPkg": "1",
-        "UMask": "0x8",
+        "PublicDescription": "Accumulates the occupancy of a given QPI VN1=
  Ingress queue in each cycles.  This tracks one of the three ring Ingress =
buffers.  This can be used with the QPI VN1  Ingress Not Empty event to cal=
culate average occupancy or the QPI VN1  Ingress Allocations event in order=
 to calculate average queuing latency.; HOM Ingress Queue",
+        "UMask": "0x1",
         "Unit": "R3QPI"
     },
     {
@@ -1835,6 +1898,7 @@
         "EventCode": "0x13",
         "EventName": "UNC_R3_RxR_OCCUPANCY_VN1.NCB",
         "PerPkg": "1",
+        "PublicDescription": "Accumulates the occupancy of a given QPI VN1=
  Ingress queue in each cycles.  This tracks one of the three ring Ingress =
buffers.  This can be used with the QPI VN1  Ingress Not Empty event to cal=
culate average occupancy or the QPI VN1  Ingress Allocations event in order=
 to calculate average queuing latency.; NCB Ingress Queue",
         "UMask": "0x10",
         "Unit": "R3QPI"
     },
@@ -1843,1410 +1907,1344 @@
         "EventCode": "0x13",
         "EventName": "UNC_R3_RxR_OCCUPANCY_VN1.NCS",
         "PerPkg": "1",
+        "PublicDescription": "Accumulates the occupancy of a given QPI VN1=
  Ingress queue in each cycles.  This tracks one of the three ring Ingress =
buffers.  This can be used with the QPI VN1  Ingress Not Empty event to cal=
culate average occupancy or the QPI VN1  Ingress Allocations event in order=
 to calculate average queuing latency.; NCS Ingress Queue",
         "UMask": "0x20",
         "Unit": "R3QPI"
     },
+    {
+        "BriefDescription": "VN1 Ingress Occupancy Accumulator; NDR",
+        "EventCode": "0x13",
+        "EventName": "UNC_R3_RxR_OCCUPANCY_VN1.NDR",
+        "PerPkg": "1",
+        "PublicDescription": "Accumulates the occupancy of a given QPI VN1=
  Ingress queue in each cycles.  This tracks one of the three ring Ingress =
buffers.  This can be used with the QPI VN1  Ingress Not Empty event to cal=
culate average occupancy or the QPI VN1  Ingress Allocations event in order=
 to calculate average queuing latency.; NDR Ingress Queue",
+        "UMask": "0x4",
+        "Unit": "R3QPI"
+    },
+    {
+        "BriefDescription": "VN1 Ingress Occupancy Accumulator; SNP",
+        "EventCode": "0x13",
+        "EventName": "UNC_R3_RxR_OCCUPANCY_VN1.SNP",
+        "PerPkg": "1",
+        "PublicDescription": "Accumulates the occupancy of a given QPI VN1=
  Ingress queue in each cycles.  This tracks one of the three ring Ingress =
buffers.  This can be used with the QPI VN1  Ingress Not Empty event to cal=
culate average occupancy or the QPI VN1  Ingress Allocations event in order=
 to calculate average queuing latency.; SNP Ingress Queue",
+        "UMask": "0x2",
+        "Unit": "R3QPI"
+    },
     {
         "BriefDescription": "SBo0 Credits Acquired; For AD Ring",
-        "Counter": "0,1",
         "EventCode": "0x28",
         "EventName": "UNC_R3_SBO0_CREDITS_ACQUIRED.AD",
         "PerPkg": "1",
+        "PublicDescription": "Number of Sbo 0 credits acquired in a given =
cycle, per ring.",
         "UMask": "0x1",
         "Unit": "R3QPI"
     },
     {
         "BriefDescription": "SBo0 Credits Acquired; For BL Ring",
-        "Counter": "0,1",
         "EventCode": "0x28",
         "EventName": "UNC_R3_SBO0_CREDITS_ACQUIRED.BL",
         "PerPkg": "1",
+        "PublicDescription": "Number of Sbo 0 credits acquired in a given =
cycle, per ring.",
+        "UMask": "0x2",
+        "Unit": "R3QPI"
+    },
+    {
+        "BriefDescription": "SBo0 Credits Occupancy; For AD Ring",
+        "EventCode": "0x2A",
+        "EventName": "UNC_R3_SBO0_CREDIT_OCCUPANCY.AD",
+        "PerPkg": "1",
+        "PublicDescription": "Number of Sbo 0 credits in use in a given cy=
cle, per ring.",
+        "UMask": "0x1",
+        "Unit": "R3QPI"
+    },
+    {
+        "BriefDescription": "SBo0 Credits Occupancy; For BL Ring",
+        "EventCode": "0x2A",
+        "EventName": "UNC_R3_SBO0_CREDIT_OCCUPANCY.BL",
+        "PerPkg": "1",
+        "PublicDescription": "Number of Sbo 0 credits in use in a given cy=
cle, per ring.",
         "UMask": "0x2",
         "Unit": "R3QPI"
     },
     {
         "BriefDescription": "SBo1 Credits Acquired; For AD Ring",
-        "Counter": "0,1",
         "EventCode": "0x29",
         "EventName": "UNC_R3_SBO1_CREDITS_ACQUIRED.AD",
         "PerPkg": "1",
+        "PublicDescription": "Number of Sbo 1 credits acquired in a given =
cycle, per ring.",
         "UMask": "0x1",
         "Unit": "R3QPI"
     },
     {
         "BriefDescription": "SBo1 Credits Acquired; For BL Ring",
-        "Counter": "0,1",
         "EventCode": "0x29",
         "EventName": "UNC_R3_SBO1_CREDITS_ACQUIRED.BL",
         "PerPkg": "1",
+        "PublicDescription": "Number of Sbo 1 credits acquired in a given =
cycle, per ring.",
         "UMask": "0x2",
         "Unit": "R3QPI"
     },
     {
-        "BriefDescription": "Stall on No Sbo Credits; For SBo0, AD Ring",
-        "Counter": "0,1",
-        "EventCode": "0x2C",
-        "EventName": "UNC_R3_STALL_NO_SBO_CREDIT.SBO0_AD",
+        "BriefDescription": "SBo1 Credits Occupancy; For AD Ring",
+        "EventCode": "0x2B",
+        "EventName": "UNC_R3_SBO1_CREDIT_OCCUPANCY.AD",
         "PerPkg": "1",
+        "PublicDescription": "Number of Sbo 1 credits in use in a given cy=
cle, per ring.",
         "UMask": "0x1",
         "Unit": "R3QPI"
     },
     {
-        "BriefDescription": "Stall on No Sbo Credits; For SBo1, AD Ring",
-        "Counter": "0,1",
-        "EventCode": "0x2C",
-        "EventName": "UNC_R3_STALL_NO_SBO_CREDIT.SBO1_AD",
+        "BriefDescription": "SBo1 Credits Occupancy; For BL Ring",
+        "EventCode": "0x2B",
+        "EventName": "UNC_R3_SBO1_CREDIT_OCCUPANCY.BL",
         "PerPkg": "1",
+        "PublicDescription": "Number of Sbo 1 credits in use in a given cy=
cle, per ring.",
         "UMask": "0x2",
         "Unit": "R3QPI"
     },
+    {
+        "BriefDescription": "Stall on No Sbo Credits; For SBo0, AD Ring",
+        "EventCode": "0x2C",
+        "EventName": "UNC_R3_STALL_NO_SBO_CREDIT.SBO0_AD",
+        "PerPkg": "1",
+        "PublicDescription": "Number of cycles Egress is stalled waiting f=
or an Sbo credit to become available.  Per Sbo, per Ring.",
+        "UMask": "0x1",
+        "Unit": "R3QPI"
+    },
     {
         "BriefDescription": "Stall on No Sbo Credits; For SBo0, BL Ring",
-        "Counter": "0,1",
         "EventCode": "0x2C",
         "EventName": "UNC_R3_STALL_NO_SBO_CREDIT.SBO0_BL",
         "PerPkg": "1",
+        "PublicDescription": "Number of cycles Egress is stalled waiting f=
or an Sbo credit to become available.  Per Sbo, per Ring.",
         "UMask": "0x4",
         "Unit": "R3QPI"
     },
+    {
+        "BriefDescription": "Stall on No Sbo Credits; For SBo1, AD Ring",
+        "EventCode": "0x2C",
+        "EventName": "UNC_R3_STALL_NO_SBO_CREDIT.SBO1_AD",
+        "PerPkg": "1",
+        "PublicDescription": "Number of cycles Egress is stalled waiting f=
or an Sbo credit to become available.  Per Sbo, per Ring.",
+        "UMask": "0x2",
+        "Unit": "R3QPI"
+    },
     {
         "BriefDescription": "Stall on No Sbo Credits; For SBo1, BL Ring",
-        "Counter": "0,1",
         "EventCode": "0x2C",
         "EventName": "UNC_R3_STALL_NO_SBO_CREDIT.SBO1_BL",
         "PerPkg": "1",
+        "PublicDescription": "Number of cycles Egress is stalled waiting f=
or an Sbo credit to become available.  Per Sbo, per Ring.",
         "UMask": "0x8",
         "Unit": "R3QPI"
     },
     {
         "BriefDescription": "Egress CCW NACK; AD CCW",
-        "Counter": "0,1",
         "EventCode": "0x26",
         "EventName": "UNC_R3_TxR_NACK.DN_AD",
         "PerPkg": "1",
+        "PublicDescription": "AD CounterClockwise Egress Queue",
         "UMask": "0x1",
         "Unit": "R3QPI"
     },
-    {
-        "BriefDescription": "Egress CCW NACK; BL CCW",
-        "Counter": "0,1",
-        "EventCode": "0x26",
-        "EventName": "UNC_R3_TxR_NACK.DN_BL",
-        "PerPkg": "1",
-        "UMask": "0x2",
-        "Unit": "R3QPI"
-    },
     {
         "BriefDescription": "Egress CCW NACK; AK CCW",
-        "Counter": "0,1",
         "EventCode": "0x26",
         "EventName": "UNC_R3_TxR_NACK.DN_AK",
         "PerPkg": "1",
+        "PublicDescription": "AK CounterClockwise Egress Queue",
         "UMask": "0x4",
         "Unit": "R3QPI"
     },
     {
-        "BriefDescription": "Egress CCW NACK; AK CCW",
-        "Counter": "0,1",
+        "BriefDescription": "Egress CCW NACK; BL CCW",
         "EventCode": "0x26",
-        "EventName": "UNC_R3_TxR_NACK.UP_AD",
+        "EventName": "UNC_R3_TxR_NACK.DN_BL",
         "PerPkg": "1",
-        "UMask": "0x8",
+        "PublicDescription": "BL CounterClockwise Egress Queue",
+        "UMask": "0x2",
         "Unit": "R3QPI"
     },
     {
-        "BriefDescription": "Egress CCW NACK; BL CCW",
-        "Counter": "0,1",
+        "BriefDescription": "Egress CCW NACK; AK CCW",
         "EventCode": "0x26",
-        "EventName": "UNC_R3_TxR_NACK.UP_BL",
+        "EventName": "UNC_R3_TxR_NACK.UP_AD",
         "PerPkg": "1",
-        "UMask": "0x10",
+        "PublicDescription": "BL CounterClockwise Egress Queue",
+        "UMask": "0x8",
         "Unit": "R3QPI"
     },
     {
         "BriefDescription": "Egress CCW NACK; BL CW",
-        "Counter": "0,1",
         "EventCode": "0x26",
         "EventName": "UNC_R3_TxR_NACK.UP_AK",
         "PerPkg": "1",
+        "PublicDescription": "AD Clockwise Egress Queue",
         "UMask": "0x20",
         "Unit": "R3QPI"
     },
     {
-        "BriefDescription": "VN0 Credit Acquisition Failed on DRS; HOM Mes=
sage Class",
-        "Counter": "0,1",
-        "EventCode": "0x37",
-        "EventName": "UNC_R3_VN0_CREDITS_REJECT.HOM",
-        "PerPkg": "1",
-        "UMask": "0x1",
-        "Unit": "R3QPI"
-    },
-    {
-        "BriefDescription": "VN0 Credit Acquisition Failed on DRS; SNP Mes=
sage Class",
-        "Counter": "0,1",
-        "EventCode": "0x37",
-        "EventName": "UNC_R3_VN0_CREDITS_REJECT.SNP",
+        "BriefDescription": "Egress CCW NACK; BL CCW",
+        "EventCode": "0x26",
+        "EventName": "UNC_R3_TxR_NACK.UP_BL",
         "PerPkg": "1",
-        "UMask": "0x2",
+        "PublicDescription": "AD CounterClockwise Egress Queue",
+        "UMask": "0x10",
         "Unit": "R3QPI"
     },
     {
-        "BriefDescription": "VN0 Credit Acquisition Failed on DRS; NDR Mes=
sage Class",
-        "Counter": "0,1",
+        "BriefDescription": "VN0 Credit Acquisition Failed on DRS; DRS Mes=
sage Class",
         "EventCode": "0x37",
-        "EventName": "UNC_R3_VN0_CREDITS_REJECT.NDR",
+        "EventName": "UNC_R3_VN0_CREDITS_REJECT.DRS",
         "PerPkg": "1",
-        "UMask": "0x4",
+        "PublicDescription": "Number of times a request failed to acquire =
a DRS VN0 credit.  In order for a request to be transferred across QPI, it =
must be guaranteed to have a flit buffer on the remote socket to sink into.=
  There are two credit pools, VNA and VN0.  VNA is a shared pool used to ac=
hieve high performance.  The VN0 pool has reserved entries for each message=
 class and is used to prevent deadlock.  Requests first attempt to acquire =
a VNA credit, and then fall back to VN0 if they fail.  This therefore count=
s the number of times when a request failed to acquire either a VNA or VN0 =
credit and is delayed.  This should generally be a rare situation.; Filter =
for Data Response (DRS).  DRS is generally used to transmit data with coher=
ency.  For example, remote reads and writes, or cache to cache transfers wi=
ll transmit their data using DRS.",
+        "UMask": "0x8",
         "Unit": "R3QPI"
     },
     {
-        "BriefDescription": "VN0 Credit Acquisition Failed on DRS; DRS Mes=
sage Class",
-        "Counter": "0,1",
+        "BriefDescription": "VN0 Credit Acquisition Failed on DRS; HOM Mes=
sage Class",
         "EventCode": "0x37",
-        "EventName": "UNC_R3_VN0_CREDITS_REJECT.DRS",
+        "EventName": "UNC_R3_VN0_CREDITS_REJECT.HOM",
         "PerPkg": "1",
-        "UMask": "0x8",
+        "PublicDescription": "Number of times a request failed to acquire =
a DRS VN0 credit.  In order for a request to be transferred across QPI, it =
must be guaranteed to have a flit buffer on the remote socket to sink into.=
  There are two credit pools, VNA and VN0.  VNA is a shared pool used to ac=
hieve high performance.  The VN0 pool has reserved entries for each message=
 class and is used to prevent deadlock.  Requests first attempt to acquire =
a VNA credit, and then fall back to VN0 if they fail.  This therefore count=
s the number of times when a request failed to acquire either a VNA or VN0 =
credit and is delayed.  This should generally be a rare situation.; Filter =
for the Home (HOM) message class.  HOM is generally used to send requests, =
request responses, and snoop responses.",
+        "UMask": "0x1",
         "Unit": "R3QPI"
     },
     {
         "BriefDescription": "VN0 Credit Acquisition Failed on DRS; NCB Mes=
sage Class",
-        "Counter": "0,1",
         "EventCode": "0x37",
         "EventName": "UNC_R3_VN0_CREDITS_REJECT.NCB",
         "PerPkg": "1",
+        "PublicDescription": "Number of times a request failed to acquire =
a DRS VN0 credit.  In order for a request to be transferred across QPI, it =
must be guaranteed to have a flit buffer on the remote socket to sink into.=
  There are two credit pools, VNA and VN0.  VNA is a shared pool used to ac=
hieve high performance.  The VN0 pool has reserved entries for each message=
 class and is used to prevent deadlock.  Requests first attempt to acquire =
a VNA credit, and then fall back to VN0 if they fail.  This therefore count=
s the number of times when a request failed to acquire either a VNA or VN0 =
credit and is delayed.  This should generally be a rare situation.; Filter =
for Non-Coherent Broadcast (NCB).  NCB is generally used to transmit data w=
ithout coherency.  For example, non-coherent read data returns.",
         "UMask": "0x10",
         "Unit": "R3QPI"
     },
     {
         "BriefDescription": "VN0 Credit Acquisition Failed on DRS; NCS Mes=
sage Class",
-        "Counter": "0,1",
         "EventCode": "0x37",
         "EventName": "UNC_R3_VN0_CREDITS_REJECT.NCS",
         "PerPkg": "1",
+        "PublicDescription": "Number of times a request failed to acquire =
a DRS VN0 credit.  In order for a request to be transferred across QPI, it =
must be guaranteed to have a flit buffer on the remote socket to sink into.=
  There are two credit pools, VNA and VN0.  VNA is a shared pool used to ac=
hieve high performance.  The VN0 pool has reserved entries for each message=
 class and is used to prevent deadlock.  Requests first attempt to acquire =
a VNA credit, and then fall back to VN0 if they fail.  This therefore count=
s the number of times when a request failed to acquire either a VNA or VN0 =
credit and is delayed.  This should generally be a rare situation.; Filter =
for Non-Coherent Standard (NCS).  NCS is commonly used for ?",
         "UMask": "0x20",
         "Unit": "R3QPI"
     },
     {
-        "BriefDescription": "VN0 Credit Used; HOM Message Class",
-        "Counter": "0,1",
-        "EventCode": "0x36",
-        "EventName": "UNC_R3_VN0_CREDITS_USED.HOM",
+        "BriefDescription": "VN0 Credit Acquisition Failed on DRS; NDR Mes=
sage Class",
+        "EventCode": "0x37",
+        "EventName": "UNC_R3_VN0_CREDITS_REJECT.NDR",
         "PerPkg": "1",
-        "UMask": "0x1",
+        "PublicDescription": "Number of times a request failed to acquire =
a DRS VN0 credit.  In order for a request to be transferred across QPI, it =
must be guaranteed to have a flit buffer on the remote socket to sink into.=
  There are two credit pools, VNA and VN0.  VNA is a shared pool used to ac=
hieve high performance.  The VN0 pool has reserved entries for each message=
 class and is used to prevent deadlock.  Requests first attempt to acquire =
a VNA credit, and then fall back to VN0 if they fail.  This therefore count=
s the number of times when a request failed to acquire either a VNA or VN0 =
credit and is delayed.  This should generally be a rare situation.; NDR pac=
kets are used to transmit a variety of protocol flits including grants and =
completions (CMP).",
+        "UMask": "0x4",
         "Unit": "R3QPI"
     },
     {
-        "BriefDescription": "VN0 Credit Used; SNP Message Class",
-        "Counter": "0,1",
-        "EventCode": "0x36",
-        "EventName": "UNC_R3_VN0_CREDITS_USED.SNP",
+        "BriefDescription": "VN0 Credit Acquisition Failed on DRS; SNP Mes=
sage Class",
+        "EventCode": "0x37",
+        "EventName": "UNC_R3_VN0_CREDITS_REJECT.SNP",
         "PerPkg": "1",
+        "PublicDescription": "Number of times a request failed to acquire =
a DRS VN0 credit.  In order for a request to be transferred across QPI, it =
must be guaranteed to have a flit buffer on the remote socket to sink into.=
  There are two credit pools, VNA and VN0.  VNA is a shared pool used to ac=
hieve high performance.  The VN0 pool has reserved entries for each message=
 class and is used to prevent deadlock.  Requests first attempt to acquire =
a VNA credit, and then fall back to VN0 if they fail.  This therefore count=
s the number of times when a request failed to acquire either a VNA or VN0 =
credit and is delayed.  This should generally be a rare situation.; Filter =
for Snoop (SNP) message class.  SNP is used for outgoing snoops.  Note that=
 snoop responses flow on the HOM message class.",
         "UMask": "0x2",
         "Unit": "R3QPI"
     },
     {
-        "BriefDescription": "VN0 Credit Used; NDR Message Class",
-        "Counter": "0,1",
+        "BriefDescription": "VN0 Credit Used; DRS Message Class",
         "EventCode": "0x36",
-        "EventName": "UNC_R3_VN0_CREDITS_USED.NDR",
+        "EventName": "UNC_R3_VN0_CREDITS_USED.DRS",
         "PerPkg": "1",
-        "UMask": "0x4",
+        "PublicDescription": "Number of times a VN0 credit was used on the=
 DRS message channel.  In order for a request to be transferred across QPI,=
 it must be guaranteed to have a flit buffer on the remote socket to sink i=
nto.  There are two credit pools, VNA and VN0.  VNA is a shared pool used t=
o achieve high performance.  The VN0 pool has reserved entries for each mes=
sage class and is used to prevent deadlock.  Requests first attempt to acqu=
ire a VNA credit, and then fall back to VN0 if they fail.  This counts the =
number of times a VN0 credit was used.  Note that a single VN0 credit holds=
 access to potentially multiple flit buffers.  For example, a transfer that=
 uses VNA could use 9 flit buffers and in that case uses 9 credits.  A tran=
sfer on VN0 will only count a single credit even though it may use multiple=
 buffers.; Filter for Data Response (DRS).  DRS is generally used to transm=
it data with coherency.  For example, remote reads and writes, or cache to =
cache transfers will transmit their data using DRS.",
+        "UMask": "0x8",
         "Unit": "R3QPI"
     },
     {
-        "BriefDescription": "VN0 Credit Used; DRS Message Class",
-        "Counter": "0,1",
+        "BriefDescription": "VN0 Credit Used; HOM Message Class",
         "EventCode": "0x36",
-        "EventName": "UNC_R3_VN0_CREDITS_USED.DRS",
+        "EventName": "UNC_R3_VN0_CREDITS_USED.HOM",
         "PerPkg": "1",
-        "UMask": "0x8",
+        "PublicDescription": "Number of times a VN0 credit was used on the=
 DRS message channel.  In order for a request to be transferred across QPI,=
 it must be guaranteed to have a flit buffer on the remote socket to sink i=
nto.  There are two credit pools, VNA and VN0.  VNA is a shared pool used t=
o achieve high performance.  The VN0 pool has reserved entries for each mes=
sage class and is used to prevent deadlock.  Requests first attempt to acqu=
ire a VNA credit, and then fall back to VN0 if they fail.  This counts the =
number of times a VN0 credit was used.  Note that a single VN0 credit holds=
 access to potentially multiple flit buffers.  For example, a transfer that=
 uses VNA could use 9 flit buffers and in that case uses 9 credits.  A tran=
sfer on VN0 will only count a single credit even though it may use multiple=
 buffers.; Filter for the Home (HOM) message class.  HOM is generally used =
to send requests, request responses, and snoop responses.",
+        "UMask": "0x1",
         "Unit": "R3QPI"
     },
     {
         "BriefDescription": "VN0 Credit Used; NCB Message Class",
-        "Counter": "0,1",
         "EventCode": "0x36",
         "EventName": "UNC_R3_VN0_CREDITS_USED.NCB",
         "PerPkg": "1",
+        "PublicDescription": "Number of times a VN0 credit was used on the=
 DRS message channel.  In order for a request to be transferred across QPI,=
 it must be guaranteed to have a flit buffer on the remote socket to sink i=
nto.  There are two credit pools, VNA and VN0.  VNA is a shared pool used t=
o achieve high performance.  The VN0 pool has reserved entries for each mes=
sage class and is used to prevent deadlock.  Requests first attempt to acqu=
ire a VNA credit, and then fall back to VN0 if they fail.  This counts the =
number of times a VN0 credit was used.  Note that a single VN0 credit holds=
 access to potentially multiple flit buffers.  For example, a transfer that=
 uses VNA could use 9 flit buffers and in that case uses 9 credits.  A tran=
sfer on VN0 will only count a single credit even though it may use multiple=
 buffers.; Filter for Non-Coherent Broadcast (NCB).  NCB is generally used =
to transmit data without coherency.  For example, non-coherent read data re=
turns.",
         "UMask": "0x10",
         "Unit": "R3QPI"
     },
     {
         "BriefDescription": "VN0 Credit Used; NCS Message Class",
-        "Counter": "0,1",
         "EventCode": "0x36",
         "EventName": "UNC_R3_VN0_CREDITS_USED.NCS",
         "PerPkg": "1",
+        "PublicDescription": "Number of times a VN0 credit was used on the=
 DRS message channel.  In order for a request to be transferred across QPI,=
 it must be guaranteed to have a flit buffer on the remote socket to sink i=
nto.  There are two credit pools, VNA and VN0.  VNA is a shared pool used t=
o achieve high performance.  The VN0 pool has reserved entries for each mes=
sage class and is used to prevent deadlock.  Requests first attempt to acqu=
ire a VNA credit, and then fall back to VN0 if they fail.  This counts the =
number of times a VN0 credit was used.  Note that a single VN0 credit holds=
 access to potentially multiple flit buffers.  For example, a transfer that=
 uses VNA could use 9 flit buffers and in that case uses 9 credits.  A tran=
sfer on VN0 will only count a single credit even though it may use multiple=
 buffers.; Filter for Non-Coherent Standard (NCS).  NCS is commonly used fo=
r ?",
         "UMask": "0x20",
         "Unit": "R3QPI"
     },
     {
-        "BriefDescription": "VN1 Credit Acquisition Failed on DRS; HOM Mes=
sage Class",
-        "Counter": "0,1",
-        "EventCode": "0x39",
-        "EventName": "UNC_R3_VN1_CREDITS_REJECT.HOM",
+        "BriefDescription": "VN0 Credit Used; NDR Message Class",
+        "EventCode": "0x36",
+        "EventName": "UNC_R3_VN0_CREDITS_USED.NDR",
         "PerPkg": "1",
-        "UMask": "0x1",
+        "PublicDescription": "Number of times a VN0 credit was used on the=
 DRS message channel.  In order for a request to be transferred across QPI,=
 it must be guaranteed to have a flit buffer on the remote socket to sink i=
nto.  There are two credit pools, VNA and VN0.  VNA is a shared pool used t=
o achieve high performance.  The VN0 pool has reserved entries for each mes=
sage class and is used to prevent deadlock.  Requests first attempt to acqu=
ire a VNA credit, and then fall back to VN0 if they fail.  This counts the =
number of times a VN0 credit was used.  Note that a single VN0 credit holds=
 access to potentially multiple flit buffers.  For example, a transfer that=
 uses VNA could use 9 flit buffers and in that case uses 9 credits.  A tran=
sfer on VN0 will only count a single credit even though it may use multiple=
 buffers.; NDR packets are used to transmit a variety of protocol flits inc=
luding grants and completions (CMP).",
+        "UMask": "0x4",
         "Unit": "R3QPI"
     },
     {
-        "BriefDescription": "VN1 Credit Acquisition Failed on DRS; SNP Mes=
sage Class",
-        "Counter": "0,1",
-        "EventCode": "0x39",
-        "EventName": "UNC_R3_VN1_CREDITS_REJECT.SNP",
+        "BriefDescription": "VN0 Credit Used; SNP Message Class",
+        "EventCode": "0x36",
+        "EventName": "UNC_R3_VN0_CREDITS_USED.SNP",
         "PerPkg": "1",
+        "PublicDescription": "Number of times a VN0 credit was used on the=
 DRS message channel.  In order for a request to be transferred across QPI,=
 it must be guaranteed to have a flit buffer on the remote socket to sink i=
nto.  There are two credit pools, VNA and VN0.  VNA is a shared pool used t=
o achieve high performance.  The VN0 pool has reserved entries for each mes=
sage class and is used to prevent deadlock.  Requests first attempt to acqu=
ire a VNA credit, and then fall back to VN0 if they fail.  This counts the =
number of times a VN0 credit was used.  Note that a single VN0 credit holds=
 access to potentially multiple flit buffers.  For example, a transfer that=
 uses VNA could use 9 flit buffers and in that case uses 9 credits.  A tran=
sfer on VN0 will only count a single credit even though it may use multiple=
 buffers.; Filter for Snoop (SNP) message class.  SNP is used for outgoing =
snoops.  Note that snoop responses flow on the HOM message class.",
         "UMask": "0x2",
         "Unit": "R3QPI"
     },
     {
-        "BriefDescription": "VN1 Credit Acquisition Failed on DRS; NDR Mes=
sage Class",
-        "Counter": "0,1",
+        "BriefDescription": "VN1 Credit Acquisition Failed on DRS; DRS Mes=
sage Class",
         "EventCode": "0x39",
-        "EventName": "UNC_R3_VN1_CREDITS_REJECT.NDR",
+        "EventName": "UNC_R3_VN1_CREDITS_REJECT.DRS",
         "PerPkg": "1",
-        "UMask": "0x4",
+        "PublicDescription": "Number of times a request failed to acquire =
a VN1 credit.  In order for a request to be transferred across QPI, it must=
 be guaranteed to have a flit buffer on the remote socket to sink into.  Th=
ere are two credit pools, VNA and VN1.  VNA is a shared pool used to achiev=
e high performance.  The VN1 pool has reserved entries for each message cla=
ss and is used to prevent deadlock.  Requests first attempt to acquire a VN=
A credit, and then fall back to VN1 if they fail.  This therefore counts th=
e number of times when a request failed to acquire either a VNA or VN1 cred=
it and is delayed.  This should generally be a rare situation.; Filter for =
Data Response (DRS).  DRS is generally used to transmit data with coherency=
.  For example, remote reads and writes, or cache to cache transfers will t=
ransmit their data using DRS.",
+        "UMask": "0x8",
         "Unit": "R3QPI"
     },
     {
-        "BriefDescription": "VN1 Credit Acquisition Failed on DRS; DRS Mes=
sage Class",
-        "Counter": "0,1",
+        "BriefDescription": "VN1 Credit Acquisition Failed on DRS; HOM Mes=
sage Class",
         "EventCode": "0x39",
-        "EventName": "UNC_R3_VN1_CREDITS_REJECT.DRS",
+        "EventName": "UNC_R3_VN1_CREDITS_REJECT.HOM",
         "PerPkg": "1",
-        "UMask": "0x8",
+        "PublicDescription": "Number of times a request failed to acquire =
a VN1 credit.  In order for a request to be transferred across QPI, it must=
 be guaranteed to have a flit buffer on the remote socket to sink into.  Th=
ere are two credit pools, VNA and VN1.  VNA is a shared pool used to achiev=
e high performance.  The VN1 pool has reserved entries for each message cla=
ss and is used to prevent deadlock.  Requests first attempt to acquire a VN=
A credit, and then fall back to VN1 if they fail.  This therefore counts th=
e number of times when a request failed to acquire either a VNA or VN1 cred=
it and is delayed.  This should generally be a rare situation.; Filter for =
the Home (HOM) message class.  HOM is generally used to send requests, requ=
est responses, and snoop responses.",
+        "UMask": "0x1",
         "Unit": "R3QPI"
     },
     {
         "BriefDescription": "VN1 Credit Acquisition Failed on DRS; NCB Mes=
sage Class",
-        "Counter": "0,1",
         "EventCode": "0x39",
         "EventName": "UNC_R3_VN1_CREDITS_REJECT.NCB",
         "PerPkg": "1",
+        "PublicDescription": "Number of times a request failed to acquire =
a VN1 credit.  In order for a request to be transferred across QPI, it must=
 be guaranteed to have a flit buffer on the remote socket to sink into.  Th=
ere are two credit pools, VNA and VN1.  VNA is a shared pool used to achiev=
e high performance.  The VN1 pool has reserved entries for each message cla=
ss and is used to prevent deadlock.  Requests first attempt to acquire a VN=
A credit, and then fall back to VN1 if they fail.  This therefore counts th=
e number of times when a request failed to acquire either a VNA or VN1 cred=
it and is delayed.  This should generally be a rare situation.; Filter for =
Non-Coherent Broadcast (NCB).  NCB is generally used to transmit data witho=
ut coherency.  For example, non-coherent read data returns.",
         "UMask": "0x10",
         "Unit": "R3QPI"
     },
     {
         "BriefDescription": "VN1 Credit Acquisition Failed on DRS; NCS Mes=
sage Class",
-        "Counter": "0,1",
         "EventCode": "0x39",
         "EventName": "UNC_R3_VN1_CREDITS_REJECT.NCS",
         "PerPkg": "1",
+        "PublicDescription": "Number of times a request failed to acquire =
a VN1 credit.  In order for a request to be transferred across QPI, it must=
 be guaranteed to have a flit buffer on the remote socket to sink into.  Th=
ere are two credit pools, VNA and VN1.  VNA is a shared pool used to achiev=
e high performance.  The VN1 pool has reserved entries for each message cla=
ss and is used to prevent deadlock.  Requests first attempt to acquire a VN=
A credit, and then fall back to VN1 if they fail.  This therefore counts th=
e number of times when a request failed to acquire either a VNA or VN1 cred=
it and is delayed.  This should generally be a rare situation.; Filter for =
Non-Coherent Standard (NCS).  NCS is commonly used for ?",
         "UMask": "0x20",
         "Unit": "R3QPI"
     },
     {
-        "BriefDescription": "VN1 Credit Used; HOM Message Class",
-        "Counter": "0,1",
-        "EventCode": "0x38",
-        "EventName": "UNC_R3_VN1_CREDITS_USED.HOM",
+        "BriefDescription": "VN1 Credit Acquisition Failed on DRS; NDR Mes=
sage Class",
+        "EventCode": "0x39",
+        "EventName": "UNC_R3_VN1_CREDITS_REJECT.NDR",
         "PerPkg": "1",
-        "UMask": "0x1",
+        "PublicDescription": "Number of times a request failed to acquire =
a VN1 credit.  In order for a request to be transferred across QPI, it must=
 be guaranteed to have a flit buffer on the remote socket to sink into.  Th=
ere are two credit pools, VNA and VN1.  VNA is a shared pool used to achiev=
e high performance.  The VN1 pool has reserved entries for each message cla=
ss and is used to prevent deadlock.  Requests first attempt to acquire a VN=
A credit, and then fall back to VN1 if they fail.  This therefore counts th=
e number of times when a request failed to acquire either a VNA or VN1 cred=
it and is delayed.  This should generally be a rare situation.; NDR packets=
 are used to transmit a variety of protocol flits including grants and comp=
letions (CMP).",
+        "UMask": "0x4",
         "Unit": "R3QPI"
     },
     {
-        "BriefDescription": "VN1 Credit Used; SNP Message Class",
-        "Counter": "0,1",
-        "EventCode": "0x38",
-        "EventName": "UNC_R3_VN1_CREDITS_USED.SNP",
+        "BriefDescription": "VN1 Credit Acquisition Failed on DRS; SNP Mes=
sage Class",
+        "EventCode": "0x39",
+        "EventName": "UNC_R3_VN1_CREDITS_REJECT.SNP",
         "PerPkg": "1",
+        "PublicDescription": "Number of times a request failed to acquire =
a VN1 credit.  In order for a request to be transferred across QPI, it must=
 be guaranteed to have a flit buffer on the remote socket to sink into.  Th=
ere are two credit pools, VNA and VN1.  VNA is a shared pool used to achiev=
e high performance.  The VN1 pool has reserved entries for each message cla=
ss and is used to prevent deadlock.  Requests first attempt to acquire a VN=
A credit, and then fall back to VN1 if they fail.  This therefore counts th=
e number of times when a request failed to acquire either a VNA or VN1 cred=
it and is delayed.  This should generally be a rare situation.; Filter for =
Snoop (SNP) message class.  SNP is used for outgoing snoops.  Note that sno=
op responses flow on the HOM message class.",
         "UMask": "0x2",
         "Unit": "R3QPI"
     },
     {
-        "BriefDescription": "VN1 Credit Used; NDR Message Class",
-        "Counter": "0,1",
+        "BriefDescription": "VN1 Credit Used; DRS Message Class",
         "EventCode": "0x38",
-        "EventName": "UNC_R3_VN1_CREDITS_USED.NDR",
+        "EventName": "UNC_R3_VN1_CREDITS_USED.DRS",
         "PerPkg": "1",
-        "UMask": "0x4",
+        "PublicDescription": "Number of times a VN1 credit was used on the=
 DRS message channel.  In order for a request to be transferred across QPI,=
 it must be guaranteed to have a flit buffer on the remote socket to sink i=
nto.  There are two credit pools, VNA and VN1.  VNA is a shared pool used t=
o achieve high performance.  The VN1 pool has reserved entries for each mes=
sage class and is used to prevent deadlock.  Requests first attempt to acqu=
ire a VNA credit, and then fall back to VN1 if they fail.  This counts the =
number of times a VN1 credit was used.  Note that a single VN1 credit holds=
 access to potentially multiple flit buffers.  For example, a transfer that=
 uses VNA could use 9 flit buffers and in that case uses 9 credits.  A tran=
sfer on VN1 will only count a single credit even though it may use multiple=
 buffers.; Filter for Data Response (DRS).  DRS is generally used to transm=
it data with coherency.  For example, remote reads and writes, or cache to =
cache transfers will transmit their data using DRS.",
+        "UMask": "0x8",
         "Unit": "R3QPI"
     },
     {
-        "BriefDescription": "VN1 Credit Used; DRS Message Class",
-        "Counter": "0,1",
+        "BriefDescription": "VN1 Credit Used; HOM Message Class",
         "EventCode": "0x38",
-        "EventName": "UNC_R3_VN1_CREDITS_USED.DRS",
+        "EventName": "UNC_R3_VN1_CREDITS_USED.HOM",
         "PerPkg": "1",
-        "UMask": "0x8",
+        "PublicDescription": "Number of times a VN1 credit was used on the=
 DRS message channel.  In order for a request to be transferred across QPI,=
 it must be guaranteed to have a flit buffer on the remote socket to sink i=
nto.  There are two credit pools, VNA and VN1.  VNA is a shared pool used t=
o achieve high performance.  The VN1 pool has reserved entries for each mes=
sage class and is used to prevent deadlock.  Requests first attempt to acqu=
ire a VNA credit, and then fall back to VN1 if they fail.  This counts the =
number of times a VN1 credit was used.  Note that a single VN1 credit holds=
 access to potentially multiple flit buffers.  For example, a transfer that=
 uses VNA could use 9 flit buffers and in that case uses 9 credits.  A tran=
sfer on VN1 will only count a single credit even though it may use multiple=
 buffers.; Filter for the Home (HOM) message class.  HOM is generally used =
to send requests, request responses, and snoop responses.",
+        "UMask": "0x1",
         "Unit": "R3QPI"
     },
     {
         "BriefDescription": "VN1 Credit Used; NCB Message Class",
-        "Counter": "0,1",
         "EventCode": "0x38",
         "EventName": "UNC_R3_VN1_CREDITS_USED.NCB",
         "PerPkg": "1",
+        "PublicDescription": "Number of times a VN1 credit was used on the=
 DRS message channel.  In order for a request to be transferred across QPI,=
 it must be guaranteed to have a flit buffer on the remote socket to sink i=
nto.  There are two credit pools, VNA and VN1.  VNA is a shared pool used t=
o achieve high performance.  The VN1 pool has reserved entries for each mes=
sage class and is used to prevent deadlock.  Requests first attempt to acqu=
ire a VNA credit, and then fall back to VN1 if they fail.  This counts the =
number of times a VN1 credit was used.  Note that a single VN1 credit holds=
 access to potentially multiple flit buffers.  For example, a transfer that=
 uses VNA could use 9 flit buffers and in that case uses 9 credits.  A tran=
sfer on VN1 will only count a single credit even though it may use multiple=
 buffers.; Filter for Non-Coherent Broadcast (NCB).  NCB is generally used =
to transmit data without coherency.  For example, non-coherent read data re=
turns.",
         "UMask": "0x10",
         "Unit": "R3QPI"
     },
     {
         "BriefDescription": "VN1 Credit Used; NCS Message Class",
-        "Counter": "0,1",
         "EventCode": "0x38",
         "EventName": "UNC_R3_VN1_CREDITS_USED.NCS",
         "PerPkg": "1",
+        "PublicDescription": "Number of times a VN1 credit was used on the=
 DRS message channel.  In order for a request to be transferred across QPI,=
 it must be guaranteed to have a flit buffer on the remote socket to sink i=
nto.  There are two credit pools, VNA and VN1.  VNA is a shared pool used t=
o achieve high performance.  The VN1 pool has reserved entries for each mes=
sage class and is used to prevent deadlock.  Requests first attempt to acqu=
ire a VNA credit, and then fall back to VN1 if they fail.  This counts the =
number of times a VN1 credit was used.  Note that a single VN1 credit holds=
 access to potentially multiple flit buffers.  For example, a transfer that=
 uses VNA could use 9 flit buffers and in that case uses 9 credits.  A tran=
sfer on VN1 will only count a single credit even though it may use multiple=
 buffers.; Filter for Non-Coherent Standard (NCS).  NCS is commonly used fo=
r ?",
         "UMask": "0x20",
         "Unit": "R3QPI"
     },
+    {
+        "BriefDescription": "VN1 Credit Used; NDR Message Class",
+        "EventCode": "0x38",
+        "EventName": "UNC_R3_VN1_CREDITS_USED.NDR",
+        "PerPkg": "1",
+        "PublicDescription": "Number of times a VN1 credit was used on the=
 DRS message channel.  In order for a request to be transferred across QPI,=
 it must be guaranteed to have a flit buffer on the remote socket to sink i=
nto.  There are two credit pools, VNA and VN1.  VNA is a shared pool used t=
o achieve high performance.  The VN1 pool has reserved entries for each mes=
sage class and is used to prevent deadlock.  Requests first attempt to acqu=
ire a VNA credit, and then fall back to VN1 if they fail.  This counts the =
number of times a VN1 credit was used.  Note that a single VN1 credit holds=
 access to potentially multiple flit buffers.  For example, a transfer that=
 uses VNA could use 9 flit buffers and in that case uses 9 credits.  A tran=
sfer on VN1 will only count a single credit even though it may use multiple=
 buffers.; NDR packets are used to transmit a variety of protocol flits inc=
luding grants and completions (CMP).",
+        "UMask": "0x4",
+        "Unit": "R3QPI"
+    },
+    {
+        "BriefDescription": "VN1 Credit Used; SNP Message Class",
+        "EventCode": "0x38",
+        "EventName": "UNC_R3_VN1_CREDITS_USED.SNP",
+        "PerPkg": "1",
+        "PublicDescription": "Number of times a VN1 credit was used on the=
 DRS message channel.  In order for a request to be transferred across QPI,=
 it must be guaranteed to have a flit buffer on the remote socket to sink i=
nto.  There are two credit pools, VNA and VN1.  VNA is a shared pool used t=
o achieve high performance.  The VN1 pool has reserved entries for each mes=
sage class and is used to prevent deadlock.  Requests first attempt to acqu=
ire a VNA credit, and then fall back to VN1 if they fail.  This counts the =
number of times a VN1 credit was used.  Note that a single VN1 credit holds=
 access to potentially multiple flit buffers.  For example, a transfer that=
 uses VNA could use 9 flit buffers and in that case uses 9 credits.  A tran=
sfer on VN1 will only count a single credit even though it may use multiple=
 buffers.; Filter for Snoop (SNP) message class.  SNP is used for outgoing =
snoops.  Note that snoop responses flow on the HOM message class.",
+        "UMask": "0x2",
+        "Unit": "R3QPI"
+    },
     {
         "BriefDescription": "VNA credit Acquisitions; HOM Message Class",
-        "Counter": "0,1",
         "EventCode": "0x33",
         "EventName": "UNC_R3_VNA_CREDITS_ACQUIRED.AD",
         "PerPkg": "1",
+        "PublicDescription": "Number of QPI VNA Credit acquisitions.  This=
 event can be used in conjunction with the VNA In-Use Accumulator to calcul=
ate the average lifetime of a credit holder.  VNA credits are used by all m=
essage classes in order to communicate across QPI.  If a packet is unable t=
o acquire credits, it will then attempt to use credts from the VN0 pool.  N=
ote that a single packet may require multiple flit buffers (i.e. when data =
is being transferred).  Therefore, this event will increment by the number =
of credits acquired in each cycle.  Filtering based on message class is not=
 provided.  One can count the number of packets transferred in a given mess=
age class using an qfclk event.; Filter for the Home (HOM) message class.  =
HOM is generally used to send requests, request responses, and snoop respon=
ses.",
         "UMask": "0x1",
         "Unit": "R3QPI"
     },
     {
         "BriefDescription": "VNA credit Acquisitions; HOM Message Class",
-        "Counter": "0,1",
         "EventCode": "0x33",
         "EventName": "UNC_R3_VNA_CREDITS_ACQUIRED.BL",
         "PerPkg": "1",
+        "PublicDescription": "Number of QPI VNA Credit acquisitions.  This=
 event can be used in conjunction with the VNA In-Use Accumulator to calcul=
ate the average lifetime of a credit holder.  VNA credits are used by all m=
essage classes in order to communicate across QPI.  If a packet is unable t=
o acquire credits, it will then attempt to use credts from the VN0 pool.  N=
ote that a single packet may require multiple flit buffers (i.e. when data =
is being transferred).  Therefore, this event will increment by the number =
of credits acquired in each cycle.  Filtering based on message class is not=
 provided.  One can count the number of packets transferred in a given mess=
age class using an qfclk event.; Filter for the Home (HOM) message class.  =
HOM is generally used to send requests, request responses, and snoop respon=
ses.",
         "UMask": "0x4",
         "Unit": "R3QPI"
     },
     {
-        "BriefDescription": "VNA Credit Reject; HOM Message Class",
-        "Counter": "0,1",
+        "BriefDescription": "VNA Credit Reject; DRS Message Class",
         "EventCode": "0x34",
-        "EventName": "UNC_R3_VNA_CREDITS_REJECT.HOM",
+        "EventName": "UNC_R3_VNA_CREDITS_REJECT.DRS",
         "PerPkg": "1",
-        "UMask": "0x1",
+        "PublicDescription": "Number of attempted VNA credit acquisitions =
that were rejected because the VNA credit pool was full (or almost full).  =
It is possible to filter this event by message class.  Some packets use mor=
e than one flit buffer, and therefore must acquire multiple credits.  There=
fore, one could get a reject even if the VNA credits were not fully used up=
.  The VNA pool is generally used to provide the bulk of the QPI bandwidth =
(as opposed to the VN0 pool which is used to guarantee forward progress).  =
VNA credits can run out if the flit buffer on the receiving side starts to =
queue up substantially.  This can happen if the rest of the uncore is unabl=
e to drain the requests fast enough.; Filter for Data Response (DRS).  DRS =
is generally used to transmit data with coherency.  For example, remote rea=
ds and writes, or cache to cache transfers will transmit their data using D=
RS.",
+        "UMask": "0x8",
         "Unit": "R3QPI"
     },
     {
-        "BriefDescription": "VNA Credit Reject; SNP Message Class",
-        "Counter": "0,1",
+        "BriefDescription": "VNA Credit Reject; HOM Message Class",
         "EventCode": "0x34",
-        "EventName": "UNC_R3_VNA_CREDITS_REJECT.SNP",
+        "EventName": "UNC_R3_VNA_CREDITS_REJECT.HOM",
         "PerPkg": "1",
-        "UMask": "0x2",
+        "PublicDescription": "Number of attempted VNA credit acquisitions =
that were rejected because the VNA credit pool was full (or almost full).  =
It is possible to filter this event by message class.  Some packets use mor=
e than one flit buffer, and therefore must acquire multiple credits.  There=
fore, one could get a reject even if the VNA credits were not fully used up=
.  The VNA pool is generally used to provide the bulk of the QPI bandwidth =
(as opposed to the VN0 pool which is used to guarantee forward progress).  =
VNA credits can run out if the flit buffer on the receiving side starts to =
queue up substantially.  This can happen if the rest of the uncore is unabl=
e to drain the requests fast enough.; Filter for the Home (HOM) message cla=
ss.  HOM is generally used to send requests, request responses, and snoop r=
esponses.",
+        "UMask": "0x1",
         "Unit": "R3QPI"
     },
     {
-        "BriefDescription": "VNA Credit Reject; NDR Message Class",
-        "Counter": "0,1",
+        "BriefDescription": "VNA Credit Reject; NCB Message Class",
         "EventCode": "0x34",
-        "EventName": "UNC_R3_VNA_CREDITS_REJECT.NDR",
+        "EventName": "UNC_R3_VNA_CREDITS_REJECT.NCB",
         "PerPkg": "1",
-        "UMask": "0x4",
-        "Unit": "R3QPI"
-    },
-    {
-        "BriefDescription": "VNA Credit Reject; DRS Message Class",
-        "Counter": "0,1",
-        "EventCode": "0x34",
-        "EventName": "UNC_R3_VNA_CREDITS_REJECT.DRS",
-        "PerPkg": "1",
-        "UMask": "0x8",
-        "Unit": "R3QPI"
-    },
-    {
-        "BriefDescription": "VNA Credit Reject; NCB Message Class",
-        "Counter": "0,1",
-        "EventCode": "0x34",
-        "EventName": "UNC_R3_VNA_CREDITS_REJECT.NCB",
-        "PerPkg": "1",
-        "UMask": "0x10",
+        "PublicDescription": "Number of attempted VNA credit acquisitions =
that were rejected because the VNA credit pool was full (or almost full).  =
It is possible to filter this event by message class.  Some packets use mor=
e than one flit buffer, and therefore must acquire multiple credits.  There=
fore, one could get a reject even if the VNA credits were not fully used up=
.  The VNA pool is generally used to provide the bulk of the QPI bandwidth =
(as opposed to the VN0 pool which is used to guarantee forward progress).  =
VNA credits can run out if the flit buffer on the receiving side starts to =
queue up substantially.  This can happen if the rest of the uncore is unabl=
e to drain the requests fast enough.; Filter for Non-Coherent Broadcast (NC=
B).  NCB is generally used to transmit data without coherency.  For example=
, non-coherent read data returns.",
+        "UMask": "0x10",
         "Unit": "R3QPI"
     },
     {
         "BriefDescription": "VNA Credit Reject; NCS Message Class",
-        "Counter": "0,1",
         "EventCode": "0x34",
         "EventName": "UNC_R3_VNA_CREDITS_REJECT.NCS",
         "PerPkg": "1",
+        "PublicDescription": "Number of attempted VNA credit acquisitions =
that were rejected because the VNA credit pool was full (or almost full).  =
It is possible to filter this event by message class.  Some packets use mor=
e than one flit buffer, and therefore must acquire multiple credits.  There=
fore, one could get a reject even if the VNA credits were not fully used up=
.  The VNA pool is generally used to provide the bulk of the QPI bandwidth =
(as opposed to the VN0 pool which is used to guarantee forward progress).  =
VNA credits can run out if the flit buffer on the receiving side starts to =
queue up substantially.  This can happen if the rest of the uncore is unabl=
e to drain the requests fast enough.; Filter for Non-Coherent Standard (NCS=
).",
         "UMask": "0x20",
         "Unit": "R3QPI"
     },
     {
-        "BriefDescription": "IOT Backpressure",
-        "Counter": "0,1,2",
-        "EventCode": "0xB",
-        "EventName": "UNC_R3_IOT_BACKPRESSURE.SAT",
-        "PerPkg": "1",
-        "UMask": "0x1",
-        "Unit": "R3QPI"
-    },
-    {
-        "BriefDescription": "IOT Backpressure",
-        "Counter": "0,1,2",
-        "EventCode": "0xB",
-        "EventName": "UNC_R3_IOT_BACKPRESSURE.HUB",
-        "PerPkg": "1",
-        "UMask": "0x2",
-        "Unit": "R3QPI"
-    },
-    {
-        "BriefDescription": "IOT Common Trigger Sequencer - Hi",
-        "Counter": "0,1,2",
-        "EventCode": "0xD",
-        "EventName": "UNC_R3_IOT_CTS_HI.CTS2",
-        "PerPkg": "1",
-        "UMask": "0x1",
-        "Unit": "R3QPI"
-    },
-    {
-        "BriefDescription": "IOT Common Trigger Sequencer - Hi",
-        "Counter": "0,1,2",
-        "EventCode": "0xD",
-        "EventName": "UNC_R3_IOT_CTS_HI.CTS3",
-        "PerPkg": "1",
-        "UMask": "0x2",
-        "Unit": "R3QPI"
-    },
-    {
-        "BriefDescription": "IOT Common Trigger Sequencer - Lo",
-        "Counter": "0,1,2",
-        "EventCode": "0xC",
-        "EventName": "UNC_R3_IOT_CTS_LO.CTS0",
-        "PerPkg": "1",
-        "UMask": "0x1",
-        "Unit": "R3QPI"
-    },
-    {
-        "BriefDescription": "IOT Common Trigger Sequencer - Lo",
-        "Counter": "0,1,2",
-        "EventCode": "0xC",
-        "EventName": "UNC_R3_IOT_CTS_LO.CTS1",
-        "PerPkg": "1",
-        "UMask": "0x2",
-        "Unit": "R3QPI"
-    },
-    {
-        "BriefDescription": "SBo0 Credits Occupancy; For AD Ring",
-        "EventCode": "0x2A",
-        "EventName": "UNC_R3_SBO0_CREDIT_OCCUPANCY.AD",
-        "PerPkg": "1",
-        "UMask": "0x1",
-        "Unit": "R3QPI"
-    },
-    {
-        "BriefDescription": "SBo0 Credits Occupancy; For BL Ring",
-        "EventCode": "0x2A",
-        "EventName": "UNC_R3_SBO0_CREDIT_OCCUPANCY.BL",
-        "PerPkg": "1",
-        "UMask": "0x2",
-        "Unit": "R3QPI"
-    },
-    {
-        "BriefDescription": "SBo1 Credits Occupancy; For AD Ring",
-        "EventCode": "0x2B",
-        "EventName": "UNC_R3_SBO1_CREDIT_OCCUPANCY.AD",
+        "BriefDescription": "VNA Credit Reject; NDR Message Class",
+        "EventCode": "0x34",
+        "EventName": "UNC_R3_VNA_CREDITS_REJECT.NDR",
         "PerPkg": "1",
-        "UMask": "0x1",
+        "PublicDescription": "Number of attempted VNA credit acquisitions =
that were rejected because the VNA credit pool was full (or almost full).  =
It is possible to filter this event by message class.  Some packets use mor=
e than one flit buffer, and therefore must acquire multiple credits.  There=
fore, one could get a reject even if the VNA credits were not fully used up=
.  The VNA pool is generally used to provide the bulk of the QPI bandwidth =
(as opposed to the VN0 pool which is used to guarantee forward progress).  =
VNA credits can run out if the flit buffer on the receiving side starts to =
queue up substantially.  This can happen if the rest of the uncore is unabl=
e to drain the requests fast enough.; NDR packets are used to transmit a va=
riety of protocol flits including grants and completions (CMP).",
+        "UMask": "0x4",
         "Unit": "R3QPI"
     },
     {
-        "BriefDescription": "SBo1 Credits Occupancy; For BL Ring",
-        "EventCode": "0x2B",
-        "EventName": "UNC_R3_SBO1_CREDIT_OCCUPANCY.BL",
+        "BriefDescription": "VNA Credit Reject; SNP Message Class",
+        "EventCode": "0x34",
+        "EventName": "UNC_R3_VNA_CREDITS_REJECT.SNP",
         "PerPkg": "1",
+        "PublicDescription": "Number of attempted VNA credit acquisitions =
that were rejected because the VNA credit pool was full (or almost full).  =
It is possible to filter this event by message class.  Some packets use mor=
e than one flit buffer, and therefore must acquire multiple credits.  There=
fore, one could get a reject even if the VNA credits were not fully used up=
.  The VNA pool is generally used to provide the bulk of the QPI bandwidth =
(as opposed to the VN0 pool which is used to guarantee forward progress).  =
VNA credits can run out if the flit buffer on the receiving side starts to =
queue up substantially.  This can happen if the rest of the uncore is unabl=
e to drain the requests fast enough.; Filter for Snoop (SNP) message class.=
  SNP is used for outgoing snoops.  Note that snoop responses flow on the H=
OM message class.",
         "UMask": "0x2",
         "Unit": "R3QPI"
     },
-    {
-        "BriefDescription": "R3 AD Ring in Use; All",
-        "Counter": "0,1,2",
-        "EventCode": "0x7",
-        "EventName": "UNC_R3_RING_AD_USED.ALL",
-        "PerPkg": "1",
-        "UMask": "0xF",
-        "Unit": "R3QPI"
-    },
-    {
-        "BriefDescription": "R3 AK Ring in Use; All",
-        "Counter": "0,1,2",
-        "EventCode": "0x8",
-        "EventName": "UNC_R3_RING_AK_USED.ALL",
-        "PerPkg": "1",
-        "UMask": "0xF",
-        "Unit": "R3QPI"
-    },
-    {
-        "BriefDescription": "R3 BL Ring in Use; All",
-        "Counter": "0,1,2",
-        "EventCode": "0x9",
-        "EventName": "UNC_R3_RING_BL_USED.ALL",
-        "PerPkg": "1",
-        "UMask": "0xF",
-        "Unit": "R3QPI"
-    },
     {
         "BriefDescription": "Bounce Control",
-        "Counter": "0,1,2,3",
         "EventCode": "0xA",
         "EventName": "UNC_S_BOUNCE_CONTROL",
         "PerPkg": "1",
+        "PublicDescription": "UNC_S_BOUNCE_CONTROL",
         "Unit": "SBO"
     },
     {
         "BriefDescription": "Uncore Clocks",
-        "Counter": "0,1,2,3",
         "EventName": "UNC_S_CLOCKTICKS",
         "PerPkg": "1",
+        "PublicDescription": "UNC_S_CLOCKTICKS",
         "Unit": "SBO"
     },
     {
         "BriefDescription": "FaST wire asserted",
-        "Counter": "0,1,2,3",
         "EventCode": "0x9",
         "EventName": "UNC_S_FAST_ASSERTED",
         "PerPkg": "1",
+        "PublicDescription": "Counts the number of cycles either the local=
 or incoming distress signals are asserted.  Incoming distress includes up,=
 dn and across.",
         "Unit": "SBO"
     },
     {
-        "BriefDescription": "AD Ring In Use; Up and Even",
-        "Counter": "0,1,2,3",
+        "BriefDescription": "AD Ring In Use; All",
         "EventCode": "0x1B",
-        "EventName": "UNC_S_RING_AD_USED.UP_EVEN",
+        "EventName": "UNC_S_RING_AD_USED.ALL",
         "PerPkg": "1",
-        "UMask": "0x1",
+        "PublicDescription": "Counts the number of cycles that the AD ring=
 is being used at this ring stop.  This includes when packets are passing b=
y and when packets are being sent, but does not include when packets are be=
ing sunk into the ring stop.  We really have two rings in BDX -- a clockwis=
e ring and a counter-clockwise ring.  On the left side of the ring, the UP =
direction is on the clockwise ring and DN is on the counter-clockwise ring.=
  On the right side of the ring, this is reversed.  The first half of the C=
Bos are on the left side of the ring, and the 2nd half are on the right sid=
e of the ring.  In other words (for example), in a 4c part, Cbo 0 UP AD is =
NOT the same ring as CBo 2 UP AD because they are on opposite sides of the =
ring.",
+        "UMask": "0xf",
         "Unit": "SBO"
     },
     {
-        "BriefDescription": "AD Ring In Use; Up and Odd",
-        "Counter": "0,1,2,3",
+        "BriefDescription": "AD Ring In Use; Down",
         "EventCode": "0x1B",
-        "EventName": "UNC_S_RING_AD_USED.UP_ODD",
+        "EventName": "UNC_S_RING_AD_USED.DOWN",
         "PerPkg": "1",
-        "UMask": "0x2",
+        "PublicDescription": "Counts the number of cycles that the AD ring=
 is being used at this ring stop.  This includes when packets are passing b=
y and when packets are being sent, but does not include when packets are be=
ing sunk into the ring stop.  We really have two rings in HSX -- a clockwis=
e ring and a counter-clockwise ring.  On the left side of the ring, the UP =
direction is on the clockwise ring and DN is on the counter-clockwise ring.=
  On the right side of the ring, this is reversed.  The first half of the C=
Bos are on the left side of the ring, and the 2nd half are on the right sid=
e of the ring.  In other words (for example), in a 4c part, Cbo 0 UP AD is =
NOT the same ring as CBo 2 UP AD because they are on opposite sides of the =
ring.",
+        "UMask": "0xc",
         "Unit": "SBO"
     },
     {
         "BriefDescription": "AD Ring In Use; Down and Event",
-        "Counter": "0,1,2,3",
         "EventCode": "0x1B",
         "EventName": "UNC_S_RING_AD_USED.DOWN_EVEN",
         "PerPkg": "1",
+        "PublicDescription": "Counts the number of cycles that the AD ring=
 is being used at this ring stop.  This includes when packets are passing b=
y and when packets are being sent, but does not include when packets are be=
ing sunk into the ring stop.  We really have two rings in BDX -- a clockwis=
e ring and a counter-clockwise ring.  On the left side of the ring, the UP =
direction is on the clockwise ring and DN is on the counter-clockwise ring.=
  On the right side of the ring, this is reversed.  The first half of the C=
Bos are on the left side of the ring, and the 2nd half are on the right sid=
e of the ring.  In other words (for example), in a 4c part, Cbo 0 UP AD is =
NOT the same ring as CBo 2 UP AD because they are on opposite sides of the =
ring.; Filters for the Down and Event ring polarity.",
         "UMask": "0x4",
         "Unit": "SBO"
     },
     {
         "BriefDescription": "AD Ring In Use; Down and Odd",
-        "Counter": "0,1,2,3",
         "EventCode": "0x1B",
         "EventName": "UNC_S_RING_AD_USED.DOWN_ODD",
         "PerPkg": "1",
+        "PublicDescription": "Counts the number of cycles that the AD ring=
 is being used at this ring stop.  This includes when packets are passing b=
y and when packets are being sent, but does not include when packets are be=
ing sunk into the ring stop.  We really have two rings in BDX -- a clockwis=
e ring and a counter-clockwise ring.  On the left side of the ring, the UP =
direction is on the clockwise ring and DN is on the counter-clockwise ring.=
  On the right side of the ring, this is reversed.  The first half of the C=
Bos are on the left side of the ring, and the 2nd half are on the right sid=
e of the ring.  In other words (for example), in a 4c part, Cbo 0 UP AD is =
NOT the same ring as CBo 2 UP AD because they are on opposite sides of the =
ring.; Filters for the Down and Odd ring polarity.",
         "UMask": "0x8",
         "Unit": "SBO"
     },
     {
         "BriefDescription": "AD Ring In Use; Up",
-        "Counter": "0,1,2,3",
         "EventCode": "0x1B",
         "EventName": "UNC_S_RING_AD_USED.UP",
         "PerPkg": "1",
+        "PublicDescription": "Counts the number of cycles that the AD ring=
 is being used at this ring stop.  This includes when packets are passing b=
y and when packets are being sent, but does not include when packets are be=
ing sunk into the ring stop.  We really have two rings in HSX -- a clockwis=
e ring and a counter-clockwise ring.  On the left side of the ring, the UP =
direction is on the clockwise ring and DN is on the counter-clockwise ring.=
  On the right side of the ring, this is reversed.  The first half of the C=
Bos are on the left side of the ring, and the 2nd half are on the right sid=
e of the ring.  In other words (for example), in a 4c part, Cbo 0 UP AD is =
NOT the same ring as CBo 2 UP AD because they are on opposite sides of the =
ring.",
         "UMask": "0x3",
         "Unit": "SBO"
     },
     {
-        "BriefDescription": "AD Ring In Use; Down",
-        "Counter": "0,1,2,3",
+        "BriefDescription": "AD Ring In Use; Up and Even",
         "EventCode": "0x1B",
-        "EventName": "UNC_S_RING_AD_USED.DOWN",
+        "EventName": "UNC_S_RING_AD_USED.UP_EVEN",
         "PerPkg": "1",
-        "UMask": "0xC",
+        "PublicDescription": "Counts the number of cycles that the AD ring=
 is being used at this ring stop.  This includes when packets are passing b=
y and when packets are being sent, but does not include when packets are be=
ing sunk into the ring stop.  We really have two rings in BDX -- a clockwis=
e ring and a counter-clockwise ring.  On the left side of the ring, the UP =
direction is on the clockwise ring and DN is on the counter-clockwise ring.=
  On the right side of the ring, this is reversed.  The first half of the C=
Bos are on the left side of the ring, and the 2nd half are on the right sid=
e of the ring.  In other words (for example), in a 4c part, Cbo 0 UP AD is =
NOT the same ring as CBo 2 UP AD because they are on opposite sides of the =
ring.; Filters for the Up and Even ring polarity.",
+        "UMask": "0x1",
         "Unit": "SBO"
     },
     {
-        "BriefDescription": "AK Ring In Use; Up and Even",
-        "Counter": "0,1,2,3",
+        "BriefDescription": "AD Ring In Use; Up and Odd",
+        "EventCode": "0x1B",
+        "EventName": "UNC_S_RING_AD_USED.UP_ODD",
+        "PerPkg": "1",
+        "PublicDescription": "Counts the number of cycles that the AD ring=
 is being used at this ring stop.  This includes when packets are passing b=
y and when packets are being sent, but does not include when packets are be=
ing sunk into the ring stop.  We really have two rings in BDX -- a clockwis=
e ring and a counter-clockwise ring.  On the left side of the ring, the UP =
direction is on the clockwise ring and DN is on the counter-clockwise ring.=
  On the right side of the ring, this is reversed.  The first half of the C=
Bos are on the left side of the ring, and the 2nd half are on the right sid=
e of the ring.  In other words (for example), in a 4c part, Cbo 0 UP AD is =
NOT the same ring as CBo 2 UP AD because they are on opposite sides of the =
ring.; Filters for the Up and Odd ring polarity.",
+        "UMask": "0x2",
+        "Unit": "SBO"
+    },
+    {
+        "BriefDescription": "AK Ring In Use; All",
         "EventCode": "0x1C",
-        "EventName": "UNC_S_RING_AK_USED.UP_EVEN",
+        "EventName": "UNC_S_RING_AK_USED.ALL",
         "PerPkg": "1",
-        "UMask": "0x1",
+        "PublicDescription": "Counts the number of cycles that the AK ring=
 is being used at this ring stop.  This includes when packets are passing b=
y and when packets are being sent, but does not include when packets are be=
ing sunk into the ring stop. We really have two rings in BDX -- a clockwise=
 ring and a counter-clockwise ring.  On the left side of the ring, the UP d=
irection is on the clockwise ring and DN is on the counter-clockwise ring. =
 On the right side of the ring, this is reversed.  The first half of the CB=
os are on the left side of the ring, and the 2nd half are on the right side=
 of the ring.  In other words (for example), in a 4c part, Cbo 0 UP AD is N=
OT the same ring as CBo 2 UP AD because they are on opposite sides of the r=
ing.",
+        "UMask": "0xf",
         "Unit": "SBO"
     },
     {
-        "BriefDescription": "AK Ring In Use; Up and Odd",
-        "Counter": "0,1,2,3",
+        "BriefDescription": "AK Ring In Use; Down",
         "EventCode": "0x1C",
-        "EventName": "UNC_S_RING_AK_USED.UP_ODD",
+        "EventName": "UNC_S_RING_AK_USED.DOWN",
         "PerPkg": "1",
-        "UMask": "0x2",
+        "PublicDescription": "Counts the number of cycles that the AK ring=
 is being used at this ring stop.  This includes when packets are passing b=
y and when packets are being sent, but does not include when packets are be=
ing sunk into the ring stop. We really have two rings in HSX -- a clockwise=
 ring and a counter-clockwise ring.  On the left side of the ring, the UP d=
irection is on the clockwise ring and DN is on the counter-clockwise ring. =
 On the right side of the ring, this is reversed.  The first half of the CB=
os are on the left side of the ring, and the 2nd half are on the right side=
 of the ring.  In other words (for example), in a 4c part, Cbo 0 UP AD is N=
OT the same ring as CBo 2 UP AD because they are on opposite sides of the r=
ing.",
+        "UMask": "0xc",
         "Unit": "SBO"
     },
     {
         "BriefDescription": "AK Ring In Use; Down and Event",
-        "Counter": "0,1,2,3",
         "EventCode": "0x1C",
         "EventName": "UNC_S_RING_AK_USED.DOWN_EVEN",
         "PerPkg": "1",
+        "PublicDescription": "Counts the number of cycles that the AK ring=
 is being used at this ring stop.  This includes when packets are passing b=
y and when packets are being sent, but does not include when packets are be=
ing sunk into the ring stop. We really have two rings in BDX -- a clockwise=
 ring and a counter-clockwise ring.  On the left side of the ring, the UP d=
irection is on the clockwise ring and DN is on the counter-clockwise ring. =
 On the right side of the ring, this is reversed.  The first half of the CB=
os are on the left side of the ring, and the 2nd half are on the right side=
 of the ring.  In other words (for example), in a 4c part, Cbo 0 UP AD is N=
OT the same ring as CBo 2 UP AD because they are on opposite sides of the r=
ing.; Filters for the Down and Event ring polarity.",
         "UMask": "0x4",
         "Unit": "SBO"
     },
     {
         "BriefDescription": "AK Ring In Use; Down and Odd",
-        "Counter": "0,1,2,3",
         "EventCode": "0x1C",
         "EventName": "UNC_S_RING_AK_USED.DOWN_ODD",
         "PerPkg": "1",
+        "PublicDescription": "Counts the number of cycles that the AK ring=
 is being used at this ring stop.  This includes when packets are passing b=
y and when packets are being sent, but does not include when packets are be=
ing sunk into the ring stop. We really have two rings in BDX -- a clockwise=
 ring and a counter-clockwise ring.  On the left side of the ring, the UP d=
irection is on the clockwise ring and DN is on the counter-clockwise ring. =
 On the right side of the ring, this is reversed.  The first half of the CB=
os are on the left side of the ring, and the 2nd half are on the right side=
 of the ring.  In other words (for example), in a 4c part, Cbo 0 UP AD is N=
OT the same ring as CBo 2 UP AD because they are on opposite sides of the r=
ing.; Filters for the Down and Odd ring polarity.",
         "UMask": "0x8",
         "Unit": "SBO"
     },
     {
         "BriefDescription": "AK Ring In Use; Up",
-        "Counter": "0,1,2,3",
         "EventCode": "0x1C",
         "EventName": "UNC_S_RING_AK_USED.UP",
         "PerPkg": "1",
+        "PublicDescription": "Counts the number of cycles that the AK ring=
 is being used at this ring stop.  This includes when packets are passing b=
y and when packets are being sent, but does not include when packets are be=
ing sunk into the ring stop. We really have two rings in HSX -- a clockwise=
 ring and a counter-clockwise ring.  On the left side of the ring, the UP d=
irection is on the clockwise ring and DN is on the counter-clockwise ring. =
 On the right side of the ring, this is reversed.  The first half of the CB=
os are on the left side of the ring, and the 2nd half are on the right side=
 of the ring.  In other words (for example), in a 4c part, Cbo 0 UP AD is N=
OT the same ring as CBo 2 UP AD because they are on opposite sides of the r=
ing.",
         "UMask": "0x3",
         "Unit": "SBO"
     },
     {
-        "BriefDescription": "AK Ring In Use; Down",
-        "Counter": "0,1,2,3",
+        "BriefDescription": "AK Ring In Use; Up and Even",
         "EventCode": "0x1C",
-        "EventName": "UNC_S_RING_AK_USED.DOWN",
+        "EventName": "UNC_S_RING_AK_USED.UP_EVEN",
         "PerPkg": "1",
-        "UMask": "0xC",
+        "PublicDescription": "Counts the number of cycles that the AK ring=
 is being used at this ring stop.  This includes when packets are passing b=
y and when packets are being sent, but does not include when packets are be=
ing sunk into the ring stop. We really have two rings in BDX -- a clockwise=
 ring and a counter-clockwise ring.  On the left side of the ring, the UP d=
irection is on the clockwise ring and DN is on the counter-clockwise ring. =
 On the right side of the ring, this is reversed.  The first half of the CB=
os are on the left side of the ring, and the 2nd half are on the right side=
 of the ring.  In other words (for example), in a 4c part, Cbo 0 UP AD is N=
OT the same ring as CBo 2 UP AD because they are on opposite sides of the r=
ing.; Filters for the Up and Even ring polarity.",
+        "UMask": "0x1",
         "Unit": "SBO"
     },
     {
-        "BriefDescription": "BL Ring in Use; Up and Even",
-        "Counter": "0,1,2,3",
+        "BriefDescription": "AK Ring In Use; Up and Odd",
+        "EventCode": "0x1C",
+        "EventName": "UNC_S_RING_AK_USED.UP_ODD",
+        "PerPkg": "1",
+        "PublicDescription": "Counts the number of cycles that the AK ring=
 is being used at this ring stop.  This includes when packets are passing b=
y and when packets are being sent, but does not include when packets are be=
ing sunk into the ring stop. We really have two rings in BDX -- a clockwise=
 ring and a counter-clockwise ring.  On the left side of the ring, the UP d=
irection is on the clockwise ring and DN is on the counter-clockwise ring. =
 On the right side of the ring, this is reversed.  The first half of the CB=
os are on the left side of the ring, and the 2nd half are on the right side=
 of the ring.  In other words (for example), in a 4c part, Cbo 0 UP AD is N=
OT the same ring as CBo 2 UP AD because they are on opposite sides of the r=
ing.; Filters for the Up and Odd ring polarity.",
+        "UMask": "0x2",
+        "Unit": "SBO"
+    },
+    {
+        "BriefDescription": "BL Ring in Use; All",
         "EventCode": "0x1D",
-        "EventName": "UNC_S_RING_BL_USED.UP_EVEN",
+        "EventName": "UNC_S_RING_BL_USED.ALL",
         "PerPkg": "1",
-        "UMask": "0x1",
+        "PublicDescription": "Counts the number of cycles that the BL ring=
 is being used at this ring stop.  This includes when packets are passing b=
y and when packets are being sent, but does not include when packets are be=
ing sunk into the ring stop. We really have two rings in BDX -- a clockwise=
 ring and a counter-clockwise ring.  On the left side of the ring, the UP d=
irection is on the clockwise ring and DN is on the counter-clockwise ring. =
 On the right side of the ring, this is reversed.  The first half of the CB=
os are on the left side of the ring, and the 2nd half are on the right side=
 of the ring.  In other words (for example), in a 4c part, Cbo 0 UP AD is N=
OT the same ring as CBo 2 UP AD because they are on opposite sides of the r=
ing.",
+        "UMask": "0xf",
         "Unit": "SBO"
     },
     {
-        "BriefDescription": "BL Ring in Use; Up and Odd",
-        "Counter": "0,1,2,3",
+        "BriefDescription": "BL Ring in Use; Down",
         "EventCode": "0x1D",
-        "EventName": "UNC_S_RING_BL_USED.UP_ODD",
+        "EventName": "UNC_S_RING_BL_USED.DOWN",
         "PerPkg": "1",
-        "UMask": "0x2",
+        "PublicDescription": "Counts the number of cycles that the BL ring=
 is being used at this ring stop.  This includes when packets are passing b=
y and when packets are being sent, but does not include when packets are be=
ing sunk into the ring stop. We really have two rings in HSX -- a clockwise=
 ring and a counter-clockwise ring.  On the left side of the ring, the UP d=
irection is on the clockwise ring and DN is on the counter-clockwise ring. =
 On the right side of the ring, this is reversed.  The first half of the CB=
os are on the left side of the ring, and the 2nd half are on the right side=
 of the ring.  In other words (for example), in a 4c part, Cbo 0 UP AD is N=
OT the same ring as CBo 2 UP AD because they are on opposite sides of the r=
ing.",
+        "UMask": "0xc",
         "Unit": "SBO"
     },
     {
         "BriefDescription": "BL Ring in Use; Down and Event",
-        "Counter": "0,1,2,3",
         "EventCode": "0x1D",
         "EventName": "UNC_S_RING_BL_USED.DOWN_EVEN",
         "PerPkg": "1",
+        "PublicDescription": "Counts the number of cycles that the BL ring=
 is being used at this ring stop.  This includes when packets are passing b=
y and when packets are being sent, but does not include when packets are be=
ing sunk into the ring stop. We really have two rings in BDX -- a clockwise=
 ring and a counter-clockwise ring.  On the left side of the ring, the UP d=
irection is on the clockwise ring and DN is on the counter-clockwise ring. =
 On the right side of the ring, this is reversed.  The first half of the CB=
os are on the left side of the ring, and the 2nd half are on the right side=
 of the ring.  In other words (for example), in a 4c part, Cbo 0 UP AD is N=
OT the same ring as CBo 2 UP AD because they are on opposite sides of the r=
ing.; Filters for the Down and Event ring polarity.",
         "UMask": "0x4",
         "Unit": "SBO"
     },
     {
         "BriefDescription": "BL Ring in Use; Down and Odd",
-        "Counter": "0,1,2,3",
         "EventCode": "0x1D",
         "EventName": "UNC_S_RING_BL_USED.DOWN_ODD",
         "PerPkg": "1",
+        "PublicDescription": "Counts the number of cycles that the BL ring=
 is being used at this ring stop.  This includes when packets are passing b=
y and when packets are being sent, but does not include when packets are be=
ing sunk into the ring stop. We really have two rings in BDX -- a clockwise=
 ring and a counter-clockwise ring.  On the left side of the ring, the UP d=
irection is on the clockwise ring and DN is on the counter-clockwise ring. =
 On the right side of the ring, this is reversed.  The first half of the CB=
os are on the left side of the ring, and the 2nd half are on the right side=
 of the ring.  In other words (for example), in a 4c part, Cbo 0 UP AD is N=
OT the same ring as CBo 2 UP AD because they are on opposite sides of the r=
ing.; Filters for the Down and Odd ring polarity.",
         "UMask": "0x8",
         "Unit": "SBO"
     },
     {
         "BriefDescription": "BL Ring in Use; Up",
-        "Counter": "0,1,2,3",
         "EventCode": "0x1D",
         "EventName": "UNC_S_RING_BL_USED.UP",
         "PerPkg": "1",
+        "PublicDescription": "Counts the number of cycles that the BL ring=
 is being used at this ring stop.  This includes when packets are passing b=
y and when packets are being sent, but does not include when packets are be=
ing sunk into the ring stop. We really have two rings in HSX -- a clockwise=
 ring and a counter-clockwise ring.  On the left side of the ring, the UP d=
irection is on the clockwise ring and DN is on the counter-clockwise ring. =
 On the right side of the ring, this is reversed.  The first half of the CB=
os are on the left side of the ring, and the 2nd half are on the right side=
 of the ring.  In other words (for example), in a 4c part, Cbo 0 UP AD is N=
OT the same ring as CBo 2 UP AD because they are on opposite sides of the r=
ing.",
         "UMask": "0x3",
         "Unit": "SBO"
     },
     {
-        "BriefDescription": "BL Ring in Use; Down",
-        "Counter": "0,1,2,3",
+        "BriefDescription": "BL Ring in Use; Up and Even",
         "EventCode": "0x1D",
-        "EventName": "UNC_S_RING_BL_USED.DOWN",
+        "EventName": "UNC_S_RING_BL_USED.UP_EVEN",
+        "PerPkg": "1",
+        "PublicDescription": "Counts the number of cycles that the BL ring=
 is being used at this ring stop.  This includes when packets are passing b=
y and when packets are being sent, but does not include when packets are be=
ing sunk into the ring stop. We really have two rings in BDX -- a clockwise=
 ring and a counter-clockwise ring.  On the left side of the ring, the UP d=
irection is on the clockwise ring and DN is on the counter-clockwise ring. =
 On the right side of the ring, this is reversed.  The first half of the CB=
os are on the left side of the ring, and the 2nd half are on the right side=
 of the ring.  In other words (for example), in a 4c part, Cbo 0 UP AD is N=
OT the same ring as CBo 2 UP AD because they are on opposite sides of the r=
ing.; Filters for the Up and Even ring polarity.",
+        "UMask": "0x1",
+        "Unit": "SBO"
+    },
+    {
+        "BriefDescription": "BL Ring in Use; Up and Odd",
+        "EventCode": "0x1D",
+        "EventName": "UNC_S_RING_BL_USED.UP_ODD",
         "PerPkg": "1",
-        "UMask": "0xC",
+        "PublicDescription": "Counts the number of cycles that the BL ring=
 is being used at this ring stop.  This includes when packets are passing b=
y and when packets are being sent, but does not include when packets are be=
ing sunk into the ring stop. We really have two rings in BDX -- a clockwise=
 ring and a counter-clockwise ring.  On the left side of the ring, the UP d=
irection is on the clockwise ring and DN is on the counter-clockwise ring. =
 On the right side of the ring, this is reversed.  The first half of the CB=
os are on the left side of the ring, and the 2nd half are on the right side=
 of the ring.  In other words (for example), in a 4c part, Cbo 0 UP AD is N=
OT the same ring as CBo 2 UP AD because they are on opposite sides of the r=
ing.; Filters for the Up and Odd ring polarity.",
+        "UMask": "0x2",
         "Unit": "SBO"
     },
     {
-        "BriefDescription": "Number of LLC responses that bounced on the R=
ing",
-        "Counter": "0,1,2,3",
+        "BriefDescription": "Number of LLC responses that bounced on the R=
ing.",
         "EventCode": "0x5",
         "EventName": "UNC_S_RING_BOUNCES.AD_CACHE",
         "PerPkg": "1",
+        "PublicDescription": "UNC_S_RING_BOUNCES.AD_CACHE",
         "UMask": "0x1",
         "Unit": "SBO"
     },
     {
         "BriefDescription": "Number of LLC responses that bounced on the R=
ing.; Acknowledgements to core",
-        "Counter": "0,1,2,3",
         "EventCode": "0x5",
         "EventName": "UNC_S_RING_BOUNCES.AK_CORE",
         "PerPkg": "1",
+        "PublicDescription": "UNC_S_RING_BOUNCES.AK_CORE",
         "UMask": "0x2",
         "Unit": "SBO"
     },
     {
         "BriefDescription": "Number of LLC responses that bounced on the R=
ing.; Data Responses to core",
-        "Counter": "0,1,2,3",
         "EventCode": "0x5",
         "EventName": "UNC_S_RING_BOUNCES.BL_CORE",
         "PerPkg": "1",
+        "PublicDescription": "UNC_S_RING_BOUNCES.BL_CORE",
         "UMask": "0x4",
         "Unit": "SBO"
     },
     {
-        "BriefDescription": "Number of LLC responses that bounced on the R=
ing.; Snoops of processor's cache",
-        "Counter": "0,1,2,3",
+        "BriefDescription": "Number of LLC responses that bounced on the R=
ing.; Snoops of processor's cache.",
         "EventCode": "0x5",
         "EventName": "UNC_S_RING_BOUNCES.IV_CORE",
         "PerPkg": "1",
+        "PublicDescription": "UNC_S_RING_BOUNCES.IV_CORE",
         "UMask": "0x8",
         "Unit": "SBO"
     },
     {
         "BriefDescription": "BL Ring in Use; Any",
-        "Counter": "0,1,2,3",
         "EventCode": "0x1E",
-        "EventName": "UNC_S_RING_IV_USED.UP",
+        "EventName": "UNC_S_RING_IV_USED.DN",
         "PerPkg": "1",
-        "UMask": "0x3",
+        "PublicDescription": "Counts the number of cycles that the BL ring=
 is being used at this ring stop.  This includes when packets are passing b=
y and when packets are being sent, but does not include when packets are be=
ing sunk into the ring stop.  There is only 1 IV ring in HSX.  Therefore, i=
f one wants to monitor the Even ring, they should select both UP_EVEN and D=
N_EVEN.  To monitor the Odd ring, they should select both UP_ODD and DN_ODD=
.; Filters any polarity",
+        "UMask": "0xc",
         "Unit": "SBO"
     },
     {
         "BriefDescription": "BL Ring in Use; Any",
-        "Counter": "0,1,2,3",
         "EventCode": "0x1E",
-        "EventName": "UNC_S_RING_IV_USED.DN",
+        "EventName": "UNC_S_RING_IV_USED.UP",
         "PerPkg": "1",
-        "UMask": "0xC",
+        "PublicDescription": "Counts the number of cycles that the BL ring=
 is being used at this ring stop.  This includes when packets are passing b=
y and when packets are being sent, but does not include when packets are be=
ing sunk into the ring stop.  There is only 1 IV ring in HSX.  Therefore, i=
f one wants to monitor the Even ring, they should select both UP_EVEN and D=
N_EVEN.  To monitor the Odd ring, they should select both UP_ODD and DN_ODD=
.; Filters any polarity",
+        "UMask": "0x3",
         "Unit": "SBO"
     },
     {
-        "BriefDescription": "Bypass; AD - Credits",
-        "Counter": "0,1,2,3",
-        "EventCode": "0x12",
-        "EventName": "UNC_S_RxR_BYPASS.AD_CRD",
+        "BriefDescription": "UNC_S_RING_SINK_STARVED.AD_CACHE",
+        "EventCode": "0x6",
+        "EventName": "UNC_S_RING_SINK_STARVED.AD_CACHE",
         "PerPkg": "1",
         "UMask": "0x1",
         "Unit": "SBO"
     },
     {
-        "BriefDescription": "Bypass; AD - Bounces",
-        "Counter": "0,1,2,3",
-        "EventCode": "0x12",
-        "EventName": "UNC_S_RxR_BYPASS.AD_BNC",
+        "BriefDescription": "UNC_S_RING_SINK_STARVED.AK_CORE",
+        "EventCode": "0x6",
+        "EventName": "UNC_S_RING_SINK_STARVED.AK_CORE",
         "PerPkg": "1",
         "UMask": "0x2",
         "Unit": "SBO"
     },
     {
-        "BriefDescription": "Bypass; BL - Credits",
-        "Counter": "0,1,2,3",
-        "EventCode": "0x12",
-        "EventName": "UNC_S_RxR_BYPASS.BL_CRD",
+        "BriefDescription": "UNC_S_RING_SINK_STARVED.BL_CORE",
+        "EventCode": "0x6",
+        "EventName": "UNC_S_RING_SINK_STARVED.BL_CORE",
         "PerPkg": "1",
         "UMask": "0x4",
         "Unit": "SBO"
     },
     {
-        "BriefDescription": "Bypass; BL - Bounces",
-        "Counter": "0,1,2,3",
-        "EventCode": "0x12",
-        "EventName": "UNC_S_RxR_BYPASS.BL_BNC",
+        "BriefDescription": "UNC_S_RING_SINK_STARVED.IV_CORE",
+        "EventCode": "0x6",
+        "EventName": "UNC_S_RING_SINK_STARVED.IV_CORE",
         "PerPkg": "1",
         "UMask": "0x8",
         "Unit": "SBO"
     },
     {
-        "BriefDescription": "Bypass; AK",
-        "Counter": "0,1,2,3",
-        "EventCode": "0x12",
-        "EventName": "UNC_S_RxR_BYPASS.AK",
+        "BriefDescription": "Injection Starvation; AD - Bounces",
+        "EventCode": "0x15",
+        "EventName": "UNC_S_RxR_BUSY_STARVED.AD_BNC",
         "PerPkg": "1",
-        "UMask": "0x10",
+        "PublicDescription": "Counts injection starvation.  This starvatio=
n is triggered when the Ingress cannot send a transaction onto the ring for=
 a long period of time.  In this case, the Ingress but unable to forward to=
 Egress because a message (credited/bounceable) is  being sent.",
+        "UMask": "0x2",
         "Unit": "SBO"
     },
     {
-        "BriefDescription": "Bypass; IV",
-        "Counter": "0,1,2,3",
-        "EventCode": "0x12",
-        "EventName": "UNC_S_RxR_BYPASS.IV",
+        "BriefDescription": "Injection Starvation; AD - Credits",
+        "EventCode": "0x15",
+        "EventName": "UNC_S_RxR_BUSY_STARVED.AD_CRD",
         "PerPkg": "1",
-        "UMask": "0x20",
+        "PublicDescription": "Counts injection starvation.  This starvatio=
n is triggered when the Ingress cannot send a transaction onto the ring for=
 a long period of time.  In this case, the Ingress but unable to forward to=
 Egress because a message (credited/bounceable) is  being sent.",
+        "UMask": "0x1",
         "Unit": "SBO"
     },
     {
-        "BriefDescription": "Ingress Allocations; AD - Credits",
-        "Counter": "0,1,2,3",
-        "EventCode": "0x13",
-        "EventName": "UNC_S_RxR_INSERTS.AD_CRD",
+        "BriefDescription": "Injection Starvation; BL - Bounces",
+        "EventCode": "0x15",
+        "EventName": "UNC_S_RxR_BUSY_STARVED.BL_BNC",
         "PerPkg": "1",
-        "UMask": "0x1",
+        "PublicDescription": "Counts injection starvation.  This starvatio=
n is triggered when the Ingress cannot send a transaction onto the ring for=
 a long period of time.  In this case, the Ingress but unable to forward to=
 Egress because a message (credited/bounceable) is  being sent.",
+        "UMask": "0x8",
         "Unit": "SBO"
     },
     {
-        "BriefDescription": "Ingress Allocations; AD - Bounces",
-        "Counter": "0,1,2,3",
-        "EventCode": "0x13",
-        "EventName": "UNC_S_RxR_INSERTS.AD_BNC",
+        "BriefDescription": "Injection Starvation; BL - Credits",
+        "EventCode": "0x15",
+        "EventName": "UNC_S_RxR_BUSY_STARVED.BL_CRD",
         "PerPkg": "1",
-        "UMask": "0x2",
+        "PublicDescription": "Counts injection starvation.  This starvatio=
n is triggered when the Ingress cannot send a transaction onto the ring for=
 a long period of time.  In this case, the Ingress but unable to forward to=
 Egress because a message (credited/bounceable) is  being sent.",
+        "UMask": "0x4",
         "Unit": "SBO"
     },
     {
-        "BriefDescription": "Ingress Allocations; BL - Credits",
-        "Counter": "0,1,2,3",
-        "EventCode": "0x13",
-        "EventName": "UNC_S_RxR_INSERTS.BL_CRD",
+        "BriefDescription": "Bypass; AD - Bounces",
+        "EventCode": "0x12",
+        "EventName": "UNC_S_RxR_BYPASS.AD_BNC",
         "PerPkg": "1",
-        "UMask": "0x4",
+        "PublicDescription": "Bypass the Sbo Ingress.",
+        "UMask": "0x2",
         "Unit": "SBO"
     },
     {
-        "BriefDescription": "Ingress Allocations; BL - Bounces",
-        "Counter": "0,1,2,3",
-        "EventCode": "0x13",
-        "EventName": "UNC_S_RxR_INSERTS.BL_BNC",
+        "BriefDescription": "Bypass; AD - Credits",
+        "EventCode": "0x12",
+        "EventName": "UNC_S_RxR_BYPASS.AD_CRD",
         "PerPkg": "1",
-        "UMask": "0x8",
+        "PublicDescription": "Bypass the Sbo Ingress.",
+        "UMask": "0x1",
         "Unit": "SBO"
     },
     {
-        "BriefDescription": "Ingress Allocations; AK",
-        "Counter": "0,1,2,3",
-        "EventCode": "0x13",
-        "EventName": "UNC_S_RxR_INSERTS.AK",
+        "BriefDescription": "Bypass; AK",
+        "EventCode": "0x12",
+        "EventName": "UNC_S_RxR_BYPASS.AK",
         "PerPkg": "1",
+        "PublicDescription": "Bypass the Sbo Ingress.",
         "UMask": "0x10",
         "Unit": "SBO"
     },
     {
-        "BriefDescription": "Ingress Allocations; IV",
-        "Counter": "0,1,2,3",
-        "EventCode": "0x13",
-        "EventName": "UNC_S_RxR_INSERTS.IV",
+        "BriefDescription": "Bypass; BL - Bounces",
+        "EventCode": "0x12",
+        "EventName": "UNC_S_RxR_BYPASS.BL_BNC",
         "PerPkg": "1",
-        "UMask": "0x20",
+        "PublicDescription": "Bypass the Sbo Ingress.",
+        "UMask": "0x8",
         "Unit": "SBO"
     },
     {
-        "BriefDescription": "Ingress Occupancy; AD - Credits",
-        "Counter": "0,1,2,3",
-        "EventCode": "0x11",
-        "EventName": "UNC_S_RxR_OCCUPANCY.AD_CRD",
+        "BriefDescription": "Bypass; BL - Credits",
+        "EventCode": "0x12",
+        "EventName": "UNC_S_RxR_BYPASS.BL_CRD",
         "PerPkg": "1",
-        "UMask": "0x1",
+        "PublicDescription": "Bypass the Sbo Ingress.",
+        "UMask": "0x4",
         "Unit": "SBO"
     },
     {
-        "BriefDescription": "Ingress Occupancy; AD - Bounces",
-        "Counter": "0,1,2,3",
-        "EventCode": "0x11",
-        "EventName": "UNC_S_RxR_OCCUPANCY.AD_BNC",
+        "BriefDescription": "Bypass; IV",
+        "EventCode": "0x12",
+        "EventName": "UNC_S_RxR_BYPASS.IV",
         "PerPkg": "1",
-        "UMask": "0x2",
+        "PublicDescription": "Bypass the Sbo Ingress.",
+        "UMask": "0x20",
         "Unit": "SBO"
     },
     {
-        "BriefDescription": "Ingress Occupancy; BL - Credits",
-        "Counter": "0,1,2,3",
-        "EventCode": "0x11",
-        "EventName": "UNC_S_RxR_OCCUPANCY.BL_CRD",
+        "BriefDescription": "Injection Starvation; AD - Bounces",
+        "EventCode": "0x14",
+        "EventName": "UNC_S_RxR_CRD_STARVED.AD_BNC",
         "PerPkg": "1",
-        "UMask": "0x4",
+        "PublicDescription": "Counts injection starvation.  This starvatio=
n is triggered when the Ingress cannot send a transaction onto the ring for=
 a long period of time.  In this case, the Ingress but unable to forward to=
 Egress due to lack of credit.",
+        "UMask": "0x2",
         "Unit": "SBO"
     },
     {
-        "BriefDescription": "Ingress Occupancy; BL - Bounces",
-        "Counter": "0,1,2,3",
-        "EventCode": "0x11",
-        "EventName": "UNC_S_RxR_OCCUPANCY.BL_BNC",
+        "BriefDescription": "Injection Starvation; AD - Credits",
+        "EventCode": "0x14",
+        "EventName": "UNC_S_RxR_CRD_STARVED.AD_CRD",
         "PerPkg": "1",
-        "UMask": "0x8",
+        "PublicDescription": "Counts injection starvation.  This starvatio=
n is triggered when the Ingress cannot send a transaction onto the ring for=
 a long period of time.  In this case, the Ingress but unable to forward to=
 Egress due to lack of credit.",
+        "UMask": "0x1",
         "Unit": "SBO"
     },
     {
-        "BriefDescription": "Ingress Occupancy; AK",
-        "Counter": "0,1,2,3",
-        "EventCode": "0x11",
-        "EventName": "UNC_S_RxR_OCCUPANCY.AK",
+        "BriefDescription": "Injection Starvation; AK",
+        "EventCode": "0x14",
+        "EventName": "UNC_S_RxR_CRD_STARVED.AK",
         "PerPkg": "1",
+        "PublicDescription": "Counts injection starvation.  This starvatio=
n is triggered when the Ingress cannot send a transaction onto the ring for=
 a long period of time.  In this case, the Ingress but unable to forward to=
 Egress due to lack of credit.",
         "UMask": "0x10",
         "Unit": "SBO"
     },
     {
-        "BriefDescription": "Ingress Occupancy; IV",
-        "Counter": "0,1,2,3",
-        "EventCode": "0x11",
-        "EventName": "UNC_S_RxR_OCCUPANCY.IV",
+        "BriefDescription": "Injection Starvation; BL - Bounces",
+        "EventCode": "0x14",
+        "EventName": "UNC_S_RxR_CRD_STARVED.BL_BNC",
         "PerPkg": "1",
-        "UMask": "0x20",
+        "PublicDescription": "Counts injection starvation.  This starvatio=
n is triggered when the Ingress cannot send a transaction onto the ring for=
 a long period of time.  In this case, the Ingress but unable to forward to=
 Egress due to lack of credit.",
+        "UMask": "0x8",
         "Unit": "SBO"
     },
     {
-        "BriefDescription": "UNC_S_TxR_ADS_USED.AD",
-        "Counter": "0,1,2,3",
-        "EventCode": "0x4",
-        "EventName": "UNC_S_TxR_ADS_USED.AD",
+        "BriefDescription": "Injection Starvation; BL - Credits",
+        "EventCode": "0x14",
+        "EventName": "UNC_S_RxR_CRD_STARVED.BL_CRD",
         "PerPkg": "1",
-        "UMask": "0x1",
+        "PublicDescription": "Counts injection starvation.  This starvatio=
n is triggered when the Ingress cannot send a transaction onto the ring for=
 a long period of time.  In this case, the Ingress but unable to forward to=
 Egress due to lack of credit.",
+        "UMask": "0x4",
         "Unit": "SBO"
     },
     {
-        "BriefDescription": "UNC_S_TxR_ADS_USED.AK",
-        "Counter": "0,1,2,3",
-        "EventCode": "0x4",
-        "EventName": "UNC_S_TxR_ADS_USED.AK",
+        "BriefDescription": "Injection Starvation; IVF Credit",
+        "EventCode": "0x14",
+        "EventName": "UNC_S_RxR_CRD_STARVED.IFV",
         "PerPkg": "1",
-        "UMask": "0x2",
+        "PublicDescription": "Counts injection starvation.  This starvatio=
n is triggered when the Ingress cannot send a transaction onto the ring for=
 a long period of time.  In this case, the Ingress but unable to forward to=
 Egress due to lack of credit.",
+        "UMask": "0x40",
         "Unit": "SBO"
     },
     {
-        "BriefDescription": "UNC_S_TxR_ADS_USED.BL",
-        "Counter": "0,1,2,3",
-        "EventCode": "0x4",
-        "EventName": "UNC_S_TxR_ADS_USED.BL",
+        "BriefDescription": "Injection Starvation; IV",
+        "EventCode": "0x14",
+        "EventName": "UNC_S_RxR_CRD_STARVED.IV",
         "PerPkg": "1",
-        "UMask": "0x4",
+        "PublicDescription": "Counts injection starvation.  This starvatio=
n is triggered when the Ingress cannot send a transaction onto the ring for=
 a long period of time.  In this case, the Ingress but unable to forward to=
 Egress due to lack of credit.",
+        "UMask": "0x20",
         "Unit": "SBO"
     },
     {
-        "BriefDescription": "Egress Allocations; AD - Credits",
-        "Counter": "0,1,2,3",
-        "EventCode": "0x2",
-        "EventName": "UNC_S_TxR_INSERTS.AD_CRD",
+        "BriefDescription": "Ingress Allocations; AD - Bounces",
+        "EventCode": "0x13",
+        "EventName": "UNC_S_RxR_INSERTS.AD_BNC",
         "PerPkg": "1",
-        "UMask": "0x1",
+        "PublicDescription": "Number of allocations into the Sbo Ingress  =
The Ingress is used to queue up requests received from the ring.",
+        "UMask": "0x2",
         "Unit": "SBO"
     },
     {
-        "BriefDescription": "Egress Allocations; AD - Bounces",
-        "Counter": "0,1,2,3",
-        "EventCode": "0x2",
-        "EventName": "UNC_S_TxR_INSERTS.AD_BNC",
+        "BriefDescription": "Ingress Allocations; AD - Credits",
+        "EventCode": "0x13",
+        "EventName": "UNC_S_RxR_INSERTS.AD_CRD",
         "PerPkg": "1",
-        "UMask": "0x2",
+        "PublicDescription": "Number of allocations into the Sbo Ingress  =
The Ingress is used to queue up requests received from the ring.",
+        "UMask": "0x1",
         "Unit": "SBO"
     },
     {
-        "BriefDescription": "Egress Allocations; BL - Credits",
-        "Counter": "0,1,2,3",
-        "EventCode": "0x2",
-        "EventName": "UNC_S_TxR_INSERTS.BL_CRD",
+        "BriefDescription": "Ingress Allocations; AK",
+        "EventCode": "0x13",
+        "EventName": "UNC_S_RxR_INSERTS.AK",
         "PerPkg": "1",
-        "UMask": "0x4",
+        "PublicDescription": "Number of allocations into the Sbo Ingress  =
The Ingress is used to queue up requests received from the ring.",
+        "UMask": "0x10",
         "Unit": "SBO"
     },
     {
-        "BriefDescription": "Egress Allocations; BL - Bounces",
-        "Counter": "0,1,2,3",
-        "EventCode": "0x2",
-        "EventName": "UNC_S_TxR_INSERTS.BL_BNC",
+        "BriefDescription": "Ingress Allocations; BL - Bounces",
+        "EventCode": "0x13",
+        "EventName": "UNC_S_RxR_INSERTS.BL_BNC",
         "PerPkg": "1",
+        "PublicDescription": "Number of allocations into the Sbo Ingress  =
The Ingress is used to queue up requests received from the ring.",
         "UMask": "0x8",
         "Unit": "SBO"
     },
     {
-        "BriefDescription": "Egress Allocations; AK",
-        "Counter": "0,1,2,3",
-        "EventCode": "0x2",
-        "EventName": "UNC_S_TxR_INSERTS.AK",
+        "BriefDescription": "Ingress Allocations; BL - Credits",
+        "EventCode": "0x13",
+        "EventName": "UNC_S_RxR_INSERTS.BL_CRD",
         "PerPkg": "1",
-        "UMask": "0x10",
+        "PublicDescription": "Number of allocations into the Sbo Ingress  =
The Ingress is used to queue up requests received from the ring.",
+        "UMask": "0x4",
         "Unit": "SBO"
     },
     {
-        "BriefDescription": "Egress Allocations; IV",
-        "Counter": "0,1,2,3",
-        "EventCode": "0x2",
-        "EventName": "UNC_S_TxR_INSERTS.IV",
+        "BriefDescription": "Ingress Allocations; IV",
+        "EventCode": "0x13",
+        "EventName": "UNC_S_RxR_INSERTS.IV",
         "PerPkg": "1",
+        "PublicDescription": "Number of allocations into the Sbo Ingress  =
The Ingress is used to queue up requests received from the ring.",
         "UMask": "0x20",
         "Unit": "SBO"
     },
     {
-        "BriefDescription": "Egress Occupancy; AD - Credits",
-        "Counter": "0,1,2,3",
-        "EventCode": "0x1",
-        "EventName": "UNC_S_TxR_OCCUPANCY.AD_CRD",
+        "BriefDescription": "Ingress Occupancy; AD - Bounces",
+        "EventCode": "0x11",
+        "EventName": "UNC_S_RxR_OCCUPANCY.AD_BNC",
         "PerPkg": "1",
-        "UMask": "0x1",
+        "PublicDescription": "Occupancy event for the Ingress buffers in t=
he Sbo.  The Ingress is used to queue up requests received from the ring.",
+        "UMask": "0x2",
         "Unit": "SBO"
     },
     {
-        "BriefDescription": "Egress Occupancy; AD - Bounces",
-        "Counter": "0,1,2,3",
-        "EventCode": "0x1",
-        "EventName": "UNC_S_TxR_OCCUPANCY.AD_BNC",
+        "BriefDescription": "Ingress Occupancy; AD - Credits",
+        "EventCode": "0x11",
+        "EventName": "UNC_S_RxR_OCCUPANCY.AD_CRD",
         "PerPkg": "1",
-        "UMask": "0x2",
+        "PublicDescription": "Occupancy event for the Ingress buffers in t=
he Sbo.  The Ingress is used to queue up requests received from the ring.",
+        "UMask": "0x1",
         "Unit": "SBO"
     },
     {
-        "BriefDescription": "Egress Occupancy; BL - Credits",
-        "Counter": "0,1,2,3",
-        "EventCode": "0x1",
-        "EventName": "UNC_S_TxR_OCCUPANCY.BL_CRD",
+        "BriefDescription": "Ingress Occupancy; AK",
+        "EventCode": "0x11",
+        "EventName": "UNC_S_RxR_OCCUPANCY.AK",
         "PerPkg": "1",
-        "UMask": "0x4",
+        "PublicDescription": "Occupancy event for the Ingress buffers in t=
he Sbo.  The Ingress is used to queue up requests received from the ring.",
+        "UMask": "0x10",
         "Unit": "SBO"
     },
     {
-        "BriefDescription": "Egress Occupancy; BL - Bounces",
-        "Counter": "0,1,2,3",
-        "EventCode": "0x1",
-        "EventName": "UNC_S_TxR_OCCUPANCY.BL_BNC",
+        "BriefDescription": "Ingress Occupancy; BL - Bounces",
+        "EventCode": "0x11",
+        "EventName": "UNC_S_RxR_OCCUPANCY.BL_BNC",
         "PerPkg": "1",
+        "PublicDescription": "Occupancy event for the Ingress buffers in t=
he Sbo.  The Ingress is used to queue up requests received from the ring.",
         "UMask": "0x8",
         "Unit": "SBO"
     },
     {
-        "BriefDescription": "Egress Occupancy; AK",
-        "Counter": "0,1,2,3",
-        "EventCode": "0x1",
-        "EventName": "UNC_S_TxR_OCCUPANCY.AK",
+        "BriefDescription": "Ingress Occupancy; BL - Credits",
+        "EventCode": "0x11",
+        "EventName": "UNC_S_RxR_OCCUPANCY.BL_CRD",
         "PerPkg": "1",
-        "UMask": "0x10",
+        "PublicDescription": "Occupancy event for the Ingress buffers in t=
he Sbo.  The Ingress is used to queue up requests received from the ring.",
+        "UMask": "0x4",
         "Unit": "SBO"
     },
     {
-        "BriefDescription": "Egress Occupancy; IV",
-        "Counter": "0,1,2,3",
-        "EventCode": "0x1",
-        "EventName": "UNC_S_TxR_OCCUPANCY.IV",
+        "BriefDescription": "Ingress Occupancy; IV",
+        "EventCode": "0x11",
+        "EventName": "UNC_S_RxR_OCCUPANCY.IV",
         "PerPkg": "1",
+        "PublicDescription": "Occupancy event for the Ingress buffers in t=
he Sbo.  The Ingress is used to queue up requests received from the ring.",
         "UMask": "0x20",
         "Unit": "SBO"
     },
     {
-        "BriefDescription": "UNC_S_RING_SINK_STARVED.AD_CACHE",
-        "Counter": "0,1,2,3",
-        "EventCode": "0x6",
-        "EventName": "UNC_S_RING_SINK_STARVED.AD_CACHE",
+        "BriefDescription": "UNC_S_TxR_ADS_USED.AD",
+        "EventCode": "0x4",
+        "EventName": "UNC_S_TxR_ADS_USED.AD",
         "PerPkg": "1",
         "UMask": "0x1",
         "Unit": "SBO"
     },
     {
-        "BriefDescription": "UNC_S_RING_SINK_STARVED.AK_CORE",
-        "Counter": "0,1,2,3",
-        "EventCode": "0x6",
-        "EventName": "UNC_S_RING_SINK_STARVED.AK_CORE",
+        "BriefDescription": "UNC_S_TxR_ADS_USED.AK",
+        "EventCode": "0x4",
+        "EventName": "UNC_S_TxR_ADS_USED.AK",
         "PerPkg": "1",
         "UMask": "0x2",
         "Unit": "SBO"
     },
     {
-        "BriefDescription": "UNC_S_RING_SINK_STARVED.BL_CORE",
-        "Counter": "0,1,2,3",
-        "EventCode": "0x6",
-        "EventName": "UNC_S_RING_SINK_STARVED.BL_CORE",
+        "BriefDescription": "UNC_S_TxR_ADS_USED.BL",
+        "EventCode": "0x4",
+        "EventName": "UNC_S_TxR_ADS_USED.BL",
         "PerPkg": "1",
         "UMask": "0x4",
         "Unit": "SBO"
     },
     {
-        "BriefDescription": "UNC_S_RING_SINK_STARVED.IV_CORE",
-        "Counter": "0,1,2,3",
-        "EventCode": "0x6",
-        "EventName": "UNC_S_RING_SINK_STARVED.IV_CORE",
+        "BriefDescription": "Egress Allocations; AD - Bounces",
+        "EventCode": "0x2",
+        "EventName": "UNC_S_TxR_INSERTS.AD_BNC",
         "PerPkg": "1",
-        "UMask": "0x8",
+        "PublicDescription": "Number of allocations into the Sbo Egress.  =
The Egress is used to queue up requests destined for the ring.",
+        "UMask": "0x2",
         "Unit": "SBO"
     },
     {
-        "BriefDescription": "Injection Starvation; AD - Credits",
-        "Counter": "0,1,2,3",
-        "EventCode": "0x15",
-        "EventName": "UNC_S_RxR_BUSY_STARVED.AD_CRD",
+        "BriefDescription": "Egress Allocations; AD - Credits",
+        "EventCode": "0x2",
+        "EventName": "UNC_S_TxR_INSERTS.AD_CRD",
         "PerPkg": "1",
+        "PublicDescription": "Number of allocations into the Sbo Egress.  =
The Egress is used to queue up requests destined for the ring.",
         "UMask": "0x1",
         "Unit": "SBO"
     },
     {
-        "BriefDescription": "Injection Starvation; AD - Bounces",
-        "Counter": "0,1,2,3",
-        "EventCode": "0x15",
-        "EventName": "UNC_S_RxR_BUSY_STARVED.AD_BNC",
+        "BriefDescription": "Egress Allocations; AK",
+        "EventCode": "0x2",
+        "EventName": "UNC_S_TxR_INSERTS.AK",
         "PerPkg": "1",
-        "UMask": "0x2",
+        "PublicDescription": "Number of allocations into the Sbo Egress.  =
The Egress is used to queue up requests destined for the ring.",
+        "UMask": "0x10",
         "Unit": "SBO"
     },
     {
-        "BriefDescription": "Injection Starvation; BL - Credits",
-        "Counter": "0,1,2,3",
-        "EventCode": "0x15",
-        "EventName": "UNC_S_RxR_BUSY_STARVED.BL_CRD",
+        "BriefDescription": "Egress Allocations; BL - Bounces",
+        "EventCode": "0x2",
+        "EventName": "UNC_S_TxR_INSERTS.BL_BNC",
         "PerPkg": "1",
-        "UMask": "0x4",
+        "PublicDescription": "Number of allocations into the Sbo Egress.  =
The Egress is used to queue up requests destined for the ring.",
+        "UMask": "0x8",
         "Unit": "SBO"
     },
     {
-        "BriefDescription": "Injection Starvation; BL - Bounces",
-        "Counter": "0,1,2,3",
-        "EventCode": "0x15",
-        "EventName": "UNC_S_RxR_BUSY_STARVED.BL_BNC",
+        "BriefDescription": "Egress Allocations; BL - Credits",
+        "EventCode": "0x2",
+        "EventName": "UNC_S_TxR_INSERTS.BL_CRD",
         "PerPkg": "1",
-        "UMask": "0x8",
+        "PublicDescription": "Number of allocations into the Sbo Egress.  =
The Egress is used to queue up requests destined for the ring.",
+        "UMask": "0x4",
         "Unit": "SBO"
     },
     {
-        "BriefDescription": "Injection Starvation; AD - Credits",
-        "Counter": "0,1,2,3",
-        "EventCode": "0x14",
-        "EventName": "UNC_S_RxR_CRD_STARVED.AD_CRD",
+        "BriefDescription": "Egress Allocations; IV",
+        "EventCode": "0x2",
+        "EventName": "UNC_S_TxR_INSERTS.IV",
         "PerPkg": "1",
-        "UMask": "0x1",
+        "PublicDescription": "Number of allocations into the Sbo Egress.  =
The Egress is used to queue up requests destined for the ring.",
+        "UMask": "0x20",
         "Unit": "SBO"
     },
     {
-        "BriefDescription": "Injection Starvation; AD - Bounces",
-        "Counter": "0,1,2,3",
-        "EventCode": "0x14",
-        "EventName": "UNC_S_RxR_CRD_STARVED.AD_BNC",
+        "BriefDescription": "Egress Occupancy; AD - Bounces",
+        "EventCode": "0x1",
+        "EventName": "UNC_S_TxR_OCCUPANCY.AD_BNC",
         "PerPkg": "1",
+        "PublicDescription": "Occupancy event for the Egress buffers in th=
e Sbo.  The egress is used to queue up requests destined for the ring.",
         "UMask": "0x2",
         "Unit": "SBO"
     },
     {
-        "BriefDescription": "Injection Starvation; BL - Credits",
-        "Counter": "0,1,2,3",
-        "EventCode": "0x14",
-        "EventName": "UNC_S_RxR_CRD_STARVED.BL_CRD",
+        "BriefDescription": "Egress Occupancy; AD - Credits",
+        "EventCode": "0x1",
+        "EventName": "UNC_S_TxR_OCCUPANCY.AD_CRD",
         "PerPkg": "1",
-        "UMask": "0x4",
+        "PublicDescription": "Occupancy event for the Egress buffers in th=
e Sbo.  The egress is used to queue up requests destined for the ring.",
+        "UMask": "0x1",
         "Unit": "SBO"
     },
     {
-        "BriefDescription": "Injection Starvation; BL - Bounces",
-        "Counter": "0,1,2,3",
-        "EventCode": "0x14",
-        "EventName": "UNC_S_RxR_CRD_STARVED.BL_BNC",
+        "BriefDescription": "Egress Occupancy; AK",
+        "EventCode": "0x1",
+        "EventName": "UNC_S_TxR_OCCUPANCY.AK",
         "PerPkg": "1",
-        "UMask": "0x8",
+        "PublicDescription": "Occupancy event for the Egress buffers in th=
e Sbo.  The egress is used to queue up requests destined for the ring.",
+        "UMask": "0x10",
         "Unit": "SBO"
     },
     {
-        "BriefDescription": "Injection Starvation; AK",
-        "Counter": "0,1,2,3",
-        "EventCode": "0x14",
-        "EventName": "UNC_S_RxR_CRD_STARVED.AK",
+        "BriefDescription": "Egress Occupancy; BL - Bounces",
+        "EventCode": "0x1",
+        "EventName": "UNC_S_TxR_OCCUPANCY.BL_BNC",
         "PerPkg": "1",
-        "UMask": "0x10",
+        "PublicDescription": "Occupancy event for the Egress buffers in th=
e Sbo.  The egress is used to queue up requests destined for the ring.",
+        "UMask": "0x8",
         "Unit": "SBO"
     },
     {
-        "BriefDescription": "Injection Starvation; IV",
-        "Counter": "0,1,2,3",
-        "EventCode": "0x14",
-        "EventName": "UNC_S_RxR_CRD_STARVED.IV",
+        "BriefDescription": "Egress Occupancy; BL - Credits",
+        "EventCode": "0x1",
+        "EventName": "UNC_S_TxR_OCCUPANCY.BL_CRD",
         "PerPkg": "1",
-        "UMask": "0x20",
+        "PublicDescription": "Occupancy event for the Egress buffers in th=
e Sbo.  The egress is used to queue up requests destined for the ring.",
+        "UMask": "0x4",
         "Unit": "SBO"
     },
     {
-        "BriefDescription": "Injection Starvation; IVF Credit",
-        "Counter": "0,1,2,3",
-        "EventCode": "0x14",
-        "EventName": "UNC_S_RxR_CRD_STARVED.IFV",
+        "BriefDescription": "Egress Occupancy; IV",
+        "EventCode": "0x1",
+        "EventName": "UNC_S_TxR_OCCUPANCY.IV",
         "PerPkg": "1",
-        "UMask": "0x40",
+        "PublicDescription": "Occupancy event for the Egress buffers in th=
e Sbo.  The egress is used to queue up requests destined for the ring.",
+        "UMask": "0x20",
         "Unit": "SBO"
     },
     {
         "BriefDescription": "Injection Starvation; Onto AD Ring",
-        "Counter": "0,1,2,3",
         "EventCode": "0x3",
         "EventName": "UNC_S_TxR_STARVED.AD",
         "PerPkg": "1",
+        "PublicDescription": "Counts injection starvation.  This starvatio=
n is triggered when the Egress cannot send a transaction onto the ring for =
a long period of time.",
         "UMask": "0x1",
         "Unit": "SBO"
     },
     {
         "BriefDescription": "Injection Starvation; Onto AK Ring",
-        "Counter": "0,1,2,3",
         "EventCode": "0x3",
         "EventName": "UNC_S_TxR_STARVED.AK",
         "PerPkg": "1",
+        "PublicDescription": "Counts injection starvation.  This starvatio=
n is triggered when the Egress cannot send a transaction onto the ring for =
a long period of time.",
         "UMask": "0x2",
         "Unit": "SBO"
     },
     {
         "BriefDescription": "Injection Starvation; Onto BL Ring",
-        "Counter": "0,1,2,3",
         "EventCode": "0x3",
         "EventName": "UNC_S_TxR_STARVED.BL",
         "PerPkg": "1",
+        "PublicDescription": "Counts injection starvation.  This starvatio=
n is triggered when the Egress cannot send a transaction onto the ring for =
a long period of time.",
         "UMask": "0x4",
         "Unit": "SBO"
     },
     {
         "BriefDescription": "Injection Starvation; Onto IV Ring",
-        "Counter": "0,1,2,3",
         "EventCode": "0x3",
         "EventName": "UNC_S_TxR_STARVED.IV",
         "PerPkg": "1",
+        "PublicDescription": "Counts injection starvation.  This starvatio=
n is triggered when the Egress cannot send a transaction onto the ring for =
a long period of time.",
         "UMask": "0x8",
         "Unit": "SBO"
     },
     {
-        "BriefDescription": "AD Ring In Use; All",
-        "Counter": "0,1,2,3",
-        "EventCode": "0x1B",
-        "EventName": "UNC_S_RING_AD_USED.ALL",
-        "PerPkg": "1",
-        "UMask": "0xF",
-        "Unit": "SBO"
-    },
-    {
-        "BriefDescription": "AK Ring In Use; All",
-        "Counter": "0,1,2,3",
-        "EventCode": "0x1C",
-        "EventName": "UNC_S_RING_AK_USED.ALL",
-        "PerPkg": "1",
-        "UMask": "0xF",
-        "Unit": "SBO"
-    },
-    {
-        "BriefDescription": "BL Ring in Use; All",
-        "Counter": "0,1,2,3",
-        "EventCode": "0x1D",
-        "EventName": "UNC_S_RING_BL_USED.ALL",
+        "BriefDescription": "Clockticks in the UBOX using a dedicated 48-b=
it Fixed Counter",
+        "EventCode": "0xff",
+        "EventName": "UNC_U_CLOCKTICKS",
         "PerPkg": "1",
-        "UMask": "0xF",
-        "Unit": "SBO"
+        "Unit": "UBOX"
     },
     {
         "BriefDescription": "VLW Received",
-        "Counter": "0,1",
         "EventCode": "0x42",
         "EventName": "UNC_U_EVENT_MSG.DOORBELL_RCVD",
         "PerPkg": "1",
+        "PublicDescription": "Virtual Logical Wire (legacy) message were r=
eceived from Uncore.   Specify the thread to filter on using NCUPMONCTRLGLC=
TR.ThreadID.",
         "UMask": "0x8",
         "Unit": "UBOX"
     },
     {
-        "BriefDescription": "Cycles PHOLD Assert to Ack; Assert to ACK",
-        "Counter": "0,1",
-        "EventCode": "0x45",
-        "EventName": "UNC_U_PHOLD_CYCLES.ASSERT_TO_ACK",
-        "PerPkg": "1",
-        "UMask": "0x1",
-        "Unit": "UBOX"
-    },
-    {
-        "BriefDescription": "RACU Request",
-        "Counter": "0,1",
-        "EventCode": "0x46",
-        "EventName": "UNC_U_RACU_REQUESTS",
+        "BriefDescription": "Filter Match",
+        "EventCode": "0x41",
+        "EventName": "UNC_U_FILTER_MATCH.DISABLE",
         "PerPkg": "1",
+        "PublicDescription": "Filter match per thread (w/ or w/o Filter En=
able).  Specify the thread to filter on using NCUPMONCTRLGLCTR.ThreadID.",
+        "UMask": "0x2",
         "Unit": "UBOX"
     },
     {
         "BriefDescription": "Filter Match",
-        "Counter": "0,1",
         "EventCode": "0x41",
         "EventName": "UNC_U_FILTER_MATCH.ENABLE",
         "PerPkg": "1",
+        "PublicDescription": "Filter match per thread (w/ or w/o Filter En=
able).  Specify the thread to filter on using NCUPMONCTRLGLCTR.ThreadID.",
         "UMask": "0x1",
         "Unit": "UBOX"
     },
     {
         "BriefDescription": "Filter Match",
-        "Counter": "0,1",
         "EventCode": "0x41",
-        "EventName": "UNC_U_FILTER_MATCH.DISABLE",
+        "EventName": "UNC_U_FILTER_MATCH.U2C_DISABLE",
         "PerPkg": "1",
-        "UMask": "0x2",
+        "PublicDescription": "Filter match per thread (w/ or w/o Filter En=
able).  Specify the thread to filter on using NCUPMONCTRLGLCTR.ThreadID.",
+        "UMask": "0x8",
         "Unit": "UBOX"
     },
     {
         "BriefDescription": "Filter Match",
-        "Counter": "0,1",
         "EventCode": "0x41",
         "EventName": "UNC_U_FILTER_MATCH.U2C_ENABLE",
         "PerPkg": "1",
+        "PublicDescription": "Filter match per thread (w/ or w/o Filter En=
able).  Specify the thread to filter on using NCUPMONCTRLGLCTR.ThreadID.",
         "UMask": "0x4",
         "Unit": "UBOX"
     },
     {
-        "BriefDescription": "Filter Match",
-        "Counter": "0,1",
-        "EventCode": "0x41",
-        "EventName": "UNC_U_FILTER_MATCH.U2C_DISABLE",
+        "BriefDescription": "Cycles PHOLD Assert to Ack; Assert to ACK",
+        "EventCode": "0x45",
+        "EventName": "UNC_U_PHOLD_CYCLES.ASSERT_TO_ACK",
         "PerPkg": "1",
-        "UMask": "0x8",
+        "PublicDescription": "PHOLD cycles.  Filter from source CoreID.",
+        "UMask": "0x1",
         "Unit": "UBOX"
     },
     {
-        "BriefDescription": "Monitor Sent to T0; Monitor T0",
-        "Counter": "0,1",
-        "EventCode": "0x43",
-        "EventName": "UNC_U_U2C_EVENTS.MONITOR_T0",
+        "BriefDescription": "RACU Request",
+        "EventCode": "0x46",
+        "EventName": "UNC_U_RACU_REQUESTS",
         "PerPkg": "1",
-        "UMask": "0x1",
+        "PublicDescription": "Number outstanding register requests within =
message channel tracker",
         "Unit": "UBOX"
     },
     {
-        "BriefDescription": "Monitor Sent to T0; Monitor T1",
-        "Counter": "0,1",
+        "BriefDescription": "Monitor Sent to T0; Correctable Machine Check=
",
         "EventCode": "0x43",
-        "EventName": "UNC_U_U2C_EVENTS.MONITOR_T1",
+        "EventName": "UNC_U_U2C_EVENTS.CMC",
         "PerPkg": "1",
-        "UMask": "0x2",
+        "PublicDescription": "Events coming from Uncore can be sent to one=
 or all cores",
+        "UMask": "0x10",
         "Unit": "UBOX"
     },
     {
         "BriefDescription": "Monitor Sent to T0; Livelock",
-        "Counter": "0,1",
         "EventCode": "0x43",
         "EventName": "UNC_U_U2C_EVENTS.LIVELOCK",
         "PerPkg": "1",
+        "PublicDescription": "Events coming from Uncore can be sent to one=
 or all cores; Filter by core",
         "UMask": "0x4",
         "Unit": "UBOX"
     },
     {
         "BriefDescription": "Monitor Sent to T0; LTError",
-        "Counter": "0,1",
         "EventCode": "0x43",
         "EventName": "UNC_U_U2C_EVENTS.LTERROR",
         "PerPkg": "1",
+        "PublicDescription": "Events coming from Uncore can be sent to one=
 or all cores; Filter by core",
         "UMask": "0x8",
         "Unit": "UBOX"
     },
     {
-        "BriefDescription": "Monitor Sent to T0; Correctable Machine Check=
",
-        "Counter": "0,1",
+        "BriefDescription": "Monitor Sent to T0; Monitor T0",
         "EventCode": "0x43",
-        "EventName": "UNC_U_U2C_EVENTS.CMC",
+        "EventName": "UNC_U_U2C_EVENTS.MONITOR_T0",
         "PerPkg": "1",
-        "UMask": "0x10",
+        "PublicDescription": "Events coming from Uncore can be sent to one=
 or all cores; Filter by core",
+        "UMask": "0x1",
         "Unit": "UBOX"
     },
     {
-        "BriefDescription": "Monitor Sent to T0; Uncorrectable Machine Che=
ck",
-        "Counter": "0,1",
+        "BriefDescription": "Monitor Sent to T0; Monitor T1",
         "EventCode": "0x43",
-        "EventName": "UNC_U_U2C_EVENTS.UMC",
+        "EventName": "UNC_U_U2C_EVENTS.MONITOR_T1",
         "PerPkg": "1",
-        "UMask": "0x20",
+        "PublicDescription": "Events coming from Uncore can be sent to one=
 or all cores; Filter by core",
+        "UMask": "0x2",
         "Unit": "UBOX"
     },
     {
-        "BriefDescription": "Monitor Sent to T0; Trap",
-        "Counter": "0,1",
+        "BriefDescription": "Monitor Sent to T0; Other",
         "EventCode": "0x43",
-        "EventName": "UNC_U_U2C_EVENTS.TRAP",
+        "EventName": "UNC_U_U2C_EVENTS.OTHER",
         "PerPkg": "1",
-        "UMask": "0x40",
+        "PublicDescription": "Events coming from Uncore can be sent to one=
 or all cores; PREQ, PSMI, P2U, Thermal, PCUSMI, PMI",
+        "UMask": "0x80",
         "Unit": "UBOX"
     },
     {
-        "BriefDescription": "Monitor Sent to T0; Other",
-        "Counter": "0,1",
+        "BriefDescription": "Monitor Sent to T0; Trap",
         "EventCode": "0x43",
-        "EventName": "UNC_U_U2C_EVENTS.OTHER",
+        "EventName": "UNC_U_U2C_EVENTS.TRAP",
         "PerPkg": "1",
-        "UMask": "0x80",
+        "PublicDescription": "Events coming from Uncore can be sent to one=
 or all cores",
+        "UMask": "0x40",
         "Unit": "UBOX"
     },
     {
-        "BriefDescription": "Clockticks in the UBOX using a dedicated 48-b=
it Fixed Counter",
-        "Counter": "FIXED",
-        "EventCode": "0xff",
-        "EventName": "UNC_U_CLOCKTICKS",
+        "BriefDescription": "Monitor Sent to T0; Uncorrectable Machine Che=
ck",
+        "EventCode": "0x43",
+        "EventName": "UNC_U_U2C_EVENTS.UMC",
         "PerPkg": "1",
+        "PublicDescription": "Events coming from Uncore can be sent to one=
 or all cores",
+        "UMask": "0x20",
         "Unit": "UBOX"
     }
 ]
diff --git a/tools/perf/pmu-events/arch/x86/broadwellx/uncore-power.json b/=
tools/perf/pmu-events/arch/x86/broadwellx/uncore-power.json
index 3ffb70ff573d..e682eedf644a 100644
--- a/tools/perf/pmu-events/arch/x86/broadwellx/uncore-power.json
+++ b/tools/perf/pmu-events/arch/x86/broadwellx/uncore-power.json
@@ -1,457 +1,457 @@
 [
     {
         "BriefDescription": "pclk Cycles",
-        "Counter": "0,1,2,3",
         "EventName": "UNC_P_CLOCKTICKS",
         "PerPkg": "1",
+        "PublicDescription": "The PCU runs off a fixed 1 GHz clock.  This =
event counts the number of pclk cycles measured while the counter was enabl=
ed.  The pclk, like the Memory Controller's dclk, counts at a constant rate=
 making it a good measure of actual wall time.",
         "Unit": "PCU"
     },
     {
         "BriefDescription": "Core C State Transition Cycles",
-        "Counter": "0,1,2,3",
         "EventCode": "0x60",
         "EventName": "UNC_P_CORE0_TRANSITION_CYCLES",
         "PerPkg": "1",
+        "PublicDescription": "Number of cycles spent performing core C sta=
te transitions.  There is one event per core.",
         "Unit": "PCU"
     },
     {
         "BriefDescription": "Core C State Transition Cycles",
-        "Counter": "0,1,2,3",
         "EventCode": "0x6A",
         "EventName": "UNC_P_CORE10_TRANSITION_CYCLES",
         "PerPkg": "1",
+        "PublicDescription": "Number of cycles spent performing core C sta=
te transitions.  There is one event per core.",
         "Unit": "PCU"
     },
     {
         "BriefDescription": "Core C State Transition Cycles",
-        "Counter": "0,1,2,3",
         "EventCode": "0x6B",
         "EventName": "UNC_P_CORE11_TRANSITION_CYCLES",
         "PerPkg": "1",
+        "PublicDescription": "Number of cycles spent performing core C sta=
te transitions.  There is one event per core.",
         "Unit": "PCU"
     },
     {
         "BriefDescription": "Core C State Transition Cycles",
-        "Counter": "0,1,2,3",
         "EventCode": "0x6C",
         "EventName": "UNC_P_CORE12_TRANSITION_CYCLES",
         "PerPkg": "1",
+        "PublicDescription": "Number of cycles spent performing core C sta=
te transitions.  There is one event per core.",
         "Unit": "PCU"
     },
     {
         "BriefDescription": "Core C State Transition Cycles",
-        "Counter": "0,1,2,3",
         "EventCode": "0x6D",
         "EventName": "UNC_P_CORE13_TRANSITION_CYCLES",
         "PerPkg": "1",
+        "PublicDescription": "Number of cycles spent performing core C sta=
te transitions.  There is one event per core.",
         "Unit": "PCU"
     },
     {
         "BriefDescription": "Core C State Transition Cycles",
-        "Counter": "0,1,2,3",
         "EventCode": "0x6E",
         "EventName": "UNC_P_CORE14_TRANSITION_CYCLES",
         "PerPkg": "1",
+        "PublicDescription": "Number of cycles spent performing core C sta=
te transitions.  There is one event per core.",
         "Unit": "PCU"
     },
     {
         "BriefDescription": "Core C State Transition Cycles",
-        "Counter": "0,1,2,3",
         "EventCode": "0x6F",
         "EventName": "UNC_P_CORE15_TRANSITION_CYCLES",
         "PerPkg": "1",
+        "PublicDescription": "Number of cycles spent performing core C sta=
te transitions.  There is one event per core.",
         "Unit": "PCU"
     },
     {
         "BriefDescription": "Core C State Transition Cycles",
-        "Counter": "0,1,2,3",
         "EventCode": "0x70",
         "EventName": "UNC_P_CORE16_TRANSITION_CYCLES",
         "PerPkg": "1",
+        "PublicDescription": "Number of cycles spent performing core C sta=
te transitions.  There is one event per core.",
         "Unit": "PCU"
     },
     {
         "BriefDescription": "Core C State Transition Cycles",
-        "Counter": "0,1,2,3",
         "EventCode": "0x71",
         "EventName": "UNC_P_CORE17_TRANSITION_CYCLES",
         "PerPkg": "1",
+        "PublicDescription": "Number of cycles spent performing core C sta=
te transitions.  There is one event per core.",
         "Unit": "PCU"
     },
     {
         "BriefDescription": "Core C State Transition Cycles",
-        "Counter": "0,1,2,3",
         "EventCode": "0x61",
         "EventName": "UNC_P_CORE1_TRANSITION_CYCLES",
         "PerPkg": "1",
+        "PublicDescription": "Number of cycles spent performing core C sta=
te transitions.  There is one event per core.",
         "Unit": "PCU"
     },
     {
         "BriefDescription": "Core C State Transition Cycles",
-        "Counter": "0,1,2,3",
         "EventCode": "0x62",
         "EventName": "UNC_P_CORE2_TRANSITION_CYCLES",
         "PerPkg": "1",
+        "PublicDescription": "Number of cycles spent performing core C sta=
te transitions.  There is one event per core.",
         "Unit": "PCU"
     },
     {
         "BriefDescription": "Core C State Transition Cycles",
-        "Counter": "0,1,2,3",
         "EventCode": "0x63",
         "EventName": "UNC_P_CORE3_TRANSITION_CYCLES",
         "PerPkg": "1",
+        "PublicDescription": "Number of cycles spent performing core C sta=
te transitions.  There is one event per core.",
         "Unit": "PCU"
     },
     {
         "BriefDescription": "Core C State Transition Cycles",
-        "Counter": "0,1,2,3",
         "EventCode": "0x64",
         "EventName": "UNC_P_CORE4_TRANSITION_CYCLES",
         "PerPkg": "1",
+        "PublicDescription": "Number of cycles spent performing core C sta=
te transitions.  There is one event per core.",
         "Unit": "PCU"
     },
     {
         "BriefDescription": "Core C State Transition Cycles",
-        "Counter": "0,1,2,3",
         "EventCode": "0x65",
         "EventName": "UNC_P_CORE5_TRANSITION_CYCLES",
         "PerPkg": "1",
+        "PublicDescription": "Number of cycles spent performing core C sta=
te transitions.  There is one event per core.",
         "Unit": "PCU"
     },
     {
         "BriefDescription": "Core C State Transition Cycles",
-        "Counter": "0,1,2,3",
         "EventCode": "0x66",
         "EventName": "UNC_P_CORE6_TRANSITION_CYCLES",
         "PerPkg": "1",
+        "PublicDescription": "Number of cycles spent performing core C sta=
te transitions.  There is one event per core.",
         "Unit": "PCU"
     },
     {
         "BriefDescription": "Core C State Transition Cycles",
-        "Counter": "0,1,2,3",
         "EventCode": "0x67",
         "EventName": "UNC_P_CORE7_TRANSITION_CYCLES",
         "PerPkg": "1",
+        "PublicDescription": "Number of cycles spent performing core C sta=
te transitions.  There is one event per core.",
         "Unit": "PCU"
     },
     {
         "BriefDescription": "Core C State Transition Cycles",
-        "Counter": "0,1,2,3",
         "EventCode": "0x68",
         "EventName": "UNC_P_CORE8_TRANSITION_CYCLES",
         "PerPkg": "1",
+        "PublicDescription": "Number of cycles spent performing core C sta=
te transitions.  There is one event per core.",
         "Unit": "PCU"
     },
     {
         "BriefDescription": "Core C State Transition Cycles",
-        "Counter": "0,1,2,3",
         "EventCode": "0x69",
         "EventName": "UNC_P_CORE9_TRANSITION_CYCLES",
         "PerPkg": "1",
+        "PublicDescription": "Number of cycles spent performing core C sta=
te transitions.  There is one event per core.",
         "Unit": "PCU"
     },
     {
         "BriefDescription": "Core C State Demotions",
-        "Counter": "0,1,2,3",
         "EventCode": "0x30",
         "EventName": "UNC_P_DEMOTIONS_CORE0",
         "PerPkg": "1",
+        "PublicDescription": "Counts the number of times when a configurab=
le cores had a C-state demotion",
         "Unit": "PCU"
     },
     {
         "BriefDescription": "Core C State Demotions",
-        "Counter": "0,1,2,3",
         "EventCode": "0x31",
         "EventName": "UNC_P_DEMOTIONS_CORE1",
         "PerPkg": "1",
+        "PublicDescription": "Counts the number of times when a configurab=
le cores had a C-state demotion",
         "Unit": "PCU"
     },
     {
         "BriefDescription": "Core C State Demotions",
-        "Counter": "0,1,2,3",
         "EventCode": "0x3A",
         "EventName": "UNC_P_DEMOTIONS_CORE10",
         "PerPkg": "1",
+        "PublicDescription": "Counts the number of times when a configurab=
le cores had a C-state demotion",
         "Unit": "PCU"
     },
     {
         "BriefDescription": "Core C State Demotions",
-        "Counter": "0,1,2,3",
         "EventCode": "0x3B",
         "EventName": "UNC_P_DEMOTIONS_CORE11",
         "PerPkg": "1",
+        "PublicDescription": "Counts the number of times when a configurab=
le cores had a C-state demotion",
         "Unit": "PCU"
     },
     {
         "BriefDescription": "Core C State Demotions",
-        "Counter": "0,1,2,3",
         "EventCode": "0x3C",
         "EventName": "UNC_P_DEMOTIONS_CORE12",
         "PerPkg": "1",
+        "PublicDescription": "Counts the number of times when a configurab=
le cores had a C-state demotion",
         "Unit": "PCU"
     },
     {
         "BriefDescription": "Core C State Demotions",
-        "Counter": "0,1,2,3",
         "EventCode": "0x3D",
         "EventName": "UNC_P_DEMOTIONS_CORE13",
         "PerPkg": "1",
+        "PublicDescription": "Counts the number of times when a configurab=
le cores had a C-state demotion",
         "Unit": "PCU"
     },
     {
         "BriefDescription": "Core C State Demotions",
-        "Counter": "0,1,2,3",
         "EventCode": "0x3E",
         "EventName": "UNC_P_DEMOTIONS_CORE14",
         "PerPkg": "1",
+        "PublicDescription": "Counts the number of times when a configurab=
le cores had a C-state demotion",
         "Unit": "PCU"
     },
     {
         "BriefDescription": "Core C State Demotions",
-        "Counter": "0,1,2,3",
         "EventCode": "0x3F",
         "EventName": "UNC_P_DEMOTIONS_CORE15",
         "PerPkg": "1",
+        "PublicDescription": "Counts the number of times when a configurab=
le cores had a C-state demotion",
         "Unit": "PCU"
     },
     {
         "BriefDescription": "Core C State Demotions",
-        "Counter": "0,1,2,3",
         "EventCode": "0x40",
         "EventName": "UNC_P_DEMOTIONS_CORE16",
         "PerPkg": "1",
+        "PublicDescription": "Counts the number of times when a configurab=
le cores had a C-state demotion",
         "Unit": "PCU"
     },
     {
         "BriefDescription": "Core C State Demotions",
-        "Counter": "0,1,2,3",
         "EventCode": "0x41",
         "EventName": "UNC_P_DEMOTIONS_CORE17",
         "PerPkg": "1",
+        "PublicDescription": "Counts the number of times when a configurab=
le cores had a C-state demotion",
         "Unit": "PCU"
     },
     {
         "BriefDescription": "Core C State Demotions",
-        "Counter": "0,1,2,3",
         "EventCode": "0x32",
         "EventName": "UNC_P_DEMOTIONS_CORE2",
         "PerPkg": "1",
+        "PublicDescription": "Counts the number of times when a configurab=
le cores had a C-state demotion",
         "Unit": "PCU"
     },
     {
         "BriefDescription": "Core C State Demotions",
-        "Counter": "0,1,2,3",
         "EventCode": "0x33",
         "EventName": "UNC_P_DEMOTIONS_CORE3",
         "PerPkg": "1",
+        "PublicDescription": "Counts the number of times when a configurab=
le cores had a C-state demotion",
         "Unit": "PCU"
     },
     {
         "BriefDescription": "Core C State Demotions",
-        "Counter": "0,1,2,3",
         "EventCode": "0x34",
         "EventName": "UNC_P_DEMOTIONS_CORE4",
         "PerPkg": "1",
+        "PublicDescription": "Counts the number of times when a configurab=
le cores had a C-state demotion",
         "Unit": "PCU"
     },
     {
         "BriefDescription": "Core C State Demotions",
-        "Counter": "0,1,2,3",
         "EventCode": "0x35",
         "EventName": "UNC_P_DEMOTIONS_CORE5",
         "PerPkg": "1",
+        "PublicDescription": "Counts the number of times when a configurab=
le cores had a C-state demotion",
         "Unit": "PCU"
     },
     {
         "BriefDescription": "Core C State Demotions",
-        "Counter": "0,1,2,3",
         "EventCode": "0x36",
         "EventName": "UNC_P_DEMOTIONS_CORE6",
         "PerPkg": "1",
+        "PublicDescription": "Counts the number of times when a configurab=
le cores had a C-state demotion",
         "Unit": "PCU"
     },
     {
         "BriefDescription": "Core C State Demotions",
-        "Counter": "0,1,2,3",
         "EventCode": "0x37",
         "EventName": "UNC_P_DEMOTIONS_CORE7",
         "PerPkg": "1",
+        "PublicDescription": "Counts the number of times when a configurab=
le cores had a C-state demotion",
         "Unit": "PCU"
     },
     {
         "BriefDescription": "Core C State Demotions",
-        "Counter": "0,1,2,3",
         "EventCode": "0x38",
         "EventName": "UNC_P_DEMOTIONS_CORE8",
         "PerPkg": "1",
+        "PublicDescription": "Counts the number of times when a configurab=
le cores had a C-state demotion",
         "Unit": "PCU"
     },
     {
         "BriefDescription": "Core C State Demotions",
-        "Counter": "0,1,2,3",
         "EventCode": "0x39",
         "EventName": "UNC_P_DEMOTIONS_CORE9",
         "PerPkg": "1",
+        "PublicDescription": "Counts the number of times when a configurab=
le cores had a C-state demotion",
         "Unit": "PCU"
     },
     {
         "BriefDescription": "Thermal Strongest Upper Limit Cycles",
-        "Counter": "0,1,2,3",
         "EventCode": "0x4",
         "EventName": "UNC_P_FREQ_MAX_LIMIT_THERMAL_CYCLES",
         "PerPkg": "1",
+        "PublicDescription": "Counts the number of cycles when thermal con=
ditions are the upper limit on frequency.  This is related to the THERMAL_T=
HROTTLE CYCLES_ABOVE_TEMP event, which always counts cycles when we are abo=
ve the thermal temperature.  This event (STRONGEST_UPPER_LIMIT) is sampled =
at the output of the algorithm that determines the actual frequency, while =
THERMAL_THROTTLE looks at the input.",
         "Unit": "PCU"
     },
     {
         "BriefDescription": "OS Strongest Upper Limit Cycles",
-        "Counter": "0,1,2,3",
         "EventCode": "0x6",
         "EventName": "UNC_P_FREQ_MAX_OS_CYCLES",
         "PerPkg": "1",
+        "PublicDescription": "Counts the number of cycles when the OS is t=
he upper limit on frequency.",
         "Unit": "PCU"
     },
     {
         "BriefDescription": "Power Strongest Upper Limit Cycles",
-        "Counter": "0,1,2,3",
         "EventCode": "0x5",
         "EventName": "UNC_P_FREQ_MAX_POWER_CYCLES",
         "PerPkg": "1",
+        "PublicDescription": "Counts the number of cycles when power is th=
e upper limit on frequency.",
         "Unit": "PCU"
     },
     {
         "BriefDescription": "IO P Limit Strongest Lower Limit Cycles",
-        "Counter": "0,1,2,3",
         "EventCode": "0x73",
         "EventName": "UNC_P_FREQ_MIN_IO_P_CYCLES",
         "PerPkg": "1",
+        "PublicDescription": "Counts the number of cycles when IO P Limit =
is preventing us from dropping the frequency lower.  This algorithm monitor=
s the needs to the IO subsystem on both local and remote sockets and will m=
aintain a frequency high enough to maintain good IO BW.  This is necessary =
for when all the IA cores on a socket are idle but a user still would like =
to maintain high IO Bandwidth.",
         "Unit": "PCU"
     },
     {
         "BriefDescription": "Cycles spent changing Frequency",
-        "Counter": "0,1,2,3",
         "EventCode": "0x74",
         "EventName": "UNC_P_FREQ_TRANS_CYCLES",
         "PerPkg": "1",
+        "PublicDescription": "Counts the number of cycles when the system =
is changing frequency.  This can not be filtered by thread ID.  One can als=
o use it with the occupancy counter that monitors number of threads in C0 t=
o estimate the performance impact that frequency transitions had on the sys=
tem.",
         "Unit": "PCU"
     },
     {
         "BriefDescription": "Memory Phase Shedding Cycles",
-        "Counter": "0,1,2,3",
         "EventCode": "0x2F",
         "EventName": "UNC_P_MEMORY_PHASE_SHEDDING_CYCLES",
         "PerPkg": "1",
+        "PublicDescription": "Counts the number of cycles that the PCU has=
 triggered memory phase shedding.  This is a mode that can be run in the iM=
C physicals that saves power at the expense of additional latency.",
         "Unit": "PCU"
     },
     {
-        "BriefDescription": "Number of cores in C-State; C0 and C1",
-        "Counter": "0,1,2,3",
-        "EventCode": "0x80",
-        "EventName": "UNC_P_POWER_STATE_OCCUPANCY.CORES_C0",
+        "BriefDescription": "Package C State Residency - C0",
+        "EventCode": "0x2A",
+        "EventName": "UNC_P_PKG_RESIDENCY_C0_CYCLES",
         "PerPkg": "1",
+        "PublicDescription": "Counts the number of cycles when the package=
 was in C0.  This event can be used in conjunction with edge detect to coun=
t C0 entrances (or exits using invert).  Residency events do not include tr=
ansition times.",
         "Unit": "PCU"
     },
     {
-        "BriefDescription": "Number of cores in C-State; C3",
-        "Counter": "0,1,2,3",
-        "EventCode": "0x80",
-        "EventName": "UNC_P_POWER_STATE_OCCUPANCY.CORES_C3",
+        "BriefDescription": "Package C State Residency - C1E",
+        "EventCode": "0x4E",
+        "EventName": "UNC_P_PKG_RESIDENCY_C1E_CYCLES",
         "PerPkg": "1",
+        "PublicDescription": "Counts the number of cycles when the package=
 was in C1E.  This event can be used in conjunction with edge detect to cou=
nt C1E entrances (or exits using invert).  Residency events do not include =
transition times.",
         "Unit": "PCU"
     },
     {
-        "BriefDescription": "Number of cores in C-State; C6 and C7",
-        "Counter": "0,1,2,3",
-        "EventCode": "0x80",
-        "EventName": "UNC_P_POWER_STATE_OCCUPANCY.CORES_C6",
+        "BriefDescription": "Package C State Residency - C2E",
+        "EventCode": "0x2B",
+        "EventName": "UNC_P_PKG_RESIDENCY_C2E_CYCLES",
         "PerPkg": "1",
+        "PublicDescription": "Counts the number of cycles when the package=
 was in C2E.  This event can be used in conjunction with edge detect to cou=
nt C2E entrances (or exits using invert).  Residency events do not include =
transition times.",
         "Unit": "PCU"
     },
     {
-        "BriefDescription": "External Prochot",
-        "Counter": "0,1,2,3",
-        "EventCode": "0xA",
-        "EventName": "UNC_P_PROCHOT_EXTERNAL_CYCLES",
+        "BriefDescription": "Package C State Residency - C3",
+        "EventCode": "0x2C",
+        "EventName": "UNC_P_PKG_RESIDENCY_C3_CYCLES",
         "PerPkg": "1",
+        "PublicDescription": "Counts the number of cycles when the package=
 was in C3.  This event can be used in conjunction with edge detect to coun=
t C3 entrances (or exits using invert).  Residency events do not include tr=
ansition times.",
         "Unit": "PCU"
     },
     {
-        "BriefDescription": "Internal Prochot",
-        "Counter": "0,1,2,3",
-        "EventCode": "0x9",
-        "EventName": "UNC_P_PROCHOT_INTERNAL_CYCLES",
+        "BriefDescription": "Package C State Residency - C6",
+        "EventCode": "0x2D",
+        "EventName": "UNC_P_PKG_RESIDENCY_C6_CYCLES",
         "PerPkg": "1",
+        "PublicDescription": "Counts the number of cycles when the package=
 was in C6.  This event can be used in conjunction with edge detect to coun=
t C6 entrances (or exits using invert).  Residency events do not include tr=
ansition times.",
         "Unit": "PCU"
     },
     {
-        "BriefDescription": "Total Core C State Transition Cycles",
-        "Counter": "0,1,2,3",
-        "EventCode": "0x72",
-        "EventName": "UNC_P_TOTAL_TRANSITION_CYCLES",
+        "BriefDescription": "Package C7 State Residency",
+        "EventCode": "0x2E",
+        "EventName": "UNC_P_PKG_RESIDENCY_C7_CYCLES",
         "PerPkg": "1",
+        "PublicDescription": "Counts the number of cycles when the package=
 was in C7.  This event can be used in conjunction with edge detect to coun=
t C7 entrances (or exits using invert).  Residency events do not include tr=
ansition times.",
         "Unit": "PCU"
     },
     {
-        "BriefDescription": "UNC_P_UFS_TRANSITIONS_RING_GV",
-        "Counter": "0,1,2,3",
-        "EventCode": "0x79",
-        "EventName": "UNC_P_UFS_TRANSITIONS_RING_GV",
+        "BriefDescription": "Number of cores in C-State; C0 and C1",
+        "EventCode": "0x80",
+        "EventName": "UNC_P_POWER_STATE_OCCUPANCY.CORES_C0",
         "PerPkg": "1",
+        "PublicDescription": "This is an occupancy event that tracks the n=
umber of cores that are in the chosen C-State.  It can be used by itself to=
 get the average number of cores in that C-state with threshholding to gene=
rate histograms, or with other PCU events and occupancy triggering to captu=
re other details.",
         "Unit": "PCU"
     },
     {
-        "BriefDescription": "VR Hot",
-        "Counter": "0,1,2,3",
-        "EventCode": "0x42",
-        "EventName": "UNC_P_VR_HOT_CYCLES",
+        "BriefDescription": "Number of cores in C-State; C3",
+        "EventCode": "0x80",
+        "EventName": "UNC_P_POWER_STATE_OCCUPANCY.CORES_C3",
         "PerPkg": "1",
+        "PublicDescription": "This is an occupancy event that tracks the n=
umber of cores that are in the chosen C-State.  It can be used by itself to=
 get the average number of cores in that C-state with threshholding to gene=
rate histograms, or with other PCU events and occupancy triggering to captu=
re other details.",
         "Unit": "PCU"
     },
     {
-        "BriefDescription": "Package C State Residency - C0",
-        "Counter": "0,1,2,3",
-        "EventCode": "0x2A",
-        "EventName": "UNC_P_PKG_RESIDENCY_C0_CYCLES",
+        "BriefDescription": "Number of cores in C-State; C6 and C7",
+        "EventCode": "0x80",
+        "EventName": "UNC_P_POWER_STATE_OCCUPANCY.CORES_C6",
         "PerPkg": "1",
+        "PublicDescription": "This is an occupancy event that tracks the n=
umber of cores that are in the chosen C-State.  It can be used by itself to=
 get the average number of cores in that C-state with threshholding to gene=
rate histograms, or with other PCU events and occupancy triggering to captu=
re other details.",
         "Unit": "PCU"
     },
     {
-        "BriefDescription": "Package C State Residency - C2E",
-        "Counter": "0,1,2,3",
-        "EventCode": "0x2B",
-        "EventName": "UNC_P_PKG_RESIDENCY_C2E_CYCLES",
+        "BriefDescription": "External Prochot",
+        "EventCode": "0xA",
+        "EventName": "UNC_P_PROCHOT_EXTERNAL_CYCLES",
         "PerPkg": "1",
+        "PublicDescription": "Counts the number of cycles that we are in e=
xternal PROCHOT mode.  This mode is triggered when a sensor off the die det=
ermines that something off-die (like DRAM) is too hot and must throttle to =
avoid damaging the chip.",
         "Unit": "PCU"
     },
     {
-        "BriefDescription": "Package C State Residency - C3",
-        "Counter": "0,1,2,3",
-        "EventCode": "0x2C",
-        "EventName": "UNC_P_PKG_RESIDENCY_C3_CYCLES",
+        "BriefDescription": "Internal Prochot",
+        "EventCode": "0x9",
+        "EventName": "UNC_P_PROCHOT_INTERNAL_CYCLES",
         "PerPkg": "1",
+        "PublicDescription": "Counts the number of cycles that we are in I=
nteral PROCHOT mode.  This mode is triggered when a sensor on the die deter=
mines that we are too hot and must throttle to avoid damaging the chip.",
         "Unit": "PCU"
     },
     {
-        "BriefDescription": "Package C State Residency - C6",
-        "Counter": "0,1,2,3",
-        "EventCode": "0x2D",
-        "EventName": "UNC_P_PKG_RESIDENCY_C6_CYCLES",
+        "BriefDescription": "Total Core C State Transition Cycles",
+        "EventCode": "0x72",
+        "EventName": "UNC_P_TOTAL_TRANSITION_CYCLES",
         "PerPkg": "1",
+        "PublicDescription": "Number of cycles spent performing core C sta=
te transitions across all cores.",
         "Unit": "PCU"
     },
     {
-        "BriefDescription": "Package C7 State Residency",
-        "Counter": "0,1,2,3",
-        "EventCode": "0x2E",
-        "EventName": "UNC_P_PKG_RESIDENCY_C7_CYCLES",
+        "BriefDescription": "UNC_P_UFS_TRANSITIONS_RING_GV",
+        "EventCode": "0x79",
+        "EventName": "UNC_P_UFS_TRANSITIONS_RING_GV",
         "PerPkg": "1",
+        "PublicDescription": "Ring GV with same final and initial frequenc=
y",
         "Unit": "PCU"
     },
     {
-        "BriefDescription": "Package C State Residency - C1E",
-        "Counter": "0,1,2,3",
-        "EventCode": "0x4E",
-        "EventName": "UNC_P_PKG_RESIDENCY_C1E_CYCLES",
+        "BriefDescription": "VR Hot",
+        "EventCode": "0x42",
+        "EventName": "UNC_P_VR_HOT_CYCLES",
         "PerPkg": "1",
+        "PublicDescription": "UNC_P_VR_HOT_CYCLES",
         "Unit": "PCU"
     }
 ]
diff --git a/tools/perf/pmu-events/arch/x86/broadwellx/virtual-memory.json =
b/tools/perf/pmu-events/arch/x86/broadwellx/virtual-memory.json
index 6a6de8790f25..93621e004d88 100644
--- a/tools/perf/pmu-events/arch/x86/broadwellx/virtual-memory.json
+++ b/tools/perf/pmu-events/arch/x86/broadwellx/virtual-memory.json
@@ -1,8 +1,6 @@
 [
     {
         "BriefDescription": "Load misses in all DTLB levels that cause pag=
e walks",
-        "Counter": "0,1,2,3",
-        "CounterHTOff": "0,1,2,3,4,5,6,7",
         "Errata": "BDM69",
         "EventCode": "0x08",
         "EventName": "DTLB_LOAD_MISSES.MISS_CAUSES_A_WALK",
@@ -12,8 +10,6 @@
     },
     {
         "BriefDescription": "Load operations that miss the first DTLB leve=
l but hit the second and do not cause page walks.",
-        "Counter": "0,1,2,3",
-        "CounterHTOff": "0,1,2,3,4,5,6,7",
         "EventCode": "0x08",
         "EventName": "DTLB_LOAD_MISSES.STLB_HIT",
         "SampleAfterValue": "2000003",
@@ -21,8 +17,6 @@
     },
     {
         "BriefDescription": "Load misses that miss the  DTLB and hit the S=
TLB (2M).",
-        "Counter": "0,1,2,3",
-        "CounterHTOff": "0,1,2,3,4,5,6,7",
         "EventCode": "0x08",
         "EventName": "DTLB_LOAD_MISSES.STLB_HIT_2M",
         "SampleAfterValue": "2000003",
@@ -30,8 +24,6 @@
     },
     {
         "BriefDescription": "Load misses that miss the  DTLB and hit the S=
TLB (4K).",
-        "Counter": "0,1,2,3",
-        "CounterHTOff": "0,1,2,3,4,5,6,7",
         "EventCode": "0x08",
         "EventName": "DTLB_LOAD_MISSES.STLB_HIT_4K",
         "SampleAfterValue": "2000003",
@@ -39,8 +31,6 @@
     },
     {
         "BriefDescription": "Demand load Miss in all translation lookaside=
 buffer (TLB) levels causes a page walk that completes of any page size.",
-        "Counter": "0,1,2,3",
-        "CounterHTOff": "0,1,2,3,4,5,6,7",
         "Errata": "BDM69",
         "EventCode": "0x08",
         "EventName": "DTLB_LOAD_MISSES.WALK_COMPLETED",
@@ -49,8 +39,6 @@
     },
     {
         "BriefDescription": "Load miss in all TLB levels causes a page wal=
k that completes. (1G)",
-        "Counter": "0,1,2,3",
-        "CounterHTOff": "0,1,2,3,4,5,6,7",
         "Errata": "BDM69",
         "EventCode": "0x08",
         "EventName": "DTLB_LOAD_MISSES.WALK_COMPLETED_1G",
@@ -60,8 +48,6 @@
     },
     {
         "BriefDescription": "Demand load Miss in all translation lookaside=
 buffer (TLB) levels causes a page walk that completes (2M/4M).",
-        "Counter": "0,1,2,3",
-        "CounterHTOff": "0,1,2,3,4,5,6,7",
         "Errata": "BDM69",
         "EventCode": "0x08",
         "EventName": "DTLB_LOAD_MISSES.WALK_COMPLETED_2M_4M",
@@ -71,8 +57,6 @@
     },
     {
         "BriefDescription": "Demand load Miss in all translation lookaside=
 buffer (TLB) levels causes a page walk that completes (4K).",
-        "Counter": "0,1,2,3",
-        "CounterHTOff": "0,1,2,3,4,5,6,7",
         "Errata": "BDM69",
         "EventCode": "0x08",
         "EventName": "DTLB_LOAD_MISSES.WALK_COMPLETED_4K",
@@ -82,8 +66,6 @@
     },
     {
         "BriefDescription": "Cycles when PMH is busy with page walks",
-        "Counter": "0,1,2,3",
-        "CounterHTOff": "0,1,2,3,4,5,6,7",
         "Errata": "BDM69",
         "EventCode": "0x08",
         "EventName": "DTLB_LOAD_MISSES.WALK_DURATION",
@@ -93,8 +75,6 @@
     },
     {
         "BriefDescription": "Store misses in all DTLB levels that cause pa=
ge walks",
-        "Counter": "0,1,2,3",
-        "CounterHTOff": "0,1,2,3,4,5,6,7",
         "Errata": "BDM69",
         "EventCode": "0x49",
         "EventName": "DTLB_STORE_MISSES.MISS_CAUSES_A_WALK",
@@ -104,8 +84,6 @@
     },
     {
         "BriefDescription": "Store operations that miss the first TLB leve=
l but hit the second and do not cause page walks.",
-        "Counter": "0,1,2,3",
-        "CounterHTOff": "0,1,2,3,4,5,6,7",
         "EventCode": "0x49",
         "EventName": "DTLB_STORE_MISSES.STLB_HIT",
         "SampleAfterValue": "100003",
@@ -113,8 +91,6 @@
     },
     {
         "BriefDescription": "Store misses that miss the  DTLB and hit the =
STLB (2M).",
-        "Counter": "0,1,2,3",
-        "CounterHTOff": "0,1,2,3,4,5,6,7",
         "EventCode": "0x49",
         "EventName": "DTLB_STORE_MISSES.STLB_HIT_2M",
         "SampleAfterValue": "100003",
@@ -122,8 +98,6 @@
     },
     {
         "BriefDescription": "Store misses that miss the  DTLB and hit the =
STLB (4K).",
-        "Counter": "0,1,2,3",
-        "CounterHTOff": "0,1,2,3,4,5,6,7",
         "EventCode": "0x49",
         "EventName": "DTLB_STORE_MISSES.STLB_HIT_4K",
         "SampleAfterValue": "100003",
@@ -131,8 +105,6 @@
     },
     {
         "BriefDescription": "Store misses in all DTLB levels that cause co=
mpleted page walks.",
-        "Counter": "0,1,2,3",
-        "CounterHTOff": "0,1,2,3,4,5,6,7",
         "Errata": "BDM69",
         "EventCode": "0x49",
         "EventName": "DTLB_STORE_MISSES.WALK_COMPLETED",
@@ -141,8 +113,6 @@
     },
     {
         "BriefDescription": "Store misses in all DTLB levels that cause co=
mpleted page walks (1G)",
-        "Counter": "0,1,2,3",
-        "CounterHTOff": "0,1,2,3,4,5,6,7",
         "Errata": "BDM69",
         "EventCode": "0x49",
         "EventName": "DTLB_STORE_MISSES.WALK_COMPLETED_1G",
@@ -152,8 +122,6 @@
     },
     {
         "BriefDescription": "Store misses in all DTLB levels that cause co=
mpleted page walks (2M/4M)",
-        "Counter": "0,1,2,3",
-        "CounterHTOff": "0,1,2,3,4,5,6,7",
         "Errata": "BDM69",
         "EventCode": "0x49",
         "EventName": "DTLB_STORE_MISSES.WALK_COMPLETED_2M_4M",
@@ -163,8 +131,6 @@
     },
     {
         "BriefDescription": "Store miss in all TLB levels causes a page wa=
lk that completes. (4K)",
-        "Counter": "0,1,2,3",
-        "CounterHTOff": "0,1,2,3,4,5,6,7",
         "Errata": "BDM69",
         "EventCode": "0x49",
         "EventName": "DTLB_STORE_MISSES.WALK_COMPLETED_4K",
@@ -174,8 +140,6 @@
     },
     {
         "BriefDescription": "Cycles when PMH is busy with page walks",
-        "Counter": "0,1,2,3",
-        "CounterHTOff": "0,1,2,3,4,5,6,7",
         "Errata": "BDM69",
         "EventCode": "0x49",
         "EventName": "DTLB_STORE_MISSES.WALK_DURATION",
@@ -185,8 +149,6 @@
     },
     {
         "BriefDescription": "Cycle count for an Extended Page table walk."=
,
-        "Counter": "0,1,2,3",
-        "CounterHTOff": "0,1,2,3,4,5,6,7",
         "EventCode": "0x4F",
         "EventName": "EPT.WALK_CYCLES",
         "PublicDescription": "This event counts cycles for an extended pag=
e table walk. The Extended Page directory cache differs from standard TLB c=
aches by the operating system that use it. Virtual machine operating system=
s use the extended page directory cache, while guest operating systems use =
the standard TLB caches.",
@@ -195,8 +157,6 @@
     },
     {
         "BriefDescription": "Flushing of the Instruction TLB (ITLB) pages,=
 includes 4k/2M/4M pages.",
-        "Counter": "0,1,2,3",
-        "CounterHTOff": "0,1,2,3,4,5,6,7",
         "EventCode": "0xAE",
         "EventName": "ITLB.ITLB_FLUSH",
         "PublicDescription": "This event counts the number of flushes of t=
he big or small ITLB pages. Counting include both TLB Flush (covering all s=
ets) and TLB Set Clear (set-specific).",
@@ -205,8 +165,6 @@
     },
     {
         "BriefDescription": "Misses at all ITLB levels that cause page wal=
ks",
-        "Counter": "0,1,2,3",
-        "CounterHTOff": "0,1,2,3,4,5,6,7",
         "Errata": "BDM69",
         "EventCode": "0x85",
         "EventName": "ITLB_MISSES.MISS_CAUSES_A_WALK",
@@ -216,8 +174,6 @@
     },
     {
         "BriefDescription": "Operations that miss the first ITLB level but=
 hit the second and do not cause any page walks.",
-        "Counter": "0,1,2,3",
-        "CounterHTOff": "0,1,2,3,4,5,6,7",
         "EventCode": "0x85",
         "EventName": "ITLB_MISSES.STLB_HIT",
         "SampleAfterValue": "100003",
@@ -225,8 +181,6 @@
     },
     {
         "BriefDescription": "Code misses that miss the  DTLB and hit the S=
TLB (2M).",
-        "Counter": "0,1,2,3",
-        "CounterHTOff": "0,1,2,3,4,5,6,7",
         "EventCode": "0x85",
         "EventName": "ITLB_MISSES.STLB_HIT_2M",
         "SampleAfterValue": "100003",
@@ -234,8 +188,6 @@
     },
     {
         "BriefDescription": "Core misses that miss the  DTLB and hit the S=
TLB (4K).",
-        "Counter": "0,1,2,3",
-        "CounterHTOff": "0,1,2,3,4,5,6,7",
         "EventCode": "0x85",
         "EventName": "ITLB_MISSES.STLB_HIT_4K",
         "SampleAfterValue": "100003",
@@ -243,8 +195,6 @@
     },
     {
         "BriefDescription": "Misses in all ITLB levels that cause complete=
d page walks.",
-        "Counter": "0,1,2,3",
-        "CounterHTOff": "0,1,2,3,4,5,6,7",
         "Errata": "BDM69",
         "EventCode": "0x85",
         "EventName": "ITLB_MISSES.WALK_COMPLETED",
@@ -253,8 +203,6 @@
     },
     {
         "BriefDescription": "Store miss in all TLB levels causes a page wa=
lk that completes. (1G)",
-        "Counter": "0,1,2,3",
-        "CounterHTOff": "0,1,2,3,4,5,6,7",
         "Errata": "BDM69",
         "EventCode": "0x85",
         "EventName": "ITLB_MISSES.WALK_COMPLETED_1G",
@@ -264,8 +212,6 @@
     },
     {
         "BriefDescription": "Code miss in all TLB levels causes a page wal=
k that completes. (2M/4M)",
-        "Counter": "0,1,2,3",
-        "CounterHTOff": "0,1,2,3,4,5,6,7",
         "Errata": "BDM69",
         "EventCode": "0x85",
         "EventName": "ITLB_MISSES.WALK_COMPLETED_2M_4M",
@@ -275,8 +221,6 @@
     },
     {
         "BriefDescription": "Code miss in all TLB levels causes a page wal=
k that completes. (4K)",
-        "Counter": "0,1,2,3",
-        "CounterHTOff": "0,1,2,3,4,5,6,7",
         "Errata": "BDM69",
         "EventCode": "0x85",
         "EventName": "ITLB_MISSES.WALK_COMPLETED_4K",
@@ -286,8 +230,6 @@
     },
     {
         "BriefDescription": "Cycles when PMH is busy with page walks",
-        "Counter": "0,1,2,3",
-        "CounterHTOff": "0,1,2,3,4,5,6,7",
         "Errata": "BDM69",
         "EventCode": "0x85",
         "EventName": "ITLB_MISSES.WALK_DURATION",
@@ -297,8 +239,6 @@
     },
     {
         "BriefDescription": "Number of DTLB page walker hits in the L1+FB.=
",
-        "Counter": "0,1,2,3",
-        "CounterHTOff": "0,1,2,3",
         "Errata": "BDM69, BDM98",
         "EventCode": "0xBC",
         "EventName": "PAGE_WALKER_LOADS.DTLB_L1",
@@ -307,8 +247,6 @@
     },
     {
         "BriefDescription": "Number of DTLB page walker hits in the L2.",
-        "Counter": "0,1,2,3",
-        "CounterHTOff": "0,1,2,3",
         "Errata": "BDM69, BDM98",
         "EventCode": "0xBC",
         "EventName": "PAGE_WALKER_LOADS.DTLB_L2",
@@ -317,8 +255,6 @@
     },
     {
         "BriefDescription": "Number of DTLB page walker hits in the L3 + X=
SNP.",
-        "Counter": "0,1,2,3",
-        "CounterHTOff": "0,1,2,3",
         "Errata": "BDM69, BDM98",
         "EventCode": "0xBC",
         "EventName": "PAGE_WALKER_LOADS.DTLB_L3",
@@ -327,8 +263,6 @@
     },
     {
         "BriefDescription": "Number of DTLB page walker hits in Memory.",
-        "Counter": "0,1,2,3",
-        "CounterHTOff": "0,1,2,3",
         "Errata": "BDM69, BDM98",
         "EventCode": "0xBC",
         "EventName": "PAGE_WALKER_LOADS.DTLB_MEMORY",
@@ -337,8 +271,6 @@
     },
     {
         "BriefDescription": "Number of ITLB page walker hits in the L1+FB.=
",
-        "Counter": "0,1,2,3",
-        "CounterHTOff": "0,1,2,3",
         "Errata": "BDM69, BDM98",
         "EventCode": "0xBC",
         "EventName": "PAGE_WALKER_LOADS.ITLB_L1",
@@ -347,8 +279,6 @@
     },
     {
         "BriefDescription": "Number of ITLB page walker hits in the L2.",
-        "Counter": "0,1,2,3",
-        "CounterHTOff": "0,1,2,3",
         "Errata": "BDM69, BDM98",
         "EventCode": "0xBC",
         "EventName": "PAGE_WALKER_LOADS.ITLB_L2",
@@ -357,8 +287,6 @@
     },
     {
         "BriefDescription": "Number of ITLB page walker hits in the L3 + X=
SNP.",
-        "Counter": "0,1,2,3",
-        "CounterHTOff": "0,1,2,3",
         "Errata": "BDM69, BDM98",
         "EventCode": "0xBC",
         "EventName": "PAGE_WALKER_LOADS.ITLB_L3",
@@ -367,8 +295,6 @@
     },
     {
         "BriefDescription": "DTLB flush attempts of the thread-specific en=
tries",
-        "Counter": "0,1,2,3",
-        "CounterHTOff": "0,1,2,3,4,5,6,7",
         "EventCode": "0xBD",
         "EventName": "TLB_FLUSH.DTLB_THREAD",
         "PublicDescription": "This event counts the number of DTLB flush a=
ttempts of the thread-specific entries.",
@@ -377,8 +303,6 @@
     },
     {
         "BriefDescription": "STLB flush attempts",
-        "Counter": "0,1,2,3",
-        "CounterHTOff": "0,1,2,3,4,5,6,7",
         "EventCode": "0xBD",
         "EventName": "TLB_FLUSH.STLB_ANY",
         "PublicDescription": "This event counts the number of any STLB flu=
sh attempts (such as entire, VPID, PCID, InvPage, CR3 write, and so on).",
--=20
2.39.0.314.g84b9a713c41-goog

