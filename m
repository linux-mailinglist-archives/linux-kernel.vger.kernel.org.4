Return-Path: <linux-kernel-owner@vger.kernel.org>
X-Original-To: lists+linux-kernel@lfdr.de
Delivered-To: lists+linux-kernel@lfdr.de
Received: from out1.vger.email (out1.vger.email [IPv6:2620:137:e000::1:20])
	by mail.lfdr.de (Postfix) with ESMTP id 930FE64D6C1
	for <lists+linux-kernel@lfdr.de>; Thu, 15 Dec 2022 07:57:15 +0100 (CET)
Received: (majordomo@vger.kernel.org) by vger.kernel.org via listexpand
        id S229561AbiLOG4t (ORCPT <rfc822;lists+linux-kernel@lfdr.de>);
        Thu, 15 Dec 2022 01:56:49 -0500
Received: from lindbergh.monkeyblade.net ([23.128.96.19]:52426 "EHLO
        lindbergh.monkeyblade.net" rhost-flags-OK-OK-OK-OK) by vger.kernel.org
        with ESMTP id S229816AbiLOG4R (ORCPT
        <rfc822;linux-kernel@vger.kernel.org>);
        Thu, 15 Dec 2022 01:56:17 -0500
Received: from mail-yb1-xb49.google.com (mail-yb1-xb49.google.com [IPv6:2607:f8b0:4864:20::b49])
        by lindbergh.monkeyblade.net (Postfix) with ESMTPS id 642365FBA2
        for <linux-kernel@vger.kernel.org>; Wed, 14 Dec 2022 22:56:06 -0800 (PST)
Received: by mail-yb1-xb49.google.com with SMTP id a5-20020a25af05000000b006e450a5e507so2636241ybh.22
        for <linux-kernel@vger.kernel.org>; Wed, 14 Dec 2022 22:56:06 -0800 (PST)
DKIM-Signature: v=1; a=rsa-sha256; c=relaxed/relaxed;
        d=google.com; s=20210112;
        h=content-transfer-encoding:cc:to:from:subject:references
         :mime-version:message-id:in-reply-to:date:from:to:cc:subject:date
         :message-id:reply-to;
        bh=UoJSaETIjErBTG1cAN+Ito0AjZUUPffUpA653lvDMNU=;
        b=oK/GXlltEoClDR5WGIeUyiv19+2BUVYdleWyS8vKlUtjbg40/NxBzVqOY0Pq+h0No+
         +0EhjP+UyyEv4LTzZiXlAa87LxmVqPXUqnOp3PJq1RUkrjYhEc6+tSrYKSI5e3dOg9dL
         9pHAspP+1QvHKdHekvOCN2yDtgGFa4xWqAa6T+PW2eJRkwSy0lfEH7JV4aJUw0WofDpi
         +8gUR9klTBwLi79mYoXCFgiR6XzsbHSRAktLbsAymIYO+RG3bx12xfAd4NLG1nELgNXO
         zg0f7rlXbUa1LR39RbLei9cT9twyMdJsJg0c45UlkOh1MdK7xC2YH3FqZYapHPHdpdE8
         usog==
X-Google-DKIM-Signature: v=1; a=rsa-sha256; c=relaxed/relaxed;
        d=1e100.net; s=20210112;
        h=content-transfer-encoding:cc:to:from:subject:references
         :mime-version:message-id:in-reply-to:date:x-gm-message-state:from:to
         :cc:subject:date:message-id:reply-to;
        bh=UoJSaETIjErBTG1cAN+Ito0AjZUUPffUpA653lvDMNU=;
        b=l0cfKT83antOZJlnb5B44kYWMBoDlMw9ODV5QW7IkGF5tvh9XYux23yWejZnXLvUpy
         vWSA0T7aGoyWrz89anycdZeOuqGwiNZPsgehYqIDwQfSUrRTiOiEopYR17lIUJAcDjhu
         djnzuGqLM5MzBSLmdWtbzMW/WATCyev4mhkZ7f46sqnDvnSpe5Se6hi2tUNdQy8FvIn7
         1gyfUGNI5SRxoaWMd57EWEtp2nPbkjt9U3k3YNEnEkbrLo0lNg9uujh/FVfuDY+qE0DA
         zeBQUYoTeKZlohYax+2MC2eCJQTfSPmjbAK8K4S1Bd410ZgqZ3rAZsOpsDEHofiatsxE
         8EIw==
X-Gm-Message-State: ANoB5pm1uVkoET5v/9qk2tZoSM96ofJQgsmAZVID3g7PWGh3H6Ok6Xlq
        gDkP5mIPMKLUDIPH+c0mgY0vsSGeo3zm
X-Google-Smtp-Source: AA0mqf6IwDHZKCjcMwrA1Vy30Qk3xpdqD5E1qGLob1l0DNFASP2qqXowTihk7wFV9FZdJlRpznsQlmoBTD20
X-Received: from irogers.svl.corp.google.com ([2620:15c:2d4:203:c7dc:d96f:4f9:f59d])
 (user=irogers job=sendgmr) by 2002:a25:d34d:0:b0:6fa:7b0a:3eed with SMTP id
 e74-20020a25d34d000000b006fa7b0a3eedmr38380840ybf.83.1671087365175; Wed, 14
 Dec 2022 22:56:05 -0800 (PST)
Date:   Wed, 14 Dec 2022 22:54:51 -0800
In-Reply-To: <20221215065510.1621979-1-irogers@google.com>
Message-Id: <20221215065510.1621979-5-irogers@google.com>
Mime-Version: 1.0
References: <20221215065510.1621979-1-irogers@google.com>
X-Mailer: git-send-email 2.39.0.314.g84b9a713c41-goog
Subject: [PATCH v1 13/32] perf vendor events intel: Refresh haswellx metrics
 and events
From:   Ian Rogers <irogers@google.com>
To:     Peter Zijlstra <peterz@infradead.org>,
        Ingo Molnar <mingo@redhat.com>,
        Arnaldo Carvalho de Melo <acme@kernel.org>,
        Mark Rutland <mark.rutland@arm.com>,
        Alexander Shishkin <alexander.shishkin@linux.intel.com>,
        Jiri Olsa <jolsa@kernel.org>,
        Namhyung Kim <namhyung@kernel.org>,
        Adrian Hunter <adrian.hunter@intel.com>,
        Kan Liang <kan.liang@linux.intel.com>,
        Xing Zhengjun <zhengjun.xing@linux.intel.com>,
        linux-perf-users@vger.kernel.org, linux-kernel@vger.kernel.org
Cc:     John Garry <john.g.garry@oracle.com>,
        Stephane Eranian <eranian@google.com>,
        Perry Taylor <perry.taylor@intel.com>,
        Caleb Biggers <caleb.biggers@intel.com>,
        Ian Rogers <irogers@google.com>
Content-Type: text/plain; charset="UTF-8"
Content-Transfer-Encoding: quoted-printable
Precedence: bulk
List-ID: <linux-kernel.vger.kernel.org>
X-Mailing-List: linux-kernel@vger.kernel.org

Update the haswellx metrics and events using the new tooling from:
https://github.com/intel/perfmon

The metrics are unchanged but the formulas differ due to parentheses,
use of exponents and removal of redundant operations like "* 1". The
order of metrics varies as TMA metrics are first converted and then
removed if perfmon versions are found. The events are updated with
fixes to uncore events and improved descriptions. The formatting
changes increase consistency across the json files.

Signed-off-by: Ian Rogers <irogers@google.com>
---
 .../pmu-events/arch/x86/haswellx/cache.json   |  217 --
 .../arch/x86/haswellx/floating-point.json     |   20 -
 .../arch/x86/haswellx/frontend.json           |   58 -
 .../arch/x86/haswellx/hsx-metrics.json        | 1467 +++++-----
 .../pmu-events/arch/x86/haswellx/memory.json  |  170 --
 .../pmu-events/arch/x86/haswellx/other.json   |    8 -
 .../arch/x86/haswellx/pipeline.json           |  258 --
 .../arch/x86/haswellx/uncore-cache.json       | 2448 ++++++++---------
 .../x86/haswellx/uncore-interconnect.json     |  722 ++---
 .../arch/x86/haswellx/uncore-memory.json      | 2037 +++++++-------
 .../arch/x86/haswellx/uncore-other.json       | 1834 ++++++------
 .../arch/x86/haswellx/uncore-power.json       |  150 +-
 .../arch/x86/haswellx/virtual-memory.json     |   98 -
 13 files changed, 4206 insertions(+), 5281 deletions(-)

diff --git a/tools/perf/pmu-events/arch/x86/haswellx/cache.json b/tools/per=
f/pmu-events/arch/x86/haswellx/cache.json
index 427c949bed6e..1836ed62694e 100644
--- a/tools/perf/pmu-events/arch/x86/haswellx/cache.json
+++ b/tools/perf/pmu-events/arch/x86/haswellx/cache.json
@@ -1,8 +1,6 @@
 [
     {
         "BriefDescription": "L1D data line replacements",
-        "Counter": "0,1,2,3",
-        "CounterHTOff": "0,1,2,3,4,5,6,7",
         "EventCode": "0x51",
         "EventName": "L1D.REPLACEMENT",
         "PublicDescription": "This event counts when new data lines are br=
ought into the L1 Data cache, which cause other lines to be evicted from th=
e cache.",
@@ -11,8 +9,6 @@
     },
     {
         "BriefDescription": "Cycles a demand request was blocked due to Fi=
ll Buffers inavailability.",
-        "Counter": "0,1,2,3",
-        "CounterHTOff": "0,1,2,3,4,5,6,7",
         "CounterMask": "1",
         "EventCode": "0x48",
         "EventName": "L1D_PEND_MISS.FB_FULL",
@@ -21,8 +17,6 @@
     },
     {
         "BriefDescription": "L1D miss outstanding duration in cycles",
-        "Counter": "2",
-        "CounterHTOff": "2",
         "EventCode": "0x48",
         "EventName": "L1D_PEND_MISS.PENDING",
         "PublicDescription": "Increments the number of outstanding L1D mis=
ses every cycle. Set Cmask =3D 1 and Edge =3D1 to count occurrences.",
@@ -31,8 +25,6 @@
     },
     {
         "BriefDescription": "Cycles with L1D load Misses outstanding.",
-        "Counter": "2",
-        "CounterHTOff": "2",
         "CounterMask": "1",
         "EventCode": "0x48",
         "EventName": "L1D_PEND_MISS.PENDING_CYCLES",
@@ -42,8 +34,6 @@
     {
         "AnyThread": "1",
         "BriefDescription": "Cycles with L1D load Misses outstanding from =
any thread on physical core.",
-        "Counter": "2",
-        "CounterHTOff": "2",
         "CounterMask": "1",
         "EventCode": "0x48",
         "EventName": "L1D_PEND_MISS.PENDING_CYCLES_ANY",
@@ -52,8 +42,6 @@
     },
     {
         "BriefDescription": "Number of times a request needed a FB entry b=
ut there was no entry available for it. That is the FB unavailability was d=
ominant reason for blocking the request. A request includes cacheable/uncac=
heable demands that is load, store or SW prefetch. HWP are e.",
-        "Counter": "0,1,2,3",
-        "CounterHTOff": "0,1,2,3,4,5,6,7",
         "EventCode": "0x48",
         "EventName": "L1D_PEND_MISS.REQUEST_FB_FULL",
         "SampleAfterValue": "2000003",
@@ -61,8 +49,6 @@
     },
     {
         "BriefDescription": "Not rejected writebacks that hit L2 cache",
-        "Counter": "0,1,2,3",
-        "CounterHTOff": "0,1,2,3,4,5,6,7",
         "EventCode": "0x27",
         "EventName": "L2_DEMAND_RQSTS.WB_HIT",
         "PublicDescription": "Not rejected writebacks that hit L2 cache.",
@@ -71,8 +57,6 @@
     },
     {
         "BriefDescription": "L2 cache lines filling L2",
-        "Counter": "0,1,2,3",
-        "CounterHTOff": "0,1,2,3,4,5,6,7",
         "EventCode": "0xF1",
         "EventName": "L2_LINES_IN.ALL",
         "PublicDescription": "This event counts the number of L2 cache lin=
es brought into the L2 cache.  Lines are filled into the L2 cache when ther=
e was an L2 miss.",
@@ -81,8 +65,6 @@
     },
     {
         "BriefDescription": "L2 cache lines in E state filling L2",
-        "Counter": "0,1,2,3",
-        "CounterHTOff": "0,1,2,3,4,5,6,7",
         "EventCode": "0xF1",
         "EventName": "L2_LINES_IN.E",
         "PublicDescription": "L2 cache lines in E state filling L2.",
@@ -91,8 +73,6 @@
     },
     {
         "BriefDescription": "L2 cache lines in I state filling L2",
-        "Counter": "0,1,2,3",
-        "CounterHTOff": "0,1,2,3,4,5,6,7",
         "EventCode": "0xF1",
         "EventName": "L2_LINES_IN.I",
         "PublicDescription": "L2 cache lines in I state filling L2.",
@@ -101,8 +81,6 @@
     },
     {
         "BriefDescription": "L2 cache lines in S state filling L2",
-        "Counter": "0,1,2,3",
-        "CounterHTOff": "0,1,2,3,4,5,6,7",
         "EventCode": "0xF1",
         "EventName": "L2_LINES_IN.S",
         "PublicDescription": "L2 cache lines in S state filling L2.",
@@ -111,8 +89,6 @@
     },
     {
         "BriefDescription": "Clean L2 cache lines evicted by demand",
-        "Counter": "0,1,2,3",
-        "CounterHTOff": "0,1,2,3,4,5,6,7",
         "EventCode": "0xF2",
         "EventName": "L2_LINES_OUT.DEMAND_CLEAN",
         "PublicDescription": "Clean L2 cache lines evicted by demand.",
@@ -121,8 +97,6 @@
     },
     {
         "BriefDescription": "Dirty L2 cache lines evicted by demand",
-        "Counter": "0,1,2,3",
-        "CounterHTOff": "0,1,2,3,4,5,6,7",
         "EventCode": "0xF2",
         "EventName": "L2_LINES_OUT.DEMAND_DIRTY",
         "PublicDescription": "Dirty L2 cache lines evicted by demand.",
@@ -131,8 +105,6 @@
     },
     {
         "BriefDescription": "L2 code requests",
-        "Counter": "0,1,2,3",
-        "CounterHTOff": "0,1,2,3,4,5,6,7",
         "EventCode": "0x24",
         "EventName": "L2_RQSTS.ALL_CODE_RD",
         "PublicDescription": "Counts all L2 code requests.",
@@ -141,8 +113,6 @@
     },
     {
         "BriefDescription": "Demand Data Read requests",
-        "Counter": "0,1,2,3",
-        "CounterHTOff": "0,1,2,3,4,5,6,7",
         "Errata": "HSD78, HSM80",
         "EventCode": "0x24",
         "EventName": "L2_RQSTS.ALL_DEMAND_DATA_RD",
@@ -152,8 +122,6 @@
     },
     {
         "BriefDescription": "Demand requests that miss L2 cache",
-        "Counter": "0,1,2,3",
-        "CounterHTOff": "0,1,2,3,4,5,6,7",
         "Errata": "HSD78, HSM80",
         "EventCode": "0x24",
         "EventName": "L2_RQSTS.ALL_DEMAND_MISS",
@@ -163,8 +131,6 @@
     },
     {
         "BriefDescription": "Demand requests to L2 cache",
-        "Counter": "0,1,2,3",
-        "CounterHTOff": "0,1,2,3,4,5,6,7",
         "Errata": "HSD78, HSM80",
         "EventCode": "0x24",
         "EventName": "L2_RQSTS.ALL_DEMAND_REFERENCES",
@@ -174,8 +140,6 @@
     },
     {
         "BriefDescription": "Requests from L2 hardware prefetchers",
-        "Counter": "0,1,2,3",
-        "CounterHTOff": "0,1,2,3,4,5,6,7",
         "EventCode": "0x24",
         "EventName": "L2_RQSTS.ALL_PF",
         "PublicDescription": "Counts all L2 HW prefetcher requests.",
@@ -184,8 +148,6 @@
     },
     {
         "BriefDescription": "RFO requests to L2 cache",
-        "Counter": "0,1,2,3",
-        "CounterHTOff": "0,1,2,3,4,5,6,7",
         "EventCode": "0x24",
         "EventName": "L2_RQSTS.ALL_RFO",
         "PublicDescription": "Counts all L2 store RFO requests.",
@@ -194,8 +156,6 @@
     },
     {
         "BriefDescription": "L2 cache hits when fetching instructions, cod=
e reads.",
-        "Counter": "0,1,2,3",
-        "CounterHTOff": "0,1,2,3,4,5,6,7",
         "EventCode": "0x24",
         "EventName": "L2_RQSTS.CODE_RD_HIT",
         "PublicDescription": "Number of instruction fetches that hit the L=
2 cache.",
@@ -204,8 +164,6 @@
     },
     {
         "BriefDescription": "L2 cache misses when fetching instructions",
-        "Counter": "0,1,2,3",
-        "CounterHTOff": "0,1,2,3,4,5,6,7",
         "EventCode": "0x24",
         "EventName": "L2_RQSTS.CODE_RD_MISS",
         "PublicDescription": "Number of instruction fetches that missed th=
e L2 cache.",
@@ -214,8 +172,6 @@
     },
     {
         "BriefDescription": "Demand Data Read requests that hit L2 cache",
-        "Counter": "0,1,2,3",
-        "CounterHTOff": "0,1,2,3,4,5,6,7",
         "Errata": "HSD78, HSM80",
         "EventCode": "0x24",
         "EventName": "L2_RQSTS.DEMAND_DATA_RD_HIT",
@@ -225,8 +181,6 @@
     },
     {
         "BriefDescription": "Demand Data Read miss L2, no rejects",
-        "Counter": "0,1,2,3",
-        "CounterHTOff": "0,1,2,3,4,5,6,7",
         "Errata": "HSD78, HSM80",
         "EventCode": "0x24",
         "EventName": "L2_RQSTS.DEMAND_DATA_RD_MISS",
@@ -236,8 +190,6 @@
     },
     {
         "BriefDescription": "L2 prefetch requests that hit L2 cache",
-        "Counter": "0,1,2,3",
-        "CounterHTOff": "0,1,2,3,4,5,6,7",
         "EventCode": "0x24",
         "EventName": "L2_RQSTS.L2_PF_HIT",
         "PublicDescription": "Counts all L2 HW prefetcher requests that hi=
t L2.",
@@ -246,8 +198,6 @@
     },
     {
         "BriefDescription": "L2 prefetch requests that miss L2 cache",
-        "Counter": "0,1,2,3",
-        "CounterHTOff": "0,1,2,3,4,5,6,7",
         "EventCode": "0x24",
         "EventName": "L2_RQSTS.L2_PF_MISS",
         "PublicDescription": "Counts all L2 HW prefetcher requests that mi=
ssed L2.",
@@ -256,8 +206,6 @@
     },
     {
         "BriefDescription": "All requests that miss L2 cache",
-        "Counter": "0,1,2,3",
-        "CounterHTOff": "0,1,2,3,4,5,6,7",
         "Errata": "HSD78, HSM80",
         "EventCode": "0x24",
         "EventName": "L2_RQSTS.MISS",
@@ -267,8 +215,6 @@
     },
     {
         "BriefDescription": "All L2 requests",
-        "Counter": "0,1,2,3",
-        "CounterHTOff": "0,1,2,3,4,5,6,7",
         "Errata": "HSD78, HSM80",
         "EventCode": "0x24",
         "EventName": "L2_RQSTS.REFERENCES",
@@ -278,8 +224,6 @@
     },
     {
         "BriefDescription": "RFO requests that hit L2 cache",
-        "Counter": "0,1,2,3",
-        "CounterHTOff": "0,1,2,3,4,5,6,7",
         "EventCode": "0x24",
         "EventName": "L2_RQSTS.RFO_HIT",
         "PublicDescription": "Counts the number of store RFO requests that=
 hit the L2 cache.",
@@ -288,8 +232,6 @@
     },
     {
         "BriefDescription": "RFO requests that miss L2 cache",
-        "Counter": "0,1,2,3",
-        "CounterHTOff": "0,1,2,3,4,5,6,7",
         "EventCode": "0x24",
         "EventName": "L2_RQSTS.RFO_MISS",
         "PublicDescription": "Counts the number of store RFO requests that=
 miss the L2 cache.",
@@ -298,8 +240,6 @@
     },
     {
         "BriefDescription": "L2 or L3 HW prefetches that access L2 cache",
-        "Counter": "0,1,2,3",
-        "CounterHTOff": "0,1,2,3,4,5,6,7",
         "EventCode": "0xf0",
         "EventName": "L2_TRANS.ALL_PF",
         "PublicDescription": "Any MLC or L3 HW prefetch accessing L2, incl=
uding rejects.",
@@ -308,8 +248,6 @@
     },
     {
         "BriefDescription": "Transactions accessing L2 pipe",
-        "Counter": "0,1,2,3",
-        "CounterHTOff": "0,1,2,3,4,5,6,7",
         "EventCode": "0xf0",
         "EventName": "L2_TRANS.ALL_REQUESTS",
         "PublicDescription": "Transactions accessing L2 pipe.",
@@ -318,8 +256,6 @@
     },
     {
         "BriefDescription": "L2 cache accesses when fetching instructions"=
,
-        "Counter": "0,1,2,3",
-        "CounterHTOff": "0,1,2,3,4,5,6,7",
         "EventCode": "0xf0",
         "EventName": "L2_TRANS.CODE_RD",
         "PublicDescription": "L2 cache accesses when fetching instructions=
.",
@@ -328,8 +264,6 @@
     },
     {
         "BriefDescription": "Demand Data Read requests that access L2 cach=
e",
-        "Counter": "0,1,2,3",
-        "CounterHTOff": "0,1,2,3,4,5,6,7",
         "EventCode": "0xf0",
         "EventName": "L2_TRANS.DEMAND_DATA_RD",
         "PublicDescription": "Demand data read requests that access L2 cac=
he.",
@@ -338,8 +272,6 @@
     },
     {
         "BriefDescription": "L1D writebacks that access L2 cache",
-        "Counter": "0,1,2,3",
-        "CounterHTOff": "0,1,2,3,4,5,6,7",
         "EventCode": "0xf0",
         "EventName": "L2_TRANS.L1D_WB",
         "PublicDescription": "L1D writebacks that access L2 cache.",
@@ -348,8 +280,6 @@
     },
     {
         "BriefDescription": "L2 fill requests that access L2 cache",
-        "Counter": "0,1,2,3",
-        "CounterHTOff": "0,1,2,3,4,5,6,7",
         "EventCode": "0xf0",
         "EventName": "L2_TRANS.L2_FILL",
         "PublicDescription": "L2 fill requests that access L2 cache.",
@@ -358,8 +288,6 @@
     },
     {
         "BriefDescription": "L2 writebacks that access L2 cache",
-        "Counter": "0,1,2,3",
-        "CounterHTOff": "0,1,2,3,4,5,6,7",
         "EventCode": "0xf0",
         "EventName": "L2_TRANS.L2_WB",
         "PublicDescription": "L2 writebacks that access L2 cache.",
@@ -368,8 +296,6 @@
     },
     {
         "BriefDescription": "RFO requests that access L2 cache",
-        "Counter": "0,1,2,3",
-        "CounterHTOff": "0,1,2,3,4,5,6,7",
         "EventCode": "0xf0",
         "EventName": "L2_TRANS.RFO",
         "PublicDescription": "RFO requests that access L2 cache.",
@@ -378,8 +304,6 @@
     },
     {
         "BriefDescription": "Cycles when L1D is locked",
-        "Counter": "0,1,2,3",
-        "CounterHTOff": "0,1,2,3,4,5,6,7",
         "EventCode": "0x63",
         "EventName": "LOCK_CYCLES.CACHE_LOCK_DURATION",
         "PublicDescription": "Cycles in which the L1D is locked.",
@@ -388,8 +312,6 @@
     },
     {
         "BriefDescription": "Core-originated cacheable demand requests mis=
sed L3",
-        "Counter": "0,1,2,3",
-        "CounterHTOff": "0,1,2,3,4,5,6,7",
         "EventCode": "0x2E",
         "EventName": "LONGEST_LAT_CACHE.MISS",
         "PublicDescription": "This event counts each cache miss condition =
for references to the last level cache.",
@@ -398,8 +320,6 @@
     },
     {
         "BriefDescription": "Core-originated cacheable demand requests tha=
t refer to L3",
-        "Counter": "0,1,2,3",
-        "CounterHTOff": "0,1,2,3,4,5,6,7",
         "EventCode": "0x2E",
         "EventName": "LONGEST_LAT_CACHE.REFERENCE",
         "PublicDescription": "This event counts requests originating from =
the core that reference a cache line in the last level cache.",
@@ -408,8 +328,6 @@
     },
     {
         "BriefDescription": "Retired load uops which data sources were L3 =
and cross-core snoop hits in on-pkg core cache.",
-        "Counter": "0,1,2,3",
-        "CounterHTOff": "0,1,2,3",
         "Data_LA": "1",
         "Errata": "HSD29, HSD25, HSM26, HSM30",
         "EventCode": "0xD2",
@@ -420,8 +338,6 @@
     },
     {
         "BriefDescription": "Retired load uops which data sources were Hit=
M responses from shared L3.",
-        "Counter": "0,1,2,3",
-        "CounterHTOff": "0,1,2,3",
         "Data_LA": "1",
         "Errata": "HSD29, HSD25, HSM26, HSM30",
         "EventCode": "0xD2",
@@ -432,8 +348,6 @@
     },
     {
         "BriefDescription": "Retired load uops which data sources were L3 =
hit and cross-core snoop missed in on-pkg core cache.",
-        "Counter": "0,1,2,3",
-        "CounterHTOff": "0,1,2,3",
         "Data_LA": "1",
         "Errata": "HSD29, HSD25, HSM26, HSM30",
         "EventCode": "0xD2",
@@ -444,8 +358,6 @@
     },
     {
         "BriefDescription": "Retired load uops which data sources were hit=
s in L3 without snoops required.",
-        "Counter": "0,1,2,3",
-        "CounterHTOff": "0,1,2,3",
         "Data_LA": "1",
         "Errata": "HSD74, HSD29, HSD25, HSM26, HSM30",
         "EventCode": "0xD2",
@@ -456,8 +368,6 @@
     },
     {
         "BriefDescription": "Data from local DRAM either Snoop not needed =
or Snoop Miss (RspI)",
-        "Counter": "0,1,2,3",
-        "CounterHTOff": "0,1,2,3",
         "Data_LA": "1",
         "Errata": "HSD74, HSD29, HSD25, HSM30",
         "EventCode": "0xD3",
@@ -469,8 +379,6 @@
     },
     {
         "BriefDescription": "Retired load uop whose Data Source was: remot=
e DRAM either Snoop not needed or Snoop Miss (RspI)",
-        "Counter": "0,1,2,3",
-        "CounterHTOff": "0,1,2,3",
         "Data_LA": "1",
         "Errata": "HSD29, HSM30",
         "EventCode": "0xD3",
@@ -481,8 +389,6 @@
     },
     {
         "BriefDescription": "Retired load uop whose Data Source was: forwa=
rded from remote cache",
-        "Counter": "0,1,2,3",
-        "CounterHTOff": "0,1,2,3",
         "Data_LA": "1",
         "Errata": "HSM30",
         "EventCode": "0xD3",
@@ -493,8 +399,6 @@
     },
     {
         "BriefDescription": "Retired load uop whose Data Source was: Remot=
e cache HITM",
-        "Counter": "0,1,2,3",
-        "CounterHTOff": "0,1,2,3",
         "Data_LA": "1",
         "Errata": "HSM30",
         "EventCode": "0xD3",
@@ -505,8 +409,6 @@
     },
     {
         "BriefDescription": "Retired load uops which data sources were loa=
d uops missed L1 but hit FB due to preceding miss to the same cache line wi=
th data not ready.",
-        "Counter": "0,1,2,3",
-        "CounterHTOff": "0,1,2,3",
         "Data_LA": "1",
         "Errata": "HSM30",
         "EventCode": "0xD1",
@@ -517,8 +419,6 @@
     },
     {
         "BriefDescription": "Retired load uops with L1 cache hits as data =
sources.",
-        "Counter": "0,1,2,3",
-        "CounterHTOff": "0,1,2,3",
         "Data_LA": "1",
         "Errata": "HSD29, HSM30",
         "EventCode": "0xD1",
@@ -529,8 +429,6 @@
     },
     {
         "BriefDescription": "Retired load uops misses in L1 cache as data =
sources.",
-        "Counter": "0,1,2,3",
-        "CounterHTOff": "0,1,2,3",
         "Data_LA": "1",
         "Errata": "HSM30",
         "EventCode": "0xD1",
@@ -542,8 +440,6 @@
     },
     {
         "BriefDescription": "Retired load uops with L2 cache hits as data =
sources.",
-        "Counter": "0,1,2,3",
-        "CounterHTOff": "0,1,2,3",
         "Data_LA": "1",
         "Errata": "HSD76, HSD29, HSM30",
         "EventCode": "0xD1",
@@ -554,8 +450,6 @@
     },
     {
         "BriefDescription": "Miss in mid-level (L2) cache. Excludes Unknow=
n data-source.",
-        "Counter": "0,1,2,3",
-        "CounterHTOff": "0,1,2,3",
         "Data_LA": "1",
         "Errata": "HSD29, HSM30",
         "EventCode": "0xD1",
@@ -567,8 +461,6 @@
     },
     {
         "BriefDescription": "Retired load uops which data sources were dat=
a hits in L3 without snoops required.",
-        "Counter": "0,1,2,3",
-        "CounterHTOff": "0,1,2,3",
         "Data_LA": "1",
         "Errata": "HSD74, HSD29, HSD25, HSM26, HSM30",
         "EventCode": "0xD1",
@@ -580,8 +472,6 @@
     },
     {
         "BriefDescription": "Miss in last-level (L3) cache. Excludes Unkno=
wn data-source.",
-        "Counter": "0,1,2,3",
-        "CounterHTOff": "0,1,2,3",
         "Data_LA": "1",
         "Errata": "HSD74, HSD29, HSD25, HSM26, HSM30",
         "EventCode": "0xD1",
@@ -593,8 +483,6 @@
     },
     {
         "BriefDescription": "Retired load uops.",
-        "Counter": "0,1,2,3",
-        "CounterHTOff": "0,1,2,3",
         "Data_LA": "1",
         "Errata": "HSD29, HSM30",
         "EventCode": "0xD0",
@@ -606,13 +494,10 @@
     },
     {
         "BriefDescription": "Retired store uops.",
-        "Counter": "0,1,2,3",
-        "CounterHTOff": "0,1,2,3",
         "Data_LA": "1",
         "Errata": "HSD29, HSM30",
         "EventCode": "0xD0",
         "EventName": "MEM_UOPS_RETIRED.ALL_STORES",
-        "L1_Hit_Indication": "1",
         "PEBS": "1",
         "PublicDescription": "Counts all retired store uops.",
         "SampleAfterValue": "2000003",
@@ -620,8 +505,6 @@
     },
     {
         "BriefDescription": "Retired load uops with locked access.",
-        "Counter": "0,1,2,3",
-        "CounterHTOff": "0,1,2,3",
         "Data_LA": "1",
         "Errata": "HSD76, HSD29, HSM30",
         "EventCode": "0xD0",
@@ -632,8 +515,6 @@
     },
     {
         "BriefDescription": "Retired load uops that split across a cacheli=
ne boundary.",
-        "Counter": "0,1,2,3",
-        "CounterHTOff": "0,1,2,3",
         "Data_LA": "1",
         "Errata": "HSD29, HSM30",
         "EventCode": "0xD0",
@@ -644,21 +525,16 @@
     },
     {
         "BriefDescription": "Retired store uops that split across a cachel=
ine boundary.",
-        "Counter": "0,1,2,3",
-        "CounterHTOff": "0,1,2,3",
         "Data_LA": "1",
         "Errata": "HSD29, HSM30",
         "EventCode": "0xD0",
         "EventName": "MEM_UOPS_RETIRED.SPLIT_STORES",
-        "L1_Hit_Indication": "1",
         "PEBS": "1",
         "SampleAfterValue": "100003",
         "UMask": "0x42"
     },
     {
         "BriefDescription": "Retired load uops that miss the STLB.",
-        "Counter": "0,1,2,3",
-        "CounterHTOff": "0,1,2,3",
         "Data_LA": "1",
         "Errata": "HSD29, HSM30",
         "EventCode": "0xD0",
@@ -669,21 +545,16 @@
     },
     {
         "BriefDescription": "Retired store uops that miss the STLB.",
-        "Counter": "0,1,2,3",
-        "CounterHTOff": "0,1,2,3",
         "Data_LA": "1",
         "Errata": "HSD29, HSM30",
         "EventCode": "0xD0",
         "EventName": "MEM_UOPS_RETIRED.STLB_MISS_STORES",
-        "L1_Hit_Indication": "1",
         "PEBS": "1",
         "SampleAfterValue": "100003",
         "UMask": "0x12"
     },
     {
         "BriefDescription": "Demand and prefetch data reads",
-        "Counter": "0,1,2,3",
-        "CounterHTOff": "0,1,2,3,4,5,6,7",
         "EventCode": "0xB0",
         "EventName": "OFFCORE_REQUESTS.ALL_DATA_RD",
         "PublicDescription": "Data read requests sent to uncore (demand an=
d prefetch).",
@@ -692,8 +563,6 @@
     },
     {
         "BriefDescription": "Cacheable and noncacheable code read requests=
",
-        "Counter": "0,1,2,3",
-        "CounterHTOff": "0,1,2,3,4,5,6,7",
         "EventCode": "0xB0",
         "EventName": "OFFCORE_REQUESTS.DEMAND_CODE_RD",
         "PublicDescription": "Demand code read requests sent to uncore.",
@@ -702,8 +571,6 @@
     },
     {
         "BriefDescription": "Demand Data Read requests sent to uncore",
-        "Counter": "0,1,2,3",
-        "CounterHTOff": "0,1,2,3,4,5,6,7",
         "Errata": "HSD78, HSM80",
         "EventCode": "0xb0",
         "EventName": "OFFCORE_REQUESTS.DEMAND_DATA_RD",
@@ -713,8 +580,6 @@
     },
     {
         "BriefDescription": "Demand RFO requests including regular RFOs, l=
ocks, ItoM",
-        "Counter": "0,1,2,3",
-        "CounterHTOff": "0,1,2,3,4,5,6,7",
         "EventCode": "0xB0",
         "EventName": "OFFCORE_REQUESTS.DEMAND_RFO",
         "PublicDescription": "Demand RFO read requests sent to uncore, inc=
luding regular RFOs, locks, ItoM.",
@@ -723,8 +588,6 @@
     },
     {
         "BriefDescription": "Offcore requests buffer cannot take more entr=
ies for this thread core.",
-        "Counter": "0,1,2,3",
-        "CounterHTOff": "0,1,2,3,4,5,6,7",
         "EventCode": "0xb2",
         "EventName": "OFFCORE_REQUESTS_BUFFER.SQ_FULL",
         "SampleAfterValue": "2000003",
@@ -732,8 +595,6 @@
     },
     {
         "BriefDescription": "Offcore outstanding cacheable Core Data Read =
transactions in SuperQueue (SQ), queue to uncore",
-        "Counter": "0,1,2,3",
-        "CounterHTOff": "0,1,2,3,4,5,6,7",
         "Errata": "HSD62, HSD61, HSM63",
         "EventCode": "0x60",
         "EventName": "OFFCORE_REQUESTS_OUTSTANDING.ALL_DATA_RD",
@@ -743,8 +604,6 @@
     },
     {
         "BriefDescription": "Cycles when offcore outstanding cacheable Cor=
e Data Read transactions are present in SuperQueue (SQ), queue to uncore.",
-        "Counter": "0,1,2,3",
-        "CounterHTOff": "0,1,2,3,4,5,6,7",
         "CounterMask": "1",
         "Errata": "HSD62, HSD61, HSM63",
         "EventCode": "0x60",
@@ -754,8 +613,6 @@
     },
     {
         "BriefDescription": "Cycles when offcore outstanding Demand Data R=
ead transactions are present in SuperQueue (SQ), queue to uncore.",
-        "Counter": "0,1,2,3",
-        "CounterHTOff": "0,1,2,3,4,5,6,7",
         "CounterMask": "1",
         "Errata": "HSD78, HSD62, HSD61, HSM63, HSM80",
         "EventCode": "0x60",
@@ -765,8 +622,6 @@
     },
     {
         "BriefDescription": "Offcore outstanding demand rfo reads transact=
ions in SuperQueue (SQ), queue to uncore, every cycle.",
-        "Counter": "0,1,2,3",
-        "CounterHTOff": "0,1,2,3,4,5,6,7",
         "CounterMask": "1",
         "Errata": "HSD62, HSD61, HSM63",
         "EventCode": "0x60",
@@ -776,8 +631,6 @@
     },
     {
         "BriefDescription": "Offcore outstanding code reads transactions i=
n SuperQueue (SQ), queue to uncore, every cycle",
-        "Counter": "0,1,2,3",
-        "CounterHTOff": "0,1,2,3,4,5,6,7",
         "Errata": "HSD62, HSD61, HSM63",
         "EventCode": "0x60",
         "EventName": "OFFCORE_REQUESTS_OUTSTANDING.DEMAND_CODE_RD",
@@ -787,8 +640,6 @@
     },
     {
         "BriefDescription": "Offcore outstanding Demand Data Read transact=
ions in uncore queue.",
-        "Counter": "0,1,2,3",
-        "CounterHTOff": "0,1,2,3,4,5,6,7",
         "Errata": "HSD78, HSD62, HSD61, HSM63, HSM80",
         "EventCode": "0x60",
         "EventName": "OFFCORE_REQUESTS_OUTSTANDING.DEMAND_DATA_RD",
@@ -798,8 +649,6 @@
     },
     {
         "BriefDescription": "Cycles with at least 6 offcore outstanding De=
mand Data Read transactions in uncore queue.",
-        "Counter": "0,1,2,3",
-        "CounterHTOff": "0,1,2,3,4,5,6,7",
         "CounterMask": "6",
         "Errata": "HSD78, HSD62, HSD61, HSM63, HSM80",
         "EventCode": "0x60",
@@ -809,8 +658,6 @@
     },
     {
         "BriefDescription": "Offcore outstanding RFO store transactions in=
 SuperQueue (SQ), queue to uncore",
-        "Counter": "0,1,2,3",
-        "CounterHTOff": "0,1,2,3,4,5,6,7",
         "Errata": "HSD62, HSD61, HSM63",
         "EventCode": "0x60",
         "EventName": "OFFCORE_REQUESTS_OUTSTANDING.DEMAND_RFO",
@@ -820,8 +667,6 @@
     },
     {
         "BriefDescription": "Offcore response can be programmed only with =
a specific pair of event select and counter MSR, and with specific event co=
des and predefine mask bit value in a dedicated MSR to specify attributes o=
f the offcore transaction.",
-        "Counter": "0,1,2,3",
-        "CounterHTOff": "0,1,2,3",
         "EventCode": "0xB7, 0xBB",
         "EventName": "OFFCORE_RESPONSE",
         "SampleAfterValue": "100003",
@@ -829,248 +674,186 @@
     },
     {
         "BriefDescription": "Counts all demand & prefetch code reads hit i=
n the L3 and the snoops to sibling cores hit in either E/S state and the li=
ne is not forwarded",
-        "Counter": "0,1,2,3",
-        "CounterHTOff": "0,1,2,3",
         "EventCode": "0xB7, 0xBB",
         "EventName": "OFFCORE_RESPONSE.ALL_CODE_RD.LLC_HIT.HIT_OTHER_CORE_=
NO_FWD",
         "MSRIndex": "0x1a6,0x1a7",
         "MSRValue": "0x4003C0244",
-        "Offcore": "1",
         "SampleAfterValue": "100003",
         "UMask": "0x1"
     },
     {
         "BriefDescription": "Counts all demand & prefetch data reads hit i=
n the L3 and the snoop to one of the sibling cores hits the line in M state=
 and the line is forwarded",
-        "Counter": "0,1,2,3",
-        "CounterHTOff": "0,1,2,3",
         "EventCode": "0xB7, 0xBB",
         "EventName": "OFFCORE_RESPONSE.ALL_DATA_RD.LLC_HIT.HITM_OTHER_CORE=
",
         "MSRIndex": "0x1a6,0x1a7",
         "MSRValue": "0x10003C0091",
-        "Offcore": "1",
         "SampleAfterValue": "100003",
         "UMask": "0x1"
     },
     {
         "BriefDescription": "Counts all demand & prefetch data reads hit i=
n the L3 and the snoops to sibling cores hit in either E/S state and the li=
ne is not forwarded",
-        "Counter": "0,1,2,3",
-        "CounterHTOff": "0,1,2,3",
         "EventCode": "0xB7, 0xBB",
         "EventName": "OFFCORE_RESPONSE.ALL_DATA_RD.LLC_HIT.HIT_OTHER_CORE_=
NO_FWD",
         "MSRIndex": "0x1a6,0x1a7",
         "MSRValue": "0x4003C0091",
-        "Offcore": "1",
         "SampleAfterValue": "100003",
         "UMask": "0x1"
     },
     {
         "BriefDescription": "Counts all data/code/rfo reads (demand & pref=
etch) hit in the L3 and the snoop to one of the sibling cores hits the line=
 in M state and the line is forwarded",
-        "Counter": "0,1,2,3",
-        "CounterHTOff": "0,1,2,3",
         "EventCode": "0xB7, 0xBB",
         "EventName": "OFFCORE_RESPONSE.ALL_READS.LLC_HIT.HITM_OTHER_CORE",
         "MSRIndex": "0x1a6,0x1a7",
         "MSRValue": "0x10003C07F7",
-        "Offcore": "1",
         "SampleAfterValue": "100003",
         "UMask": "0x1"
     },
     {
         "BriefDescription": "Counts all data/code/rfo reads (demand & pref=
etch) hit in the L3 and the snoops to sibling cores hit in either E/S state=
 and the line is not forwarded",
-        "Counter": "0,1,2,3",
-        "CounterHTOff": "0,1,2,3",
         "EventCode": "0xB7, 0xBB",
         "EventName": "OFFCORE_RESPONSE.ALL_READS.LLC_HIT.HIT_OTHER_CORE_NO=
_FWD",
         "MSRIndex": "0x1a6,0x1a7",
         "MSRValue": "0x4003C07F7",
-        "Offcore": "1",
         "SampleAfterValue": "100003",
         "UMask": "0x1"
     },
     {
         "BriefDescription": "Counts all requests hit in the L3",
-        "Counter": "0,1,2,3",
-        "CounterHTOff": "0,1,2,3",
         "EventCode": "0xB7, 0xBB",
         "EventName": "OFFCORE_RESPONSE.ALL_REQUESTS.LLC_HIT.ANY_RESPONSE",
         "MSRIndex": "0x1a6,0x1a7",
         "MSRValue": "0x3F803C8FFF",
-        "Offcore": "1",
         "SampleAfterValue": "100003",
         "UMask": "0x1"
     },
     {
         "BriefDescription": "Counts all demand & prefetch RFOs hit in the =
L3 and the snoop to one of the sibling cores hits the line in M state and t=
he line is forwarded",
-        "Counter": "0,1,2,3",
-        "CounterHTOff": "0,1,2,3",
         "EventCode": "0xB7, 0xBB",
         "EventName": "OFFCORE_RESPONSE.ALL_RFO.LLC_HIT.HITM_OTHER_CORE",
         "MSRIndex": "0x1a6,0x1a7",
         "MSRValue": "0x10003C0122",
-        "Offcore": "1",
         "SampleAfterValue": "100003",
         "UMask": "0x1"
     },
     {
         "BriefDescription": "Counts all demand & prefetch RFOs hit in the =
L3 and the snoops to sibling cores hit in either E/S state and the line is =
not forwarded",
-        "Counter": "0,1,2,3",
-        "CounterHTOff": "0,1,2,3",
         "EventCode": "0xB7, 0xBB",
         "EventName": "OFFCORE_RESPONSE.ALL_RFO.LLC_HIT.HIT_OTHER_CORE_NO_F=
WD",
         "MSRIndex": "0x1a6,0x1a7",
         "MSRValue": "0x4003C0122",
-        "Offcore": "1",
         "SampleAfterValue": "100003",
         "UMask": "0x1"
     },
     {
         "BriefDescription": "Counts all demand code reads hit in the L3 an=
d the snoop to one of the sibling cores hits the line in M state and the li=
ne is forwarded",
-        "Counter": "0,1,2,3",
-        "CounterHTOff": "0,1,2,3",
         "EventCode": "0xB7, 0xBB",
         "EventName": "OFFCORE_RESPONSE.DEMAND_CODE_RD.LLC_HIT.HITM_OTHER_C=
ORE",
         "MSRIndex": "0x1a6,0x1a7",
         "MSRValue": "0x10003C0004",
-        "Offcore": "1",
         "SampleAfterValue": "100003",
         "UMask": "0x1"
     },
     {
         "BriefDescription": "Counts all demand code reads hit in the L3 an=
d the snoops to sibling cores hit in either E/S state and the line is not f=
orwarded",
-        "Counter": "0,1,2,3",
-        "CounterHTOff": "0,1,2,3",
         "EventCode": "0xB7, 0xBB",
         "EventName": "OFFCORE_RESPONSE.DEMAND_CODE_RD.LLC_HIT.HIT_OTHER_CO=
RE_NO_FWD",
         "MSRIndex": "0x1a6,0x1a7",
         "MSRValue": "0x4003C0004",
-        "Offcore": "1",
         "SampleAfterValue": "100003",
         "UMask": "0x1"
     },
     {
         "BriefDescription": "Counts demand data reads hit in the L3 and th=
e snoop to one of the sibling cores hits the line in M state and the line i=
s forwarded",
-        "Counter": "0,1,2,3",
-        "CounterHTOff": "0,1,2,3",
         "EventCode": "0xB7, 0xBB",
         "EventName": "OFFCORE_RESPONSE.DEMAND_DATA_RD.LLC_HIT.HITM_OTHER_C=
ORE",
         "MSRIndex": "0x1a6,0x1a7",
         "MSRValue": "0x10003C0001",
-        "Offcore": "1",
         "SampleAfterValue": "100003",
         "UMask": "0x1"
     },
     {
         "BriefDescription": "Counts demand data reads hit in the L3 and th=
e snoops to sibling cores hit in either E/S state and the line is not forwa=
rded",
-        "Counter": "0,1,2,3",
-        "CounterHTOff": "0,1,2,3",
         "EventCode": "0xB7, 0xBB",
         "EventName": "OFFCORE_RESPONSE.DEMAND_DATA_RD.LLC_HIT.HIT_OTHER_CO=
RE_NO_FWD",
         "MSRIndex": "0x1a6,0x1a7",
         "MSRValue": "0x4003C0001",
-        "Offcore": "1",
         "SampleAfterValue": "100003",
         "UMask": "0x1"
     },
     {
         "BriefDescription": "Counts all demand data writes (RFOs) hit in t=
he L3 and the snoop to one of the sibling cores hits the line in M state an=
d the line is forwarded",
-        "Counter": "0,1,2,3",
-        "CounterHTOff": "0,1,2,3",
         "EventCode": "0xB7, 0xBB",
         "EventName": "OFFCORE_RESPONSE.DEMAND_RFO.LLC_HIT.HITM_OTHER_CORE"=
,
         "MSRIndex": "0x1a6,0x1a7",
         "MSRValue": "0x10003C0002",
-        "Offcore": "1",
         "SampleAfterValue": "100003",
         "UMask": "0x1"
     },
     {
         "BriefDescription": "Counts all demand data writes (RFOs) hit in t=
he L3 and the snoops to sibling cores hit in either E/S state and the line =
is not forwarded",
-        "Counter": "0,1,2,3",
-        "CounterHTOff": "0,1,2,3",
         "EventCode": "0xB7, 0xBB",
         "EventName": "OFFCORE_RESPONSE.DEMAND_RFO.LLC_HIT.HIT_OTHER_CORE_N=
O_FWD",
         "MSRIndex": "0x1a6,0x1a7",
         "MSRValue": "0x4003C0002",
-        "Offcore": "1",
         "SampleAfterValue": "100003",
         "UMask": "0x1"
     },
     {
         "BriefDescription": "Counts all prefetch (that bring data to LLC o=
nly) code reads hit in the L3",
-        "Counter": "0,1,2,3",
-        "CounterHTOff": "0,1,2,3",
         "EventCode": "0xB7, 0xBB",
         "EventName": "OFFCORE_RESPONSE.PF_L2_CODE_RD.LLC_HIT.ANY_RESPONSE"=
,
         "MSRIndex": "0x1a6,0x1a7",
         "MSRValue": "0x3F803C0040",
-        "Offcore": "1",
         "SampleAfterValue": "100003",
         "UMask": "0x1"
     },
     {
         "BriefDescription": "Counts prefetch (that bring data to L2) data =
reads hit in the L3",
-        "Counter": "0,1,2,3",
-        "CounterHTOff": "0,1,2,3",
         "EventCode": "0xB7, 0xBB",
         "EventName": "OFFCORE_RESPONSE.PF_L2_DATA_RD.LLC_HIT.ANY_RESPONSE"=
,
         "MSRIndex": "0x1a6,0x1a7",
         "MSRValue": "0x3F803C0010",
-        "Offcore": "1",
         "SampleAfterValue": "100003",
         "UMask": "0x1"
     },
     {
         "BriefDescription": "Counts all prefetch (that bring data to L2) R=
FOs hit in the L3",
-        "Counter": "0,1,2,3",
-        "CounterHTOff": "0,1,2,3",
         "EventCode": "0xB7, 0xBB",
         "EventName": "OFFCORE_RESPONSE.PF_L2_RFO.LLC_HIT.ANY_RESPONSE",
         "MSRIndex": "0x1a6,0x1a7",
         "MSRValue": "0x3F803C0020",
-        "Offcore": "1",
         "SampleAfterValue": "100003",
         "UMask": "0x1"
     },
     {
         "BriefDescription": "Counts prefetch (that bring data to LLC only)=
 code reads hit in the L3",
-        "Counter": "0,1,2,3",
-        "CounterHTOff": "0,1,2,3",
         "EventCode": "0xB7, 0xBB",
         "EventName": "OFFCORE_RESPONSE.PF_LLC_CODE_RD.LLC_HIT.ANY_RESPONSE=
",
         "MSRIndex": "0x1a6,0x1a7",
         "MSRValue": "0x3F803C0200",
-        "Offcore": "1",
         "SampleAfterValue": "100003",
         "UMask": "0x1"
     },
     {
         "BriefDescription": "Counts all prefetch (that bring data to LLC o=
nly) data reads hit in the L3",
-        "Counter": "0,1,2,3",
-        "CounterHTOff": "0,1,2,3",
         "EventCode": "0xB7, 0xBB",
         "EventName": "OFFCORE_RESPONSE.PF_LLC_DATA_RD.LLC_HIT.ANY_RESPONSE=
",
         "MSRIndex": "0x1a6,0x1a7",
         "MSRValue": "0x3F803C0080",
-        "Offcore": "1",
         "SampleAfterValue": "100003",
         "UMask": "0x1"
     },
     {
         "BriefDescription": "Counts all prefetch (that bring data to LLC o=
nly) RFOs hit in the L3",
-        "Counter": "0,1,2,3",
-        "CounterHTOff": "0,1,2,3",
         "EventCode": "0xB7, 0xBB",
         "EventName": "OFFCORE_RESPONSE.PF_LLC_RFO.LLC_HIT.ANY_RESPONSE",
         "MSRIndex": "0x1a6,0x1a7",
         "MSRValue": "0x3F803C0100",
-        "Offcore": "1",
         "SampleAfterValue": "100003",
         "UMask": "0x1"
     },
     {
         "BriefDescription": "Split locks in SQ",
-        "Counter": "0,1,2,3",
-        "CounterHTOff": "0,1,2,3,4,5,6,7",
         "EventCode": "0xf4",
         "EventName": "SQ_MISC.SPLIT_LOCK",
         "SampleAfterValue": "100003",
diff --git a/tools/perf/pmu-events/arch/x86/haswellx/floating-point.json b/=
tools/perf/pmu-events/arch/x86/haswellx/floating-point.json
index 7cf203a90a74..8fcc10f74ad9 100644
--- a/tools/perf/pmu-events/arch/x86/haswellx/floating-point.json
+++ b/tools/perf/pmu-events/arch/x86/haswellx/floating-point.json
@@ -1,8 +1,6 @@
 [
     {
         "BriefDescription": "Approximate counts of AVX & AVX2 256-bit inst=
ructions, including non-arithmetic instructions, loads, and stores.  May co=
unt non-AVX instructions that employ 256-bit operations, including (but not=
 necessarily limited to) rep string instructions that use 256-bit loads and=
 stores for optimized performance, XSAVE* and XRSTOR*, and operations that =
transition the x87 FPU data registers between x87 and MMX.",
-        "Counter": "0,1,2,3",
-        "CounterHTOff": "0,1,2,3,4,5,6,7",
         "EventCode": "0xC6",
         "EventName": "AVX_INSTS.ALL",
         "PublicDescription": "Note that a whole rep string only counts AVX=
_INST.ALL once.",
@@ -11,8 +9,6 @@
     },
     {
         "BriefDescription": "Cycles with any input/output SSE or FP assist=
",
-        "Counter": "0,1,2,3",
-        "CounterHTOff": "0,1,2,3",
         "CounterMask": "1",
         "EventCode": "0xCA",
         "EventName": "FP_ASSIST.ANY",
@@ -22,8 +18,6 @@
     },
     {
         "BriefDescription": "Number of SIMD FP assists due to input values=
",
-        "Counter": "0,1,2,3",
-        "CounterHTOff": "0,1,2,3,4,5,6,7",
         "EventCode": "0xCA",
         "EventName": "FP_ASSIST.SIMD_INPUT",
         "PublicDescription": "Number of SIMD FP assists due to input value=
s.",
@@ -32,8 +26,6 @@
     },
     {
         "BriefDescription": "Number of SIMD FP assists due to Output value=
s",
-        "Counter": "0,1,2,3",
-        "CounterHTOff": "0,1,2,3,4,5,6,7",
         "EventCode": "0xCA",
         "EventName": "FP_ASSIST.SIMD_OUTPUT",
         "PublicDescription": "Number of SIMD FP assists due to output valu=
es.",
@@ -42,8 +34,6 @@
     },
     {
         "BriefDescription": "Number of X87 assists due to input value.",
-        "Counter": "0,1,2,3",
-        "CounterHTOff": "0,1,2,3,4,5,6,7",
         "EventCode": "0xCA",
         "EventName": "FP_ASSIST.X87_INPUT",
         "PublicDescription": "Number of X87 FP assists due to input values=
.",
@@ -52,8 +42,6 @@
     },
     {
         "BriefDescription": "Number of X87 assists due to output value.",
-        "Counter": "0,1,2,3",
-        "CounterHTOff": "0,1,2,3,4,5,6,7",
         "EventCode": "0xCA",
         "EventName": "FP_ASSIST.X87_OUTPUT",
         "PublicDescription": "Number of X87 FP assists due to output value=
s.",
@@ -62,8 +50,6 @@
     },
     {
         "BriefDescription": "Number of SIMD Move Elimination candidate uop=
s that were eliminated.",
-        "Counter": "0,1,2,3",
-        "CounterHTOff": "0,1,2,3,4,5,6,7",
         "EventCode": "0x58",
         "EventName": "MOVE_ELIMINATION.SIMD_ELIMINATED",
         "PublicDescription": "Number of SIMD move elimination candidate uo=
ps that were eliminated.",
@@ -72,8 +58,6 @@
     },
     {
         "BriefDescription": "Number of SIMD Move Elimination candidate uop=
s that were not eliminated.",
-        "Counter": "0,1,2,3",
-        "CounterHTOff": "0,1,2,3,4,5,6,7",
         "EventCode": "0x58",
         "EventName": "MOVE_ELIMINATION.SIMD_NOT_ELIMINATED",
         "PublicDescription": "Number of SIMD move elimination candidate uo=
ps that were not eliminated.",
@@ -82,8 +66,6 @@
     },
     {
         "BriefDescription": "Number of transitions from AVX-256 to legacy =
SSE when penalty applicable.",
-        "Counter": "0,1,2,3",
-        "CounterHTOff": "0,1,2,3,4,5,6,7",
         "Errata": "HSD56, HSM57",
         "EventCode": "0xC1",
         "EventName": "OTHER_ASSISTS.AVX_TO_SSE",
@@ -92,8 +74,6 @@
     },
     {
         "BriefDescription": "Number of transitions from SSE to AVX-256 whe=
n penalty applicable.",
-        "Counter": "0,1,2,3",
-        "CounterHTOff": "0,1,2,3,4,5,6,7",
         "Errata": "HSD56, HSM57",
         "EventCode": "0xC1",
         "EventName": "OTHER_ASSISTS.SSE_TO_AVX",
diff --git a/tools/perf/pmu-events/arch/x86/haswellx/frontend.json b/tools/=
perf/pmu-events/arch/x86/haswellx/frontend.json
index 18a993297108..73d6d681dfa7 100644
--- a/tools/perf/pmu-events/arch/x86/haswellx/frontend.json
+++ b/tools/perf/pmu-events/arch/x86/haswellx/frontend.json
@@ -1,8 +1,6 @@
 [
     {
         "BriefDescription": "Counts the total number when the front end is=
 resteered, mainly when the BPU cannot provide a correct prediction and thi=
s is corrected by other branch handling mechanisms at the front end.",
-        "Counter": "0,1,2,3",
-        "CounterHTOff": "0,1,2,3,4,5,6,7",
         "EventCode": "0xe6",
         "EventName": "BACLEARS.ANY",
         "PublicDescription": "Number of front end re-steers due to BPU mis=
prediction.",
@@ -11,8 +9,6 @@
     },
     {
         "BriefDescription": "Decode Stream Buffer (DSB)-to-MITE switch tru=
e penalty cycles.",
-        "Counter": "0,1,2,3",
-        "CounterHTOff": "0,1,2,3,4,5,6,7",
         "EventCode": "0xAB",
         "EventName": "DSB2MITE_SWITCHES.PENALTY_CYCLES",
         "SampleAfterValue": "2000003",
@@ -20,8 +16,6 @@
     },
     {
         "BriefDescription": "Number of Instruction Cache, Streaming Buffer=
 and Victim Cache Reads. both cacheable and noncacheable, including UC fetc=
hes.",
-        "Counter": "0,1,2,3",
-        "CounterHTOff": "0,1,2,3,4,5,6,7",
         "EventCode": "0x80",
         "EventName": "ICACHE.HIT",
         "SampleAfterValue": "2000003",
@@ -29,8 +23,6 @@
     },
     {
         "BriefDescription": "Cycles where a code fetch is stalled due to L=
1 instruction-cache miss.",
-        "Counter": "0,1,2,3",
-        "CounterHTOff": "0,1,2,3,4,5,6,7",
         "EventCode": "0x80",
         "EventName": "ICACHE.IFDATA_STALL",
         "SampleAfterValue": "2000003",
@@ -38,8 +30,6 @@
     },
     {
         "BriefDescription": "Cycles where a code fetch is stalled due to L=
1 instruction-cache miss.",
-        "Counter": "0,1,2,3",
-        "CounterHTOff": "0,1,2,3,4,5,6,7",
         "EventCode": "0x80",
         "EventName": "ICACHE.IFETCH_STALL",
         "SampleAfterValue": "2000003",
@@ -47,8 +37,6 @@
     },
     {
         "BriefDescription": "Number of Instruction Cache, Streaming Buffer=
 and Victim Cache Misses. Includes Uncacheable accesses.",
-        "Counter": "0,1,2,3",
-        "CounterHTOff": "0,1,2,3,4,5,6,7",
         "EventCode": "0x80",
         "EventName": "ICACHE.MISSES",
         "PublicDescription": "This event counts Instruction Cache (ICACHE)=
 misses.",
@@ -57,8 +45,6 @@
     },
     {
         "BriefDescription": "Cycles Decode Stream Buffer (DSB) is deliveri=
ng 4 Uops",
-        "Counter": "0,1,2,3",
-        "CounterHTOff": "0,1,2,3,4,5,6,7",
         "CounterMask": "4",
         "EventCode": "0x79",
         "EventName": "IDQ.ALL_DSB_CYCLES_4_UOPS",
@@ -68,8 +54,6 @@
     },
     {
         "BriefDescription": "Cycles Decode Stream Buffer (DSB) is deliveri=
ng any Uop",
-        "Counter": "0,1,2,3",
-        "CounterHTOff": "0,1,2,3,4,5,6,7",
         "CounterMask": "1",
         "EventCode": "0x79",
         "EventName": "IDQ.ALL_DSB_CYCLES_ANY_UOPS",
@@ -79,8 +63,6 @@
     },
     {
         "BriefDescription": "Cycles MITE is delivering 4 Uops",
-        "Counter": "0,1,2,3",
-        "CounterHTOff": "0,1,2,3,4,5,6,7",
         "CounterMask": "4",
         "EventCode": "0x79",
         "EventName": "IDQ.ALL_MITE_CYCLES_4_UOPS",
@@ -90,8 +72,6 @@
     },
     {
         "BriefDescription": "Cycles MITE is delivering any Uop",
-        "Counter": "0,1,2,3",
-        "CounterHTOff": "0,1,2,3,4,5,6,7",
         "CounterMask": "1",
         "EventCode": "0x79",
         "EventName": "IDQ.ALL_MITE_CYCLES_ANY_UOPS",
@@ -101,8 +81,6 @@
     },
     {
         "BriefDescription": "Cycles when uops are being delivered to Instr=
uction Decode Queue (IDQ) from Decode Stream Buffer (DSB) path.",
-        "Counter": "0,1,2,3",
-        "CounterHTOff": "0,1,2,3,4,5,6,7",
         "CounterMask": "1",
         "EventCode": "0x79",
         "EventName": "IDQ.DSB_CYCLES",
@@ -111,8 +89,6 @@
     },
     {
         "BriefDescription": "Uops delivered to Instruction Decode Queue (I=
DQ) from the Decode Stream Buffer (DSB) path",
-        "Counter": "0,1,2,3",
-        "CounterHTOff": "0,1,2,3,4,5,6,7",
         "EventCode": "0x79",
         "EventName": "IDQ.DSB_UOPS",
         "PublicDescription": "Increment each cycle. # of uops delivered to=
 IDQ from DSB path. Set Cmask =3D 1 to count cycles.",
@@ -121,8 +97,6 @@
     },
     {
         "BriefDescription": "Instruction Decode Queue (IDQ) empty cycles",
-        "Counter": "0,1,2,3",
-        "CounterHTOff": "0,1,2,3",
         "Errata": "HSD135",
         "EventCode": "0x79",
         "EventName": "IDQ.EMPTY",
@@ -132,8 +106,6 @@
     },
     {
         "BriefDescription": "Uops delivered to Instruction Decode Queue (I=
DQ) from MITE path",
-        "Counter": "0,1,2,3",
-        "CounterHTOff": "0,1,2,3,4,5,6,7",
         "EventCode": "0x79",
         "EventName": "IDQ.MITE_ALL_UOPS",
         "PublicDescription": "Number of uops delivered to IDQ from any pat=
h.",
@@ -142,8 +114,6 @@
     },
     {
         "BriefDescription": "Cycles when uops are being delivered to Instr=
uction Decode Queue (IDQ) from MITE path.",
-        "Counter": "0,1,2,3",
-        "CounterHTOff": "0,1,2,3,4,5,6,7",
         "CounterMask": "1",
         "EventCode": "0x79",
         "EventName": "IDQ.MITE_CYCLES",
@@ -152,8 +122,6 @@
     },
     {
         "BriefDescription": "Uops delivered to Instruction Decode Queue (I=
DQ) from MITE path",
-        "Counter": "0,1,2,3",
-        "CounterHTOff": "0,1,2,3,4,5,6,7",
         "EventCode": "0x79",
         "EventName": "IDQ.MITE_UOPS",
         "PublicDescription": "Increment each cycle # of uops delivered to =
IDQ from MITE path. Set Cmask =3D 1 to count cycles.",
@@ -162,8 +130,6 @@
     },
     {
         "BriefDescription": "Cycles when uops are being delivered to Instr=
uction Decode Queue (IDQ) while Microcode Sequencer (MS) is busy",
-        "Counter": "0,1,2,3",
-        "CounterHTOff": "0,1,2,3,4,5,6,7",
         "CounterMask": "1",
         "EventCode": "0x79",
         "EventName": "IDQ.MS_CYCLES",
@@ -173,8 +139,6 @@
     },
     {
         "BriefDescription": "Cycles when uops initiated by Decode Stream B=
uffer (DSB) are being delivered to Instruction Decode Queue (IDQ) while Mic=
rocode Sequencer (MS) is busy.",
-        "Counter": "0,1,2,3",
-        "CounterHTOff": "0,1,2,3,4,5,6,7",
         "CounterMask": "1",
         "EventCode": "0x79",
         "EventName": "IDQ.MS_DSB_CYCLES",
@@ -183,8 +147,6 @@
     },
     {
         "BriefDescription": "Deliveries to Instruction Decode Queue (IDQ) =
initiated by Decode Stream Buffer (DSB) while Microcode Sequencer (MS) is b=
usy.",
-        "Counter": "0,1,2,3",
-        "CounterHTOff": "0,1,2,3,4,5,6,7",
         "CounterMask": "1",
         "EdgeDetect": "1",
         "EventCode": "0x79",
@@ -194,8 +156,6 @@
     },
     {
         "BriefDescription": "Uops initiated by Decode Stream Buffer (DSB) =
that are being delivered to Instruction Decode Queue (IDQ) while Microcode =
Sequencer (MS) is busy",
-        "Counter": "0,1,2,3",
-        "CounterHTOff": "0,1,2,3,4,5,6,7",
         "EventCode": "0x79",
         "EventName": "IDQ.MS_DSB_UOPS",
         "PublicDescription": "Increment each cycle # of uops delivered to =
IDQ when MS_busy by DSB. Set Cmask =3D 1 to count cycles. Add Edge=3D1 to c=
ount # of delivery.",
@@ -204,8 +164,6 @@
     },
     {
         "BriefDescription": "Uops initiated by MITE and delivered to Instr=
uction Decode Queue (IDQ) while Microcode Sequencer (MS) is busy",
-        "Counter": "0,1,2,3",
-        "CounterHTOff": "0,1,2,3,4,5,6,7",
         "EventCode": "0x79",
         "EventName": "IDQ.MS_MITE_UOPS",
         "PublicDescription": "Increment each cycle # of uops delivered to =
IDQ when MS_busy by MITE. Set Cmask =3D 1 to count cycles.",
@@ -214,8 +172,6 @@
     },
     {
         "BriefDescription": "Number of switches from DSB (Decode Stream Bu=
ffer) or MITE (legacy decode pipeline) to the Microcode Sequencer.",
-        "Counter": "0,1,2,3",
-        "CounterHTOff": "0,1,2,3,4,5,6,7",
         "CounterMask": "1",
         "EdgeDetect": "1",
         "EventCode": "0x79",
@@ -225,8 +181,6 @@
     },
     {
         "BriefDescription": "Uops delivered to Instruction Decode Queue (I=
DQ) while Microcode Sequencer (MS) is busy",
-        "Counter": "0,1,2,3",
-        "CounterHTOff": "0,1,2,3,4,5,6,7",
         "EventCode": "0x79",
         "EventName": "IDQ.MS_UOPS",
         "PublicDescription": "This event counts uops delivered by the Fron=
t-end with the assistance of the microcode sequencer.  Microcode assists ar=
e used for complex instructions or scenarios that can't be handled by the s=
tandard decoder.  Using other instructions, if possible, will usually impro=
ve performance.",
@@ -235,8 +189,6 @@
     },
     {
         "BriefDescription": "Uops not delivered to Resource Allocation Tab=
le (RAT) per thread when backend of the machine is not stalled",
-        "Counter": "0,1,2,3",
-        "CounterHTOff": "0,1,2,3",
         "Errata": "HSD135",
         "EventCode": "0x9C",
         "EventName": "IDQ_UOPS_NOT_DELIVERED.CORE",
@@ -246,8 +198,6 @@
     },
     {
         "BriefDescription": "Cycles per thread when 4 or more uops are not=
 delivered to Resource Allocation Table (RAT) when backend of the machine i=
s not stalled",
-        "Counter": "0,1,2,3",
-        "CounterHTOff": "0,1,2,3",
         "CounterMask": "4",
         "Errata": "HSD135",
         "EventCode": "0x9C",
@@ -258,8 +208,6 @@
     },
     {
         "BriefDescription": "Counts cycles FE delivered 4 uops or Resource=
 Allocation Table (RAT) was stalling FE.",
-        "Counter": "0,1,2,3",
-        "CounterHTOff": "0,1,2,3",
         "CounterMask": "1",
         "Errata": "HSD135",
         "EventCode": "0x9C",
@@ -270,8 +218,6 @@
     },
     {
         "BriefDescription": "Cycles per thread when 3 or more uops are not=
 delivered to Resource Allocation Table (RAT) when backend of the machine i=
s not stalled.",
-        "Counter": "0,1,2,3",
-        "CounterHTOff": "0,1,2,3",
         "CounterMask": "3",
         "Errata": "HSD135",
         "EventCode": "0x9C",
@@ -281,8 +227,6 @@
     },
     {
         "BriefDescription": "Cycles with less than 2 uops delivered by the=
 front end.",
-        "Counter": "0,1,2,3",
-        "CounterHTOff": "0,1,2,3",
         "CounterMask": "2",
         "Errata": "HSD135",
         "EventCode": "0x9C",
@@ -292,8 +236,6 @@
     },
     {
         "BriefDescription": "Cycles with less than 3 uops delivered by the=
 front end.",
-        "Counter": "0,1,2,3",
-        "CounterHTOff": "0,1,2,3",
         "CounterMask": "1",
         "Errata": "HSD135",
         "EventCode": "0x9C",
diff --git a/tools/perf/pmu-events/arch/x86/haswellx/hsx-metrics.json b/too=
ls/perf/pmu-events/arch/x86/haswellx/hsx-metrics.json
index 2cd86750986a..2e1fbc936d25 100644
--- a/tools/perf/pmu-events/arch/x86/haswellx/hsx-metrics.json
+++ b/tools/perf/pmu-events/arch/x86/haswellx/hsx-metrics.json
@@ -1,1040 +1,1023 @@
 [
     {
-        "BriefDescription": "This category represents fraction of slots wh=
ere the processor's Frontend undersupplies its Backend",
-        "MetricExpr": "IDQ_UOPS_NOT_DELIVERED.CORE / SLOTS",
-        "MetricGroup": "PGO;TopdownL1;tma_L1_group",
-        "MetricName": "tma_frontend_bound",
-        "PublicDescription": "This category represents fraction of slots w=
here the processor's Frontend undersupplies its Backend. Frontend denotes t=
he first part of the processor core responsible to fetch operations that ar=
e executed later on by the Backend part. Within the Frontend; a branch pred=
ictor predicts the next address to fetch; cache-lines are fetched from the =
memory subsystem; parsed into instructions; and lastly decoded into micro-o=
perations (uops). Ideally the Frontend can issue Machine_Width uops every c=
ycle to the Backend. Frontend Bound denotes unutilized issue-slots when the=
re is no Backend stall; i.e. bubbles where Frontend delivered no uops while=
 Backend could have accepted them. For example; stalls due to instruction-c=
ache misses would be categorized under Frontend Bound.",
-        "ScaleUnit": "100%"
+        "BriefDescription": "Instructions Per Cycle (per Logical Processor=
)",
+        "MetricExpr": "INST_RETIRED.ANY / CLKS",
+        "MetricGroup": "Ret;Summary",
+        "MetricName": "IPC"
     },
     {
-        "BriefDescription": "This metric represents fraction of slots the =
CPU was stalled due to Frontend latency issues",
-        "MetricExpr": "4 * min(CPU_CLK_UNHALTED.THREAD, IDQ_UOPS_NOT_DELIV=
ERED.CYCLES_0_UOPS_DELIV.CORE) / SLOTS",
-        "MetricGroup": "Frontend;TopdownL2;tma_L2_group;tma_frontend_bound=
_group",
-        "MetricName": "tma_fetch_latency",
-        "PublicDescription": "This metric represents fraction of slots the=
 CPU was stalled due to Frontend latency issues.  For example; instruction-=
cache misses; iTLB misses or fetch stalls after a branch misprediction are =
categorized under Frontend Latency. In such cases; the Frontend eventually =
delivers no uops for some period. Sample with: RS_EVENTS.EMPTY_END",
-        "ScaleUnit": "100%"
+        "BriefDescription": "Uops Per Instruction",
+        "MetricExpr": "UOPS_RETIRED.RETIRE_SLOTS / INST_RETIRED.ANY",
+        "MetricGroup": "Pipeline;Ret;Retire",
+        "MetricName": "UPI"
     },
     {
-        "BriefDescription": "This metric represents fraction of cycles the=
 CPU was stalled due to instruction cache misses.",
-        "MetricExpr": "ICACHE.IFDATA_STALL / CLKS",
-        "MetricGroup": "BigFoot;FetchLat;IcMiss;TopdownL3;tma_fetch_latenc=
y_group",
-        "MetricName": "tma_icache_misses",
-        "ScaleUnit": "100%"
+        "BriefDescription": "Instruction per taken branch",
+        "MetricExpr": "UOPS_RETIRED.RETIRE_SLOTS / BR_INST_RETIRED.NEAR_TA=
KEN",
+        "MetricGroup": "Branches;Fed;FetchBW",
+        "MetricName": "UpTB"
     },
     {
-        "BriefDescription": "This metric represents fraction of cycles the=
 CPU was stalled due to Instruction TLB (ITLB) misses",
-        "MetricExpr": "(14 * ITLB_MISSES.STLB_HIT + ITLB_MISSES.WALK_DURAT=
ION) / CLKS",
-        "MetricGroup": "BigFoot;FetchLat;MemoryTLB;TopdownL3;tma_fetch_lat=
ency_group",
-        "MetricName": "tma_itlb_misses",
-        "PublicDescription": "This metric represents fraction of cycles th=
e CPU was stalled due to Instruction TLB (ITLB) misses. Sample with: ITLB_M=
ISSES.WALK_COMPLETED",
-        "ScaleUnit": "100%"
+        "BriefDescription": "Cycles Per Instruction (per Logical Processor=
)",
+        "MetricExpr": "1 / IPC",
+        "MetricGroup": "Mem;Pipeline",
+        "MetricName": "CPI"
     },
     {
-        "BriefDescription": "This metric represents fraction of cycles the=
 CPU was stalled due to Branch Resteers",
-        "MetricExpr": "12 * (BR_MISP_RETIRED.ALL_BRANCHES + MACHINE_CLEARS=
.COUNT + BACLEARS.ANY) / CLKS",
-        "MetricGroup": "FetchLat;TopdownL3;tma_fetch_latency_group",
-        "MetricName": "tma_branch_resteers",
-        "PublicDescription": "This metric represents fraction of cycles th=
e CPU was stalled due to Branch Resteers. Branch Resteers estimates the Fro=
ntend delay in fetching operations from corrected path; following all sorts=
 of miss-predicted branches. For example; branchy code with lots of miss-pr=
edictions might get categorized under Branch Resteers. Note the value of th=
is node may overlap with its siblings. Sample with: BR_MISP_RETIRED.ALL_BRA=
NCHES",
-        "ScaleUnit": "100%"
+        "BriefDescription": "Per-Logical Processor actual clocks when the =
Logical Processor is active.",
+        "MetricExpr": "CPU_CLK_UNHALTED.THREAD",
+        "MetricGroup": "Pipeline",
+        "MetricName": "CLKS"
     },
     {
-        "BriefDescription": "This metric represents fraction of cycles the=
 CPU was stalled due to switches from DSB to MITE pipelines",
-        "MetricExpr": "DSB2MITE_SWITCHES.PENALTY_CYCLES / CLKS",
-        "MetricGroup": "DSBmiss;FetchLat;TopdownL3;tma_fetch_latency_group=
",
-        "MetricName": "tma_dsb_switches",
-        "PublicDescription": "This metric represents fraction of cycles th=
e CPU was stalled due to switches from DSB to MITE pipelines. The DSB (deco=
ded i-cache) is a Uop Cache where the front-end directly delivers Uops (mic=
ro operations) avoiding heavy x86 decoding. The DSB pipeline has shorter la=
tency and delivered higher bandwidth than the MITE (legacy instruction deco=
de pipeline). Switching between the two pipelines can cause penalties hence=
 this metric measures the exposed penalty.",
-        "ScaleUnit": "100%"
+        "BriefDescription": "Total issue-pipeline slots (per-Physical Core=
 till ICL; per-Logical Processor ICL onward)",
+        "MetricExpr": "4 * CORE_CLKS",
+        "MetricGroup": "tma_L1_group",
+        "MetricName": "SLOTS"
     },
     {
-        "BriefDescription": "This metric represents fraction of cycles CPU=
 was stalled due to Length Changing Prefixes (LCPs)",
-        "MetricExpr": "ILD_STALL.LCP / CLKS",
-        "MetricGroup": "FetchLat;TopdownL3;tma_fetch_latency_group",
-        "MetricName": "tma_lcp",
-        "PublicDescription": "This metric represents fraction of cycles CP=
U was stalled due to Length Changing Prefixes (LCPs). Using proper compiler=
 flags or Intel Compiler by default will certainly avoid this. #Link: Optim=
ization Guide about LCP BKMs.",
-        "ScaleUnit": "100%"
+        "BriefDescription": "Instructions Per Cycle across hyper-threads (=
per physical core)",
+        "MetricExpr": "INST_RETIRED.ANY / CORE_CLKS",
+        "MetricGroup": "Ret;SMT;tma_L1_group",
+        "MetricName": "CoreIPC"
     },
     {
-        "BriefDescription": "This metric estimates the fraction of cycles =
when the CPU was stalled due to switches of uop delivery to the Microcode S=
equencer (MS)",
-        "MetricExpr": "2 * IDQ.MS_SWITCHES / CLKS",
-        "MetricGroup": "FetchLat;MicroSeq;TopdownL3;tma_fetch_latency_grou=
p",
-        "MetricName": "tma_ms_switches",
-        "PublicDescription": "This metric estimates the fraction of cycles=
 when the CPU was stalled due to switches of uop delivery to the Microcode =
Sequencer (MS). Commonly used instructions are optimized for delivery by th=
e DSB (decoded i-cache) or MITE (legacy instruction decode) pipelines. Cert=
ain operations cannot be handled natively by the execution pipeline; and mu=
st be performed by microcode (small programs injected into the execution st=
ream). Switching to the MS too often can negatively impact performance. The=
 MS is designated to deliver long uop flows required by CISC instructions l=
ike CPUID; or uncommon conditions like Floating Point Assists when dealing =
with Denormals. Sample with: IDQ.MS_SWITCHES",
-        "ScaleUnit": "100%"
+        "BriefDescription": "Instruction-Level-Parallelism (average number=
 of uops executed when there is execution) per-core",
+        "MetricExpr": "(UOPS_EXECUTED.CORE / 2 / (cpu@UOPS_EXECUTED.CORE\\=
,cmask\\=3D1@ / 2 if #SMT_on else cpu@UOPS_EXECUTED.CORE\\,cmask\\=3D1@) if=
 #SMT_on else UOPS_EXECUTED.CORE / (cpu@UOPS_EXECUTED.CORE\\,cmask\\=3D1@ /=
 2 if #SMT_on else cpu@UOPS_EXECUTED.CORE\\,cmask\\=3D1@))",
+        "MetricGroup": "Backend;Cor;Pipeline;PortsUtil",
+        "MetricName": "ILP"
     },
     {
-        "BriefDescription": "This metric represents fraction of slots the =
CPU was stalled due to Frontend bandwidth issues",
-        "MetricExpr": "tma_frontend_bound - tma_fetch_latency",
-        "MetricGroup": "FetchBW;Frontend;TopdownL2;tma_L2_group;tma_fronte=
nd_bound_group",
-        "MetricName": "tma_fetch_bandwidth",
-        "PublicDescription": "This metric represents fraction of slots the=
 CPU was stalled due to Frontend bandwidth issues.  For example; inefficien=
cies at the instruction decoders; or restrictions for caching in the DSB (d=
ecoded uops cache) are categorized under Fetch Bandwidth. In such cases; th=
e Frontend typically delivers suboptimal amount of uops to the Backend.",
-        "ScaleUnit": "100%"
+        "BriefDescription": "Core actual clocks when any Logical Processor=
 is active on the Physical Core",
+        "MetricExpr": "(CPU_CLK_UNHALTED.THREAD / 2 * (1 + CPU_CLK_UNHALTE=
D.ONE_THREAD_ACTIVE / CPU_CLK_UNHALTED.REF_XCLK) if #core_wide < 1 else (CP=
U_CLK_UNHALTED.THREAD_ANY / 2 if #SMT_on else CLKS))",
+        "MetricGroup": "SMT",
+        "MetricName": "CORE_CLKS"
     },
     {
-        "BriefDescription": "This metric represents Core fraction of cycle=
s in which CPU was likely limited due to the MITE pipeline (the legacy deco=
de pipeline)",
-        "MetricExpr": "(IDQ.ALL_MITE_CYCLES_ANY_UOPS - IDQ.ALL_MITE_CYCLES=
_4_UOPS) / CORE_CLKS / 2",
-        "MetricGroup": "DSBmiss;FetchBW;TopdownL3;tma_fetch_bandwidth_grou=
p",
-        "MetricName": "tma_mite",
-        "PublicDescription": "This metric represents Core fraction of cycl=
es in which CPU was likely limited due to the MITE pipeline (the legacy dec=
ode pipeline). This pipeline is used for code that was not pre-cached in th=
e DSB or LSD. For example; inefficiencies due to asymmetric decoders; use o=
f long immediate or LCP can manifest as MITE fetch bandwidth bottleneck.",
-        "ScaleUnit": "100%"
+        "BriefDescription": "Instructions per Load (lower number means hig=
her occurrence rate)",
+        "MetricExpr": "INST_RETIRED.ANY / MEM_UOPS_RETIRED.ALL_LOADS",
+        "MetricGroup": "InsType",
+        "MetricName": "IpLoad"
     },
     {
-        "BriefDescription": "This metric represents Core fraction of cycle=
s in which CPU was likely limited due to DSB (decoded uop cache) fetch pipe=
line",
-        "MetricExpr": "(IDQ.ALL_DSB_CYCLES_ANY_UOPS - IDQ.ALL_DSB_CYCLES_4=
_UOPS) / CORE_CLKS / 2",
-        "MetricGroup": "DSB;FetchBW;TopdownL3;tma_fetch_bandwidth_group",
-        "MetricName": "tma_dsb",
-        "PublicDescription": "This metric represents Core fraction of cycl=
es in which CPU was likely limited due to DSB (decoded uop cache) fetch pip=
eline.  For example; inefficient utilization of the DSB cache structure or =
bank conflict when reading from it; are categorized here.",
-        "ScaleUnit": "100%"
+        "BriefDescription": "Instructions per Store (lower number means hi=
gher occurrence rate)",
+        "MetricExpr": "INST_RETIRED.ANY / MEM_UOPS_RETIRED.ALL_STORES",
+        "MetricGroup": "InsType",
+        "MetricName": "IpStore"
     },
     {
-        "BriefDescription": "This category represents fraction of slots wa=
sted due to incorrect speculations",
-        "MetricExpr": "(UOPS_ISSUED.ANY - UOPS_RETIRED.RETIRE_SLOTS + 4 * =
((INT_MISC.RECOVERY_CYCLES_ANY / 2) if #SMT_on else INT_MISC.RECOVERY_CYCLE=
S)) / SLOTS",
-        "MetricGroup": "TopdownL1;tma_L1_group",
-        "MetricName": "tma_bad_speculation",
-        "PublicDescription": "This category represents fraction of slots w=
asted due to incorrect speculations. This include slots used to issue uops =
that do not eventually get retired and slots for which the issue-pipeline w=
as blocked due to recovery from earlier incorrect speculation. For example;=
 wasted work due to miss-predicted branches are categorized under Bad Specu=
lation category. Incorrect data speculation followed by Memory Ordering Nuk=
es is another example.",
-        "ScaleUnit": "100%"
+        "BriefDescription": "Instructions per Branch (lower number means h=
igher occurrence rate)",
+        "MetricExpr": "INST_RETIRED.ANY / BR_INST_RETIRED.ALL_BRANCHES",
+        "MetricGroup": "Branches;Fed;InsType",
+        "MetricName": "IpBranch"
     },
     {
-        "BriefDescription": "This metric represents fraction of slots the =
CPU has wasted due to Branch Misprediction",
-        "MetricExpr": "(BR_MISP_RETIRED.ALL_BRANCHES / (BR_MISP_RETIRED.AL=
L_BRANCHES + MACHINE_CLEARS.COUNT)) * tma_bad_speculation",
-        "MetricGroup": "BadSpec;BrMispredicts;TopdownL2;tma_L2_group;tma_b=
ad_speculation_group",
-        "MetricName": "tma_branch_mispredicts",
-        "PublicDescription": "This metric represents fraction of slots the=
 CPU has wasted due to Branch Misprediction.  These slots are either wasted=
 by uops fetched from an incorrectly speculated program path; or stalls whe=
n the out-of-order part of the machine needs to recover its state from a sp=
eculative path. Sample with: BR_MISP_RETIRED.ALL_BRANCHES",
-        "ScaleUnit": "100%"
+        "BriefDescription": "Instructions per (near) call (lower number me=
ans higher occurrence rate)",
+        "MetricExpr": "INST_RETIRED.ANY / BR_INST_RETIRED.NEAR_CALL",
+        "MetricGroup": "Branches;Fed;PGO",
+        "MetricName": "IpCall"
     },
     {
-        "BriefDescription": "This metric represents fraction of slots the =
CPU has wasted due to Machine Clears",
-        "MetricExpr": "tma_bad_speculation - tma_branch_mispredicts",
-        "MetricGroup": "BadSpec;MachineClears;TopdownL2;tma_L2_group;tma_b=
ad_speculation_group",
-        "MetricName": "tma_machine_clears",
-        "PublicDescription": "This metric represents fraction of slots the=
 CPU has wasted due to Machine Clears.  These slots are either wasted by uo=
ps fetched prior to the clear; or stalls the out-of-order portion of the ma=
chine needs to recover its state after the clear. For example; this can hap=
pen due to memory ordering Nukes (e.g. Memory Disambiguation) or Self-Modif=
ying-Code (SMC) nukes. Sample with: MACHINE_CLEARS.COUNT",
-        "ScaleUnit": "100%"
+        "BriefDescription": "Instruction per taken branch",
+        "MetricExpr": "INST_RETIRED.ANY / BR_INST_RETIRED.NEAR_TAKEN",
+        "MetricGroup": "Branches;Fed;FetchBW;Frontend;PGO",
+        "MetricName": "IpTB"
     },
     {
-        "BriefDescription": "This category represents fraction of slots wh=
ere no uops are being delivered due to a lack of required resources for acc=
epting new uops in the Backend",
-        "MetricExpr": "1 - (tma_frontend_bound + tma_bad_speculation + tma=
_retiring)",
-        "MetricGroup": "TopdownL1;tma_L1_group",
-        "MetricName": "tma_backend_bound",
-        "PublicDescription": "This category represents fraction of slots w=
here no uops are being delivered due to a lack of required resources for ac=
cepting new uops in the Backend. Backend is the portion of the processor co=
re where the out-of-order scheduler dispatches ready uops into their respec=
tive execution units; and once completed these uops get retired according t=
o program order. For example; stalls due to data-cache misses or stalls due=
 to the divider unit being overloaded are both categorized under Backend Bo=
und. Backend Bound is further divided into two main categories: Memory Boun=
d and Core Bound.",
-        "ScaleUnit": "100%"
+        "BriefDescription": "Branch instructions per taken branch. ",
+        "MetricExpr": "BR_INST_RETIRED.ALL_BRANCHES / BR_INST_RETIRED.NEAR=
_TAKEN",
+        "MetricGroup": "Branches;Fed;PGO",
+        "MetricName": "BpTkBranch"
     },
     {
-        "BriefDescription": "This metric represents fraction of slots the =
Memory subsystem within the Backend was a bottleneck",
-        "MetricExpr": "((min(CPU_CLK_UNHALTED.THREAD, CYCLE_ACTIVITY.STALL=
S_LDM_PENDING) + RESOURCE_STALLS.SB) / (min(CPU_CLK_UNHALTED.THREAD, CYCLE_=
ACTIVITY.CYCLES_NO_EXECUTE) + (cpu@UOPS_EXECUTED.CORE\\,cmask\\=3D1@ - cpu@=
UOPS_EXECUTED.CORE\\,cmask\\=3D3@ if (IPC > 1.8) else cpu@UOPS_EXECUTED.COR=
E\\,cmask\\=3D2@) / 2 - RS_EVENTS.EMPTY_CYCLES if (tma_fetch_latency > 0.1)=
 else RESOURCE_STALLS.SB) if #SMT_on else (min(CPU_CLK_UNHALTED.THREAD, CYC=
LE_ACTIVITY.CYCLES_NO_EXECUTE) + cpu@UOPS_EXECUTED.CORE\\,cmask\\=3D1@ - cp=
u@UOPS_EXECUTED.CORE\\,cmask\\=3D3@ if (IPC > 1.8) else cpu@UOPS_EXECUTED.C=
ORE\\,cmask\\=3D2@ - RS_EVENTS.EMPTY_CYCLES if (tma_fetch_latency > 0.1) el=
se RESOURCE_STALLS.SB)) * tma_backend_bound",
-        "MetricGroup": "Backend;TopdownL2;tma_L2_group;tma_backend_bound_g=
roup",
-        "MetricName": "tma_memory_bound",
-        "PublicDescription": "This metric represents fraction of slots the=
 Memory subsystem within the Backend was a bottleneck.  Memory Bound estima=
tes fraction of slots where pipeline is likely stalled due to demand load o=
r store instructions. This accounts mainly for (1) non-completed in-flight =
memory demand loads which coincides with execution units starvation; in add=
ition to (2) cases where stores could impose backpressure on the pipeline w=
hen many of them get buffered at the same time (less common out of the two)=
.",
-        "ScaleUnit": "100%"
+        "BriefDescription": "Total number of retired Instructions Sample w=
ith: INST_RETIRED.PREC_DIST",
+        "MetricExpr": "INST_RETIRED.ANY",
+        "MetricGroup": "Summary;tma_L1_group",
+        "MetricName": "Instructions"
     },
     {
-        "BriefDescription": "This metric estimates how often the CPU was s=
talled without loads missing the L1 data cache",
-        "MetricExpr": "max((min(CPU_CLK_UNHALTED.THREAD, CYCLE_ACTIVITY.ST=
ALLS_LDM_PENDING) - CYCLE_ACTIVITY.STALLS_L1D_PENDING) / CLKS, 0)",
-        "MetricGroup": "CacheMisses;MemoryBound;TmaL3mem;TopdownL3;tma_mem=
ory_bound_group",
-        "MetricName": "tma_l1_bound",
-        "PublicDescription": "This metric estimates how often the CPU was =
stalled without loads missing the L1 data cache.  The L1 data cache typical=
ly has the shortest latency.  However; in certain cases like loads blocked =
on older stores; a load might suffer due to high latency even though it is =
being satisfied by the L1. Another example is loads who miss in the TLB. Th=
ese cases are characterized by execution unit stalls; while some non-comple=
ted demand load lives in the machine without having that demand load missin=
g the L1 cache. Sample with: MEM_LOAD_UOPS_RETIRED.L1_HIT_PS;MEM_LOAD_UOPS_=
RETIRED.HIT_LFB_PS",
-        "ScaleUnit": "100%"
+        "BriefDescription": "Average number of Uops retired in cycles wher=
e at least one uop has retired.",
+        "MetricExpr": "UOPS_RETIRED.RETIRE_SLOTS / cpu@UOPS_RETIRED.RETIRE=
_SLOTS\\,cmask\\=3D1@",
+        "MetricGroup": "Pipeline;Ret",
+        "MetricName": "Retire"
     },
     {
-        "BriefDescription": "This metric roughly estimates the fraction of=
 cycles where the Data TLB (DTLB) was missed by load accesses",
-        "MetricExpr": "(8 * DTLB_LOAD_MISSES.STLB_HIT + DTLB_LOAD_MISSES.W=
ALK_DURATION) / CLKS",
-        "MetricGroup": "MemoryTLB;TopdownL4;tma_l1_bound_group",
-        "MetricName": "tma_dtlb_load",
-        "PublicDescription": "This metric roughly estimates the fraction o=
f cycles where the Data TLB (DTLB) was missed by load accesses. TLBs (Trans=
lation Look-aside Buffers) are processor caches for recently used entries o=
ut of the Page Tables that are used to map virtual- to physical-addresses b=
y the operating system. This metric approximates the potential delay of dem=
and loads missing the first-level data TLB (assuming worst case scenario wi=
th back to back misses to different pages). This includes hitting in the se=
cond-level TLB (STLB) as well as performing a hardware page walk on an STLB=
 miss. Sample with: MEM_UOPS_RETIRED.STLB_MISS_LOADS_PS",
-        "ScaleUnit": "100%"
+        "BriefDescription": "Fraction of Uops delivered by the DSB (aka De=
coded ICache; or Uop Cache)",
+        "MetricExpr": "IDQ.DSB_UOPS / (IDQ.DSB_UOPS + LSD.UOPS + IDQ.MITE_=
UOPS + IDQ.MS_UOPS)",
+        "MetricGroup": "DSB;Fed;FetchBW",
+        "MetricName": "DSB_Coverage"
     },
     {
-        "BriefDescription": "This metric roughly estimates fraction of cyc=
les when the memory subsystem had loads blocked since they could not forwar=
d data from earlier (in program order) overlapping stores",
-        "MetricExpr": "13 * LD_BLOCKS.STORE_FORWARD / CLKS",
-        "MetricGroup": "TopdownL4;tma_l1_bound_group",
-        "MetricName": "tma_store_fwd_blk",
-        "PublicDescription": "This metric roughly estimates fraction of cy=
cles when the memory subsystem had loads blocked since they could not forwa=
rd data from earlier (in program order) overlapping stores. To streamline m=
emory operations in the pipeline; a load can avoid waiting for memory if a =
prior in-flight store is writing the data that the load wants to read (stor=
e forwarding process). However; in some cases the load may be blocked for a=
 significant time pending the store forward. For example; when the prior st=
ore is writing a smaller region than the load is reading.",
-        "ScaleUnit": "100%"
+        "BriefDescription": "Number of Instructions per non-speculative Br=
anch Misprediction (JEClear) (lower number means higher occurrence rate)",
+        "MetricExpr": "INST_RETIRED.ANY / BR_MISP_RETIRED.ALL_BRANCHES",
+        "MetricGroup": "Bad;BadSpec;BrMispredicts",
+        "MetricName": "IpMispredict"
     },
     {
-        "BriefDescription": "This metric represents fraction of cycles the=
 CPU spent handling cache misses due to lock operations",
-        "MetricExpr": "(MEM_UOPS_RETIRED.LOCK_LOADS / MEM_UOPS_RETIRED.ALL=
_STORES) * min(CPU_CLK_UNHALTED.THREAD, OFFCORE_REQUESTS_OUTSTANDING.CYCLES=
_WITH_DEMAND_RFO) / CLKS",
-        "MetricGroup": "Offcore;TopdownL4;tma_l1_bound_group",
-        "MetricName": "tma_lock_latency",
-        "PublicDescription": "This metric represents fraction of cycles th=
e CPU spent handling cache misses due to lock operations. Due to the microa=
rchitecture handling of locks; they are classified as L1_Bound regardless o=
f what memory source satisfied them. Sample with: MEM_UOPS_RETIRED.LOCK_LOA=
DS_PS",
-        "ScaleUnit": "100%"
+        "BriefDescription": "Actual Average Latency for L1 data-cache miss=
 demand load operations (in core cycles)",
+        "MetricExpr": "L1D_PEND_MISS.PENDING / (MEM_LOAD_UOPS_RETIRED.L1_M=
ISS + MEM_LOAD_UOPS_RETIRED.HIT_LFB)",
+        "MetricGroup": "Mem;MemoryBound;MemoryLat",
+        "MetricName": "Load_Miss_Real_Latency"
     },
     {
-        "BriefDescription": "This metric estimates fraction of cycles hand=
ling memory load split accesses - load that cross 64-byte cache line bounda=
ry",
-        "MetricExpr": "Load_Miss_Real_Latency * LD_BLOCKS.NO_SR / CLKS",
-        "MetricGroup": "TopdownL4;tma_l1_bound_group",
-        "MetricName": "tma_split_loads",
-        "PublicDescription": "This metric estimates fraction of cycles han=
dling memory load split accesses - load that cross 64-byte cache line bound=
ary.  Sample with: MEM_UOPS_RETIRED.SPLIT_LOADS_PS",
-        "ScaleUnit": "100%"
+        "BriefDescription": "Memory-Level-Parallelism (average number of L=
1 miss demand load when there is at least one such miss. Per-Logical Proces=
sor)",
+        "MetricExpr": "L1D_PEND_MISS.PENDING / L1D_PEND_MISS.PENDING_CYCLE=
S",
+        "MetricGroup": "Mem;MemoryBW;MemoryBound",
+        "MetricName": "MLP"
     },
     {
-        "BriefDescription": "This metric estimates how often memory load a=
ccesses were aliased by preceding stores (in program order) with a 4K addre=
ss offset",
-        "MetricExpr": "LD_BLOCKS_PARTIAL.ADDRESS_ALIAS / CLKS",
-        "MetricGroup": "TopdownL4;tma_l1_bound_group",
-        "MetricName": "tma_4k_aliasing",
-        "PublicDescription": "This metric estimates how often memory load =
accesses were aliased by preceding stores (in program order) with a 4K addr=
ess offset. False match is possible; which incur a few cycles load re-issue=
. However; the short re-issue duration is often hidden by the out-of-order =
core and HW optimizations; hence a user may safely ignore a high value of t=
his metric unless it manages to propagate up into parent nodes of the hiera=
rchy (e.g. to L1_Bound).",
-        "ScaleUnit": "100%"
+        "BriefDescription": "L1 cache true misses per kilo instruction for=
 retired demand loads",
+        "MetricExpr": "1e3 * MEM_LOAD_UOPS_RETIRED.L1_MISS / INST_RETIRED.=
ANY",
+        "MetricGroup": "CacheMisses;Mem",
+        "MetricName": "L1MPKI"
     },
     {
-        "BriefDescription": "This metric does a *rough estimation* of how =
often L1D Fill Buffer unavailability limited additional L1D miss memory acc=
ess requests to proceed",
-        "MetricExpr": "Load_Miss_Real_Latency * cpu@L1D_PEND_MISS.REQUEST_=
FB_FULL\\,cmask\\=3D1@ / CLKS",
-        "MetricGroup": "MemoryBW;TopdownL4;tma_l1_bound_group",
-        "MetricName": "tma_fb_full",
-        "PublicDescription": "This metric does a *rough estimation* of how=
 often L1D Fill Buffer unavailability limited additional L1D miss memory ac=
cess requests to proceed. The higher the metric value; the deeper the memor=
y hierarchy level the misses are satisfied from (metric values >1 are valid=
). Often it hints on approaching bandwidth limits (to L2 cache; L3 cache or=
 external memory).",
-        "ScaleUnit": "100%"
+        "BriefDescription": "L2 cache true misses per kilo instruction for=
 retired demand loads",
+        "MetricExpr": "1e3 * MEM_LOAD_UOPS_RETIRED.L2_MISS / INST_RETIRED.=
ANY",
+        "MetricGroup": "Backend;CacheMisses;Mem",
+        "MetricName": "L2MPKI"
     },
     {
-        "BriefDescription": "This metric estimates how often the CPU was s=
talled due to L2 cache accesses by loads",
-        "MetricExpr": "(CYCLE_ACTIVITY.STALLS_L1D_PENDING - CYCLE_ACTIVITY=
.STALLS_L2_PENDING) / CLKS",
-        "MetricGroup": "CacheMisses;MemoryBound;TmaL3mem;TopdownL3;tma_mem=
ory_bound_group",
-        "MetricName": "tma_l2_bound",
-        "PublicDescription": "This metric estimates how often the CPU was =
stalled due to L2 cache accesses by loads.  Avoiding cache misses (i.e. L1 =
misses/L2 hits) can improve the latency and increase performance. Sample wi=
th: MEM_LOAD_UOPS_RETIRED.L2_HIT_PS",
-        "ScaleUnit": "100%"
+        "BriefDescription": "L3 cache true misses per kilo instruction for=
 retired demand loads",
+        "MetricExpr": "1e3 * MEM_LOAD_UOPS_RETIRED.L3_MISS / INST_RETIRED.=
ANY",
+        "MetricGroup": "CacheMisses;Mem",
+        "MetricName": "L3MPKI"
     },
     {
-        "BriefDescription": "This metric estimates how often the CPU was s=
talled due to loads accesses to L3 cache or contended with a sibling Core",
-        "MetricExpr": "(MEM_LOAD_UOPS_RETIRED.L3_HIT / (MEM_LOAD_UOPS_RETI=
RED.L3_HIT + 7 * MEM_LOAD_UOPS_RETIRED.L3_MISS)) * CYCLE_ACTIVITY.STALLS_L2=
_PENDING / CLKS",
-        "MetricGroup": "CacheMisses;MemoryBound;TmaL3mem;TopdownL3;tma_mem=
ory_bound_group",
-        "MetricName": "tma_l3_bound",
-        "PublicDescription": "This metric estimates how often the CPU was =
stalled due to loads accesses to L3 cache or contended with a sibling Core.=
  Avoiding cache misses (i.e. L2 misses/L3 hits) can improve the latency an=
d increase performance. Sample with: MEM_LOAD_UOPS_RETIRED.L3_HIT_PS",
-        "ScaleUnit": "100%"
+        "BriefDescription": "Utilization of the core's Page Walker(s) serv=
ing STLB misses triggered by instruction/Load/Store accesses",
+        "MetricConstraint": "NO_NMI_WATCHDOG",
+        "MetricExpr": "(ITLB_MISSES.WALK_DURATION + DTLB_LOAD_MISSES.WALK_=
DURATION + DTLB_STORE_MISSES.WALK_DURATION) / CORE_CLKS",
+        "MetricGroup": "Mem;MemoryTLB",
+        "MetricName": "Page_Walks_Utilization"
     },
     {
-        "BriefDescription": "This metric estimates fraction of cycles whil=
e the memory subsystem was handling synchronizations due to contested acces=
ses",
-        "MetricExpr": "(60 * (MEM_LOAD_UOPS_L3_HIT_RETIRED.XSNP_HITM * (1 =
+ mem_load_uops_retired.hit_lfb / ((MEM_LOAD_UOPS_RETIRED.L2_HIT + MEM_LOAD=
_UOPS_RETIRED.L3_HIT + MEM_LOAD_UOPS_L3_HIT_RETIRED.XSNP_HIT + MEM_LOAD_UOP=
S_L3_HIT_RETIRED.XSNP_HITM + MEM_LOAD_UOPS_L3_HIT_RETIRED.XSNP_MISS) + MEM_=
LOAD_UOPS_L3_MISS_RETIRED.LOCAL_DRAM + MEM_LOAD_UOPS_L3_MISS_RETIRED.REMOTE=
_DRAM + MEM_LOAD_UOPS_L3_MISS_RETIRED.REMOTE_HITM + MEM_LOAD_UOPS_L3_MISS_R=
ETIRED.REMOTE_FWD))) + 43 * (MEM_LOAD_UOPS_L3_HIT_RETIRED.XSNP_MISS * (1 + =
mem_load_uops_retired.hit_lfb / ((MEM_LOAD_UOPS_RETIRED.L2_HIT + MEM_LOAD_U=
OPS_RETIRED.L3_HIT + MEM_LOAD_UOPS_L3_HIT_RETIRED.XSNP_HIT + MEM_LOAD_UOPS_=
L3_HIT_RETIRED.XSNP_HITM + MEM_LOAD_UOPS_L3_HIT_RETIRED.XSNP_MISS) + MEM_LO=
AD_UOPS_L3_MISS_RETIRED.LOCAL_DRAM + MEM_LOAD_UOPS_L3_MISS_RETIRED.REMOTE_D=
RAM + MEM_LOAD_UOPS_L3_MISS_RETIRED.REMOTE_HITM + MEM_LOAD_UOPS_L3_MISS_RET=
IRED.REMOTE_FWD)))) / CLKS",
-        "MetricGroup": "DataSharing;Offcore;Snoop;TopdownL4;tma_l3_bound_g=
roup",
-        "MetricName": "tma_contested_accesses",
-        "PublicDescription": "This metric estimates fraction of cycles whi=
le the memory subsystem was handling synchronizations due to contested acce=
sses. Contested accesses occur when data written by one Logical Processor a=
re read by another Logical Processor on a different Physical Core. Examples=
 of contested accesses include synchronizations such as locks; true data sh=
aring such as modified locked variables; and false sharing. Sample with: ME=
M_LOAD_L3_HIT_RETIRED.XSNP_HITM_PS;MEM_LOAD_L3_HIT_RETIRED.XSNP_MISS_PS",
-        "ScaleUnit": "100%"
+        "BriefDescription": "Average per-core data fill bandwidth to the L=
1 data cache [GB / sec]",
+        "MetricExpr": "64 * L1D.REPLACEMENT / 1e9 / duration_time",
+        "MetricGroup": "Mem;MemoryBW",
+        "MetricName": "L1D_Cache_Fill_BW"
     },
     {
-        "BriefDescription": "This metric estimates fraction of cycles whil=
e the memory subsystem was handling synchronizations due to data-sharing ac=
cesses",
-        "MetricExpr": "43 * (MEM_LOAD_UOPS_L3_HIT_RETIRED.XSNP_HIT * (1 + =
mem_load_uops_retired.hit_lfb / ((MEM_LOAD_UOPS_RETIRED.L2_HIT + MEM_LOAD_U=
OPS_RETIRED.L3_HIT + MEM_LOAD_UOPS_L3_HIT_RETIRED.XSNP_HIT + MEM_LOAD_UOPS_=
L3_HIT_RETIRED.XSNP_HITM + MEM_LOAD_UOPS_L3_HIT_RETIRED.XSNP_MISS) + MEM_LO=
AD_UOPS_L3_MISS_RETIRED.LOCAL_DRAM + MEM_LOAD_UOPS_L3_MISS_RETIRED.REMOTE_D=
RAM + MEM_LOAD_UOPS_L3_MISS_RETIRED.REMOTE_HITM + MEM_LOAD_UOPS_L3_MISS_RET=
IRED.REMOTE_FWD))) / CLKS",
-        "MetricGroup": "Offcore;Snoop;TopdownL4;tma_l3_bound_group",
-        "MetricName": "tma_data_sharing",
-        "PublicDescription": "This metric estimates fraction of cycles whi=
le the memory subsystem was handling synchronizations due to data-sharing a=
ccesses. Data shared by multiple Logical Processors (even just read shared)=
 may cause increased access latency due to cache coherency. Excessive data =
sharing can drastically harm multithreaded performance. Sample with: MEM_LO=
AD_L3_HIT_RETIRED.XSNP_HIT_PS",
-        "ScaleUnit": "100%"
+        "BriefDescription": "Average per-core data fill bandwidth to the L=
2 cache [GB / sec]",
+        "MetricExpr": "64 * L2_LINES_IN.ALL / 1e9 / duration_time",
+        "MetricGroup": "Mem;MemoryBW",
+        "MetricName": "L2_Cache_Fill_BW"
     },
     {
-        "BriefDescription": "This metric represents fraction of cycles wit=
h demand load accesses that hit the L3 cache under unloaded scenarios (poss=
ibly L3 latency limited)",
-        "MetricExpr": "41 * (MEM_LOAD_UOPS_RETIRED.L3_HIT * (1 + mem_load_=
uops_retired.hit_lfb / ((MEM_LOAD_UOPS_RETIRED.L2_HIT + MEM_LOAD_UOPS_RETIR=
ED.L3_HIT + MEM_LOAD_UOPS_L3_HIT_RETIRED.XSNP_HIT + MEM_LOAD_UOPS_L3_HIT_RE=
TIRED.XSNP_HITM + MEM_LOAD_UOPS_L3_HIT_RETIRED.XSNP_MISS) + MEM_LOAD_UOPS_L=
3_MISS_RETIRED.LOCAL_DRAM + MEM_LOAD_UOPS_L3_MISS_RETIRED.REMOTE_DRAM + MEM=
_LOAD_UOPS_L3_MISS_RETIRED.REMOTE_HITM + MEM_LOAD_UOPS_L3_MISS_RETIRED.REMO=
TE_FWD))) / CLKS",
-        "MetricGroup": "MemoryLat;TopdownL4;tma_l3_bound_group",
-        "MetricName": "tma_l3_hit_latency",
-        "PublicDescription": "This metric represents fraction of cycles wi=
th demand load accesses that hit the L3 cache under unloaded scenarios (pos=
sibly L3 latency limited).  Avoiding private cache misses (i.e. L2 misses/L=
3 hits) will improve the latency; reduce contention with sibling physical c=
ores and increase performance.  Note the value of this node may overlap wit=
h its siblings. Sample with: MEM_LOAD_UOPS_RETIRED.L3_HIT_PS",
-        "ScaleUnit": "100%"
+        "BriefDescription": "Average per-core data fill bandwidth to the L=
3 cache [GB / sec]",
+        "MetricExpr": "64 * LONGEST_LAT_CACHE.MISS / 1e9 / duration_time",
+        "MetricGroup": "Mem;MemoryBW",
+        "MetricName": "L3_Cache_Fill_BW"
     },
     {
-        "BriefDescription": "This metric measures fraction of cycles where=
 the Super Queue (SQ) was full taking into account all request-types and bo=
th hardware SMT threads (Logical Processors)",
-        "MetricExpr": "((OFFCORE_REQUESTS_BUFFER.SQ_FULL / 2) if #SMT_on e=
lse OFFCORE_REQUESTS_BUFFER.SQ_FULL) / CORE_CLKS",
-        "MetricGroup": "MemoryBW;Offcore;TopdownL4;tma_l3_bound_group",
-        "MetricName": "tma_sq_full",
-        "PublicDescription": "This metric measures fraction of cycles wher=
e the Super Queue (SQ) was full taking into account all request-types and b=
oth hardware SMT threads (Logical Processors). The Super Queue is used for =
requests to access the L2 cache or to go out to the Uncore.",
-        "ScaleUnit": "100%"
+        "BriefDescription": "Average per-thread data fill bandwidth to the=
 L1 data cache [GB / sec]",
+        "MetricExpr": "L1D_Cache_Fill_BW",
+        "MetricGroup": "Mem;MemoryBW",
+        "MetricName": "L1D_Cache_Fill_BW_1T"
     },
     {
-        "BriefDescription": "This metric estimates how often the CPU was s=
talled on accesses to external memory (DRAM) by loads",
-        "MetricExpr": "(1 - (MEM_LOAD_UOPS_RETIRED.L3_HIT / (MEM_LOAD_UOPS=
_RETIRED.L3_HIT + 7 * MEM_LOAD_UOPS_RETIRED.L3_MISS))) * CYCLE_ACTIVITY.STA=
LLS_L2_PENDING / CLKS",
-        "MetricGroup": "MemoryBound;TmaL3mem;TopdownL3;tma_memory_bound_gr=
oup",
-        "MetricName": "tma_dram_bound",
-        "PublicDescription": "This metric estimates how often the CPU was =
stalled on accesses to external memory (DRAM) by loads. Better caching can =
improve the latency and increase performance. Sample with: MEM_LOAD_UOPS_RE=
TIRED.L3_MISS_PS",
-        "ScaleUnit": "100%"
+        "BriefDescription": "Average per-thread data fill bandwidth to the=
 L2 cache [GB / sec]",
+        "MetricExpr": "L2_Cache_Fill_BW",
+        "MetricGroup": "Mem;MemoryBW",
+        "MetricName": "L2_Cache_Fill_BW_1T"
     },
     {
-        "BriefDescription": "This metric estimates fraction of cycles wher=
e the core's performance was likely hurt due to approaching bandwidth limit=
s of external memory (DRAM)",
-        "MetricExpr": "min(CPU_CLK_UNHALTED.THREAD, cpu@OFFCORE_REQUESTS_O=
UTSTANDING.ALL_DATA_RD\\,cmask\\=3D6@) / CLKS",
-        "MetricGroup": "MemoryBW;Offcore;TopdownL4;tma_dram_bound_group",
-        "MetricName": "tma_mem_bandwidth",
-        "PublicDescription": "This metric estimates fraction of cycles whe=
re the core's performance was likely hurt due to approaching bandwidth limi=
ts of external memory (DRAM).  The underlying heuristic assumes that a simi=
lar off-core traffic is generated by all IA cores. This metric does not agg=
regate non-data-read requests by this logical processor; requests from othe=
r IA Logical Processors/Physical Cores/sockets; or other non-IA devices lik=
e GPU; hence the maximum external memory bandwidth limits may or may not be=
 approached when this metric is flagged (see Uncore counters for that).",
-        "ScaleUnit": "100%"
+        "BriefDescription": "Average per-thread data fill bandwidth to the=
 L3 cache [GB / sec]",
+        "MetricExpr": "L3_Cache_Fill_BW",
+        "MetricGroup": "Mem;MemoryBW",
+        "MetricName": "L3_Cache_Fill_BW_1T"
     },
     {
-        "BriefDescription": "This metric estimates fraction of cycles wher=
e the performance was likely hurt due to latency from external memory (DRAM=
)",
-        "MetricExpr": "min(CPU_CLK_UNHALTED.THREAD, OFFCORE_REQUESTS_OUTST=
ANDING.CYCLES_WITH_DATA_RD) / CLKS - tma_mem_bandwidth",
-        "MetricGroup": "MemoryLat;Offcore;TopdownL4;tma_dram_bound_group",
-        "MetricName": "tma_mem_latency",
-        "PublicDescription": "This metric estimates fraction of cycles whe=
re the performance was likely hurt due to latency from external memory (DRA=
M).  This metric does not aggregate requests from other Logical Processors/=
Physical Cores/sockets (see Uncore counters for that).",
-        "ScaleUnit": "100%"
+        "BriefDescription": "Average per-thread data access bandwidth to t=
he L3 cache [GB / sec]",
+        "MetricExpr": "0",
+        "MetricGroup": "Mem;MemoryBW;Offcore",
+        "MetricName": "L3_Cache_Access_BW_1T"
     },
     {
-        "BriefDescription": "This metric estimates fraction of cycles whil=
e the memory subsystem was handling loads from local memory",
-        "MetricExpr": "200 * (MEM_LOAD_UOPS_L3_MISS_RETIRED.LOCAL_DRAM * (=
1 + mem_load_uops_retired.hit_lfb / ((MEM_LOAD_UOPS_RETIRED.L2_HIT + MEM_LO=
AD_UOPS_RETIRED.L3_HIT + MEM_LOAD_UOPS_L3_HIT_RETIRED.XSNP_HIT + MEM_LOAD_U=
OPS_L3_HIT_RETIRED.XSNP_HITM + MEM_LOAD_UOPS_L3_HIT_RETIRED.XSNP_MISS) + ME=
M_LOAD_UOPS_L3_MISS_RETIRED.LOCAL_DRAM + MEM_LOAD_UOPS_L3_MISS_RETIRED.REMO=
TE_DRAM + MEM_LOAD_UOPS_L3_MISS_RETIRED.REMOTE_HITM + MEM_LOAD_UOPS_L3_MISS=
_RETIRED.REMOTE_FWD))) / CLKS",
-        "MetricGroup": "Server;TopdownL5;tma_mem_latency_group",
-        "MetricName": "tma_local_dram",
-        "PublicDescription": "This metric estimates fraction of cycles whi=
le the memory subsystem was handling loads from local memory. Caching will =
improve the latency and increase performance. Sample with: MEM_LOAD_UOPS_L3=
_MISS_RETIRED.LOCAL_DRAM_PS",
-        "ScaleUnit": "100%"
+        "BriefDescription": "Average CPU Utilization",
+        "MetricExpr": "CPU_CLK_UNHALTED.REF_TSC / TSC",
+        "MetricGroup": "HPC;Summary",
+        "MetricName": "CPU_Utilization"
     },
     {
-        "BriefDescription": "This metric estimates fraction of cycles whil=
e the memory subsystem was handling loads from remote memory",
-        "MetricExpr": "310 * (MEM_LOAD_UOPS_L3_MISS_RETIRED.REMOTE_DRAM * =
(1 + mem_load_uops_retired.hit_lfb / ((MEM_LOAD_UOPS_RETIRED.L2_HIT + MEM_L=
OAD_UOPS_RETIRED.L3_HIT + MEM_LOAD_UOPS_L3_HIT_RETIRED.XSNP_HIT + MEM_LOAD_=
UOPS_L3_HIT_RETIRED.XSNP_HITM + MEM_LOAD_UOPS_L3_HIT_RETIRED.XSNP_MISS) + M=
EM_LOAD_UOPS_L3_MISS_RETIRED.LOCAL_DRAM + MEM_LOAD_UOPS_L3_MISS_RETIRED.REM=
OTE_DRAM + MEM_LOAD_UOPS_L3_MISS_RETIRED.REMOTE_HITM + MEM_LOAD_UOPS_L3_MIS=
S_RETIRED.REMOTE_FWD))) / CLKS",
-        "MetricGroup": "Server;Snoop;TopdownL5;tma_mem_latency_group",
-        "MetricName": "tma_remote_dram",
-        "PublicDescription": "This metric estimates fraction of cycles whi=
le the memory subsystem was handling loads from remote memory. This is caus=
ed often due to non-optimal NUMA allocations. #link to NUMA article Sample =
with: MEM_LOAD_UOPS_L3_MISS_RETIRED.REMOTE_DRAM_PS",
-        "ScaleUnit": "100%"
+        "BriefDescription": "Measured Average Frequency for unhalted proce=
ssors [GHz]",
+        "MetricExpr": "Turbo_Utilization * TSC / 1e9 / duration_time",
+        "MetricGroup": "Power;Summary",
+        "MetricName": "Average_Frequency"
     },
     {
-        "BriefDescription": "This metric estimates fraction of cycles whil=
e the memory subsystem was handling loads from remote cache in other socket=
s including synchronizations issues",
-        "MetricExpr": "(200 * (MEM_LOAD_UOPS_L3_MISS_RETIRED.REMOTE_HITM *=
 (1 + mem_load_uops_retired.hit_lfb / ((MEM_LOAD_UOPS_RETIRED.L2_HIT + MEM_=
LOAD_UOPS_RETIRED.L3_HIT + MEM_LOAD_UOPS_L3_HIT_RETIRED.XSNP_HIT + MEM_LOAD=
_UOPS_L3_HIT_RETIRED.XSNP_HITM + MEM_LOAD_UOPS_L3_HIT_RETIRED.XSNP_MISS) + =
MEM_LOAD_UOPS_L3_MISS_RETIRED.LOCAL_DRAM + MEM_LOAD_UOPS_L3_MISS_RETIRED.RE=
MOTE_DRAM + MEM_LOAD_UOPS_L3_MISS_RETIRED.REMOTE_HITM + MEM_LOAD_UOPS_L3_MI=
SS_RETIRED.REMOTE_FWD))) + 180 * (MEM_LOAD_UOPS_L3_MISS_RETIRED.REMOTE_FWD =
* (1 + mem_load_uops_retired.hit_lfb / ((MEM_LOAD_UOPS_RETIRED.L2_HIT + MEM=
_LOAD_UOPS_RETIRED.L3_HIT + MEM_LOAD_UOPS_L3_HIT_RETIRED.XSNP_HIT + MEM_LOA=
D_UOPS_L3_HIT_RETIRED.XSNP_HITM + MEM_LOAD_UOPS_L3_HIT_RETIRED.XSNP_MISS) +=
 MEM_LOAD_UOPS_L3_MISS_RETIRED.LOCAL_DRAM + MEM_LOAD_UOPS_L3_MISS_RETIRED.R=
EMOTE_DRAM + MEM_LOAD_UOPS_L3_MISS_RETIRED.REMOTE_HITM + MEM_LOAD_UOPS_L3_M=
ISS_RETIRED.REMOTE_FWD)))) / CLKS",
-        "MetricGroup": "Offcore;Server;Snoop;TopdownL5;tma_mem_latency_gro=
up",
-        "MetricName": "tma_remote_cache",
-        "PublicDescription": "This metric estimates fraction of cycles whi=
le the memory subsystem was handling loads from remote cache in other socke=
ts including synchronizations issues. This is caused often due to non-optim=
al NUMA allocations. #link to NUMA article Sample with: MEM_LOAD_UOPS_L3_MI=
SS_RETIRED.REMOTE_HITM_PS;MEM_LOAD_UOPS_L3_MISS_RETIRED.REMOTE_FWD_PS",
-        "ScaleUnit": "100%"
+        "BriefDescription": "Average Frequency Utilization relative nomina=
l frequency",
+        "MetricExpr": "CLKS / CPU_CLK_UNHALTED.REF_TSC",
+        "MetricGroup": "Power",
+        "MetricName": "Turbo_Utilization"
     },
     {
-        "BriefDescription": "This metric estimates how often CPU was stall=
ed  due to RFO store memory accesses; RFO store issue a read-for-ownership =
request before the write",
-        "MetricExpr": "RESOURCE_STALLS.SB / CLKS",
-        "MetricGroup": "MemoryBound;TmaL3mem;TopdownL3;tma_memory_bound_gr=
oup",
-        "MetricName": "tma_store_bound",
-        "PublicDescription": "This metric estimates how often CPU was stal=
led  due to RFO store memory accesses; RFO store issue a read-for-ownership=
 request before the write. Even though store accesses do not typically stal=
l out-of-order CPUs; there are few cases where stores can lead to actual st=
alls. This metric will be flagged should RFO stores be a bottleneck. Sample=
 with: MEM_UOPS_RETIRED.ALL_STORES_PS",
-        "ScaleUnit": "100%"
+        "BriefDescription": "Fraction of cycles where both hardware Logica=
l Processors were active",
+        "MetricExpr": "(1 - CPU_CLK_UNHALTED.ONE_THREAD_ACTIVE / (CPU_CLK_=
UNHALTED.REF_XCLK_ANY / 2) if #SMT_on else 0)",
+        "MetricGroup": "SMT",
+        "MetricName": "SMT_2T_Utilization"
     },
     {
-        "BriefDescription": "This metric estimates fraction of cycles the =
CPU spent handling L1D store misses",
-        "MetricExpr": "((L2_RQSTS.RFO_HIT * 9 * (1 - (MEM_UOPS_RETIRED.LOC=
K_LOADS / MEM_UOPS_RETIRED.ALL_STORES))) + (1 - (MEM_UOPS_RETIRED.LOCK_LOAD=
S / MEM_UOPS_RETIRED.ALL_STORES)) * min(CPU_CLK_UNHALTED.THREAD, OFFCORE_RE=
QUESTS_OUTSTANDING.CYCLES_WITH_DEMAND_RFO)) / CLKS",
-        "MetricGroup": "MemoryLat;Offcore;TopdownL4;tma_store_bound_group"=
,
-        "MetricName": "tma_store_latency",
-        "PublicDescription": "This metric estimates fraction of cycles the=
 CPU spent handling L1D store misses. Store accesses usually less impact ou=
t-of-order core performance; however; holding resources for longer time can=
 lead into undesired implications (e.g. contention on L1D fill-buffer entri=
es - see FB_Full)",
-        "ScaleUnit": "100%"
+        "BriefDescription": "Fraction of cycles spent in the Operating Sys=
tem (OS) Kernel mode",
+        "MetricExpr": "CPU_CLK_UNHALTED.THREAD_P:k / CPU_CLK_UNHALTED.THRE=
AD",
+        "MetricGroup": "OS",
+        "MetricName": "Kernel_Utilization"
     },
     {
-        "BriefDescription": "This metric roughly estimates how often CPU w=
as handling synchronizations due to False Sharing",
-        "MetricExpr": "(200 * OFFCORE_RESPONSE.DEMAND_RFO.LLC_MISS.REMOTE_=
HITM + 60 * OFFCORE_RESPONSE.DEMAND_RFO.LLC_HIT.HITM_OTHER_CORE) / CLKS",
-        "MetricGroup": "DataSharing;Offcore;Snoop;TopdownL4;tma_store_boun=
d_group",
-        "MetricName": "tma_false_sharing",
-        "PublicDescription": "This metric roughly estimates how often CPU =
was handling synchronizations due to False Sharing. False Sharing is a mult=
ithreading hiccup; where multiple Logical Processors contend on different d=
ata-elements mapped into the same cache line.  Sample with: MEM_LOAD_L3_HIT=
_RETIRED.XSNP_HITM_PS;OFFCORE_RESPONSE.DEMAND_RFO.L3_HIT.SNOOP_HITM",
-        "ScaleUnit": "100%"
+        "BriefDescription": "Cycles Per Instruction for the Operating Syst=
em (OS) Kernel mode",
+        "MetricExpr": "CPU_CLK_UNHALTED.THREAD_P:k / INST_RETIRED.ANY_P:k"=
,
+        "MetricGroup": "OS",
+        "MetricName": "Kernel_CPI"
     },
     {
-        "BriefDescription": "This metric represents rate of split store ac=
cesses",
-        "MetricExpr": "2 * MEM_UOPS_RETIRED.SPLIT_STORES / CORE_CLKS",
-        "MetricGroup": "TopdownL4;tma_store_bound_group",
-        "MetricName": "tma_split_stores",
-        "PublicDescription": "This metric represents rate of split store a=
ccesses.  Consider aligning your data to the 64-byte cache line granularity=
. Sample with: MEM_UOPS_RETIRED.SPLIT_STORES_PS",
-        "ScaleUnit": "100%"
+        "BriefDescription": "Average external Memory Bandwidth Use for rea=
ds and writes [GB / sec]",
+        "MetricExpr": "64 * (UNC_M_CAS_COUNT.RD + UNC_M_CAS_COUNT.WR) / 1e=
9 / duration_time",
+        "MetricGroup": "HPC;Mem;MemoryBW;SoC",
+        "MetricName": "DRAM_BW_Use"
     },
     {
-        "BriefDescription": "This metric roughly estimates the fraction of=
 cycles spent handling first-level data TLB store misses",
-        "MetricExpr": "(8 * DTLB_STORE_MISSES.STLB_HIT + DTLB_STORE_MISSES=
.WALK_DURATION) / CLKS",
-        "MetricGroup": "MemoryTLB;TopdownL4;tma_store_bound_group",
-        "MetricName": "tma_dtlb_store",
-        "PublicDescription": "This metric roughly estimates the fraction o=
f cycles spent handling first-level data TLB store misses.  As with ordinar=
y data caching; focus on improving data locality and reducing working-set s=
ize to reduce DTLB overhead.  Additionally; consider using profile-guided o=
ptimization (PGO) to collocate frequently-used data on the same page.  Try =
using larger page sizes for large amounts of frequently-used data. Sample w=
ith: MEM_UOPS_RETIRED.STLB_MISS_STORES_PS",
-        "ScaleUnit": "100%"
+        "BriefDescription": "Average latency of data read request to exter=
nal memory (in nanoseconds). Accounts for demand loads and L1/L2 prefetches=
",
+        "MetricExpr": "1e9 * (UNC_C_TOR_OCCUPANCY.MISS_OPCODE@filter_opc\\=
=3D0x182@ / UNC_C_TOR_INSERTS.MISS_OPCODE@filter_opc\\=3D0x182@) / (Socket_=
CLKS / duration_time)",
+        "MetricGroup": "Mem;MemoryLat;SoC",
+        "MetricName": "MEM_Read_Latency"
     },
     {
-        "BriefDescription": "This metric represents fraction of slots wher=
e Core non-memory issues were of a bottleneck",
-        "MetricExpr": "tma_backend_bound - tma_memory_bound",
-        "MetricGroup": "Backend;Compute;TopdownL2;tma_L2_group;tma_backend=
_bound_group",
-        "MetricName": "tma_core_bound",
-        "PublicDescription": "This metric represents fraction of slots whe=
re Core non-memory issues were of a bottleneck.  Shortage in hardware compu=
te resources; or dependencies in software's instructions are both categoriz=
ed under Core Bound. Hence it may indicate the machine ran out of an out-of=
-order resource; certain execution units are overloaded or dependencies in =
program's data- or instruction-flow are limiting the performance (e.g. FP-c=
hained long-latency arithmetic operations).",
-        "ScaleUnit": "100%"
+        "BriefDescription": "Average number of parallel data read requests=
 to external memory. Accounts for demand loads and L1/L2 prefetches",
+        "MetricExpr": "UNC_C_TOR_OCCUPANCY.MISS_OPCODE@filter_opc\\=3D0x18=
2@ / UNC_C_TOR_OCCUPANCY.MISS_OPCODE@filter_opc\\=3D0x182\\,thresh\\=3D1@",
+        "MetricGroup": "Mem;MemoryBW;SoC",
+        "MetricName": "MEM_Parallel_Reads"
     },
     {
-        "BriefDescription": "This metric represents fraction of cycles whe=
re the Divider unit was active",
-        "MetricExpr": "10 * ARITH.DIVIDER_UOPS / CORE_CLKS",
-        "MetricGroup": "TopdownL3;tma_core_bound_group",
-        "MetricName": "tma_divider",
-        "PublicDescription": "This metric represents fraction of cycles wh=
ere the Divider unit was active. Divide and square root instructions are pe=
rformed by the Divider unit and can take considerably longer latency than i=
nteger or Floating Point addition; subtraction; or multiplication. Sample w=
ith: ARITH.DIVIDER_UOPS",
-        "ScaleUnit": "100%"
+        "BriefDescription": "Socket actual clocks when any core is active =
on that socket",
+        "MetricExpr": "cbox_0@event\\=3D0x0@",
+        "MetricGroup": "SoC",
+        "MetricName": "Socket_CLKS"
     },
     {
-        "BriefDescription": "This metric estimates fraction of cycles the =
CPU performance was potentially limited due to Core computation issues (non=
 divider-related)",
-        "MetricExpr": "((min(CPU_CLK_UNHALTED.THREAD, CYCLE_ACTIVITY.CYCLE=
S_NO_EXECUTE) + (cpu@UOPS_EXECUTED.CORE\\,cmask\\=3D1@ - cpu@UOPS_EXECUTED.=
CORE\\,cmask\\=3D3@ if (IPC > 1.8) else cpu@UOPS_EXECUTED.CORE\\,cmask\\=3D=
2@) / 2 - RS_EVENTS.EMPTY_CYCLES if (tma_fetch_latency > 0.1) else RESOURCE=
_STALLS.SB) if #SMT_on else (min(CPU_CLK_UNHALTED.THREAD, CYCLE_ACTIVITY.CY=
CLES_NO_EXECUTE) + cpu@UOPS_EXECUTED.CORE\\,cmask\\=3D1@ - cpu@UOPS_EXECUTE=
D.CORE\\,cmask\\=3D3@ if (IPC > 1.8) else cpu@UOPS_EXECUTED.CORE\\,cmask\\=
=3D2@ - RS_EVENTS.EMPTY_CYCLES if (tma_fetch_latency > 0.1) else RESOURCE_S=
TALLS.SB) - RESOURCE_STALLS.SB - min(CPU_CLK_UNHALTED.THREAD, CYCLE_ACTIVIT=
Y.STALLS_LDM_PENDING)) / CLKS",
-        "MetricGroup": "PortsUtil;TopdownL3;tma_core_bound_group",
-        "MetricName": "tma_ports_utilization",
-        "PublicDescription": "This metric estimates fraction of cycles the=
 CPU performance was potentially limited due to Core computation issues (no=
n divider-related).  Two distinct categories can be attributed into this me=
tric: (1) heavy data-dependency among contiguous instructions would manifes=
t in this metric - such cases are often referred to as low Instruction Leve=
l Parallelism (ILP). (2) Contention on some hardware execution unit other t=
han Divider. For example; when there are too many multiply operations.",
-        "ScaleUnit": "100%"
+        "BriefDescription": "Instructions per Far Branch ( Far Branches ap=
ply upon transition from application to operating system, handling interrup=
ts, exceptions) [lower number means higher occurrence rate]",
+        "MetricExpr": "INST_RETIRED.ANY / BR_INST_RETIRED.FAR_BRANCH:u",
+        "MetricGroup": "Branches;OS",
+        "MetricName": "IpFarBranch"
     },
     {
-        "BriefDescription": "This metric represents fraction of cycles CPU=
 executed no uops on any execution port (Logical Processor cycles since ICL=
, Physical Core cycles otherwise)",
-        "MetricExpr": "(cpu@UOPS_EXECUTED.CORE\\,inv\\,cmask\\=3D1@) / 2 i=
f #SMT_on else (min(CPU_CLK_UNHALTED.THREAD, CYCLE_ACTIVITY.CYCLES_NO_EXECU=
TE) - RS_EVENTS.EMPTY_CYCLES if (tma_fetch_latency > 0.1) else 0) / CORE_CL=
KS",
-        "MetricGroup": "PortsUtil;TopdownL4;tma_ports_utilization_group",
-        "MetricName": "tma_ports_utilized_0",
-        "PublicDescription": "This metric represents fraction of cycles CP=
U executed no uops on any execution port (Logical Processor cycles since IC=
L, Physical Core cycles otherwise). Long-latency instructions like divides =
may contribute to this metric.",
-        "ScaleUnit": "100%"
+        "BriefDescription": "Uncore frequency per die [GHZ]",
+        "MetricExpr": "Socket_CLKS / #num_dies / duration_time / 1e9",
+        "MetricGroup": "SoC",
+        "MetricName": "UNCORE_FREQ"
     },
     {
-        "BriefDescription": "This metric represents fraction of cycles whe=
re the CPU executed total of 1 uop per cycle on all execution ports (Logica=
l Processor cycles since ICL, Physical Core cycles otherwise)",
-        "MetricExpr": "(cpu@UOPS_EXECUTED.CORE\\,cmask\\=3D1@ - cpu@UOPS_E=
XECUTED.CORE\\,cmask\\=3D2@) / 2 if #SMT_on else (cpu@UOPS_EXECUTED.CORE\\,=
cmask\\=3D1@ - cpu@UOPS_EXECUTED.CORE\\,cmask\\=3D2@) / CORE_CLKS",
-        "MetricGroup": "PortsUtil;TopdownL4;tma_ports_utilization_group",
-        "MetricName": "tma_ports_utilized_1",
-        "PublicDescription": "This metric represents fraction of cycles wh=
ere the CPU executed total of 1 uop per cycle on all execution ports (Logic=
al Processor cycles since ICL, Physical Core cycles otherwise). This can be=
 due to heavy data-dependency among software instructions; or over oversubs=
cribing a particular hardware resource. In some other cases with high 1_Por=
t_Utilized and L1_Bound; this metric can point to L1 data-cache latency bot=
tleneck that may not necessarily manifest with complete execution starvatio=
n (due to the short L1 latency e.g. walking a linked list) - looking at the=
 assembly can be helpful.",
-        "ScaleUnit": "100%"
+        "BriefDescription": "CPU operating frequency (in GHz)",
+        "MetricExpr": "CPU_CLK_UNHALTED.THREAD / CPU_CLK_UNHALTED.REF_TSC =
* #SYSTEM_TSC_FREQ / 1e9 / duration_time",
+        "MetricName": "cpu_operating_frequency",
+        "ScaleUnit": "1GHz"
     },
     {
-        "BriefDescription": "This metric represents fraction of cycles CPU=
 executed total of 2 uops per cycle on all execution ports (Logical Process=
or cycles since ICL, Physical Core cycles otherwise)",
-        "MetricExpr": "(cpu@UOPS_EXECUTED.CORE\\,cmask\\=3D2@ - cpu@UOPS_E=
XECUTED.CORE\\,cmask\\=3D3@) / 2 if #SMT_on else (cpu@UOPS_EXECUTED.CORE\\,=
cmask\\=3D2@ - cpu@UOPS_EXECUTED.CORE\\,cmask\\=3D3@) / CORE_CLKS",
-        "MetricGroup": "PortsUtil;TopdownL4;tma_ports_utilization_group",
-        "MetricName": "tma_ports_utilized_2",
-        "PublicDescription": "This metric represents fraction of cycles CP=
U executed total of 2 uops per cycle on all execution ports (Logical Proces=
sor cycles since ICL, Physical Core cycles otherwise).  Loop Vectorization =
-most compilers feature auto-Vectorization options today- reduces pressure =
on the execution ports as multiple elements are calculated with same uop.",
-        "ScaleUnit": "100%"
+        "BriefDescription": "Cycles per instruction retired; indicating ho=
w much time each executed instruction took; in units of cycles.",
+        "MetricExpr": "CPU_CLK_UNHALTED.THREAD / INST_RETIRED.ANY",
+        "MetricName": "cpi",
+        "ScaleUnit": "1per_instr"
     },
     {
-        "BriefDescription": "This metric represents fraction of cycles CPU=
 executed total of 3 or more uops per cycle on all execution ports (Logical=
 Processor cycles since ICL, Physical Core cycles otherwise).",
-        "MetricExpr": "((cpu@UOPS_EXECUTED.CORE\\,cmask\\=3D3@ / 2) if #SM=
T_on else cpu@UOPS_EXECUTED.CORE\\,cmask\\=3D3@) / CORE_CLKS",
-        "MetricGroup": "PortsUtil;TopdownL4;tma_ports_utilization_group",
-        "MetricName": "tma_ports_utilized_3m",
-        "ScaleUnit": "100%"
+        "BriefDescription": "The ratio of number of completed memory load =
instructions to the total number completed instructions",
+        "MetricExpr": "MEM_UOPS_RETIRED.ALL_LOADS / INST_RETIRED.ANY",
+        "MetricName": "loads_per_instr",
+        "ScaleUnit": "1per_instr"
     },
     {
-        "BriefDescription": "This metric represents Core fraction of cycle=
s CPU dispatched uops on execution ports for ALU operations.",
-        "MetricExpr": "(UOPS_DISPATCHED_PORT.PORT_0 + UOPS_DISPATCHED_PORT=
.PORT_1 + UOPS_DISPATCHED_PORT.PORT_5 + UOPS_DISPATCHED_PORT.PORT_6) / (4 *=
 CORE_CLKS)",
-        "MetricGroup": "TopdownL5;tma_ports_utilized_3m_group",
-        "MetricName": "tma_alu_op_utilization",
-        "ScaleUnit": "100%"
+        "BriefDescription": "The ratio of number of completed memory store=
 instructions to the total number completed instructions",
+        "MetricExpr": "MEM_UOPS_RETIRED.ALL_STORES / INST_RETIRED.ANY",
+        "MetricName": "stores_per_instr",
+        "ScaleUnit": "1per_instr"
     },
     {
-        "BriefDescription": "This metric represents Core fraction of cycle=
s CPU dispatched uops on execution port 0 ([SNB+] ALU; [HSW+] ALU and 2nd b=
ranch) Sample with: UOPS_DISPATCHED_PORT.PORT_0",
-        "MetricExpr": "UOPS_DISPATCHED_PORT.PORT_0 / CORE_CLKS",
-        "MetricGroup": "Compute;TopdownL6;tma_alu_op_utilization_group",
-        "MetricName": "tma_port_0",
-        "ScaleUnit": "100%"
+        "BriefDescription": "Ratio of number of requests missing L1 data c=
ache (includes data+rfo w/ prefetches) to the total number of completed ins=
tructions",
+        "MetricExpr": "L1D.REPLACEMENT / INST_RETIRED.ANY",
+        "MetricName": "l1d_mpi",
+        "ScaleUnit": "1per_instr"
     },
     {
-        "BriefDescription": "This metric represents Core fraction of cycle=
s CPU dispatched uops on execution port 1 (ALU) Sample with: UOPS_DISPATCHE=
D_PORT.PORT_1",
-        "MetricExpr": "UOPS_DISPATCHED_PORT.PORT_1 / CORE_CLKS",
-        "MetricGroup": "TopdownL6;tma_alu_op_utilization_group",
-        "MetricName": "tma_port_1",
-        "ScaleUnit": "100%"
+        "BriefDescription": "Ratio of number of demand load requests hitti=
ng in L1 data cache to the total number of completed instructions",
+        "MetricExpr": "MEM_LOAD_UOPS_RETIRED.L1_HIT / INST_RETIRED.ANY",
+        "MetricName": "l1d_demand_data_read_hits_per_instr",
+        "ScaleUnit": "1per_instr"
     },
     {
-        "BriefDescription": "This metric represents Core fraction of cycle=
s CPU dispatched uops on execution port 5 ([SNB+] Branches and ALU; [HSW+] =
ALU) Sample with: UOPS_DISPATCHED.PORT_5",
-        "MetricExpr": "UOPS_DISPATCHED_PORT.PORT_5 / CORE_CLKS",
-        "MetricGroup": "TopdownL6;tma_alu_op_utilization_group",
-        "MetricName": "tma_port_5",
-        "ScaleUnit": "100%"
+        "BriefDescription": "Ratio of number of code read requests missing=
 in L1 instruction cache (includes prefetches) to the total number of compl=
eted instructions",
+        "MetricExpr": "L2_RQSTS.ALL_CODE_RD / INST_RETIRED.ANY",
+        "MetricName": "l1_i_code_read_misses_with_prefetches_per_instr",
+        "ScaleUnit": "1per_instr"
     },
     {
-        "BriefDescription": "This metric represents Core fraction of cycle=
s CPU dispatched uops on execution port 6 ([HSW+]Primary Branch and simple =
ALU) Sample with: UOPS_DISPATCHED_PORT.PORT_6",
-        "MetricExpr": "UOPS_DISPATCHED_PORT.PORT_6 / CORE_CLKS",
-        "MetricGroup": "TopdownL6;tma_alu_op_utilization_group",
-        "MetricName": "tma_port_6",
-        "ScaleUnit": "100%"
+        "BriefDescription": "Ratio of number of completed demand load requ=
ests hitting in L2 cache to the total number of completed instructions",
+        "MetricExpr": "MEM_LOAD_UOPS_RETIRED.L2_HIT / INST_RETIRED.ANY",
+        "MetricName": "l2_demand_data_read_hits_per_instr",
+        "ScaleUnit": "1per_instr"
     },
     {
-        "BriefDescription": "This metric represents Core fraction of cycle=
s CPU dispatched uops on execution port for Load operations Sample with: UO=
PS_DISPATCHED.PORT_2_3",
-        "MetricExpr": "(UOPS_DISPATCHED_PORT.PORT_2 + UOPS_DISPATCHED_PORT=
.PORT_3 + UOPS_DISPATCHED_PORT.PORT_7 - UOPS_DISPATCHED_PORT.PORT_4) / (2 *=
 CORE_CLKS)",
-        "MetricGroup": "TopdownL5;tma_ports_utilized_3m_group",
-        "MetricName": "tma_load_op_utilization",
-        "ScaleUnit": "100%"
+        "BriefDescription": "Ratio of number of requests missing L2 cache =
(includes code+data+rfo w/ prefetches) to the total number of completed ins=
tructions",
+        "MetricExpr": "L2_LINES_IN.ALL / INST_RETIRED.ANY",
+        "MetricName": "l2_mpi",
+        "ScaleUnit": "1per_instr"
     },
     {
-        "BriefDescription": "This metric represents Core fraction of cycle=
s CPU dispatched uops on execution port 2 ([SNB+]Loads and Store-address; [=
ICL+] Loads) Sample with: UOPS_DISPATCHED_PORT.PORT_2",
-        "MetricExpr": "UOPS_DISPATCHED_PORT.PORT_2 / CORE_CLKS",
-        "MetricGroup": "TopdownL6;tma_load_op_utilization_group",
-        "MetricName": "tma_port_2",
-        "ScaleUnit": "100%"
+        "BriefDescription": "Ratio of number of completed data read reques=
t missing L2 cache to the total number of completed instructions",
+        "MetricExpr": "MEM_LOAD_UOPS_RETIRED.L2_MISS / INST_RETIRED.ANY",
+        "MetricName": "l2_demand_data_read_mpi",
+        "ScaleUnit": "1per_instr"
     },
     {
-        "BriefDescription": "This metric represents Core fraction of cycle=
s CPU dispatched uops on execution port 3 ([SNB+]Loads and Store-address; [=
ICL+] Loads) Sample with: UOPS_DISPATCHED_PORT.PORT_3",
-        "MetricExpr": "UOPS_DISPATCHED_PORT.PORT_3 / CORE_CLKS",
-        "MetricGroup": "TopdownL6;tma_load_op_utilization_group",
-        "MetricName": "tma_port_3",
-        "ScaleUnit": "100%"
+        "BriefDescription": "Ratio of number of code read request missing =
L2 cache to the total number of completed instructions",
+        "MetricExpr": "L2_RQSTS.CODE_RD_MISS / INST_RETIRED.ANY",
+        "MetricName": "l2_demand_code_mpi",
+        "ScaleUnit": "1per_instr"
     },
     {
-        "BriefDescription": "This metric represents Core fraction of cycle=
s CPU dispatched uops on execution port for Store operations",
-        "MetricExpr": "UOPS_DISPATCHED_PORT.PORT_4 / CORE_CLKS",
-        "MetricGroup": "TopdownL5;tma_ports_utilized_3m_group",
-        "MetricName": "tma_store_op_utilization",
-        "ScaleUnit": "100%"
+        "BriefDescription": "Average latency of a last level cache (LLC) d=
emand and prefetch data read miss (read memory access) in nano seconds",
+        "MetricExpr": "1e9 * (cbox@UNC_C_TOR_OCCUPANCY.MISS_OPCODE\\,filte=
r_opc\\=3D0x182@ / cbox@UNC_C_TOR_INSERTS.MISS_OPCODE\\,filter_opc\\=3D0x18=
2@) / (UNC_C_CLOCKTICKS / (#num_cores / #num_packages * #num_packages)) * d=
uration_time",
+        "MetricName": "llc_data_read_demand_plus_prefetch_miss_latency",
+        "ScaleUnit": "1ns"
     },
     {
-        "BriefDescription": "This metric represents Core fraction of cycle=
s CPU dispatched uops on execution port 4 (Store-data) Sample with: UOPS_DI=
SPATCHED_PORT.PORT_4",
-        "MetricExpr": "UOPS_DISPATCHED_PORT.PORT_4 / CORE_CLKS",
-        "MetricGroup": "TopdownL6;tma_store_op_utilization_group",
-        "MetricName": "tma_port_4",
-        "ScaleUnit": "100%"
+        "BriefDescription": "Average latency of a last level cache (LLC) d=
emand and prefetch data read miss (read memory access) addressed to local m=
emory in nano seconds",
+        "MetricExpr": "1e9 * (cbox@UNC_C_TOR_OCCUPANCY.MISS_LOCAL_OPCODE\\=
,filter_opc\\=3D0x182@ / cbox@UNC_C_TOR_INSERTS.MISS_LOCAL_OPCODE\\,filter_=
opc\\=3D0x182@) / (UNC_C_CLOCKTICKS / (#num_cores / #num_packages * #num_pa=
ckages)) * duration_time",
+        "MetricName": "llc_data_read_demand_plus_prefetch_miss_latency_for=
_local_requests",
+        "ScaleUnit": "1ns"
     },
     {
-        "BriefDescription": "This metric represents Core fraction of cycle=
s CPU dispatched uops on execution port 7 ([HSW+]simple Store-address) Samp=
le with: UOPS_DISPATCHED_PORT.PORT_7",
-        "MetricExpr": "UOPS_DISPATCHED_PORT.PORT_7 / CORE_CLKS",
-        "MetricGroup": "TopdownL6;tma_store_op_utilization_group",
-        "MetricName": "tma_port_7",
-        "ScaleUnit": "100%"
+        "BriefDescription": "Average latency of a last level cache (LLC) d=
emand and prefetch data read miss (read memory access) addressed to remote =
memory in nano seconds",
+        "MetricExpr": "1e9 * (cbox@UNC_C_TOR_OCCUPANCY.MISS_REMOTE_OPCODE\=
\,filter_opc\\=3D0x182@ / cbox@UNC_C_TOR_INSERTS.MISS_REMOTE_OPCODE\\,filte=
r_opc\\=3D0x182@) / (UNC_C_CLOCKTICKS / (#num_cores / #num_packages * #num_=
packages)) * duration_time",
+        "MetricName": "llc_data_read_demand_plus_prefetch_miss_latency_for=
_remote_requests",
+        "ScaleUnit": "1ns"
     },
     {
-        "BriefDescription": "This category represents fraction of slots ut=
ilized by useful work i.e. issued uops that eventually get retired",
-        "MetricExpr": "UOPS_RETIRED.RETIRE_SLOTS / SLOTS",
-        "MetricGroup": "TopdownL1;tma_L1_group",
-        "MetricName": "tma_retiring",
-        "PublicDescription": "This category represents fraction of slots u=
tilized by useful work i.e. issued uops that eventually get retired. Ideall=
y; all pipeline slots would be attributed to the Retiring category.  Retiri=
ng of 100% would indicate the maximum Pipeline_Width throughput was achieve=
d.  Maximizing Retiring typically increases the Instructions-per-cycle (see=
 IPC metric). Note that a high Retiring value does not necessary mean there=
 is no room for more performance.  For example; Heavy-operations or Microco=
de Assists are categorized under Retiring. They often indicate suboptimal p=
erformance and can often be optimized or avoided.  Sample with: UOPS_RETIRE=
D.RETIRE_SLOTS",
-        "ScaleUnit": "100%"
+        "BriefDescription": "Ratio of number of completed page walks (for =
all page sizes) caused by a code fetch to the total number of completed ins=
tructions",
+        "MetricExpr": "ITLB_MISSES.WALK_COMPLETED / INST_RETIRED.ANY",
+        "MetricName": "itlb_mpi",
+        "PublicDescription": "Ratio of number of completed page walks (for=
 all page sizes) caused by a code fetch to the total number of completed in=
structions. This implies it missed in the ITLB (Instruction TLB) and furthe=
r levels of TLB.",
+        "ScaleUnit": "1per_instr"
     },
     {
-        "BriefDescription": "This metric represents fraction of slots wher=
e the CPU was retiring light-weight operations -- instructions that require=
 no more than one uop (micro-operation)",
-        "MetricExpr": "tma_retiring - tma_heavy_operations",
-        "MetricGroup": "Retire;TopdownL2;tma_L2_group;tma_retiring_group",
-        "MetricName": "tma_light_operations",
-        "PublicDescription": "This metric represents fraction of slots whe=
re the CPU was retiring light-weight operations -- instructions that requir=
e no more than one uop (micro-operation). This correlates with total number=
 of instructions used by the program. A uops-per-instruction (see UPI metri=
c) ratio of 1 or less should be expected for decently optimized software ru=
nning on Intel Core/Xeon products. While this often indicates efficient X86=
 instructions were executed; high value does not necessarily mean better pe=
rformance cannot be achieved. Sample with: INST_RETIRED.PREC_DIST",
-        "ScaleUnit": "100%"
+        "BriefDescription": "Ratio of number of completed page walks (for =
2 megabyte and 4 megabyte page sizes) caused by a code fetch to the total n=
umber of completed instructions",
+        "MetricExpr": "ITLB_MISSES.WALK_COMPLETED_2M_4M / INST_RETIRED.ANY=
",
+        "MetricName": "itlb_large_page_mpi",
+        "PublicDescription": "Ratio of number of completed page walks (for=
 2 megabyte and 4 megabyte page sizes) caused by a code fetch to the total =
number of completed instructions. This implies it missed in the Instruction=
 Translation Lookaside Buffer (ITLB) and further levels of TLB.",
+        "ScaleUnit": "1per_instr"
     },
     {
-        "BriefDescription": "This metric serves as an approximation of leg=
acy x87 usage",
-        "MetricExpr": "INST_RETIRED.X87 * UPI / UOPS_RETIRED.RETIRE_SLOTS"=
,
-        "MetricGroup": "Compute;TopdownL4;tma_fp_arith_group",
-        "MetricName": "tma_x87_use",
-        "PublicDescription": "This metric serves as an approximation of le=
gacy x87 usage. It accounts for instructions beyond X87 FP arithmetic opera=
tions; hence may be used as a thermometer to avoid X87 high usage and prefe=
rably upgrade to modern ISA. See Tip under Tuning Hint.",
-        "ScaleUnit": "100%"
+        "BriefDescription": "Ratio of number of completed page walks (for =
all page sizes) caused by demand data loads to the total number of complete=
d instructions",
+        "MetricExpr": "DTLB_LOAD_MISSES.WALK_COMPLETED / INST_RETIRED.ANY"=
,
+        "MetricName": "dtlb_load_mpi",
+        "PublicDescription": "Ratio of number of completed page walks (for=
 all page sizes) caused by demand data loads to the total number of complet=
ed instructions. This implies it missed in the DTLB and further levels of T=
LB.",
+        "ScaleUnit": "1per_instr"
     },
     {
-        "BriefDescription": "This metric represents fraction of slots wher=
e the CPU was retiring heavy-weight operations -- instructions that require=
 two or more uops or microcoded sequences",
-        "MetricExpr": "tma_microcode_sequencer",
-        "MetricGroup": "Retire;TopdownL2;tma_L2_group;tma_retiring_group",
-        "MetricName": "tma_heavy_operations",
-        "PublicDescription": "This metric represents fraction of slots whe=
re the CPU was retiring heavy-weight operations -- instructions that requir=
e two or more uops or microcoded sequences. This highly-correlates with the=
 uop length of these instructions/sequences.",
-        "ScaleUnit": "100%"
+        "BriefDescription": "Ratio of number of completed page walks (for =
all page sizes) caused by demand data stores to the total number of complet=
ed instructions",
+        "MetricExpr": "DTLB_STORE_MISSES.WALK_COMPLETED / INST_RETIRED.ANY=
",
+        "MetricName": "dtlb_store_mpi",
+        "PublicDescription": "Ratio of number of completed page walks (for=
 all page sizes) caused by demand data stores to the total number of comple=
ted instructions. This implies it missed in the DTLB and further levels of =
TLB.",
+        "ScaleUnit": "1per_instr"
     },
     {
-        "BriefDescription": "This metric represents fraction of slots the =
CPU was retiring uops fetched by the Microcode Sequencer (MS) unit",
-        "MetricExpr": "(UOPS_RETIRED.RETIRE_SLOTS / UOPS_ISSUED.ANY) * IDQ=
.MS_UOPS / SLOTS",
-        "MetricGroup": "MicroSeq;TopdownL3;tma_heavy_operations_group",
-        "MetricName": "tma_microcode_sequencer",
-        "PublicDescription": "This metric represents fraction of slots the=
 CPU was retiring uops fetched by the Microcode Sequencer (MS) unit.  The M=
S is used for CISC instructions not supported by the default decoders (like=
 repeat move strings; or CPUID); or by microcode assists used to address so=
me operation modes (like in Floating Point assists). These cases can often =
be avoided. Sample with: IDQ.MS_UOPS",
-        "ScaleUnit": "100%"
+        "BriefDescription": "Uncore operating frequency in GHz",
+        "MetricExpr": "UNC_C_CLOCKTICKS / (#num_cores / #num_packages * #n=
um_packages) / 1e9 / duration_time",
+        "MetricName": "uncore_frequency",
+        "ScaleUnit": "1GHz"
     },
     {
-        "BriefDescription": "This metric estimates fraction of slots the C=
PU retired uops delivered by the Microcode_Sequencer as a result of Assists=
",
-        "MetricExpr": "100 * OTHER_ASSISTS.ANY_WB_ASSIST / SLOTS",
-        "MetricGroup": "TopdownL4;tma_microcode_sequencer_group",
-        "MetricName": "tma_assists",
-        "PublicDescription": "This metric estimates fraction of slots the =
CPU retired uops delivered by the Microcode_Sequencer as a result of Assist=
s. Assists are long sequences of uops that are required in certain corner-c=
ases for operations that cannot be handled natively by the execution pipeli=
ne. For example; when working with very small floating point values (so-cal=
led Denormals); the FP units are not set up to perform these operations nat=
ively. Instead; a sequence of instructions to perform the computation on th=
e Denormals is injected into the pipeline. Since these microcode sequences =
might be dozens of uops long; Assists can be extremely deleterious to perfo=
rmance and they can be avoided in many cases. Sample with: OTHER_ASSISTS.AN=
Y",
-        "ScaleUnit": "100%"
+        "BriefDescription": "Intel(R) Quick Path Interconnect (QPI) data t=
ransmit bandwidth (MB/sec)",
+        "MetricExpr": "UNC_Q_TxL_FLITS_G0.DATA * 8 / 1e6 / duration_time",
+        "MetricName": "qpi_data_transmit_bw",
+        "ScaleUnit": "1MB/s"
     },
     {
-        "BriefDescription": "This metric estimates fraction of cycles the =
CPU retired uops originated from CISC (complex instruction set computer) in=
struction",
-        "MetricExpr": "max(0, tma_microcode_sequencer - tma_assists)",
-        "MetricGroup": "TopdownL4;tma_microcode_sequencer_group",
-        "MetricName": "tma_cisc",
-        "PublicDescription": "This metric estimates fraction of cycles the=
 CPU retired uops originated from CISC (complex instruction set computer) i=
nstruction. A CISC instruction has multiple uops that are required to perfo=
rm the instruction's functionality as in the case of read-modify-write as a=
n example. Since these instructions require multiple uops they may or may n=
ot imply sub-optimal use of machine resources.",
-        "ScaleUnit": "100%"
+        "BriefDescription": "DDR memory read bandwidth (MB/sec)",
+        "MetricExpr": "UNC_M_CAS_COUNT.RD * 64 / 1e6 / duration_time",
+        "MetricName": "memory_bandwidth_read",
+        "ScaleUnit": "1MB/s"
     },
     {
-        "BriefDescription": "Instructions Per Cycle (per Logical Processor=
)",
-        "MetricExpr": "INST_RETIRED.ANY / CLKS",
-        "MetricGroup": "Ret;Summary",
-        "MetricName": "IPC"
+        "BriefDescription": "DDR memory write bandwidth (MB/sec)",
+        "MetricExpr": "UNC_M_CAS_COUNT.WR * 64 / 1e6 / duration_time",
+        "MetricName": "memory_bandwidth_write",
+        "ScaleUnit": "1MB/s"
     },
     {
-        "BriefDescription": "Uops Per Instruction",
-        "MetricExpr": "UOPS_RETIRED.RETIRE_SLOTS / INST_RETIRED.ANY",
-        "MetricGroup": "Pipeline;Ret;Retire",
-        "MetricName": "UPI"
+        "BriefDescription": "DDR memory bandwidth (MB/sec)",
+        "MetricExpr": "(UNC_M_CAS_COUNT.RD + UNC_M_CAS_COUNT.WR) * 64 / 1e=
6 / duration_time",
+        "MetricName": "memory_bandwidth_total",
+        "ScaleUnit": "1MB/s"
     },
     {
-        "BriefDescription": "Instruction per taken branch",
-        "MetricExpr": "UOPS_RETIRED.RETIRE_SLOTS / BR_INST_RETIRED.NEAR_TA=
KEN",
-        "MetricGroup": "Branches;Fed;FetchBW",
-        "MetricName": "UpTB"
+        "BriefDescription": "Bandwidth of IO reads that are initiated by e=
nd device controllers that are requesting memory from the CPU.",
+        "MetricExpr": "cbox@UNC_C_TOR_INSERTS.OPCODE\\,filter_opc\\=3D0x19=
e@ * 64 / 1e6 / duration_time",
+        "MetricName": "io_bandwidth_disk_or_network_writes",
+        "ScaleUnit": "1MB/s"
     },
     {
-        "BriefDescription": "Cycles Per Instruction (per Logical Processor=
)",
-        "MetricExpr": "1 / IPC",
-        "MetricGroup": "Mem;Pipeline",
-        "MetricName": "CPI"
+        "BriefDescription": "Bandwidth of IO writes that are initiated by =
end device controllers that are writing memory to the CPU.",
+        "MetricExpr": "cbox@UNC_C_TOR_INSERTS.OPCODE\\,filter_opc\\=3D0x1c=
8\\,filter_tid\\=3D0x3e@ * 64 / 1e6 / duration_time",
+        "MetricName": "io_bandwidth_disk_or_network_reads",
+        "ScaleUnit": "1MB/s"
     },
     {
-        "BriefDescription": "Per-Logical Processor actual clocks when the =
Logical Processor is active.",
-        "MetricExpr": "CPU_CLK_UNHALTED.THREAD",
-        "MetricGroup": "Pipeline",
-        "MetricName": "CLKS"
+        "BriefDescription": "Uops delivered from decoded instruction cache=
 (decoded stream buffer or DSB) as a percent of total uops delivered to Ins=
truction Decode Queue",
+        "MetricExpr": "IDQ.DSB_UOPS / UOPS_ISSUED.ANY",
+        "MetricName": "percent_uops_delivered_from_decoded_icache",
+        "ScaleUnit": "100%"
     },
     {
-        "BriefDescription": "Total issue-pipeline slots (per-Physical Core=
 till ICL; per-Logical Processor ICL onward)",
-        "MetricExpr": "4 * CORE_CLKS",
-        "MetricGroup": "tma_L1_group",
-        "MetricName": "SLOTS"
+        "BriefDescription": "Uops delivered from legacy decode pipeline (M=
icro-instruction Translation Engine or MITE) as a percent of total uops del=
ivered to Instruction Decode Queue",
+        "MetricExpr": "IDQ.MITE_UOPS / UOPS_ISSUED.ANY",
+        "MetricName": "percent_uops_delivered_from_legacy_decode_pipeline"=
,
+        "ScaleUnit": "100%"
     },
     {
-        "BriefDescription": "Instructions Per Cycle across hyper-threads (=
per physical core)",
-        "MetricExpr": "INST_RETIRED.ANY / CORE_CLKS",
-        "MetricGroup": "Ret;SMT;tma_L1_group",
-        "MetricName": "CoreIPC"
+        "BriefDescription": "Uops delivered from microcode sequencer (MS) =
as a percent of total uops delivered to Instruction Decode Queue",
+        "MetricExpr": "IDQ.MS_UOPS / UOPS_ISSUED.ANY",
+        "MetricName": "percent_uops_delivered_from_microcode_sequencer",
+        "ScaleUnit": "100%"
     },
     {
-        "BriefDescription": "Instruction-Level-Parallelism (average number=
 of uops executed when there is execution) per-core",
-        "MetricExpr": "(UOPS_EXECUTED.CORE / 2 / ((cpu@UOPS_EXECUTED.CORE\=
\,cmask\\=3D1@ / 2) if #SMT_on else cpu@UOPS_EXECUTED.CORE\\,cmask\\=3D1@))=
 if #SMT_on else UOPS_EXECUTED.CORE / ((cpu@UOPS_EXECUTED.CORE\\,cmask\\=3D=
1@ / 2) if #SMT_on else cpu@UOPS_EXECUTED.CORE\\,cmask\\=3D1@)",
-        "MetricGroup": "Backend;Cor;Pipeline;PortsUtil",
-        "MetricName": "ILP"
+        "BriefDescription": "Uops delivered from loop stream detector(LSD)=
 as a percent of total uops delivered to Instruction Decode Queue",
+        "MetricExpr": "(UOPS_ISSUED.ANY - IDQ.MITE_UOPS - IDQ.MS_UOPS - ID=
Q.DSB_UOPS) / UOPS_ISSUED.ANY",
+        "MetricName": "percent_uops_delivered_from_loop_stream_detector",
+        "ScaleUnit": "100%"
     },
     {
-        "BriefDescription": "Core actual clocks when any Logical Processor=
 is active on the Physical Core",
-        "MetricExpr": "((CPU_CLK_UNHALTED.THREAD / 2) * (1 + CPU_CLK_UNHAL=
TED.ONE_THREAD_ACTIVE / CPU_CLK_UNHALTED.REF_XCLK)) if #core_wide < 1 else =
(CPU_CLK_UNHALTED.THREAD_ANY / 2) if #SMT_on else CLKS",
-        "MetricGroup": "SMT",
-        "MetricName": "CORE_CLKS"
+        "BriefDescription": "Ratio of number of data read requests missing=
 last level core cache (includes demand w/ prefetches) to the total number =
of completed instructions",
+        "MetricExpr": "(cbox@UNC_C_TOR_INSERTS.MISS_OPCODE\\,filter_opc\\=
=3D0x182@ + cbox@UNC_C_TOR_INSERTS.MISS_OPCODE\\,filter_opc\\=3D0x192@) / I=
NST_RETIRED.ANY",
+        "MetricName": "llc_data_read_mpi_demand_plus_prefetch",
+        "ScaleUnit": "1per_instr"
     },
     {
-        "BriefDescription": "Instructions per Load (lower number means hig=
her occurrence rate)",
-        "MetricExpr": "INST_RETIRED.ANY / MEM_UOPS_RETIRED.ALL_LOADS",
-        "MetricGroup": "InsType",
-        "MetricName": "IpLoad"
+        "BriefDescription": "Ratio of number of code read requests missing=
 last level core cache (includes demand w/ prefetches) to the total number =
of completed instructions",
+        "MetricExpr": "(cbox@UNC_C_TOR_INSERTS.MISS_OPCODE\\,filter_opc\\=
=3D0x181@ + cbox@UNC_C_TOR_INSERTS.MISS_OPCODE\\,filter_opc\\=3D0x191@) / I=
NST_RETIRED.ANY",
+        "MetricName": "llc_code_read_mpi_demand_plus_prefetch",
+        "ScaleUnit": "1per_instr"
     },
     {
-        "BriefDescription": "Instructions per Store (lower number means hi=
gher occurrence rate)",
-        "MetricExpr": "INST_RETIRED.ANY / MEM_UOPS_RETIRED.ALL_STORES",
-        "MetricGroup": "InsType",
-        "MetricName": "IpStore"
+        "BriefDescription": "Memory read that miss the last level cache (L=
LC) addressed to local DRAM as a percentage of total memory read accesses, =
does not include LLC prefetches.",
+        "MetricExpr": "cbox@UNC_C_TOR_INSERTS.MISS_LOCAL_OPCODE\\,filter_o=
pc\\=3D0x182@ / (cbox@UNC_C_TOR_INSERTS.MISS_LOCAL_OPCODE\\,filter_opc\\=3D=
0x182@ + cbox@UNC_C_TOR_INSERTS.MISS_REMOTE_OPCODE\\,filter_opc\\=3D0x182@)=
",
+        "MetricName": "numa_reads_addressed_to_local_dram",
+        "ScaleUnit": "100%"
     },
     {
-        "BriefDescription": "Instructions per Branch (lower number means h=
igher occurrence rate)",
-        "MetricExpr": "INST_RETIRED.ANY / BR_INST_RETIRED.ALL_BRANCHES",
-        "MetricGroup": "Branches;Fed;InsType",
-        "MetricName": "IpBranch"
+        "BriefDescription": "Memory reads that miss the last level cache (=
LLC) addressed to remote DRAM as a percentage of total memory read accesses=
, does not include LLC prefetches.",
+        "MetricExpr": "cbox@UNC_C_TOR_INSERTS.MISS_REMOTE_OPCODE\\,filter_=
opc\\=3D0x182@ / (cbox@UNC_C_TOR_INSERTS.MISS_LOCAL_OPCODE\\,filter_opc\\=
=3D0x182@ + cbox@UNC_C_TOR_INSERTS.MISS_REMOTE_OPCODE\\,filter_opc\\=3D0x18=
2@)",
+        "MetricName": "numa_reads_addressed_to_remote_dram",
+        "ScaleUnit": "100%"
     },
     {
-        "BriefDescription": "Instructions per (near) call (lower number me=
ans higher occurrence rate)",
-        "MetricExpr": "INST_RETIRED.ANY / BR_INST_RETIRED.NEAR_CALL",
-        "MetricGroup": "Branches;Fed;PGO",
-        "MetricName": "IpCall"
+        "BriefDescription": "This category represents fraction of slots wh=
ere the processor's Frontend undersupplies its Backend",
+        "MetricExpr": "IDQ_UOPS_NOT_DELIVERED.CORE / SLOTS",
+        "MetricGroup": "PGO;TopdownL1;tma_L1_group;tma_L1_group",
+        "MetricName": "tma_frontend_bound",
+        "PublicDescription": "This category represents fraction of slots w=
here the processor's Frontend undersupplies its Backend. Frontend denotes t=
he first part of the processor core responsible to fetch operations that ar=
e executed later on by the Backend part. Within the Frontend; a branch pred=
ictor predicts the next address to fetch; cache-lines are fetched from the =
memory subsystem; parsed into instructions; and lastly decoded into micro-o=
perations (uops). Ideally the Frontend can issue Machine_Width uops every c=
ycle to the Backend. Frontend Bound denotes unutilized issue-slots when the=
re is no Backend stall; i.e. bubbles where Frontend delivered no uops while=
 Backend could have accepted them. For example; stalls due to instruction-c=
ache misses would be categorized under Frontend Bound.",
+        "ScaleUnit": "100%"
     },
     {
-        "BriefDescription": "Instruction per taken branch",
-        "MetricExpr": "INST_RETIRED.ANY / BR_INST_RETIRED.NEAR_TAKEN",
-        "MetricGroup": "Branches;Fed;FetchBW;Frontend;PGO",
-        "MetricName": "IpTB"
+        "BriefDescription": "This metric represents fraction of slots the =
CPU was stalled due to Frontend latency issues",
+        "MetricExpr": "4 * min(CPU_CLK_UNHALTED.THREAD, IDQ_UOPS_NOT_DELIV=
ERED.CYCLES_0_UOPS_DELIV.CORE) / SLOTS",
+        "MetricGroup": "Frontend;TopdownL2;tma_L2_group;tma_L2_group;tma_f=
rontend_bound_group",
+        "MetricName": "tma_fetch_latency",
+        "PublicDescription": "This metric represents fraction of slots the=
 CPU was stalled due to Frontend latency issues.  For example; instruction-=
cache misses; iTLB misses or fetch stalls after a branch misprediction are =
categorized under Frontend Latency. In such cases; the Frontend eventually =
delivers no uops for some period.",
+        "ScaleUnit": "100%"
     },
     {
-        "BriefDescription": "Branch instructions per taken branch. ",
-        "MetricExpr": "BR_INST_RETIRED.ALL_BRANCHES / BR_INST_RETIRED.NEAR=
_TAKEN",
-        "MetricGroup": "Branches;Fed;PGO",
-        "MetricName": "BpTkBranch"
+        "BriefDescription": "This metric represents fraction of cycles the=
 CPU was stalled due to instruction cache misses.",
+        "MetricExpr": "ICACHE.IFDATA_STALL / CPU_CLK_UNHALTED.THREAD",
+        "MetricGroup": "BigFoot;FetchLat;IcMiss;TopdownL3;tma_L3_group;tma=
_fetch_latency_group",
+        "MetricName": "tma_icache_misses",
+        "ScaleUnit": "100%"
     },
     {
-        "BriefDescription": "Total number of retired Instructions Sample w=
ith: INST_RETIRED.PREC_DIST",
-        "MetricExpr": "INST_RETIRED.ANY",
-        "MetricGroup": "Summary;tma_L1_group",
-        "MetricName": "Instructions"
+        "BriefDescription": "This metric represents fraction of cycles the=
 CPU was stalled due to Instruction TLB (ITLB) misses.",
+        "MetricExpr": "(14 * ITLB_MISSES.STLB_HIT + ITLB_MISSES.WALK_DURAT=
ION) / CPU_CLK_UNHALTED.THREAD",
+        "MetricGroup": "BigFoot;FetchLat;MemoryTLB;TopdownL3;tma_L3_group;=
tma_fetch_latency_group",
+        "MetricName": "tma_itlb_misses",
+        "ScaleUnit": "100%"
     },
     {
-        "BriefDescription": "Average number of Uops retired in cycles wher=
e at least one uop has retired.",
-        "MetricExpr": "UOPS_RETIRED.RETIRE_SLOTS / cpu@UOPS_RETIRED.RETIRE=
_SLOTS\\,cmask\\=3D1@",
-        "MetricGroup": "Pipeline;Ret",
-        "MetricName": "Retire"
+        "BriefDescription": "This metric represents fraction of cycles the=
 CPU was stalled due to Branch Resteers",
+        "MetricExpr": "12 * (BR_MISP_RETIRED.ALL_BRANCHES + MACHINE_CLEARS=
.COUNT + BACLEARS.ANY) / CPU_CLK_UNHALTED.THREAD",
+        "MetricGroup": "FetchLat;TopdownL3;tma_L3_group;tma_fetch_latency_=
group",
+        "MetricName": "tma_branch_resteers",
+        "PublicDescription": "This metric represents fraction of cycles th=
e CPU was stalled due to Branch Resteers. Branch Resteers estimates the Fro=
ntend delay in fetching operations from corrected path; following all sorts=
 of miss-predicted branches. For example; branchy code with lots of miss-pr=
edictions might get categorized under Branch Resteers. Note the value of th=
is node may overlap with its siblings.",
+        "ScaleUnit": "100%"
     },
     {
-        "BriefDescription": "Fraction of Uops delivered by the DSB (aka De=
coded ICache; or Uop Cache)",
-        "MetricExpr": "IDQ.DSB_UOPS / ((IDQ.DSB_UOPS + LSD.UOPS + IDQ.MITE=
_UOPS + IDQ.MS_UOPS))",
-        "MetricGroup": "DSB;Fed;FetchBW",
-        "MetricName": "DSB_Coverage"
+        "BriefDescription": "This metric represents fraction of cycles the=
 CPU was stalled due to switches from DSB to MITE pipelines",
+        "MetricExpr": "DSB2MITE_SWITCHES.PENALTY_CYCLES / CPU_CLK_UNHALTED=
.THREAD",
+        "MetricGroup": "DSBmiss;FetchLat;TopdownL3;tma_L3_group;tma_fetch_=
latency_group",
+        "MetricName": "tma_dsb_switches",
+        "PublicDescription": "This metric represents fraction of cycles th=
e CPU was stalled due to switches from DSB to MITE pipelines. The DSB (deco=
ded i-cache) is a Uop Cache where the front-end directly delivers Uops (mic=
ro operations) avoiding heavy x86 decoding. The DSB pipeline has shorter la=
tency and delivered higher bandwidth than the MITE (legacy instruction deco=
de pipeline). Switching between the two pipelines can cause penalties hence=
 this metric measures the exposed penalty.",
+        "ScaleUnit": "100%"
     },
     {
-        "BriefDescription": "Number of Instructions per non-speculative Br=
anch Misprediction (JEClear) (lower number means higher occurrence rate)",
-        "MetricExpr": "INST_RETIRED.ANY / BR_MISP_RETIRED.ALL_BRANCHES",
-        "MetricGroup": "Bad;BadSpec;BrMispredicts",
-        "MetricName": "IpMispredict"
+        "BriefDescription": "This metric represents fraction of cycles CPU=
 was stalled due to Length Changing Prefixes (LCPs)",
+        "MetricExpr": "ILD_STALL.LCP / CPU_CLK_UNHALTED.THREAD",
+        "MetricGroup": "FetchLat;TopdownL3;tma_L3_group;tma_fetch_latency_=
group",
+        "MetricName": "tma_lcp",
+        "PublicDescription": "This metric represents fraction of cycles CP=
U was stalled due to Length Changing Prefixes (LCPs). Using proper compiler=
 flags or Intel Compiler by default will certainly avoid this. #Link: Optim=
ization Guide about LCP BKMs.",
+        "ScaleUnit": "100%"
     },
     {
-        "BriefDescription": "Actual Average Latency for L1 data-cache miss=
 demand load operations (in core cycles)",
-        "MetricExpr": "L1D_PEND_MISS.PENDING / (MEM_LOAD_UOPS_RETIRED.L1_M=
ISS + mem_load_uops_retired.hit_lfb)",
-        "MetricGroup": "Mem;MemoryBound;MemoryLat",
-        "MetricName": "Load_Miss_Real_Latency"
+        "BriefDescription": "This metric estimates the fraction of cycles =
when the CPU was stalled due to switches of uop delivery to the Microcode S=
equencer (MS)",
+        "MetricExpr": "2 * IDQ.MS_SWITCHES / CPU_CLK_UNHALTED.THREAD",
+        "MetricGroup": "FetchLat;MicroSeq;TopdownL3;tma_L3_group;tma_fetch=
_latency_group",
+        "MetricName": "tma_ms_switches",
+        "PublicDescription": "This metric estimates the fraction of cycles=
 when the CPU was stalled due to switches of uop delivery to the Microcode =
Sequencer (MS). Commonly used instructions are optimized for delivery by th=
e DSB (decoded i-cache) or MITE (legacy instruction decode) pipelines. Cert=
ain operations cannot be handled natively by the execution pipeline; and mu=
st be performed by microcode (small programs injected into the execution st=
ream). Switching to the MS too often can negatively impact performance. The=
 MS is designated to deliver long uop flows required by CISC instructions l=
ike CPUID; or uncommon conditions like Floating Point Assists when dealing =
with Denormals.",
+        "ScaleUnit": "100%"
     },
     {
-        "BriefDescription": "Memory-Level-Parallelism (average number of L=
1 miss demand load when there is at least one such miss. Per-Logical Proces=
sor)",
-        "MetricExpr": "L1D_PEND_MISS.PENDING / L1D_PEND_MISS.PENDING_CYCLE=
S",
-        "MetricGroup": "Mem;MemoryBW;MemoryBound",
-        "MetricName": "MLP"
+        "BriefDescription": "This metric represents fraction of slots the =
CPU was stalled due to Frontend bandwidth issues",
+        "MetricExpr": "tma_frontend_bound - tma_fetch_latency",
+        "MetricGroup": "FetchBW;Frontend;TopdownL2;tma_L2_group;tma_L2_gro=
up;tma_frontend_bound_group",
+        "MetricName": "tma_fetch_bandwidth",
+        "PublicDescription": "This metric represents fraction of slots the=
 CPU was stalled due to Frontend bandwidth issues.  For example; inefficien=
cies at the instruction decoders; or restrictions for caching in the DSB (d=
ecoded uops cache) are categorized under Fetch Bandwidth. In such cases; th=
e Frontend typically delivers suboptimal amount of uops to the Backend.",
+        "ScaleUnit": "100%"
     },
     {
-        "BriefDescription": "L1 cache true misses per kilo instruction for=
 retired demand loads",
-        "MetricExpr": "1000 * MEM_LOAD_UOPS_RETIRED.L1_MISS / INST_RETIRED=
.ANY",
-        "MetricGroup": "CacheMisses;Mem",
-        "MetricName": "L1MPKI"
+        "BriefDescription": "This metric represents Core fraction of cycle=
s in which CPU was likely limited due to the MITE pipeline (the legacy deco=
de pipeline)",
+        "MetricExpr": "(IDQ.ALL_MITE_CYCLES_ANY_UOPS - IDQ.ALL_MITE_CYCLES=
_4_UOPS) / CORE_CLKS / 2",
+        "MetricGroup": "DSBmiss;FetchBW;TopdownL3;tma_L3_group;tma_fetch_b=
andwidth_group",
+        "MetricName": "tma_mite",
+        "PublicDescription": "This metric represents Core fraction of cycl=
es in which CPU was likely limited due to the MITE pipeline (the legacy dec=
ode pipeline). This pipeline is used for code that was not pre-cached in th=
e DSB or LSD. For example; inefficiencies due to asymmetric decoders; use o=
f long immediate or LCP can manifest as MITE fetch bandwidth bottleneck.",
+        "ScaleUnit": "100%"
     },
     {
-        "BriefDescription": "L2 cache true misses per kilo instruction for=
 retired demand loads",
-        "MetricExpr": "1000 * MEM_LOAD_UOPS_RETIRED.L2_MISS / INST_RETIRED=
.ANY",
-        "MetricGroup": "Backend;CacheMisses;Mem",
-        "MetricName": "L2MPKI"
+        "BriefDescription": "This metric represents Core fraction of cycle=
s in which CPU was likely limited due to DSB (decoded uop cache) fetch pipe=
line",
+        "MetricExpr": "(IDQ.ALL_DSB_CYCLES_ANY_UOPS - IDQ.ALL_DSB_CYCLES_4=
_UOPS) / CORE_CLKS / 2",
+        "MetricGroup": "DSB;FetchBW;TopdownL3;tma_L3_group;tma_fetch_bandw=
idth_group",
+        "MetricName": "tma_dsb",
+        "PublicDescription": "This metric represents Core fraction of cycl=
es in which CPU was likely limited due to DSB (decoded uop cache) fetch pip=
eline.  For example; inefficient utilization of the DSB cache structure or =
bank conflict when reading from it; are categorized here.",
+        "ScaleUnit": "100%"
     },
     {
-        "BriefDescription": "L3 cache true misses per kilo instruction for=
 retired demand loads",
-        "MetricExpr": "1000 * MEM_LOAD_UOPS_RETIRED.L3_MISS / INST_RETIRED=
.ANY",
-        "MetricGroup": "CacheMisses;Mem",
-        "MetricName": "L3MPKI"
+        "BriefDescription": "This category represents fraction of slots wa=
sted due to incorrect speculations",
+        "MetricExpr": "(UOPS_ISSUED.ANY - UOPS_RETIRED.RETIRE_SLOTS + 4 * =
(INT_MISC.RECOVERY_CYCLES_ANY / 2 if #SMT_on else INT_MISC.RECOVERY_CYCLES)=
) / SLOTS",
+        "MetricGroup": "TopdownL1;tma_L1_group;tma_L1_group",
+        "MetricName": "tma_bad_speculation",
+        "PublicDescription": "This category represents fraction of slots w=
asted due to incorrect speculations. This include slots used to issue uops =
that do not eventually get retired and slots for which the issue-pipeline w=
as blocked due to recovery from earlier incorrect speculation. For example;=
 wasted work due to miss-predicted branches are categorized under Bad Specu=
lation category. Incorrect data speculation followed by Memory Ordering Nuk=
es is another example.",
+        "ScaleUnit": "100%"
     },
     {
-        "BriefDescription": "Utilization of the core's Page Walker(s) serv=
ing STLB misses triggered by instruction/Load/Store accesses",
-        "MetricConstraint": "NO_NMI_WATCHDOG",
-        "MetricExpr": "(ITLB_MISSES.WALK_DURATION + DTLB_LOAD_MISSES.WALK_=
DURATION + DTLB_STORE_MISSES.WALK_DURATION) / CORE_CLKS",
-        "MetricGroup": "Mem;MemoryTLB",
-        "MetricName": "Page_Walks_Utilization"
+        "BriefDescription": "This metric represents fraction of slots the =
CPU has wasted due to Branch Misprediction",
+        "MetricExpr": "BR_MISP_RETIRED.ALL_BRANCHES / (BR_MISP_RETIRED.ALL=
_BRANCHES + MACHINE_CLEARS.COUNT) * tma_bad_speculation",
+        "MetricGroup": "BadSpec;BrMispredicts;TopdownL2;tma_L2_group;tma_L=
2_group;tma_bad_speculation_group",
+        "MetricName": "tma_branch_mispredicts",
+        "PublicDescription": "This metric represents fraction of slots the=
 CPU has wasted due to Branch Misprediction.  These slots are either wasted=
 by uops fetched from an incorrectly speculated program path; or stalls whe=
n the out-of-order part of the machine needs to recover its state from a sp=
eculative path.",
+        "ScaleUnit": "100%"
     },
     {
-        "BriefDescription": "Average per-core data fill bandwidth to the L=
1 data cache [GB / sec]",
-        "MetricExpr": "64 * L1D.REPLACEMENT / 1000000000 / duration_time",
-        "MetricGroup": "Mem;MemoryBW",
-        "MetricName": "L1D_Cache_Fill_BW"
+        "BriefDescription": "This metric represents fraction of slots the =
CPU has wasted due to Machine Clears",
+        "MetricExpr": "tma_bad_speculation - tma_branch_mispredicts",
+        "MetricGroup": "BadSpec;MachineClears;TopdownL2;tma_L2_group;tma_L=
2_group;tma_bad_speculation_group",
+        "MetricName": "tma_machine_clears",
+        "PublicDescription": "This metric represents fraction of slots the=
 CPU has wasted due to Machine Clears.  These slots are either wasted by uo=
ps fetched prior to the clear; or stalls the out-of-order portion of the ma=
chine needs to recover its state after the clear. For example; this can hap=
pen due to memory ordering Nukes (e.g. Memory Disambiguation) or Self-Modif=
ying-Code (SMC) nukes.",
+        "ScaleUnit": "100%"
     },
     {
-        "BriefDescription": "Average per-core data fill bandwidth to the L=
2 cache [GB / sec]",
-        "MetricExpr": "64 * L2_LINES_IN.ALL / 1000000000 / duration_time",
-        "MetricGroup": "Mem;MemoryBW",
-        "MetricName": "L2_Cache_Fill_BW"
+        "BriefDescription": "This category represents fraction of slots wh=
ere no uops are being delivered due to a lack of required resources for acc=
epting new uops in the Backend",
+        "MetricExpr": "1 - (tma_frontend_bound + tma_bad_speculation + UOP=
S_RETIRED.RETIRE_SLOTS / SLOTS)",
+        "MetricGroup": "TopdownL1;tma_L1_group;tma_L1_group",
+        "MetricName": "tma_backend_bound",
+        "PublicDescription": "This category represents fraction of slots w=
here no uops are being delivered due to a lack of required resources for ac=
cepting new uops in the Backend. Backend is the portion of the processor co=
re where the out-of-order scheduler dispatches ready uops into their respec=
tive execution units; and once completed these uops get retired according t=
o program order. For example; stalls due to data-cache misses or stalls due=
 to the divider unit being overloaded are both categorized under Backend Bo=
und. Backend Bound is further divided into two main categories: Memory Boun=
d and Core Bound.",
+        "ScaleUnit": "100%"
     },
     {
-        "BriefDescription": "Average per-core data fill bandwidth to the L=
3 cache [GB / sec]",
-        "MetricExpr": "64 * LONGEST_LAT_CACHE.MISS / 1000000000 / duration=
_time",
-        "MetricGroup": "Mem;MemoryBW",
-        "MetricName": "L3_Cache_Fill_BW"
+        "BriefDescription": "This metric represents fraction of slots the =
Memory subsystem within the Backend was a bottleneck",
+        "MetricExpr": "(min(CPU_CLK_UNHALTED.THREAD, CYCLE_ACTIVITY.STALLS=
_LDM_PENDING) + RESOURCE_STALLS.SB) / (min(CPU_CLK_UNHALTED.THREAD, CYCLE_A=
CTIVITY.CYCLES_NO_EXECUTE) + (cpu@UOPS_EXECUTED.CORE\\,cmask\\=3D0x1@ - (cp=
u@UOPS_EXECUTED.CORE\\,cmask\\=3D0x3@ if INST_RETIRED.ANY / CPU_CLK_UNHALTE=
D.THREAD > 1.8 else cpu@UOPS_EXECUTED.CORE\\,cmask\\=3D0x2@)) / 2 - (RS_EVE=
NTS.EMPTY_CYCLES if tma_fetch_latency > 0.1 else 0) + RESOURCE_STALLS.SB if=
 #SMT_on else min(CPU_CLK_UNHALTED.THREAD, CYCLE_ACTIVITY.CYCLES_NO_EXECUTE=
) + cpu@UOPS_EXECUTED.CORE\\,cmask\\=3D0x1@ - (cpu@UOPS_EXECUTED.CORE\\,cma=
sk\\=3D0x3@ if INST_RETIRED.ANY / CPU_CLK_UNHALTED.THREAD > 1.8 else cpu@UO=
PS_EXECUTED.CORE\\,cmask\\=3D0x2@) - (RS_EVENTS.EMPTY_CYCLES if tma_fetch_l=
atency > 0.1 else 0) + RESOURCE_STALLS.SB) * tma_backend_bound",
+        "MetricGroup": "Backend;TopdownL2;tma_L2_group;tma_L2_group;tma_ba=
ckend_bound_group",
+        "MetricName": "tma_memory_bound",
+        "PublicDescription": "This metric represents fraction of slots the=
 Memory subsystem within the Backend was a bottleneck.  Memory Bound estima=
tes fraction of slots where pipeline is likely stalled due to demand load o=
r store instructions. This accounts mainly for (1) non-completed in-flight =
memory demand loads which coincides with execution units starvation; in add=
ition to (2) cases where stores could impose backpressure on the pipeline w=
hen many of them get buffered at the same time (less common out of the two)=
.",
+        "ScaleUnit": "100%"
     },
     {
-        "BriefDescription": "Average per-thread data fill bandwidth to the=
 L1 data cache [GB / sec]",
-        "MetricExpr": "L1D_Cache_Fill_BW",
-        "MetricGroup": "Mem;MemoryBW",
-        "MetricName": "L1D_Cache_Fill_BW_1T"
+        "BriefDescription": "This metric estimates how often the CPU was s=
talled without loads missing the L1 data cache",
+        "MetricExpr": "max((min(CPU_CLK_UNHALTED.THREAD, CYCLE_ACTIVITY.ST=
ALLS_LDM_PENDING) - CYCLE_ACTIVITY.STALLS_L1D_PENDING) / CPU_CLK_UNHALTED.T=
HREAD, 0)",
+        "MetricGroup": "CacheMisses;MemoryBound;TmaL3mem;TopdownL3;tma_L3_=
group;tma_memory_bound_group",
+        "MetricName": "tma_l1_bound",
+        "PublicDescription": "This metric estimates how often the CPU was =
stalled without loads missing the L1 data cache.  The L1 data cache typical=
ly has the shortest latency.  However; in certain cases like loads blocked =
on older stores; a load might suffer due to high latency even though it is =
being satisfied by the L1. Another example is loads who miss in the TLB. Th=
ese cases are characterized by execution unit stalls; while some non-comple=
ted demand load lives in the machine without having that demand load missin=
g the L1 cache.",
+        "ScaleUnit": "100%"
     },
     {
-        "BriefDescription": "Average per-thread data fill bandwidth to the=
 L2 cache [GB / sec]",
-        "MetricExpr": "L2_Cache_Fill_BW",
-        "MetricGroup": "Mem;MemoryBW",
-        "MetricName": "L2_Cache_Fill_BW_1T"
+        "BriefDescription": "This metric roughly estimates the fraction of=
 cycles where the Data TLB (DTLB) was missed by load accesses",
+        "MetricExpr": "(8 * DTLB_LOAD_MISSES.STLB_HIT + DTLB_LOAD_MISSES.W=
ALK_DURATION) / CPU_CLK_UNHALTED.THREAD",
+        "MetricGroup": "MemoryTLB;TopdownL4;tma_L4_group;tma_l1_bound_grou=
p",
+        "MetricName": "tma_dtlb_load",
+        "PublicDescription": "This metric roughly estimates the fraction o=
f cycles where the Data TLB (DTLB) was missed by load accesses. TLBs (Trans=
lation Look-aside Buffers) are processor caches for recently used entries o=
ut of the Page Tables that are used to map virtual- to physical-addresses b=
y the operating system. This metric approximates the potential delay of dem=
and loads missing the first-level data TLB (assuming worst case scenario wi=
th back to back misses to different pages). This includes hitting in the se=
cond-level TLB (STLB) as well as performing a hardware page walk on an STLB=
 miss.",
+        "ScaleUnit": "100%"
     },
     {
-        "BriefDescription": "Average per-thread data fill bandwidth to the=
 L3 cache [GB / sec]",
-        "MetricExpr": "L3_Cache_Fill_BW",
-        "MetricGroup": "Mem;MemoryBW",
-        "MetricName": "L3_Cache_Fill_BW_1T"
+        "BriefDescription": "This metric roughly estimates fraction of cyc=
les when the memory subsystem had loads blocked since they could not forwar=
d data from earlier (in program order) overlapping stores",
+        "MetricExpr": "min(13 * LD_BLOCKS.STORE_FORWARD / CPU_CLK_UNHALTED=
.THREAD, 1)",
+        "MetricGroup": "TopdownL4;tma_L4_group;tma_l1_bound_group",
+        "MetricName": "tma_store_fwd_blk",
+        "PublicDescription": "This metric roughly estimates fraction of cy=
cles when the memory subsystem had loads blocked since they could not forwa=
rd data from earlier (in program order) overlapping stores. To streamline m=
emory operations in the pipeline; a load can avoid waiting for memory if a =
prior in-flight store is writing the data that the load wants to read (stor=
e forwarding process). However; in some cases the load may be blocked for a=
 significant time pending the store forward. For example; when the prior st=
ore is writing a smaller region than the load is reading.",
+        "ScaleUnit": "100%"
     },
     {
-        "BriefDescription": "Average per-thread data access bandwidth to t=
he L3 cache [GB / sec]",
-        "MetricExpr": "0",
-        "MetricGroup": "Mem;MemoryBW;Offcore",
-        "MetricName": "L3_Cache_Access_BW_1T"
+        "BriefDescription": "This metric represents fraction of cycles the=
 CPU spent handling cache misses due to lock operations",
+        "MetricExpr": "min(MEM_UOPS_RETIRED.LOCK_LOADS / MEM_UOPS_RETIRED.=
ALL_STORES * min(CPU_CLK_UNHALTED.THREAD, OFFCORE_REQUESTS_OUTSTANDING.CYCL=
ES_WITH_DEMAND_RFO) / CPU_CLK_UNHALTED.THREAD, 1)",
+        "MetricGroup": "Offcore;TopdownL4;tma_L4_group;tma_l1_bound_group"=
,
+        "MetricName": "tma_lock_latency",
+        "PublicDescription": "This metric represents fraction of cycles th=
e CPU spent handling cache misses due to lock operations. Due to the microa=
rchitecture handling of locks; they are classified as L1_Bound regardless o=
f what memory source satisfied them.",
+        "ScaleUnit": "100%"
     },
     {
-        "BriefDescription": "Average CPU Utilization",
-        "MetricExpr": "CPU_CLK_UNHALTED.REF_TSC / msr@tsc@",
-        "MetricGroup": "HPC;Summary",
-        "MetricName": "CPU_Utilization"
+        "BriefDescription": "This metric estimates fraction of cycles hand=
ling memory load split accesses - load that cross 64-byte cache line bounda=
ry. ",
+        "MetricExpr": "min(Load_Miss_Real_Latency * LD_BLOCKS.NO_SR / CPU_=
CLK_UNHALTED.THREAD, 1)",
+        "MetricGroup": "TopdownL4;tma_L4_group;tma_l1_bound_group",
+        "MetricName": "tma_split_loads",
+        "ScaleUnit": "100%"
     },
     {
-        "BriefDescription": "Measured Average Frequency for unhalted proce=
ssors [GHz]",
-        "MetricExpr": "Turbo_Utilization * msr@tsc@ / 1000000000 / duratio=
n_time",
-        "MetricGroup": "Power;Summary",
-        "MetricName": "Average_Frequency"
+        "BriefDescription": "This metric estimates how often memory load a=
ccesses were aliased by preceding stores (in program order) with a 4K addre=
ss offset",
+        "MetricExpr": "LD_BLOCKS_PARTIAL.ADDRESS_ALIAS / CPU_CLK_UNHALTED.=
THREAD",
+        "MetricGroup": "TopdownL4;tma_L4_group;tma_l1_bound_group",
+        "MetricName": "tma_4k_aliasing",
+        "PublicDescription": "This metric estimates how often memory load =
accesses were aliased by preceding stores (in program order) with a 4K addr=
ess offset. False match is possible; which incur a few cycles load re-issue=
. However; the short re-issue duration is often hidden by the out-of-order =
core and HW optimizations; hence a user may safely ignore a high value of t=
his metric unless it manages to propagate up into parent nodes of the hiera=
rchy (e.g. to L1_Bound).",
+        "ScaleUnit": "100%"
     },
     {
-        "BriefDescription": "Average Frequency Utilization relative nomina=
l frequency",
-        "MetricExpr": "CLKS / CPU_CLK_UNHALTED.REF_TSC",
-        "MetricGroup": "Power",
-        "MetricName": "Turbo_Utilization"
+        "BriefDescription": "This metric does a *rough estimation* of how =
often L1D Fill Buffer unavailability limited additional L1D miss memory acc=
ess requests to proceed",
+        "MetricExpr": "Load_Miss_Real_Latency * cpu@L1D_PEND_MISS.REQUEST_=
FB_FULL\\,cmask\\=3D0x1@ / CPU_CLK_UNHALTED.THREAD",
+        "MetricGroup": "MemoryBW;TopdownL4;tma_L4_group;tma_l1_bound_group=
",
+        "MetricName": "tma_fb_full",
+        "PublicDescription": "This metric does a *rough estimation* of how=
 often L1D Fill Buffer unavailability limited additional L1D miss memory ac=
cess requests to proceed. The higher the metric value; the deeper the memor=
y hierarchy level the misses are satisfied from (metric values >1 are valid=
). Often it hints on approaching bandwidth limits (to L2 cache; L3 cache or=
 external memory).",
+        "ScaleUnit": "100%"
     },
     {
-        "BriefDescription": "Fraction of cycles where both hardware Logica=
l Processors were active",
-        "MetricExpr": "1 - CPU_CLK_UNHALTED.ONE_THREAD_ACTIVE / (CPU_CLK_U=
NHALTED.REF_XCLK_ANY / 2) if #SMT_on else 0",
-        "MetricGroup": "SMT",
-        "MetricName": "SMT_2T_Utilization"
+        "BriefDescription": "This metric estimates how often the CPU was s=
talled due to L2 cache accesses by loads",
+        "MetricExpr": "(CYCLE_ACTIVITY.STALLS_L1D_PENDING - CYCLE_ACTIVITY=
.STALLS_L2_PENDING) / CPU_CLK_UNHALTED.THREAD",
+        "MetricGroup": "CacheMisses;MemoryBound;TmaL3mem;TopdownL3;tma_L3_=
group;tma_memory_bound_group",
+        "MetricName": "tma_l2_bound",
+        "PublicDescription": "This metric estimates how often the CPU was =
stalled due to L2 cache accesses by loads.  Avoiding cache misses (i.e. L1 =
misses/L2 hits) can improve the latency and increase performance.",
+        "ScaleUnit": "100%"
     },
     {
-        "BriefDescription": "Fraction of cycles spent in the Operating Sys=
tem (OS) Kernel mode",
-        "MetricExpr": "CPU_CLK_UNHALTED.THREAD_P:k / CPU_CLK_UNHALTED.THRE=
AD",
-        "MetricGroup": "OS",
-        "MetricName": "Kernel_Utilization"
+        "BriefDescription": "This metric estimates how often the CPU was s=
talled due to loads accesses to L3 cache or contended with a sibling Core",
+        "MetricExpr": "MEM_LOAD_UOPS_RETIRED.L3_HIT / (MEM_LOAD_UOPS_RETIR=
ED.L3_HIT + 7 * MEM_LOAD_UOPS_RETIRED.L3_MISS) * CYCLE_ACTIVITY.STALLS_L2_P=
ENDING / CPU_CLK_UNHALTED.THREAD",
+        "MetricGroup": "CacheMisses;MemoryBound;TmaL3mem;TopdownL3;tma_L3_=
group;tma_memory_bound_group",
+        "MetricName": "tma_l3_bound",
+        "PublicDescription": "This metric estimates how often the CPU was =
stalled due to loads accesses to L3 cache or contended with a sibling Core.=
  Avoiding cache misses (i.e. L2 misses/L3 hits) can improve the latency an=
d increase performance.",
+        "ScaleUnit": "100%"
     },
     {
-        "BriefDescription": "Cycles Per Instruction for the Operating Syst=
em (OS) Kernel mode",
-        "MetricExpr": "CPU_CLK_UNHALTED.THREAD_P:k / INST_RETIRED.ANY_P:k"=
,
-        "MetricGroup": "OS",
-        "MetricName": "Kernel_CPI"
+        "BriefDescription": "This metric estimates fraction of cycles whil=
e the memory subsystem was handling synchronizations due to contested acces=
ses",
+        "MetricExpr": "min((60 * (MEM_LOAD_UOPS_L3_HIT_RETIRED.XSNP_HITM *=
 (1 + MEM_LOAD_UOPS_RETIRED.HIT_LFB / (MEM_LOAD_UOPS_RETIRED.L2_HIT + MEM_L=
OAD_UOPS_RETIRED.L3_HIT + MEM_LOAD_UOPS_L3_HIT_RETIRED.XSNP_HIT + MEM_LOAD_=
UOPS_L3_HIT_RETIRED.XSNP_HITM + MEM_LOAD_UOPS_L3_HIT_RETIRED.XSNP_MISS + ME=
M_LOAD_UOPS_L3_MISS_RETIRED.LOCAL_DRAM + MEM_LOAD_UOPS_L3_MISS_RETIRED.REMO=
TE_DRAM + MEM_LOAD_UOPS_L3_MISS_RETIRED.REMOTE_HITM + MEM_LOAD_UOPS_L3_MISS=
_RETIRED.REMOTE_FWD))) + 43 * (MEM_LOAD_UOPS_L3_HIT_RETIRED.XSNP_MISS * (1 =
+ MEM_LOAD_UOPS_RETIRED.HIT_LFB / (MEM_LOAD_UOPS_RETIRED.L2_HIT + MEM_LOAD_=
UOPS_RETIRED.L3_HIT + MEM_LOAD_UOPS_L3_HIT_RETIRED.XSNP_HIT + MEM_LOAD_UOPS=
_L3_HIT_RETIRED.XSNP_HITM + MEM_LOAD_UOPS_L3_HIT_RETIRED.XSNP_MISS + MEM_LO=
AD_UOPS_L3_MISS_RETIRED.LOCAL_DRAM + MEM_LOAD_UOPS_L3_MISS_RETIRED.REMOTE_D=
RAM + MEM_LOAD_UOPS_L3_MISS_RETIRED.REMOTE_HITM + MEM_LOAD_UOPS_L3_MISS_RET=
IRED.REMOTE_FWD)))) / CPU_CLK_UNHALTED.THREAD, 1)",
+        "MetricGroup": "DataSharing;Offcore;Snoop;TopdownL4;tma_L4_group;t=
ma_l3_bound_group",
+        "MetricName": "tma_contested_accesses",
+        "PublicDescription": "This metric estimates fraction of cycles whi=
le the memory subsystem was handling synchronizations due to contested acce=
sses. Contested accesses occur when data written by one Logical Processor a=
re read by another Logical Processor on a different Physical Core. Examples=
 of contested accesses include synchronizations such as locks; true data sh=
aring such as modified locked variables; and false sharing.",
+        "ScaleUnit": "100%"
     },
     {
-        "BriefDescription": "Average external Memory Bandwidth Use for rea=
ds and writes [GB / sec]",
-        "MetricExpr": "(64 * (uncore_imc@cas_count_read@ + uncore_imc@cas_=
count_write@) / 1000000000) / duration_time",
-        "MetricGroup": "HPC;Mem;MemoryBW;SoC",
-        "MetricName": "DRAM_BW_Use"
+        "BriefDescription": "This metric estimates fraction of cycles whil=
e the memory subsystem was handling synchronizations due to data-sharing ac=
cesses",
+        "MetricExpr": "min(43 * (MEM_LOAD_UOPS_L3_HIT_RETIRED.XSNP_HIT * (=
1 + MEM_LOAD_UOPS_RETIRED.HIT_LFB / (MEM_LOAD_UOPS_RETIRED.L2_HIT + MEM_LOA=
D_UOPS_RETIRED.L3_HIT + MEM_LOAD_UOPS_L3_HIT_RETIRED.XSNP_HIT + MEM_LOAD_UO=
PS_L3_HIT_RETIRED.XSNP_HITM + MEM_LOAD_UOPS_L3_HIT_RETIRED.XSNP_MISS + MEM_=
LOAD_UOPS_L3_MISS_RETIRED.LOCAL_DRAM + MEM_LOAD_UOPS_L3_MISS_RETIRED.REMOTE=
_DRAM + MEM_LOAD_UOPS_L3_MISS_RETIRED.REMOTE_HITM + MEM_LOAD_UOPS_L3_MISS_R=
ETIRED.REMOTE_FWD))) / CPU_CLK_UNHALTED.THREAD, 1)",
+        "MetricGroup": "Offcore;Snoop;TopdownL4;tma_L4_group;tma_l3_bound_=
group",
+        "MetricName": "tma_data_sharing",
+        "PublicDescription": "This metric estimates fraction of cycles whi=
le the memory subsystem was handling synchronizations due to data-sharing a=
ccesses. Data shared by multiple Logical Processors (even just read shared)=
 may cause increased access latency due to cache coherency. Excessive data =
sharing can drastically harm multithreaded performance.",
+        "ScaleUnit": "100%"
     },
     {
-        "BriefDescription": "Average latency of data read request to exter=
nal memory (in nanoseconds). Accounts for demand loads and L1/L2 prefetches=
",
-        "MetricExpr": "1000000000 * (cbox@event\\=3D0x36\\,umask\\=3D0x3\\=
,filter_opc\\=3D0x182@ / cbox@event\\=3D0x35\\,umask\\=3D0x3\\,filter_opc\\=
=3D0x182@) / (Socket_CLKS / duration_time)",
-        "MetricGroup": "Mem;MemoryLat;SoC",
-        "MetricName": "MEM_Read_Latency"
+        "BriefDescription": "This metric represents fraction of cycles wit=
h demand load accesses that hit the L3 cache under unloaded scenarios (poss=
ibly L3 latency limited)",
+        "MetricExpr": "min(41 * (MEM_LOAD_UOPS_RETIRED.L3_HIT * (1 + MEM_L=
OAD_UOPS_RETIRED.HIT_LFB / (MEM_LOAD_UOPS_RETIRED.L2_HIT + MEM_LOAD_UOPS_RE=
TIRED.L3_HIT + MEM_LOAD_UOPS_L3_HIT_RETIRED.XSNP_HIT + MEM_LOAD_UOPS_L3_HIT=
_RETIRED.XSNP_HITM + MEM_LOAD_UOPS_L3_HIT_RETIRED.XSNP_MISS + MEM_LOAD_UOPS=
_L3_MISS_RETIRED.LOCAL_DRAM + MEM_LOAD_UOPS_L3_MISS_RETIRED.REMOTE_DRAM + M=
EM_LOAD_UOPS_L3_MISS_RETIRED.REMOTE_HITM + MEM_LOAD_UOPS_L3_MISS_RETIRED.RE=
MOTE_FWD))) / CPU_CLK_UNHALTED.THREAD, 1)",
+        "MetricGroup": "MemoryLat;TopdownL4;tma_L4_group;tma_l3_bound_grou=
p",
+        "MetricName": "tma_l3_hit_latency",
+        "PublicDescription": "This metric represents fraction of cycles wi=
th demand load accesses that hit the L3 cache under unloaded scenarios (pos=
sibly L3 latency limited).  Avoiding private cache misses (i.e. L2 misses/L=
3 hits) will improve the latency; reduce contention with sibling physical c=
ores and increase performance.  Note the value of this node may overlap wit=
h its siblings.",
+        "ScaleUnit": "100%"
     },
     {
-        "BriefDescription": "Average number of parallel data read requests=
 to external memory. Accounts for demand loads and L1/L2 prefetches",
-        "MetricExpr": "cbox@event\\=3D0x36\\,umask\\=3D0x3\\,filter_opc\\=
=3D0x182@ / cbox@event\\=3D0x36\\,umask\\=3D0x3\\,filter_opc\\=3D0x182\\,th=
resh\\=3D1@",
-        "MetricGroup": "Mem;MemoryBW;SoC",
-        "MetricName": "MEM_Parallel_Reads"
+        "BriefDescription": "This metric measures fraction of cycles where=
 the Super Queue (SQ) was full taking into account all request-types and bo=
th hardware SMT threads (Logical Processors)",
+        "MetricExpr": "(OFFCORE_REQUESTS_BUFFER.SQ_FULL / 2 if #SMT_on els=
e OFFCORE_REQUESTS_BUFFER.SQ_FULL) / CORE_CLKS",
+        "MetricGroup": "MemoryBW;Offcore;TopdownL4;tma_L4_group;tma_l3_bou=
nd_group",
+        "MetricName": "tma_sq_full",
+        "PublicDescription": "This metric measures fraction of cycles wher=
e the Super Queue (SQ) was full taking into account all request-types and b=
oth hardware SMT threads (Logical Processors). The Super Queue is used for =
requests to access the L2 cache or to go out to the Uncore.",
+        "ScaleUnit": "100%"
     },
     {
-        "BriefDescription": "Socket actual clocks when any core is active =
on that socket",
-        "MetricExpr": "cbox_0@event\\=3D0x0@",
-        "MetricGroup": "SoC",
-        "MetricName": "Socket_CLKS"
+        "BriefDescription": "This metric estimates how often the CPU was s=
talled on accesses to external memory (DRAM) by loads",
+        "MetricExpr": "min((1 - MEM_LOAD_UOPS_RETIRED.L3_HIT / (MEM_LOAD_U=
OPS_RETIRED.L3_HIT + 7 * MEM_LOAD_UOPS_RETIRED.L3_MISS)) * CYCLE_ACTIVITY.S=
TALLS_L2_PENDING / CPU_CLK_UNHALTED.THREAD, 1)",
+        "MetricGroup": "MemoryBound;TmaL3mem;TopdownL3;tma_L3_group;tma_me=
mory_bound_group",
+        "MetricName": "tma_dram_bound",
+        "PublicDescription": "This metric estimates how often the CPU was =
stalled on accesses to external memory (DRAM) by loads. Better caching can =
improve the latency and increase performance.",
+        "ScaleUnit": "100%"
     },
     {
-        "BriefDescription": "Instructions per Far Branch ( Far Branches ap=
ply upon transition from application to operating system, handling interrup=
ts, exceptions) [lower number means higher occurrence rate]",
-        "MetricExpr": "INST_RETIRED.ANY / BR_INST_RETIRED.FAR_BRANCH:u",
-        "MetricGroup": "Branches;OS",
-        "MetricName": "IpFarBranch"
+        "BriefDescription": "This metric estimates fraction of cycles wher=
e the core's performance was likely hurt due to approaching bandwidth limit=
s of external memory (DRAM)",
+        "MetricExpr": "min(CPU_CLK_UNHALTED.THREAD, cpu@OFFCORE_REQUESTS_O=
UTSTANDING.ALL_DATA_RD\\,cmask\\=3D0x6@) / CPU_CLK_UNHALTED.THREAD",
+        "MetricGroup": "MemoryBW;Offcore;TopdownL4;tma_L4_group;tma_dram_b=
ound_group",
+        "MetricName": "tma_mem_bandwidth",
+        "PublicDescription": "This metric estimates fraction of cycles whe=
re the core's performance was likely hurt due to approaching bandwidth limi=
ts of external memory (DRAM).  The underlying heuristic assumes that a simi=
lar off-core traffic is generated by all IA cores. This metric does not agg=
regate non-data-read requests by this logical processor; requests from othe=
r IA Logical Processors/Physical Cores/sockets; or other non-IA devices lik=
e GPU; hence the maximum external memory bandwidth limits may or may not be=
 approached when this metric is flagged (see Uncore counters for that).",
+        "ScaleUnit": "100%"
     },
     {
-        "BriefDescription": "C3 residency percent per core",
-        "MetricExpr": "(cstate_core@c3\\-residency@ / msr@tsc@) * 100",
-        "MetricGroup": "Power",
-        "MetricName": "C3_Core_Residency"
+        "BriefDescription": "This metric estimates fraction of cycles wher=
e the performance was likely hurt due to latency from external memory (DRAM=
)",
+        "MetricExpr": "min(CPU_CLK_UNHALTED.THREAD, OFFCORE_REQUESTS_OUTST=
ANDING.CYCLES_WITH_DATA_RD) / CPU_CLK_UNHALTED.THREAD - tma_mem_bandwidth",
+        "MetricGroup": "MemoryLat;Offcore;TopdownL4;tma_L4_group;tma_dram_=
bound_group",
+        "MetricName": "tma_mem_latency",
+        "PublicDescription": "This metric estimates fraction of cycles whe=
re the performance was likely hurt due to latency from external memory (DRA=
M).  This metric does not aggregate requests from other Logical Processors/=
Physical Cores/sockets (see Uncore counters for that).",
+        "ScaleUnit": "100%"
     },
     {
-        "BriefDescription": "C6 residency percent per core",
-        "MetricExpr": "(cstate_core@c6\\-residency@ / msr@tsc@) * 100",
-        "MetricGroup": "Power",
-        "MetricName": "C6_Core_Residency"
+        "BriefDescription": "This metric estimates fraction of cycles whil=
e the memory subsystem was handling loads from local memory",
+        "MetricExpr": "min(200 * (MEM_LOAD_UOPS_L3_MISS_RETIRED.LOCAL_DRAM=
 * (1 + MEM_LOAD_UOPS_RETIRED.HIT_LFB / (MEM_LOAD_UOPS_RETIRED.L2_HIT + MEM=
_LOAD_UOPS_RETIRED.L3_HIT + MEM_LOAD_UOPS_L3_HIT_RETIRED.XSNP_HIT + MEM_LOA=
D_UOPS_L3_HIT_RETIRED.XSNP_HITM + MEM_LOAD_UOPS_L3_HIT_RETIRED.XSNP_MISS + =
MEM_LOAD_UOPS_L3_MISS_RETIRED.LOCAL_DRAM + MEM_LOAD_UOPS_L3_MISS_RETIRED.RE=
MOTE_DRAM + MEM_LOAD_UOPS_L3_MISS_RETIRED.REMOTE_HITM + MEM_LOAD_UOPS_L3_MI=
SS_RETIRED.REMOTE_FWD))) / CPU_CLK_UNHALTED.THREAD, 1)",
+        "MetricGroup": "Server;TopdownL5;tma_L5_group;tma_mem_latency_grou=
p",
+        "MetricName": "tma_local_dram",
+        "PublicDescription": "This metric estimates fraction of cycles whi=
le the memory subsystem was handling loads from local memory. Caching will =
improve the latency and increase performance.",
+        "ScaleUnit": "100%"
     },
     {
-        "BriefDescription": "C7 residency percent per core",
-        "MetricExpr": "(cstate_core@c7\\-residency@ / msr@tsc@) * 100",
-        "MetricGroup": "Power",
-        "MetricName": "C7_Core_Residency"
+        "BriefDescription": "This metric estimates fraction of cycles whil=
e the memory subsystem was handling loads from remote memory",
+        "MetricExpr": "min(310 * (MEM_LOAD_UOPS_L3_MISS_RETIRED.REMOTE_DRA=
M * (1 + MEM_LOAD_UOPS_RETIRED.HIT_LFB / (MEM_LOAD_UOPS_RETIRED.L2_HIT + ME=
M_LOAD_UOPS_RETIRED.L3_HIT + MEM_LOAD_UOPS_L3_HIT_RETIRED.XSNP_HIT + MEM_LO=
AD_UOPS_L3_HIT_RETIRED.XSNP_HITM + MEM_LOAD_UOPS_L3_HIT_RETIRED.XSNP_MISS +=
 MEM_LOAD_UOPS_L3_MISS_RETIRED.LOCAL_DRAM + MEM_LOAD_UOPS_L3_MISS_RETIRED.R=
EMOTE_DRAM + MEM_LOAD_UOPS_L3_MISS_RETIRED.REMOTE_HITM + MEM_LOAD_UOPS_L3_M=
ISS_RETIRED.REMOTE_FWD))) / CPU_CLK_UNHALTED.THREAD, 1)",
+        "MetricGroup": "Server;Snoop;TopdownL5;tma_L5_group;tma_mem_latenc=
y_group",
+        "MetricName": "tma_remote_dram",
+        "PublicDescription": "This metric estimates fraction of cycles whi=
le the memory subsystem was handling loads from remote memory. This is caus=
ed often due to non-optimal NUMA allocations. #link to NUMA article",
+        "ScaleUnit": "100%"
     },
     {
-        "BriefDescription": "C2 residency percent per package",
-        "MetricExpr": "(cstate_pkg@c2\\-residency@ / msr@tsc@) * 100",
-        "MetricGroup": "Power",
-        "MetricName": "C2_Pkg_Residency"
+        "BriefDescription": "This metric estimates fraction of cycles whil=
e the memory subsystem was handling loads from remote cache in other socket=
s including synchronizations issues",
+        "MetricExpr": "min((200 * (MEM_LOAD_UOPS_L3_MISS_RETIRED.REMOTE_HI=
TM * (1 + MEM_LOAD_UOPS_RETIRED.HIT_LFB / (MEM_LOAD_UOPS_RETIRED.L2_HIT + M=
EM_LOAD_UOPS_RETIRED.L3_HIT + MEM_LOAD_UOPS_L3_HIT_RETIRED.XSNP_HIT + MEM_L=
OAD_UOPS_L3_HIT_RETIRED.XSNP_HITM + MEM_LOAD_UOPS_L3_HIT_RETIRED.XSNP_MISS =
+ MEM_LOAD_UOPS_L3_MISS_RETIRED.LOCAL_DRAM + MEM_LOAD_UOPS_L3_MISS_RETIRED.=
REMOTE_DRAM + MEM_LOAD_UOPS_L3_MISS_RETIRED.REMOTE_HITM + MEM_LOAD_UOPS_L3_=
MISS_RETIRED.REMOTE_FWD))) + 180 * (MEM_LOAD_UOPS_L3_MISS_RETIRED.REMOTE_FW=
D * (1 + MEM_LOAD_UOPS_RETIRED.HIT_LFB / (MEM_LOAD_UOPS_RETIRED.L2_HIT + ME=
M_LOAD_UOPS_RETIRED.L3_HIT + MEM_LOAD_UOPS_L3_HIT_RETIRED.XSNP_HIT + MEM_LO=
AD_UOPS_L3_HIT_RETIRED.XSNP_HITM + MEM_LOAD_UOPS_L3_HIT_RETIRED.XSNP_MISS +=
 MEM_LOAD_UOPS_L3_MISS_RETIRED.LOCAL_DRAM + MEM_LOAD_UOPS_L3_MISS_RETIRED.R=
EMOTE_DRAM + MEM_LOAD_UOPS_L3_MISS_RETIRED.REMOTE_HITM + MEM_LOAD_UOPS_L3_M=
ISS_RETIRED.REMOTE_FWD)))) / CPU_CLK_UNHALTED.THREAD, 1)",
+        "MetricGroup": "Offcore;Server;Snoop;TopdownL5;tma_L5_group;tma_me=
m_latency_group",
+        "MetricName": "tma_remote_cache",
+        "PublicDescription": "This metric estimates fraction of cycles whi=
le the memory subsystem was handling loads from remote cache in other socke=
ts including synchronizations issues. This is caused often due to non-optim=
al NUMA allocations. #link to NUMA article",
+        "ScaleUnit": "100%"
     },
     {
-        "BriefDescription": "C3 residency percent per package",
-        "MetricExpr": "(cstate_pkg@c3\\-residency@ / msr@tsc@) * 100",
-        "MetricGroup": "Power",
-        "MetricName": "C3_Pkg_Residency"
+        "BriefDescription": "This metric estimates how often CPU was stall=
ed  due to RFO store memory accesses; RFO store issue a read-for-ownership =
request before the write",
+        "MetricExpr": "RESOURCE_STALLS.SB / CPU_CLK_UNHALTED.THREAD",
+        "MetricGroup": "MemoryBound;TmaL3mem;TopdownL3;tma_L3_group;tma_me=
mory_bound_group",
+        "MetricName": "tma_store_bound",
+        "PublicDescription": "This metric estimates how often CPU was stal=
led  due to RFO store memory accesses; RFO store issue a read-for-ownership=
 request before the write. Even though store accesses do not typically stal=
l out-of-order CPUs; there are few cases where stores can lead to actual st=
alls. This metric will be flagged should RFO stores be a bottleneck.",
+        "ScaleUnit": "100%"
     },
     {
-        "BriefDescription": "C6 residency percent per package",
-        "MetricExpr": "(cstate_pkg@c6\\-residency@ / msr@tsc@) * 100",
-        "MetricGroup": "Power",
-        "MetricName": "C6_Pkg_Residency"
+        "BriefDescription": "This metric estimates fraction of cycles the =
CPU spent handling L1D store misses",
+        "MetricExpr": "(L2_RQSTS.RFO_HIT * 9 * (1 - MEM_UOPS_RETIRED.LOCK_=
LOADS / MEM_UOPS_RETIRED.ALL_STORES) + (1 - MEM_UOPS_RETIRED.LOCK_LOADS / M=
EM_UOPS_RETIRED.ALL_STORES) * min(CPU_CLK_UNHALTED.THREAD, OFFCORE_REQUESTS=
_OUTSTANDING.CYCLES_WITH_DEMAND_RFO)) / CPU_CLK_UNHALTED.THREAD",
+        "MetricGroup": "MemoryLat;Offcore;TopdownL4;tma_L4_group;tma_store=
_bound_group",
+        "MetricName": "tma_store_latency",
+        "PublicDescription": "This metric estimates fraction of cycles the=
 CPU spent handling L1D store misses. Store accesses usually less impact ou=
t-of-order core performance; however; holding resources for longer time can=
 lead into undesired implications (e.g. contention on L1D fill-buffer entri=
es - see FB_Full)",
+        "ScaleUnit": "100%"
     },
     {
-        "BriefDescription": "C7 residency percent per package",
-        "MetricExpr": "(cstate_pkg@c7\\-residency@ / msr@tsc@) * 100",
-        "MetricGroup": "Power",
-        "MetricName": "C7_Pkg_Residency"
+        "BriefDescription": "This metric roughly estimates how often CPU w=
as handling synchronizations due to False Sharing",
+        "MetricExpr": "min((200 * OFFCORE_RESPONSE.DEMAND_RFO.LLC_MISS.REM=
OTE_HITM + 60 * OFFCORE_RESPONSE.DEMAND_RFO.LLC_HIT.HITM_OTHER_CORE) / CPU_=
CLK_UNHALTED.THREAD, 1)",
+        "MetricGroup": "DataSharing;Offcore;Snoop;TopdownL4;tma_L4_group;t=
ma_store_bound_group",
+        "MetricName": "tma_false_sharing",
+        "PublicDescription": "This metric roughly estimates how often CPU =
was handling synchronizations due to False Sharing. False Sharing is a mult=
ithreading hiccup; where multiple Logical Processors contend on different d=
ata-elements mapped into the same cache line. ",
+        "ScaleUnit": "100%"
     },
     {
-        "BriefDescription": "Uncore frequency per die [GHZ]",
-        "MetricExpr": "Socket_CLKS / #num_dies / duration_time / 100000000=
0",
-        "MetricGroup": "SoC",
-        "MetricName": "UNCORE_FREQ"
+        "BriefDescription": "This metric represents rate of split store ac=
cesses",
+        "MetricExpr": "2 * MEM_UOPS_RETIRED.SPLIT_STORES / CORE_CLKS",
+        "MetricGroup": "TopdownL4;tma_L4_group;tma_store_bound_group",
+        "MetricName": "tma_split_stores",
+        "PublicDescription": "This metric represents rate of split store a=
ccesses.  Consider aligning your data to the 64-byte cache line granularity=
.",
+        "ScaleUnit": "100%"
     },
     {
-        "BriefDescription": "CPU operating frequency (in GHz)",
-        "MetricExpr": "(( CPU_CLK_UNHALTED.THREAD / CPU_CLK_UNHALTED.REF_T=
SC * #SYSTEM_TSC_FREQ ) / 1000000000) / duration_time",
-        "MetricGroup": "",
-        "MetricName": "cpu_operating_frequency",
-        "ScaleUnit": "1GHz"
+        "BriefDescription": "This metric roughly estimates the fraction of=
 cycles spent handling first-level data TLB store misses",
+        "MetricExpr": "min((8 * DTLB_STORE_MISSES.STLB_HIT + DTLB_STORE_MI=
SSES.WALK_DURATION) / CPU_CLK_UNHALTED.THREAD, 1)",
+        "MetricGroup": "MemoryTLB;TopdownL4;tma_L4_group;tma_store_bound_g=
roup",
+        "MetricName": "tma_dtlb_store",
+        "PublicDescription": "This metric roughly estimates the fraction o=
f cycles spent handling first-level data TLB store misses.  As with ordinar=
y data caching; focus on improving data locality and reducing working-set s=
ize to reduce DTLB overhead.  Additionally; consider using profile-guided o=
ptimization (PGO) to collocate frequently-used data on the same page.  Try =
using larger page sizes for large amounts of frequently-used data.",
+        "ScaleUnit": "100%"
     },
     {
-        "BriefDescription": "The ratio of number of completed memory load =
instructions to the total number completed instructions",
-        "MetricExpr": "MEM_UOPS_RETIRED.ALL_LOADS / INST_RETIRED.ANY",
-        "MetricGroup": "",
-        "MetricName": "loads_per_instr",
-        "ScaleUnit": "1per_instr"
+        "BriefDescription": "This metric represents fraction of slots wher=
e Core non-memory issues were of a bottleneck",
+        "MetricExpr": "tma_backend_bound - tma_memory_bound",
+        "MetricGroup": "Backend;Compute;TopdownL2;tma_L2_group;tma_L2_grou=
p;tma_backend_bound_group",
+        "MetricName": "tma_core_bound",
+        "PublicDescription": "This metric represents fraction of slots whe=
re Core non-memory issues were of a bottleneck.  Shortage in hardware compu=
te resources; or dependencies in software's instructions are both categoriz=
ed under Core Bound. Hence it may indicate the machine ran out of an out-of=
-order resource; certain execution units are overloaded or dependencies in =
program's data- or instruction-flow are limiting the performance (e.g. FP-c=
hained long-latency arithmetic operations).",
+        "ScaleUnit": "100%"
     },
     {
-        "BriefDescription": "The ratio of number of completed memory store=
 instructions to the total number completed instructions",
-        "MetricExpr": "MEM_UOPS_RETIRED.ALL_STORES / INST_RETIRED.ANY",
-        "MetricGroup": "",
-        "MetricName": "stores_per_instr",
-        "ScaleUnit": "1per_instr"
+        "BriefDescription": "This metric represents fraction of cycles whe=
re the Divider unit was active",
+        "MetricExpr": "10 * ARITH.DIVIDER_UOPS / CORE_CLKS",
+        "MetricGroup": "TopdownL3;tma_L3_group;tma_core_bound_group",
+        "MetricName": "tma_divider",
+        "PublicDescription": "This metric represents fraction of cycles wh=
ere the Divider unit was active. Divide and square root instructions are pe=
rformed by the Divider unit and can take considerably longer latency than i=
nteger or Floating Point addition; subtraction; or multiplication.",
+        "ScaleUnit": "100%"
     },
     {
-        "BriefDescription": "Ratio of number of requests missing L1 data c=
ache (includes data+rfo w/ prefetches) to the total number of completed ins=
tructions",
-        "MetricExpr": "L1D.REPLACEMENT / INST_RETIRED.ANY",
-        "MetricGroup": "",
-        "MetricName": "l1d_mpi",
-        "ScaleUnit": "1per_instr"
+        "BriefDescription": "This metric estimates fraction of cycles the =
CPU performance was potentially limited due to Core computation issues (non=
 divider-related)",
+        "MetricExpr": "((min(CPU_CLK_UNHALTED.THREAD, CYCLE_ACTIVITY.CYCLE=
S_NO_EXECUTE) + (cpu@UOPS_EXECUTED.CORE\\,cmask\\=3D0x1@ - (cpu@UOPS_EXECUT=
ED.CORE\\,cmask\\=3D0x3@ if INST_RETIRED.ANY / CPU_CLK_UNHALTED.THREAD > 1.=
8 else cpu@UOPS_EXECUTED.CORE\\,cmask\\=3D0x2@)) / 2 - (RS_EVENTS.EMPTY_CYC=
LES if tma_fetch_latency > 0.1 else 0) + RESOURCE_STALLS.SB if #SMT_on else=
 min(CPU_CLK_UNHALTED.THREAD, CYCLE_ACTIVITY.CYCLES_NO_EXECUTE) + cpu@UOPS_=
EXECUTED.CORE\\,cmask\\=3D0x1@ - (cpu@UOPS_EXECUTED.CORE\\,cmask\\=3D0x3@ i=
f INST_RETIRED.ANY / CPU_CLK_UNHALTED.THREAD > 1.8 else cpu@UOPS_EXECUTED.C=
ORE\\,cmask\\=3D0x2@) - (RS_EVENTS.EMPTY_CYCLES if tma_fetch_latency > 0.1 =
else 0) + RESOURCE_STALLS.SB) - RESOURCE_STALLS.SB - min(CPU_CLK_UNHALTED.T=
HREAD, CYCLE_ACTIVITY.STALLS_LDM_PENDING)) / CPU_CLK_UNHALTED.THREAD",
+        "MetricGroup": "PortsUtil;TopdownL3;tma_L3_group;tma_core_bound_gr=
oup",
+        "MetricName": "tma_ports_utilization",
+        "PublicDescription": "This metric estimates fraction of cycles the=
 CPU performance was potentially limited due to Core computation issues (no=
n divider-related).  Two distinct categories can be attributed into this me=
tric: (1) heavy data-dependency among contiguous instructions would manifes=
t in this metric - such cases are often referred to as low Instruction Leve=
l Parallelism (ILP). (2) Contention on some hardware execution unit other t=
han Divider. For example; when there are too many multiply operations.",
+        "ScaleUnit": "100%"
     },
     {
-        "BriefDescription": "Ratio of number of demand load requests hitti=
ng in L1 data cache to the total number of completed instructions",
-        "MetricExpr": "MEM_LOAD_UOPS_RETIRED.L1_HIT / INST_RETIRED.ANY",
-        "MetricGroup": "",
-        "MetricName": "l1d_demand_data_read_hits_per_instr",
-        "ScaleUnit": "1per_instr"
+        "BriefDescription": "This metric represents fraction of cycles CPU=
 executed no uops on any execution port (Logical Processor cycles since ICL=
, Physical Core cycles otherwise)",
+        "MetricExpr": "(cpu@UOPS_EXECUTED.CORE\\,inv\\=3D0x1\\,cmask\\=3D0=
x1@ / 2 if #SMT_on else min(CPU_CLK_UNHALTED.THREAD, CYCLE_ACTIVITY.CYCLES_=
NO_EXECUTE) - (RS_EVENTS.EMPTY_CYCLES if tma_fetch_latency > 0.1 else 0)) /=
 CORE_CLKS",
+        "MetricGroup": "PortsUtil;TopdownL4;tma_L4_group;tma_ports_utiliza=
tion_group",
+        "MetricName": "tma_ports_utilized_0",
+        "PublicDescription": "This metric represents fraction of cycles CP=
U executed no uops on any execution port (Logical Processor cycles since IC=
L, Physical Core cycles otherwise). Long-latency instructions like divides =
may contribute to this metric.",
+        "ScaleUnit": "100%"
     },
     {
-        "BriefDescription": "Ratio of number of code read requests missing=
 in L1 instruction cache (includes prefetches) to the total number of compl=
eted instructions",
-        "MetricExpr": "L2_RQSTS.ALL_CODE_RD / INST_RETIRED.ANY",
-        "MetricGroup": "",
-        "MetricName": "l1_i_code_read_misses_with_prefetches_per_instr",
-        "ScaleUnit": "1per_instr"
+        "BriefDescription": "This metric represents fraction of cycles whe=
re the CPU executed total of 1 uop per cycle on all execution ports (Logica=
l Processor cycles since ICL, Physical Core cycles otherwise)",
+        "MetricExpr": "((cpu@UOPS_EXECUTED.CORE\\,cmask\\=3D0x1@ - cpu@UOP=
S_EXECUTED.CORE\\,cmask\\=3D0x2@) / 2 if #SMT_on else cpu@UOPS_EXECUTED.COR=
E\\,cmask\\=3D0x1@ - cpu@UOPS_EXECUTED.CORE\\,cmask\\=3D0x2@) / CORE_CLKS",
+        "MetricGroup": "PortsUtil;TopdownL4;tma_L4_group;tma_ports_utiliza=
tion_group",
+        "MetricName": "tma_ports_utilized_1",
+        "PublicDescription": "This metric represents fraction of cycles wh=
ere the CPU executed total of 1 uop per cycle on all execution ports (Logic=
al Processor cycles since ICL, Physical Core cycles otherwise). This can be=
 due to heavy data-dependency among software instructions; or over oversubs=
cribing a particular hardware resource. In some other cases with high 1_Por=
t_Utilized and L1_Bound; this metric can point to L1 data-cache latency bot=
tleneck that may not necessarily manifest with complete execution starvatio=
n (due to the short L1 latency e.g. walking a linked list) - looking at the=
 assembly can be helpful.",
+        "ScaleUnit": "100%"
     },
     {
-        "BriefDescription": "Ratio of number of completed demand load requ=
ests hitting in L2 cache to the total number of completed instructions",
-        "MetricExpr": "MEM_LOAD_UOPS_RETIRED.L2_HIT / INST_RETIRED.ANY",
-        "MetricGroup": "",
-        "MetricName": "l2_demand_data_read_hits_per_instr",
-        "ScaleUnit": "1per_instr"
+        "BriefDescription": "This metric represents fraction of cycles CPU=
 executed total of 2 uops per cycle on all execution ports (Logical Process=
or cycles since ICL, Physical Core cycles otherwise)",
+        "MetricExpr": "((cpu@UOPS_EXECUTED.CORE\\,cmask\\=3D0x2@ - cpu@UOP=
S_EXECUTED.CORE\\,cmask\\=3D0x3@) / 2 if #SMT_on else cpu@UOPS_EXECUTED.COR=
E\\,cmask\\=3D0x2@ - cpu@UOPS_EXECUTED.CORE\\,cmask\\=3D0x3@) / CORE_CLKS",
+        "MetricGroup": "PortsUtil;TopdownL4;tma_L4_group;tma_ports_utiliza=
tion_group",
+        "MetricName": "tma_ports_utilized_2",
+        "PublicDescription": "This metric represents fraction of cycles CP=
U executed total of 2 uops per cycle on all execution ports (Logical Proces=
sor cycles since ICL, Physical Core cycles otherwise).  Loop Vectorization =
-most compilers feature auto-Vectorization options today- reduces pressure =
on the execution ports as multiple elements are calculated with same uop.",
+        "ScaleUnit": "100%"
     },
     {
-        "BriefDescription": "Ratio of number of requests missing L2 cache =
(includes code+data+rfo w/ prefetches) to the total number of completed ins=
tructions",
-        "MetricExpr": "L2_LINES_IN.ALL / INST_RETIRED.ANY",
-        "MetricGroup": "",
-        "MetricName": "l2_mpi",
-        "ScaleUnit": "1per_instr"
+        "BriefDescription": "This metric represents fraction of cycles CPU=
 executed total of 3 or more uops per cycle on all execution ports (Logical=
 Processor cycles since ICL, Physical Core cycles otherwise).",
+        "MetricExpr": "(cpu@UOPS_EXECUTED.CORE\\,cmask\\=3D0x3@ / 2 if #SM=
T_on else cpu@UOPS_EXECUTED.CORE\\,cmask\\=3D0x3@) / CORE_CLKS",
+        "MetricGroup": "PortsUtil;TopdownL4;tma_L4_group;tma_ports_utiliza=
tion_group",
+        "MetricName": "tma_ports_utilized_3m",
+        "ScaleUnit": "100%"
     },
     {
-        "BriefDescription": "Ratio of number of completed data read reques=
t missing L2 cache to the total number of completed instructions",
-        "MetricExpr": "MEM_LOAD_UOPS_RETIRED.L2_MISS / INST_RETIRED.ANY",
-        "MetricGroup": "",
-        "MetricName": "l2_demand_data_read_mpi",
-        "ScaleUnit": "1per_instr"
+        "BriefDescription": "This metric represents Core fraction of cycle=
s CPU dispatched uops on execution ports for ALU operations.",
+        "MetricExpr": "(UOPS_DISPATCHED_PORT.PORT_0 + UOPS_DISPATCHED_PORT=
.PORT_1 + UOPS_DISPATCHED_PORT.PORT_5 + UOPS_DISPATCHED_PORT.PORT_6) / SLOT=
S",
+        "MetricGroup": "TopdownL5;tma_L5_group;tma_ports_utilized_3m_group=
",
+        "MetricName": "tma_alu_op_utilization",
+        "ScaleUnit": "100%"
     },
     {
-        "BriefDescription": "Ratio of number of code read request missing =
L2 cache to the total number of completed instructions",
-        "MetricExpr": "L2_RQSTS.CODE_RD_MISS / INST_RETIRED.ANY",
-        "MetricGroup": "",
-        "MetricName": "l2_demand_code_mpi",
-        "ScaleUnit": "1per_instr"
+        "BriefDescription": "This metric represents Core fraction of cycle=
s CPU dispatched uops on execution port 0 ([SNB+] ALU; [HSW+] ALU and 2nd b=
ranch)",
+        "MetricExpr": "UOPS_DISPATCHED_PORT.PORT_0 / CORE_CLKS",
+        "MetricGroup": "Compute;TopdownL6;tma_L6_group;tma_alu_op_utilizat=
ion_group",
+        "MetricName": "tma_port_0",
+        "ScaleUnit": "100%"
     },
     {
-        "BriefDescription": "Average latency of a last level cache (LLC) d=
emand and prefetch data read miss (read memory access) in nano seconds",
-        "MetricExpr": "( 1000000000 * ( cbox@UNC_C_TOR_OCCUPANCY.MISS_OPCO=
DE\\,filter_opc\\=3D0x182@ / cbox@UNC_C_TOR_INSERTS.MISS_OPCODE\\,filter_op=
c\\=3D0x182@ ) / ( UNC_C_CLOCKTICKS / ( #num_cores / #num_packages * #num_p=
ackages ) ) ) * duration_time",
-        "MetricGroup": "",
-        "MetricName": "llc_data_read_demand_plus_prefetch_miss_latency",
-        "ScaleUnit": "1ns"
+        "BriefDescription": "This metric represents Core fraction of cycle=
s CPU dispatched uops on execution port 1 (ALU)",
+        "MetricExpr": "UOPS_DISPATCHED_PORT.PORT_1 / CORE_CLKS",
+        "MetricGroup": "TopdownL6;tma_L6_group;tma_alu_op_utilization_grou=
p",
+        "MetricName": "tma_port_1",
+        "ScaleUnit": "100%"
     },
     {
-        "BriefDescription": "Average latency of a last level cache (LLC) d=
emand and prefetch data read miss (read memory access) addressed to local m=
emory in nano seconds",
-        "MetricExpr": "( 1000000000 * ( cbox@UNC_C_TOR_OCCUPANCY.MISS_LOCA=
L_OPCODE\\,filter_opc\\=3D0x182@ / cbox@UNC_C_TOR_INSERTS.MISS_LOCAL_OPCODE=
\\,filter_opc\\=3D0x182@ ) / ( UNC_C_CLOCKTICKS / ( #num_cores / #num_packa=
ges * #num_packages ) ) ) * duration_time",
-        "MetricGroup": "",
-        "MetricName": "llc_data_read_demand_plus_prefetch_miss_latency_for=
_local_requests",
-        "ScaleUnit": "1ns"
+        "BriefDescription": "This metric represents Core fraction of cycle=
s CPU dispatched uops on execution port 5 ([SNB+] Branches and ALU; [HSW+] =
ALU)",
+        "MetricExpr": "UOPS_DISPATCHED_PORT.PORT_5 / CORE_CLKS",
+        "MetricGroup": "TopdownL6;tma_L6_group;tma_alu_op_utilization_grou=
p",
+        "MetricName": "tma_port_5",
+        "ScaleUnit": "100%"
     },
     {
-        "BriefDescription": "Average latency of a last level cache (LLC) d=
emand and prefetch data read miss (read memory access) addressed to remote =
memory in nano seconds",
-        "MetricExpr": "( 1000000000 * ( cbox@UNC_C_TOR_OCCUPANCY.MISS_REMO=
TE_OPCODE\\,filter_opc\\=3D0x182@ / cbox@UNC_C_TOR_INSERTS.MISS_REMOTE_OPCO=
DE\\,filter_opc\\=3D0x182@ ) / ( UNC_C_CLOCKTICKS / ( #num_cores / #num_pac=
kages * #num_packages ) ) ) * duration_time",
-        "MetricGroup": "",
-        "MetricName": "llc_data_read_demand_plus_prefetch_miss_latency_for=
_remote_requests",
-        "ScaleUnit": "1ns"
+        "BriefDescription": "This metric represents Core fraction of cycle=
s CPU dispatched uops on execution port 6 ([HSW+]Primary Branch and simple =
ALU)",
+        "MetricExpr": "UOPS_DISPATCHED_PORT.PORT_6 / CORE_CLKS",
+        "MetricGroup": "TopdownL6;tma_L6_group;tma_alu_op_utilization_grou=
p",
+        "MetricName": "tma_port_6",
+        "ScaleUnit": "100%"
     },
     {
-        "BriefDescription": "Ratio of number of completed page walks (for =
all page sizes) caused by a code fetch to the total number of completed ins=
tructions. This implies it missed in the ITLB (Instruction TLB) and further=
 levels of TLB.",
-        "MetricExpr": "ITLB_MISSES.WALK_COMPLETED / INST_RETIRED.ANY",
-        "MetricGroup": "",
-        "MetricName": "itlb_mpi",
-        "ScaleUnit": "1per_instr"
+        "BriefDescription": "This metric represents Core fraction of cycle=
s CPU dispatched uops on execution port for Load operations",
+        "MetricExpr": "(UOPS_DISPATCHED_PORT.PORT_2 + UOPS_DISPATCHED_PORT=
.PORT_3 + UOPS_DISPATCHED_PORT.PORT_7 - UOPS_DISPATCHED_PORT.PORT_4) / (2 *=
 CORE_CLKS)",
+        "MetricGroup": "TopdownL5;tma_L5_group;tma_ports_utilized_3m_group=
",
+        "MetricName": "tma_load_op_utilization",
+        "ScaleUnit": "100%"
     },
     {
-        "BriefDescription": "Ratio of number of completed page walks (for =
2 megabyte and 4 megabyte page sizes) caused by a code fetch to the total n=
umber of completed instructions. This implies it missed in the Instruction =
Translation Lookaside Buffer (ITLB) and further levels of TLB.",
-        "MetricExpr": "ITLB_MISSES.WALK_COMPLETED_2M_4M / INST_RETIRED.ANY=
",
-        "MetricGroup": "",
-        "MetricName": "itlb_large_page_mpi",
-        "ScaleUnit": "1per_instr"
+        "BriefDescription": "This metric represents Core fraction of cycle=
s CPU dispatched uops on execution port 2 ([SNB+]Loads and Store-address; [=
ICL+] Loads)",
+        "MetricExpr": "UOPS_DISPATCHED_PORT.PORT_2 / CORE_CLKS",
+        "MetricGroup": "TopdownL6;tma_L6_group;tma_load_op_utilization_gro=
up",
+        "MetricName": "tma_port_2",
+        "ScaleUnit": "100%"
     },
     {
-        "BriefDescription": "Ratio of number of completed page walks (for =
all page sizes) caused by demand data loads to the total number of complete=
d instructions. This implies it missed in the DTLB and further levels of TL=
B.",
-        "MetricExpr": "DTLB_LOAD_MISSES.WALK_COMPLETED / INST_RETIRED.ANY"=
,
-        "MetricGroup": "",
-        "MetricName": "dtlb_load_mpi",
-        "ScaleUnit": "1per_instr"
+        "BriefDescription": "This metric represents Core fraction of cycle=
s CPU dispatched uops on execution port 3 ([SNB+]Loads and Store-address; [=
ICL+] Loads)",
+        "MetricExpr": "UOPS_DISPATCHED_PORT.PORT_3 / CORE_CLKS",
+        "MetricGroup": "TopdownL6;tma_L6_group;tma_load_op_utilization_gro=
up",
+        "MetricName": "tma_port_3",
+        "ScaleUnit": "100%"
     },
     {
-        "BriefDescription": "Ratio of number of completed page walks (for =
all page sizes) caused by demand data stores to the total number of complet=
ed instructions. This implies it missed in the DTLB and further levels of T=
LB.",
-        "MetricExpr": "DTLB_STORE_MISSES.WALK_COMPLETED / INST_RETIRED.ANY=
",
-        "MetricGroup": "",
-        "MetricName": "dtlb_store_mpi",
-        "ScaleUnit": "1per_instr"
+        "BriefDescription": "This metric represents Core fraction of cycle=
s CPU dispatched uops on execution port for Store operations",
+        "MetricExpr": "UOPS_DISPATCHED_PORT.PORT_4 / CORE_CLKS",
+        "MetricGroup": "TopdownL5;tma_L5_group;tma_ports_utilized_3m_group=
",
+        "MetricName": "tma_store_op_utilization",
+        "ScaleUnit": "100%"
     },
     {
-        "BriefDescription": "Uncore operating frequency in GHz",
-        "MetricExpr": "( UNC_C_CLOCKTICKS / ( #num_cores / #num_packages *=
 #num_packages ) / 1000000000) / duration_time",
-        "MetricGroup": "",
-        "MetricName": "uncore_frequency",
-        "ScaleUnit": "1GHz"
+        "BriefDescription": "This metric represents Core fraction of cycle=
s CPU dispatched uops on execution port 4 (Store-data)",
+        "MetricExpr": "tma_store_op_utilization",
+        "MetricGroup": "TopdownL6;tma_L6_group;tma_store_op_utilization_gr=
oup",
+        "MetricName": "tma_port_4",
+        "ScaleUnit": "100%"
     },
     {
-        "BriefDescription": "Intel(R) Quick Path Interconnect (QPI) data t=
ransmit bandwidth (MB/sec)",
-        "MetricExpr": "( UNC_Q_TxL_FLITS_G0.DATA * 8 / 1000000) / duration=
_time",
-        "MetricGroup": "",
-        "MetricName": "qpi_data_transmit_bw",
-        "ScaleUnit": "1MB/s"
+        "BriefDescription": "This metric represents Core fraction of cycle=
s CPU dispatched uops on execution port 7 ([HSW+]simple Store-address)",
+        "MetricExpr": "UOPS_DISPATCHED_PORT.PORT_7 / CORE_CLKS",
+        "MetricGroup": "TopdownL6;tma_L6_group;tma_store_op_utilization_gr=
oup",
+        "MetricName": "tma_port_7",
+        "ScaleUnit": "100%"
     },
     {
-        "BriefDescription": "DDR memory read bandwidth (MB/sec)",
-        "MetricExpr": "( UNC_M_CAS_COUNT.RD * 64 / 1000000) / duration_tim=
e",
-        "MetricGroup": "",
-        "MetricName": "memory_bandwidth_read",
-        "ScaleUnit": "1MB/s"
+        "BriefDescription": "This category represents fraction of slots ut=
ilized by useful work i.e. issued uops that eventually get retired",
+        "MetricExpr": "UOPS_RETIRED.RETIRE_SLOTS / SLOTS",
+        "MetricGroup": "TopdownL1;tma_L1_group;tma_L1_group",
+        "MetricName": "tma_retiring",
+        "PublicDescription": "This category represents fraction of slots u=
tilized by useful work i.e. issued uops that eventually get retired. Ideall=
y; all pipeline slots would be attributed to the Retiring category.  Retiri=
ng of 100% would indicate the maximum Pipeline_Width throughput was achieve=
d.  Maximizing Retiring typically increases the Instructions-per-cycle (see=
 IPC metric). Note that a high Retiring value does not necessary mean there=
 is no room for more performance.  For example; Heavy-operations or Microco=
de Assists are categorized under Retiring. They often indicate suboptimal p=
erformance and can often be optimized or avoided. ",
+        "ScaleUnit": "100%"
     },
     {
-        "BriefDescription": "DDR memory write bandwidth (MB/sec)",
-        "MetricExpr": "( UNC_M_CAS_COUNT.WR * 64 / 1000000) / duration_tim=
e",
-        "MetricGroup": "",
-        "MetricName": "memory_bandwidth_write",
-        "ScaleUnit": "1MB/s"
+        "BriefDescription": "This metric represents fraction of slots wher=
e the CPU was retiring light-weight operations -- instructions that require=
 no more than one uop (micro-operation)",
+        "MetricExpr": "tma_retiring - UOPS_RETIRED.RETIRE_SLOTS / UOPS_ISS=
UED.ANY * IDQ.MS_UOPS / SLOTS",
+        "MetricGroup": "Retire;TopdownL2;tma_L2_group;tma_L2_group;tma_ret=
iring_group",
+        "MetricName": "tma_light_operations",
+        "PublicDescription": "This metric represents fraction of slots whe=
re the CPU was retiring light-weight operations -- instructions that requir=
e no more than one uop (micro-operation). This correlates with total number=
 of instructions used by the program. A uops-per-instruction (see UPI metri=
c) ratio of 1 or less should be expected for decently optimized software ru=
nning on Intel Core/Xeon products. While this often indicates efficient X86=
 instructions were executed; high value does not necessarily mean better pe=
rformance cannot be achieved.",
+        "ScaleUnit": "100%"
     },
     {
-        "BriefDescription": "DDR memory bandwidth (MB/sec)",
-        "MetricExpr": "(( UNC_M_CAS_COUNT.RD + UNC_M_CAS_COUNT.WR ) * 64 /=
 1000000) / duration_time",
-        "MetricGroup": "",
-        "MetricName": "memory_bandwidth_total",
-        "ScaleUnit": "1MB/s"
+        "BriefDescription": "This metric serves as an approximation of leg=
acy x87 usage",
+        "MetricExpr": "INST_RETIRED.X87 * UPI / UOPS_RETIRED.RETIRE_SLOTS"=
,
+        "MetricGroup": "Compute;TopdownL4;tma_L4_group;tma_ports_utilizati=
on_group",
+        "MetricName": "tma_x87_use",
+        "PublicDescription": "This metric serves as an approximation of le=
gacy x87 usage. It accounts for instructions beyond X87 FP arithmetic opera=
tions; hence may be used as a thermometer to avoid X87 high usage and prefe=
rably upgrade to modern ISA. See Tip under Tuning Hint.",
+        "ScaleUnit": "100%"
     },
     {
-        "BriefDescription": "Bandwidth of IO reads that are initiated by e=
nd device controllers that are requesting memory from the CPU.",
-        "MetricExpr": "( cbox@UNC_C_TOR_INSERTS.OPCODE\\,filter_opc\\=3D0x=
19e@ * 64 / 1000000) / duration_time",
-        "MetricGroup": "",
-        "MetricName": "io_bandwidth_disk_or_network_writes",
-        "ScaleUnit": "1MB/s"
+        "BriefDescription": "This metric represents fraction of slots wher=
e the CPU was retiring heavy-weight operations -- instructions that require=
 two or more uops or microcoded sequences",
+        "MetricExpr": "UOPS_RETIRED.RETIRE_SLOTS / UOPS_ISSUED.ANY * IDQ.M=
S_UOPS / SLOTS",
+        "MetricGroup": "Retire;TopdownL2;tma_L2_group;tma_L2_group;tma_ret=
iring_group",
+        "MetricName": "tma_heavy_operations",
+        "PublicDescription": "This metric represents fraction of slots whe=
re the CPU was retiring heavy-weight operations -- instructions that requir=
e two or more uops or microcoded sequences. This highly-correlates with the=
 uop length of these instructions/sequences.",
+        "ScaleUnit": "100%"
     },
     {
-        "BriefDescription": "Bandwidth of IO writes that are initiated by =
end device controllers that are writing memory to the CPU.",
-        "MetricExpr": "( cbox@UNC_C_TOR_INSERTS.OPCODE\\,filter_opc\\=3D0x=
1c8\\,filter_tid\\=3D0x3e@ * 64 / 1000000) / duration_time",
-        "MetricGroup": "",
-        "MetricName": "io_bandwidth_disk_or_network_reads",
-        "ScaleUnit": "1MB/s"
+        "BriefDescription": "This metric represents fraction of slots the =
CPU was retiring uops fetched by the Microcode Sequencer (MS) unit",
+        "MetricExpr": "tma_heavy_operations",
+        "MetricGroup": "MicroSeq;TopdownL3;tma_L3_group;tma_heavy_operatio=
ns_group",
+        "MetricName": "tma_microcode_sequencer",
+        "PublicDescription": "This metric represents fraction of slots the=
 CPU was retiring uops fetched by the Microcode Sequencer (MS) unit.  The M=
S is used for CISC instructions not supported by the default decoders (like=
 repeat move strings; or CPUID); or by microcode assists used to address so=
me operation modes (like in Floating Point assists). These cases can often =
be avoided.",
+        "ScaleUnit": "100%"
     },
     {
-        "BriefDescription": "Uops delivered from decoded instruction cache=
 (decoded stream buffer or DSB) as a percent of total uops delivered to Ins=
truction Decode Queue",
-        "MetricExpr": "100 * ( IDQ.DSB_UOPS / UOPS_ISSUED.ANY )",
-        "MetricGroup": "",
-        "MetricName": "percent_uops_delivered_from_decoded_icache",
-        "ScaleUnit": "1%"
+        "BriefDescription": "This metric estimates fraction of slots the C=
PU retired uops delivered by the Microcode_Sequencer as a result of Assists=
",
+        "MetricExpr": "min(100 * OTHER_ASSISTS.ANY_WB_ASSIST / SLOTS, 1)",
+        "MetricGroup": "TopdownL4;tma_L4_group;tma_microcode_sequencer_gro=
up",
+        "MetricName": "tma_assists",
+        "PublicDescription": "This metric estimates fraction of slots the =
CPU retired uops delivered by the Microcode_Sequencer as a result of Assist=
s. Assists are long sequences of uops that are required in certain corner-c=
ases for operations that cannot be handled natively by the execution pipeli=
ne. For example; when working with very small floating point values (so-cal=
led Denormals); the FP units are not set up to perform these operations nat=
ively. Instead; a sequence of instructions to perform the computation on th=
e Denormals is injected into the pipeline. Since these microcode sequences =
might be dozens of uops long; Assists can be extremely deleterious to perfo=
rmance and they can be avoided in many cases.",
+        "ScaleUnit": "100%"
     },
     {
-        "BriefDescription": "Uops delivered from legacy decode pipeline (M=
icro-instruction Translation Engine or MITE) as a percent of total uops del=
ivered to Instruction Decode Queue",
-        "MetricExpr": "100 * ( IDQ.MITE_UOPS / UOPS_ISSUED.ANY )",
-        "MetricGroup": "",
-        "MetricName": "percent_uops_delivered_from_legacy_decode_pipeline"=
,
-        "ScaleUnit": "1%"
+        "BriefDescription": "This metric estimates fraction of cycles the =
CPU retired uops originated from CISC (complex instruction set computer) in=
struction",
+        "MetricExpr": "max(0, tma_heavy_operations - tma_assists)",
+        "MetricGroup": "TopdownL4;tma_L4_group;tma_microcode_sequencer_gro=
up",
+        "MetricName": "tma_cisc",
+        "PublicDescription": "This metric estimates fraction of cycles the=
 CPU retired uops originated from CISC (complex instruction set computer) i=
nstruction. A CISC instruction has multiple uops that are required to perfo=
rm the instruction's functionality as in the case of read-modify-write as a=
n example. Since these instructions require multiple uops they may or may n=
ot imply sub-optimal use of machine resources.",
+        "ScaleUnit": "100%"
     },
     {
-        "BriefDescription": "Uops delivered from microcode sequencer (MS) =
as a percent of total uops delivered to Instruction Decode Queue",
-        "MetricExpr": "100 * ( IDQ.MS_UOPS / UOPS_ISSUED.ANY )",
-        "MetricGroup": "",
-        "MetricName": "percent_uops_delivered_from_microcode_sequencer",
-        "ScaleUnit": "1%"
+        "BriefDescription": "C3 residency percent per core",
+        "MetricExpr": "cstate_core@c3\\-residency@ / TSC",
+        "MetricGroup": "Power",
+        "MetricName": "C3_Core_Residency",
+        "ScaleUnit": "100%"
     },
     {
-        "BriefDescription": "Uops delivered from loop stream detector(LSD)=
 as a percent of total uops delivered to Instruction Decode Queue",
-        "MetricExpr": "100 * ( UOPS_ISSUED.ANY - IDQ.MITE_UOPS - IDQ.MS_UO=
PS - IDQ.DSB_UOPS ) / UOPS_ISSUED.ANY",
-        "MetricGroup": "",
-        "MetricName": "percent_uops_delivered_from_loop_stream_detector",
-        "ScaleUnit": "1%"
+        "BriefDescription": "C6 residency percent per core",
+        "MetricExpr": "cstate_core@c6\\-residency@ / TSC",
+        "MetricGroup": "Power",
+        "MetricName": "C6_Core_Residency",
+        "ScaleUnit": "100%"
     },
     {
-        "BriefDescription": "Ratio of number of data read requests missing=
 last level core cache (includes demand w/ prefetches) to the total number =
of completed instructions",
-        "MetricExpr": "( cbox@UNC_C_TOR_INSERTS.MISS_OPCODE\\,filter_opc\\=
=3D0x182@ + cbox@UNC_C_TOR_INSERTS.MISS_OPCODE\\,filter_opc\\=3D0x192@ ) / =
INST_RETIRED.ANY",
-        "MetricGroup": "",
-        "MetricName": "llc_data_read_mpi_demand_plus_prefetch",
-        "ScaleUnit": "1per_instr"
+        "BriefDescription": "C7 residency percent per core",
+        "MetricExpr": "cstate_core@c7\\-residency@ / TSC",
+        "MetricGroup": "Power",
+        "MetricName": "C7_Core_Residency",
+        "ScaleUnit": "100%"
     },
     {
-        "BriefDescription": "Ratio of number of code read requests missing=
 last level core cache (includes demand w/ prefetches) to the total number =
of completed instructions",
-        "MetricExpr": "( cbox@UNC_C_TOR_INSERTS.MISS_OPCODE\\,filter_opc\\=
=3D0x181@ + cbox@UNC_C_TOR_INSERTS.MISS_OPCODE\\,filter_opc\\=3D0x191@ ) / =
INST_RETIRED.ANY",
-        "MetricGroup": "",
-        "MetricName": "llc_code_read_mpi_demand_plus_prefetch",
-        "ScaleUnit": "1per_instr"
+        "BriefDescription": "C2 residency percent per package",
+        "MetricExpr": "cstate_pkg@c2\\-residency@ / TSC",
+        "MetricGroup": "Power",
+        "MetricName": "C2_Pkg_Residency",
+        "ScaleUnit": "100%"
     },
     {
-        "BriefDescription": "Memory read that miss the last level cache (L=
LC) addressed to local DRAM as a percentage of total memory read accesses, =
does not include LLC prefetches.",
-        "MetricExpr": "100 * cbox@UNC_C_TOR_INSERTS.MISS_LOCAL_OPCODE\\,fi=
lter_opc\\=3D0x182@ / ( cbox@UNC_C_TOR_INSERTS.MISS_LOCAL_OPCODE\\,filter_o=
pc\\=3D0x182@ + cbox@UNC_C_TOR_INSERTS.MISS_REMOTE_OPCODE\\,filter_opc\\=3D=
0x182@ )",
-        "MetricGroup": "",
-        "MetricName": "numa_reads_addressed_to_local_dram",
-        "ScaleUnit": "1%"
+        "BriefDescription": "C3 residency percent per package",
+        "MetricExpr": "cstate_pkg@c3\\-residency@ / TSC",
+        "MetricGroup": "Power",
+        "MetricName": "C3_Pkg_Residency",
+        "ScaleUnit": "100%"
     },
     {
-        "BriefDescription": "Memory reads that miss the last level cache (=
LLC) addressed to remote DRAM as a percentage of total memory read accesses=
, does not include LLC prefetches.",
-        "MetricExpr": "100 * cbox@UNC_C_TOR_INSERTS.MISS_REMOTE_OPCODE\\,f=
ilter_opc\\=3D0x182@ / ( cbox@UNC_C_TOR_INSERTS.MISS_LOCAL_OPCODE\\,filter_=
opc\\=3D0x182@ + cbox@UNC_C_TOR_INSERTS.MISS_REMOTE_OPCODE\\,filter_opc\\=
=3D0x182@ )",
-        "MetricGroup": "",
-        "MetricName": "numa_reads_addressed_to_remote_dram",
-        "ScaleUnit": "1%"
+        "BriefDescription": "C6 residency percent per package",
+        "MetricExpr": "cstate_pkg@c6\\-residency@ / TSC",
+        "MetricGroup": "Power",
+        "MetricName": "C6_Pkg_Residency",
+        "ScaleUnit": "100%"
+    },
+    {
+        "BriefDescription": "C7 residency percent per package",
+        "MetricExpr": "cstate_pkg@c7\\-residency@ / TSC",
+        "MetricGroup": "Power",
+        "MetricName": "C7_Pkg_Residency",
+        "ScaleUnit": "100%"
     }
 ]
diff --git a/tools/perf/pmu-events/arch/x86/haswellx/memory.json b/tools/pe=
rf/pmu-events/arch/x86/haswellx/memory.json
index fdabc9fe12a5..2d212cf59e92 100644
--- a/tools/perf/pmu-events/arch/x86/haswellx/memory.json
+++ b/tools/perf/pmu-events/arch/x86/haswellx/memory.json
@@ -1,8 +1,6 @@
 [
     {
         "BriefDescription": "Number of times an HLE execution aborted due =
to any reasons (multiple categories may count as one).",
-        "Counter": "0,1,2,3",
-        "CounterHTOff": "0,1,2,3,4,5,6,7",
         "EventCode": "0xc8",
         "EventName": "HLE_RETIRED.ABORTED",
         "PEBS": "1",
@@ -11,8 +9,6 @@
     },
     {
         "BriefDescription": "Number of times an HLE execution aborted due =
to various memory events (e.g., read/write capacity and conflicts).",
-        "Counter": "0,1,2,3",
-        "CounterHTOff": "0,1,2,3,4,5,6,7",
         "EventCode": "0xc8",
         "EventName": "HLE_RETIRED.ABORTED_MISC1",
         "SampleAfterValue": "2000003",
@@ -20,8 +16,6 @@
     },
     {
         "BriefDescription": "Number of times an HLE execution aborted due =
to uncommon conditions.",
-        "Counter": "0,1,2,3",
-        "CounterHTOff": "0,1,2,3,4,5,6,7",
         "EventCode": "0xc8",
         "EventName": "HLE_RETIRED.ABORTED_MISC2",
         "SampleAfterValue": "2000003",
@@ -29,8 +23,6 @@
     },
     {
         "BriefDescription": "Number of times an HLE execution aborted due =
to HLE-unfriendly instructions.",
-        "Counter": "0,1,2,3",
-        "CounterHTOff": "0,1,2,3,4,5,6,7",
         "EventCode": "0xc8",
         "EventName": "HLE_RETIRED.ABORTED_MISC3",
         "SampleAfterValue": "2000003",
@@ -38,8 +30,6 @@
     },
     {
         "BriefDescription": "Number of times an HLE execution aborted due =
to incompatible memory type.",
-        "Counter": "0,1,2,3",
-        "CounterHTOff": "0,1,2,3,4,5,6,7",
         "Errata": "HSD65",
         "EventCode": "0xc8",
         "EventName": "HLE_RETIRED.ABORTED_MISC4",
@@ -48,8 +38,6 @@
     },
     {
         "BriefDescription": "Number of times an HLE execution aborted due =
to none of the previous 4 categories (e.g. interrupts)",
-        "Counter": "0,1,2,3",
-        "CounterHTOff": "0,1,2,3,4,5,6,7",
         "EventCode": "0xc8",
         "EventName": "HLE_RETIRED.ABORTED_MISC5",
         "PublicDescription": "Number of times an HLE execution aborted due=
 to none of the previous 4 categories (e.g. interrupts).",
@@ -58,8 +46,6 @@
     },
     {
         "BriefDescription": "Number of times an HLE execution successfully=
 committed.",
-        "Counter": "0,1,2,3",
-        "CounterHTOff": "0,1,2,3,4,5,6,7",
         "EventCode": "0xc8",
         "EventName": "HLE_RETIRED.COMMIT",
         "SampleAfterValue": "2000003",
@@ -67,8 +53,6 @@
     },
     {
         "BriefDescription": "Number of times an HLE execution started.",
-        "Counter": "0,1,2,3",
-        "CounterHTOff": "0,1,2,3,4,5,6,7",
         "EventCode": "0xC8",
         "EventName": "HLE_RETIRED.START",
         "SampleAfterValue": "2000003",
@@ -76,8 +60,6 @@
     },
     {
         "BriefDescription": "Counts the number of machine clears due to me=
mory order conflicts.",
-        "Counter": "0,1,2,3",
-        "CounterHTOff": "0,1,2,3,4,5,6,7",
         "EventCode": "0xC3",
         "EventName": "MACHINE_CLEARS.MEMORY_ORDERING",
         "PublicDescription": "This event counts the number of memory order=
ing machine clears detected. Memory ordering machine clears can result from=
 memory address aliasing or snoops from another hardware thread or core to =
data inflight in the pipeline.  Machine clears can have a significant perfo=
rmance impact if they are happening frequently.",
@@ -86,8 +68,6 @@
     },
     {
         "BriefDescription": "Randomly selected loads with latency value be=
ing above 128.",
-        "Counter": "3",
-        "CounterHTOff": "3",
         "Data_LA": "1",
         "Errata": "HSD76, HSD25, HSM26",
         "EventCode": "0xcd",
@@ -96,13 +76,10 @@
         "MSRValue": "0x80",
         "PEBS": "2",
         "SampleAfterValue": "1009",
-        "TakenAlone": "1",
         "UMask": "0x1"
     },
     {
         "BriefDescription": "Randomly selected loads with latency value be=
ing above 16.",
-        "Counter": "3",
-        "CounterHTOff": "3",
         "Data_LA": "1",
         "Errata": "HSD76, HSD25, HSM26",
         "EventCode": "0xcd",
@@ -111,13 +88,10 @@
         "MSRValue": "0x10",
         "PEBS": "2",
         "SampleAfterValue": "20011",
-        "TakenAlone": "1",
         "UMask": "0x1"
     },
     {
         "BriefDescription": "Randomly selected loads with latency value be=
ing above 256.",
-        "Counter": "3",
-        "CounterHTOff": "3",
         "Data_LA": "1",
         "Errata": "HSD76, HSD25, HSM26",
         "EventCode": "0xcd",
@@ -126,13 +100,10 @@
         "MSRValue": "0x100",
         "PEBS": "2",
         "SampleAfterValue": "503",
-        "TakenAlone": "1",
         "UMask": "0x1"
     },
     {
         "BriefDescription": "Randomly selected loads with latency value be=
ing above 32.",
-        "Counter": "3",
-        "CounterHTOff": "3",
         "Data_LA": "1",
         "Errata": "HSD76, HSD25, HSM26",
         "EventCode": "0xcd",
@@ -141,13 +112,10 @@
         "MSRValue": "0x20",
         "PEBS": "2",
         "SampleAfterValue": "100003",
-        "TakenAlone": "1",
         "UMask": "0x1"
     },
     {
         "BriefDescription": "Randomly selected loads with latency value be=
ing above 4.",
-        "Counter": "3",
-        "CounterHTOff": "3",
         "Data_LA": "1",
         "Errata": "HSD76, HSD25, HSM26",
         "EventCode": "0xcd",
@@ -156,13 +124,10 @@
         "MSRValue": "0x4",
         "PEBS": "2",
         "SampleAfterValue": "100003",
-        "TakenAlone": "1",
         "UMask": "0x1"
     },
     {
         "BriefDescription": "Randomly selected loads with latency value be=
ing above 512.",
-        "Counter": "3",
-        "CounterHTOff": "3",
         "Data_LA": "1",
         "Errata": "HSD76, HSD25, HSM26",
         "EventCode": "0xcd",
@@ -171,13 +136,10 @@
         "MSRValue": "0x200",
         "PEBS": "2",
         "SampleAfterValue": "101",
-        "TakenAlone": "1",
         "UMask": "0x1"
     },
     {
         "BriefDescription": "Randomly selected loads with latency value be=
ing above 64.",
-        "Counter": "3",
-        "CounterHTOff": "3",
         "Data_LA": "1",
         "Errata": "HSD76, HSD25, HSM26",
         "EventCode": "0xcd",
@@ -186,13 +148,10 @@
         "MSRValue": "0x40",
         "PEBS": "2",
         "SampleAfterValue": "2003",
-        "TakenAlone": "1",
         "UMask": "0x1"
     },
     {
         "BriefDescription": "Randomly selected loads with latency value be=
ing above 8.",
-        "Counter": "3",
-        "CounterHTOff": "3",
         "Data_LA": "1",
         "Errata": "HSD76, HSD25, HSM26",
         "EventCode": "0xcd",
@@ -201,13 +160,10 @@
         "MSRValue": "0x8",
         "PEBS": "2",
         "SampleAfterValue": "50021",
-        "TakenAlone": "1",
         "UMask": "0x1"
     },
     {
         "BriefDescription": "Speculative cache line split load uops dispat=
ched to L1 cache",
-        "Counter": "0,1,2,3",
-        "CounterHTOff": "0,1,2,3,4,5,6,7",
         "EventCode": "0x05",
         "EventName": "MISALIGN_MEM_REF.LOADS",
         "PublicDescription": "Speculative cache-line split load uops dispa=
tched to L1D.",
@@ -216,8 +172,6 @@
     },
     {
         "BriefDescription": "Speculative cache line split STA uops dispatc=
hed to L1 cache",
-        "Counter": "0,1,2,3",
-        "CounterHTOff": "0,1,2,3,4,5,6,7",
         "EventCode": "0x05",
         "EventName": "MISALIGN_MEM_REF.STORES",
         "PublicDescription": "Speculative cache-line split store-address u=
ops dispatched to L1D.",
@@ -226,344 +180,258 @@
     },
     {
         "BriefDescription": "Counts all demand & prefetch code reads miss =
in the L3",
-        "Counter": "0,1,2,3",
-        "CounterHTOff": "0,1,2,3",
         "EventCode": "0xB7, 0xBB",
         "EventName": "OFFCORE_RESPONSE.ALL_CODE_RD.LLC_MISS.ANY_RESPONSE",
         "MSRIndex": "0x1a6,0x1a7",
         "MSRValue": "0x3FBFC00244",
-        "Offcore": "1",
         "SampleAfterValue": "100003",
         "UMask": "0x1"
     },
     {
         "BriefDescription": "Counts all demand & prefetch code reads miss =
the L3 and the data is returned from local dram",
-        "Counter": "0,1,2,3",
-        "CounterHTOff": "0,1,2,3",
         "EventCode": "0xB7, 0xBB",
         "EventName": "OFFCORE_RESPONSE.ALL_CODE_RD.LLC_MISS.LOCAL_DRAM",
         "MSRIndex": "0x1a6,0x1a7",
         "MSRValue": "0x600400244",
-        "Offcore": "1",
         "SampleAfterValue": "100003",
         "UMask": "0x1"
     },
     {
         "BriefDescription": "Counts all demand & prefetch data reads miss =
in the L3",
-        "Counter": "0,1,2,3",
-        "CounterHTOff": "0,1,2,3",
         "EventCode": "0xB7, 0xBB",
         "EventName": "OFFCORE_RESPONSE.ALL_DATA_RD.LLC_MISS.ANY_RESPONSE",
         "MSRIndex": "0x1a6,0x1a7",
         "MSRValue": "0x3FBFC00091",
-        "Offcore": "1",
         "SampleAfterValue": "100003",
         "UMask": "0x1"
     },
     {
         "BriefDescription": "Counts all demand & prefetch data reads miss =
the L3 and the data is returned from local dram",
-        "Counter": "0,1,2,3",
-        "CounterHTOff": "0,1,2,3",
         "EventCode": "0xB7, 0xBB",
         "EventName": "OFFCORE_RESPONSE.ALL_DATA_RD.LLC_MISS.LOCAL_DRAM",
         "MSRIndex": "0x1a6,0x1a7",
         "MSRValue": "0x600400091",
-        "Offcore": "1",
         "SampleAfterValue": "100003",
         "UMask": "0x1"
     },
     {
         "BriefDescription": "Counts all demand & prefetch data reads miss =
the L3 and the data is returned from remote dram",
-        "Counter": "0,1,2,3",
-        "CounterHTOff": "0,1,2,3",
         "EventCode": "0xB7, 0xBB",
         "EventName": "OFFCORE_RESPONSE.ALL_DATA_RD.LLC_MISS.REMOTE_DRAM",
         "MSRIndex": "0x1a6,0x1a7",
         "MSRValue": "0x63F800091",
-        "Offcore": "1",
         "SampleAfterValue": "100003",
         "UMask": "0x1"
     },
     {
         "BriefDescription": "Counts all demand & prefetch data reads miss =
the L3 and the modified data is transferred from remote cache",
-        "Counter": "0,1,2,3",
-        "CounterHTOff": "0,1,2,3",
         "EventCode": "0xB7, 0xBB",
         "EventName": "OFFCORE_RESPONSE.ALL_DATA_RD.LLC_MISS.REMOTE_HITM",
         "MSRIndex": "0x1a6,0x1a7",
         "MSRValue": "0x103FC00091",
-        "Offcore": "1",
         "SampleAfterValue": "100003",
         "UMask": "0x1"
     },
     {
         "BriefDescription": "Counts all demand & prefetch data reads miss =
the L3 and clean or shared data is transferred from remote cache",
-        "Counter": "0,1,2,3",
-        "CounterHTOff": "0,1,2,3",
         "EventCode": "0xB7, 0xBB",
         "EventName": "OFFCORE_RESPONSE.ALL_DATA_RD.LLC_MISS.REMOTE_HIT_FOR=
WARD",
         "MSRIndex": "0x1a6,0x1a7",
         "MSRValue": "0x83FC00091",
-        "Offcore": "1",
         "SampleAfterValue": "100003",
         "UMask": "0x1"
     },
     {
         "BriefDescription": "Counts all data/code/rfo reads (demand & pref=
etch) miss in the L3",
-        "Counter": "0,1,2,3",
-        "CounterHTOff": "0,1,2,3",
         "EventCode": "0xB7, 0xBB",
         "EventName": "OFFCORE_RESPONSE.ALL_READS.LLC_MISS.ANY_RESPONSE",
         "MSRIndex": "0x1a6,0x1a7",
         "MSRValue": "0x3FBFC007F7",
-        "Offcore": "1",
         "SampleAfterValue": "100003",
         "UMask": "0x1"
     },
     {
         "BriefDescription": "Counts all data/code/rfo reads (demand & pref=
etch) miss the L3 and the data is returned from local dram",
-        "Counter": "0,1,2,3",
-        "CounterHTOff": "0,1,2,3",
         "EventCode": "0xB7, 0xBB",
         "EventName": "OFFCORE_RESPONSE.ALL_READS.LLC_MISS.LOCAL_DRAM",
         "MSRIndex": "0x1a6,0x1a7",
         "MSRValue": "0x6004007F7",
-        "Offcore": "1",
         "SampleAfterValue": "100003",
         "UMask": "0x1"
     },
     {
         "BriefDescription": "Counts all data/code/rfo reads (demand & pref=
etch) miss the L3 and the data is returned from remote dram",
-        "Counter": "0,1,2,3",
-        "CounterHTOff": "0,1,2,3",
         "EventCode": "0xB7, 0xBB",
         "EventName": "OFFCORE_RESPONSE.ALL_READS.LLC_MISS.REMOTE_DRAM",
         "MSRIndex": "0x1a6,0x1a7",
         "MSRValue": "0x63F8007F7",
-        "Offcore": "1",
         "SampleAfterValue": "100003",
         "UMask": "0x1"
     },
     {
         "BriefDescription": "Counts all data/code/rfo reads (demand & pref=
etch) miss the L3 and the modified data is transferred from remote cache",
-        "Counter": "0,1,2,3",
-        "CounterHTOff": "0,1,2,3",
         "EventCode": "0xB7, 0xBB",
         "EventName": "OFFCORE_RESPONSE.ALL_READS.LLC_MISS.REMOTE_HITM",
         "MSRIndex": "0x1a6,0x1a7",
         "MSRValue": "0x103FC007F7",
-        "Offcore": "1",
         "SampleAfterValue": "100003",
         "UMask": "0x1"
     },
     {
         "BriefDescription": "Counts all data/code/rfo reads (demand & pref=
etch) miss the L3 and clean or shared data is transferred from remote cache=
",
-        "Counter": "0,1,2,3",
-        "CounterHTOff": "0,1,2,3",
         "EventCode": "0xB7, 0xBB",
         "EventName": "OFFCORE_RESPONSE.ALL_READS.LLC_MISS.REMOTE_HIT_FORWA=
RD",
         "MSRIndex": "0x1a6,0x1a7",
         "MSRValue": "0x83FC007F7",
-        "Offcore": "1",
         "SampleAfterValue": "100003",
         "UMask": "0x1"
     },
     {
         "BriefDescription": "Counts all requests miss in the L3",
-        "Counter": "0,1,2,3",
-        "CounterHTOff": "0,1,2,3",
         "EventCode": "0xB7, 0xBB",
         "EventName": "OFFCORE_RESPONSE.ALL_REQUESTS.LLC_MISS.ANY_RESPONSE"=
,
         "MSRIndex": "0x1a6,0x1a7",
         "MSRValue": "0x3FBFC08FFF",
-        "Offcore": "1",
         "SampleAfterValue": "100003",
         "UMask": "0x1"
     },
     {
         "BriefDescription": "Counts all demand & prefetch RFOs miss in the=
 L3",
-        "Counter": "0,1,2,3",
-        "CounterHTOff": "0,1,2,3",
         "EventCode": "0xB7, 0xBB",
         "EventName": "OFFCORE_RESPONSE.ALL_RFO.LLC_MISS.ANY_RESPONSE",
         "MSRIndex": "0x1a6,0x1a7",
         "MSRValue": "0x3FBFC00122",
-        "Offcore": "1",
         "SampleAfterValue": "100003",
         "UMask": "0x1"
     },
     {
         "BriefDescription": "Counts all demand & prefetch RFOs miss the L3=
 and the data is returned from local dram",
-        "Counter": "0,1,2,3",
-        "CounterHTOff": "0,1,2,3",
         "EventCode": "0xB7, 0xBB",
         "EventName": "OFFCORE_RESPONSE.ALL_RFO.LLC_MISS.LOCAL_DRAM",
         "MSRIndex": "0x1a6,0x1a7",
         "MSRValue": "0x600400122",
-        "Offcore": "1",
         "SampleAfterValue": "100003",
         "UMask": "0x1"
     },
     {
         "BriefDescription": "Counts all demand code reads miss in the L3",
-        "Counter": "0,1,2,3",
-        "CounterHTOff": "0,1,2,3",
         "EventCode": "0xB7, 0xBB",
         "EventName": "OFFCORE_RESPONSE.DEMAND_CODE_RD.LLC_MISS.ANY_RESPONS=
E",
         "MSRIndex": "0x1a6,0x1a7",
         "MSRValue": "0x3FBFC00004",
-        "Offcore": "1",
         "SampleAfterValue": "100003",
         "UMask": "0x1"
     },
     {
         "BriefDescription": "Counts all demand code reads miss the L3 and =
the data is returned from local dram",
-        "Counter": "0,1,2,3",
-        "CounterHTOff": "0,1,2,3",
         "EventCode": "0xB7, 0xBB",
         "EventName": "OFFCORE_RESPONSE.DEMAND_CODE_RD.LLC_MISS.LOCAL_DRAM"=
,
         "MSRIndex": "0x1a6,0x1a7",
         "MSRValue": "0x600400004",
-        "Offcore": "1",
         "SampleAfterValue": "100003",
         "UMask": "0x1"
     },
     {
         "BriefDescription": "Counts demand data reads miss in the L3",
-        "Counter": "0,1,2,3",
-        "CounterHTOff": "0,1,2,3",
         "EventCode": "0xB7, 0xBB",
         "EventName": "OFFCORE_RESPONSE.DEMAND_DATA_RD.LLC_MISS.ANY_RESPONS=
E",
         "MSRIndex": "0x1a6,0x1a7",
         "MSRValue": "0x3FBFC00001",
-        "Offcore": "1",
         "SampleAfterValue": "100003",
         "UMask": "0x1"
     },
     {
         "BriefDescription": "Counts demand data reads miss the L3 and the =
data is returned from local dram",
-        "Counter": "0,1,2,3",
-        "CounterHTOff": "0,1,2,3",
         "EventCode": "0xB7, 0xBB",
         "EventName": "OFFCORE_RESPONSE.DEMAND_DATA_RD.LLC_MISS.LOCAL_DRAM"=
,
         "MSRIndex": "0x1a6,0x1a7",
         "MSRValue": "0x600400001",
-        "Offcore": "1",
         "SampleAfterValue": "100003",
         "UMask": "0x1"
     },
     {
         "BriefDescription": "Counts all demand data writes (RFOs) miss in =
the L3",
-        "Counter": "0,1,2,3",
-        "CounterHTOff": "0,1,2,3",
         "EventCode": "0xB7, 0xBB",
         "EventName": "OFFCORE_RESPONSE.DEMAND_RFO.LLC_MISS.ANY_RESPONSE",
         "MSRIndex": "0x1a6,0x1a7",
         "MSRValue": "0x3FBFC00002",
-        "Offcore": "1",
         "SampleAfterValue": "100003",
         "UMask": "0x1"
     },
     {
         "BriefDescription": "Counts all demand data writes (RFOs) miss the=
 L3 and the data is returned from local dram",
-        "Counter": "0,1,2,3",
-        "CounterHTOff": "0,1,2,3",
         "EventCode": "0xB7, 0xBB",
         "EventName": "OFFCORE_RESPONSE.DEMAND_RFO.LLC_MISS.LOCAL_DRAM",
         "MSRIndex": "0x1a6,0x1a7",
         "MSRValue": "0x600400002",
-        "Offcore": "1",
         "SampleAfterValue": "100003",
         "UMask": "0x1"
     },
     {
         "BriefDescription": "Counts all demand data writes (RFOs) miss the=
 L3 and the modified data is transferred from remote cache",
-        "Counter": "0,1,2,3",
-        "CounterHTOff": "0,1,2,3",
         "EventCode": "0xB7, 0xBB",
         "EventName": "OFFCORE_RESPONSE.DEMAND_RFO.LLC_MISS.REMOTE_HITM",
         "MSRIndex": "0x1a6,0x1a7",
         "MSRValue": "0x103FC00002",
-        "Offcore": "1",
         "SampleAfterValue": "100003",
         "UMask": "0x1"
     },
     {
         "BriefDescription": "Counts all prefetch (that bring data to LLC o=
nly) code reads miss in the L3",
-        "Counter": "0,1,2,3",
-        "CounterHTOff": "0,1,2,3",
         "EventCode": "0xB7, 0xBB",
         "EventName": "OFFCORE_RESPONSE.PF_L2_CODE_RD.LLC_MISS.ANY_RESPONSE=
",
         "MSRIndex": "0x1a6,0x1a7",
         "MSRValue": "0x3FBFC00040",
-        "Offcore": "1",
         "SampleAfterValue": "100003",
         "UMask": "0x1"
     },
     {
         "BriefDescription": "Counts prefetch (that bring data to L2) data =
reads miss in the L3",
-        "Counter": "0,1,2,3",
-        "CounterHTOff": "0,1,2,3",
         "EventCode": "0xB7, 0xBB",
         "EventName": "OFFCORE_RESPONSE.PF_L2_DATA_RD.LLC_MISS.ANY_RESPONSE=
",
         "MSRIndex": "0x1a6,0x1a7",
         "MSRValue": "0x3FBFC00010",
-        "Offcore": "1",
         "SampleAfterValue": "100003",
         "UMask": "0x1"
     },
     {
         "BriefDescription": "Counts all prefetch (that bring data to L2) R=
FOs miss in the L3",
-        "Counter": "0,1,2,3",
-        "CounterHTOff": "0,1,2,3",
         "EventCode": "0xB7, 0xBB",
         "EventName": "OFFCORE_RESPONSE.PF_L2_RFO.LLC_MISS.ANY_RESPONSE",
         "MSRIndex": "0x1a6,0x1a7",
         "MSRValue": "0x3FBFC00020",
-        "Offcore": "1",
         "SampleAfterValue": "100003",
         "UMask": "0x1"
     },
     {
         "BriefDescription": "Counts prefetch (that bring data to LLC only)=
 code reads miss in the L3",
-        "Counter": "0,1,2,3",
-        "CounterHTOff": "0,1,2,3",
         "EventCode": "0xB7, 0xBB",
         "EventName": "OFFCORE_RESPONSE.PF_LLC_CODE_RD.LLC_MISS.ANY_RESPONS=
E",
         "MSRIndex": "0x1a6,0x1a7",
         "MSRValue": "0x3FBFC00200",
-        "Offcore": "1",
         "SampleAfterValue": "100003",
         "UMask": "0x1"
     },
     {
         "BriefDescription": "Counts all prefetch (that bring data to LLC o=
nly) data reads miss in the L3",
-        "Counter": "0,1,2,3",
-        "CounterHTOff": "0,1,2,3",
         "EventCode": "0xB7, 0xBB",
         "EventName": "OFFCORE_RESPONSE.PF_LLC_DATA_RD.LLC_MISS.ANY_RESPONS=
E",
         "MSRIndex": "0x1a6,0x1a7",
         "MSRValue": "0x3FBFC00080",
-        "Offcore": "1",
         "SampleAfterValue": "100003",
         "UMask": "0x1"
     },
     {
         "BriefDescription": "Counts all prefetch (that bring data to LLC o=
nly) RFOs miss in the L3",
-        "Counter": "0,1,2,3",
-        "CounterHTOff": "0,1,2,3",
         "EventCode": "0xB7, 0xBB",
         "EventName": "OFFCORE_RESPONSE.PF_LLC_RFO.LLC_MISS.ANY_RESPONSE",
         "MSRIndex": "0x1a6,0x1a7",
         "MSRValue": "0x3FBFC00100",
-        "Offcore": "1",
         "SampleAfterValue": "100003",
         "UMask": "0x1"
     },
     {
         "BriefDescription": "Number of times an RTM execution aborted due =
to any reasons (multiple categories may count as one).",
-        "Counter": "0,1,2,3",
-        "CounterHTOff": "0,1,2,3",
         "EventCode": "0xc9",
         "EventName": "RTM_RETIRED.ABORTED",
         "PEBS": "1",
@@ -572,8 +440,6 @@
     },
     {
         "BriefDescription": "Number of times an RTM execution aborted due =
to various memory events (e.g. read/write capacity and conflicts)",
-        "Counter": "0,1,2,3",
-        "CounterHTOff": "0,1,2,3",
         "EventCode": "0xc9",
         "EventName": "RTM_RETIRED.ABORTED_MISC1",
         "PublicDescription": "Number of times an RTM execution aborted due=
 to various memory events (e.g. read/write capacity and conflicts).",
@@ -582,8 +448,6 @@
     },
     {
         "BriefDescription": "Number of times an RTM execution aborted due =
to various memory events (e.g., read/write capacity and conflicts).",
-        "Counter": "0,1,2,3",
-        "CounterHTOff": "0,1,2,3",
         "EventCode": "0xc9",
         "EventName": "RTM_RETIRED.ABORTED_MISC2",
         "SampleAfterValue": "2000003",
@@ -591,8 +455,6 @@
     },
     {
         "BriefDescription": "Number of times an RTM execution aborted due =
to HLE-unfriendly instructions.",
-        "Counter": "0,1,2,3",
-        "CounterHTOff": "0,1,2,3",
         "EventCode": "0xc9",
         "EventName": "RTM_RETIRED.ABORTED_MISC3",
         "SampleAfterValue": "2000003",
@@ -600,8 +462,6 @@
     },
     {
         "BriefDescription": "Number of times an RTM execution aborted due =
to incompatible memory type.",
-        "Counter": "0,1,2,3",
-        "CounterHTOff": "0,1,2,3",
         "Errata": "HSD65",
         "EventCode": "0xc9",
         "EventName": "RTM_RETIRED.ABORTED_MISC4",
@@ -610,8 +470,6 @@
     },
     {
         "BriefDescription": "Number of times an RTM execution aborted due =
to none of the previous 4 categories (e.g. interrupt)",
-        "Counter": "0,1,2,3",
-        "CounterHTOff": "0,1,2,3",
         "EventCode": "0xc9",
         "EventName": "RTM_RETIRED.ABORTED_MISC5",
         "PublicDescription": "Number of times an RTM execution aborted due=
 to none of the previous 4 categories (e.g. interrupt).",
@@ -620,8 +478,6 @@
     },
     {
         "BriefDescription": "Number of times an RTM execution successfully=
 committed.",
-        "Counter": "0,1,2,3",
-        "CounterHTOff": "0,1,2,3",
         "EventCode": "0xc9",
         "EventName": "RTM_RETIRED.COMMIT",
         "SampleAfterValue": "2000003",
@@ -629,8 +485,6 @@
     },
     {
         "BriefDescription": "Number of times an RTM execution started.",
-        "Counter": "0,1,2,3",
-        "CounterHTOff": "0,1,2,3",
         "EventCode": "0xC9",
         "EventName": "RTM_RETIRED.START",
         "SampleAfterValue": "2000003",
@@ -638,8 +492,6 @@
     },
     {
         "BriefDescription": "Counts the number of times a class of instruc=
tions that may cause a transactional abort was executed. Since this is the =
count of execution, it may not always cause a transactional abort.",
-        "Counter": "0,1,2,3",
-        "CounterHTOff": "0,1,2,3,4,5,6,7",
         "EventCode": "0x5d",
         "EventName": "TX_EXEC.MISC1",
         "SampleAfterValue": "2000003",
@@ -647,8 +499,6 @@
     },
     {
         "BriefDescription": "Counts the number of times a class of instruc=
tions (e.g., vzeroupper) that may cause a transactional abort was executed =
inside a transactional region.",
-        "Counter": "0,1,2,3",
-        "CounterHTOff": "0,1,2,3,4,5,6,7",
         "EventCode": "0x5d",
         "EventName": "TX_EXEC.MISC2",
         "SampleAfterValue": "2000003",
@@ -656,8 +506,6 @@
     },
     {
         "BriefDescription": "Counts the number of times an instruction exe=
cution caused the transactional nest count supported to be exceeded.",
-        "Counter": "0,1,2,3",
-        "CounterHTOff": "0,1,2,3,4,5,6,7",
         "EventCode": "0x5d",
         "EventName": "TX_EXEC.MISC3",
         "SampleAfterValue": "2000003",
@@ -665,8 +513,6 @@
     },
     {
         "BriefDescription": "Counts the number of times a XBEGIN instructi=
on was executed inside an HLE transactional region.",
-        "Counter": "0,1,2,3",
-        "CounterHTOff": "0,1,2,3,4,5,6,7",
         "EventCode": "0x5d",
         "EventName": "TX_EXEC.MISC4",
         "SampleAfterValue": "2000003",
@@ -674,8 +520,6 @@
     },
     {
         "BriefDescription": "Counts the number of times an HLE XACQUIRE in=
struction was executed inside an RTM transactional region.",
-        "Counter": "0,1,2,3",
-        "CounterHTOff": "0,1,2,3,4,5,6,7",
         "EventCode": "0x5d",
         "EventName": "TX_EXEC.MISC5",
         "SampleAfterValue": "2000003",
@@ -683,8 +527,6 @@
     },
     {
         "BriefDescription": "Number of times a transactional abort was sig=
naled due to a data capacity limitation for transactional writes.",
-        "Counter": "0,1,2,3",
-        "CounterHTOff": "0,1,2,3,4,5,6,7",
         "EventCode": "0x54",
         "EventName": "TX_MEM.ABORT_CAPACITY_WRITE",
         "SampleAfterValue": "2000003",
@@ -692,8 +534,6 @@
     },
     {
         "BriefDescription": "Number of times a transactional abort was sig=
naled due to a data conflict on a transactionally accessed address.",
-        "Counter": "0,1,2,3",
-        "CounterHTOff": "0,1,2,3,4,5,6,7",
         "EventCode": "0x54",
         "EventName": "TX_MEM.ABORT_CONFLICT",
         "SampleAfterValue": "2000003",
@@ -701,8 +541,6 @@
     },
     {
         "BriefDescription": "Number of times an HLE transactional executio=
n aborted due to XRELEASE lock not satisfying the address and value require=
ments in the elision buffer.",
-        "Counter": "0,1,2,3",
-        "CounterHTOff": "0,1,2,3,4,5,6,7",
         "EventCode": "0x54",
         "EventName": "TX_MEM.ABORT_HLE_ELISION_BUFFER_MISMATCH",
         "SampleAfterValue": "2000003",
@@ -710,8 +548,6 @@
     },
     {
         "BriefDescription": "Number of times an HLE transactional executio=
n aborted due to NoAllocatedElisionBuffer being non-zero.",
-        "Counter": "0,1,2,3",
-        "CounterHTOff": "0,1,2,3,4,5,6,7",
         "EventCode": "0x54",
         "EventName": "TX_MEM.ABORT_HLE_ELISION_BUFFER_NOT_EMPTY",
         "SampleAfterValue": "2000003",
@@ -719,8 +555,6 @@
     },
     {
         "BriefDescription": "Number of times an HLE transactional executio=
n aborted due to an unsupported read alignment from the elision buffer.",
-        "Counter": "0,1,2,3",
-        "CounterHTOff": "0,1,2,3,4,5,6,7",
         "EventCode": "0x54",
         "EventName": "TX_MEM.ABORT_HLE_ELISION_BUFFER_UNSUPPORTED_ALIGNMEN=
T",
         "SampleAfterValue": "2000003",
@@ -728,8 +562,6 @@
     },
     {
         "BriefDescription": "Number of times a HLE transactional region ab=
orted due to a non XRELEASE prefixed instruction writing to an elided lock =
in the elision buffer.",
-        "Counter": "0,1,2,3",
-        "CounterHTOff": "0,1,2,3,4,5,6,7",
         "EventCode": "0x54",
         "EventName": "TX_MEM.ABORT_HLE_STORE_TO_ELIDED_LOCK",
         "SampleAfterValue": "2000003",
@@ -737,8 +569,6 @@
     },
     {
         "BriefDescription": "Number of times HLE lock could not be elided =
due to ElisionBufferAvailable being zero.",
-        "Counter": "0,1,2,3",
-        "CounterHTOff": "0,1,2,3,4,5,6,7",
         "EventCode": "0x54",
         "EventName": "TX_MEM.HLE_ELISION_BUFFER_FULL",
         "SampleAfterValue": "2000003",
diff --git a/tools/perf/pmu-events/arch/x86/haswellx/other.json b/tools/per=
f/pmu-events/arch/x86/haswellx/other.json
index 7ca34f09b185..2395ebf112db 100644
--- a/tools/perf/pmu-events/arch/x86/haswellx/other.json
+++ b/tools/perf/pmu-events/arch/x86/haswellx/other.json
@@ -1,8 +1,6 @@
 [
     {
         "BriefDescription": "Unhalted core cycles when the thread is in ri=
ng 0",
-        "Counter": "0,1,2,3",
-        "CounterHTOff": "0,1,2,3,4,5,6,7",
         "EventCode": "0x5C",
         "EventName": "CPL_CYCLES.RING0",
         "PublicDescription": "Unhalted core cycles when the thread is in r=
ing 0.",
@@ -11,8 +9,6 @@
     },
     {
         "BriefDescription": "Number of intervals between processor halts w=
hile thread is in ring 0.",
-        "Counter": "0,1,2,3",
-        "CounterHTOff": "0,1,2,3,4,5,6,7",
         "CounterMask": "1",
         "EdgeDetect": "1",
         "EventCode": "0x5C",
@@ -22,8 +18,6 @@
     },
     {
         "BriefDescription": "Unhalted core cycles when thread is in rings =
1, 2, or 3",
-        "Counter": "0,1,2,3",
-        "CounterHTOff": "0,1,2,3,4,5,6,7",
         "EventCode": "0x5C",
         "EventName": "CPL_CYCLES.RING123",
         "PublicDescription": "Unhalted core cycles when the thread is not =
in ring 0.",
@@ -32,8 +26,6 @@
     },
     {
         "BriefDescription": "Cycles when L1 and L2 are locked due to UC or=
 split lock",
-        "Counter": "0,1,2,3",
-        "CounterHTOff": "0,1,2,3,4,5,6,7",
         "EventCode": "0x63",
         "EventName": "LOCK_CYCLES.SPLIT_LOCK_UC_LOCK_DURATION",
         "PublicDescription": "Cycles in which the L1D and L2 are locked, d=
ue to a UC lock or split lock.",
diff --git a/tools/perf/pmu-events/arch/x86/haswellx/pipeline.json b/tools/=
perf/pmu-events/arch/x86/haswellx/pipeline.json
index 42f6a8100661..9ac36c1c24b6 100644
--- a/tools/perf/pmu-events/arch/x86/haswellx/pipeline.json
+++ b/tools/perf/pmu-events/arch/x86/haswellx/pipeline.json
@@ -1,8 +1,6 @@
 [
     {
         "BriefDescription": "Any uop executed by the Divider. (This includ=
es all divide uops, sqrt, ...)",
-        "Counter": "0,1,2,3",
-        "CounterHTOff": "0,1,2,3,4,5,6,7",
         "EventCode": "0x14",
         "EventName": "ARITH.DIVIDER_UOPS",
         "SampleAfterValue": "2000003",
@@ -10,8 +8,6 @@
     },
     {
         "BriefDescription": "Speculative and retired  branches",
-        "Counter": "0,1,2,3",
-        "CounterHTOff": "0,1,2,3,4,5,6,7",
         "EventCode": "0x88",
         "EventName": "BR_INST_EXEC.ALL_BRANCHES",
         "PublicDescription": "Counts all near executed branches (not neces=
sarily retired).",
@@ -20,8 +16,6 @@
     },
     {
         "BriefDescription": "Speculative and retired macro-conditional bra=
nches.",
-        "Counter": "0,1,2,3",
-        "CounterHTOff": "0,1,2,3,4,5,6,7",
         "EventCode": "0x88",
         "EventName": "BR_INST_EXEC.ALL_CONDITIONAL",
         "SampleAfterValue": "200003",
@@ -29,8 +23,6 @@
     },
     {
         "BriefDescription": "Speculative and retired macro-unconditional b=
ranches excluding calls and indirects.",
-        "Counter": "0,1,2,3",
-        "CounterHTOff": "0,1,2,3,4,5,6,7",
         "EventCode": "0x88",
         "EventName": "BR_INST_EXEC.ALL_DIRECT_JMP",
         "SampleAfterValue": "200003",
@@ -38,8 +30,6 @@
     },
     {
         "BriefDescription": "Speculative and retired direct near calls.",
-        "Counter": "0,1,2,3",
-        "CounterHTOff": "0,1,2,3,4,5,6,7",
         "EventCode": "0x88",
         "EventName": "BR_INST_EXEC.ALL_DIRECT_NEAR_CALL",
         "SampleAfterValue": "200003",
@@ -47,8 +37,6 @@
     },
     {
         "BriefDescription": "Speculative and retired indirect branches exc=
luding calls and returns.",
-        "Counter": "0,1,2,3",
-        "CounterHTOff": "0,1,2,3,4,5,6,7",
         "EventCode": "0x88",
         "EventName": "BR_INST_EXEC.ALL_INDIRECT_JUMP_NON_CALL_RET",
         "SampleAfterValue": "200003",
@@ -56,8 +44,6 @@
     },
     {
         "BriefDescription": "Speculative and retired indirect return branc=
hes.",
-        "Counter": "0,1,2,3",
-        "CounterHTOff": "0,1,2,3,4,5,6,7",
         "EventCode": "0x88",
         "EventName": "BR_INST_EXEC.ALL_INDIRECT_NEAR_RETURN",
         "SampleAfterValue": "200003",
@@ -65,8 +51,6 @@
     },
     {
         "BriefDescription": "Not taken macro-conditional branches.",
-        "Counter": "0,1,2,3",
-        "CounterHTOff": "0,1,2,3,4,5,6,7",
         "EventCode": "0x88",
         "EventName": "BR_INST_EXEC.NONTAKEN_CONDITIONAL",
         "SampleAfterValue": "200003",
@@ -74,8 +58,6 @@
     },
     {
         "BriefDescription": "Taken speculative and retired macro-condition=
al branches.",
-        "Counter": "0,1,2,3",
-        "CounterHTOff": "0,1,2,3,4,5,6,7",
         "EventCode": "0x88",
         "EventName": "BR_INST_EXEC.TAKEN_CONDITIONAL",
         "SampleAfterValue": "200003",
@@ -83,8 +65,6 @@
     },
     {
         "BriefDescription": "Taken speculative and retired macro-condition=
al branch instructions excluding calls and indirects.",
-        "Counter": "0,1,2,3",
-        "CounterHTOff": "0,1,2,3,4,5,6,7",
         "EventCode": "0x88",
         "EventName": "BR_INST_EXEC.TAKEN_DIRECT_JUMP",
         "SampleAfterValue": "200003",
@@ -92,8 +72,6 @@
     },
     {
         "BriefDescription": "Taken speculative and retired direct near cal=
ls.",
-        "Counter": "0,1,2,3",
-        "CounterHTOff": "0,1,2,3,4,5,6,7",
         "EventCode": "0x88",
         "EventName": "BR_INST_EXEC.TAKEN_DIRECT_NEAR_CALL",
         "SampleAfterValue": "200003",
@@ -101,8 +79,6 @@
     },
     {
         "BriefDescription": "Taken speculative and retired indirect branch=
es excluding calls and returns.",
-        "Counter": "0,1,2,3",
-        "CounterHTOff": "0,1,2,3,4,5,6,7",
         "EventCode": "0x88",
         "EventName": "BR_INST_EXEC.TAKEN_INDIRECT_JUMP_NON_CALL_RET",
         "SampleAfterValue": "200003",
@@ -110,8 +86,6 @@
     },
     {
         "BriefDescription": "Taken speculative and retired indirect calls.=
",
-        "Counter": "0,1,2,3",
-        "CounterHTOff": "0,1,2,3,4,5,6,7",
         "EventCode": "0x88",
         "EventName": "BR_INST_EXEC.TAKEN_INDIRECT_NEAR_CALL",
         "SampleAfterValue": "200003",
@@ -119,8 +93,6 @@
     },
     {
         "BriefDescription": "Taken speculative and retired indirect branch=
es with return mnemonic.",
-        "Counter": "0,1,2,3",
-        "CounterHTOff": "0,1,2,3,4,5,6,7",
         "EventCode": "0x88",
         "EventName": "BR_INST_EXEC.TAKEN_INDIRECT_NEAR_RETURN",
         "SampleAfterValue": "200003",
@@ -128,8 +100,6 @@
     },
     {
         "BriefDescription": "All (macro) branch instructions retired.",
-        "Counter": "0,1,2,3",
-        "CounterHTOff": "0,1,2,3,4,5,6,7",
         "EventCode": "0xC4",
         "EventName": "BR_INST_RETIRED.ALL_BRANCHES",
         "PublicDescription": "Branch instructions at retirement.",
@@ -137,8 +107,6 @@
     },
     {
         "BriefDescription": "All (macro) branch instructions retired.",
-        "Counter": "0,1,2,3",
-        "CounterHTOff": "0,1,2,3",
         "EventCode": "0xC4",
         "EventName": "BR_INST_RETIRED.ALL_BRANCHES_PEBS",
         "PEBS": "2",
@@ -147,8 +115,6 @@
     },
     {
         "BriefDescription": "Conditional branch instructions retired.",
-        "Counter": "0,1,2,3",
-        "CounterHTOff": "0,1,2,3,4,5,6,7",
         "EventCode": "0xC4",
         "EventName": "BR_INST_RETIRED.CONDITIONAL",
         "PEBS": "1",
@@ -158,8 +124,6 @@
     },
     {
         "BriefDescription": "Far branch instructions retired.",
-        "Counter": "0,1,2,3",
-        "CounterHTOff": "0,1,2,3,4,5,6,7",
         "EventCode": "0xC4",
         "EventName": "BR_INST_RETIRED.FAR_BRANCH",
         "PublicDescription": "Number of far branches retired.",
@@ -168,8 +132,6 @@
     },
     {
         "BriefDescription": "Direct and indirect near call instructions re=
tired.",
-        "Counter": "0,1,2,3",
-        "CounterHTOff": "0,1,2,3,4,5,6,7",
         "EventCode": "0xC4",
         "EventName": "BR_INST_RETIRED.NEAR_CALL",
         "PEBS": "1",
@@ -178,8 +140,6 @@
     },
     {
         "BriefDescription": "Direct and indirect macro near call instructi=
ons retired (captured in ring 3).",
-        "Counter": "0,1,2,3",
-        "CounterHTOff": "0,1,2,3,4,5,6,7",
         "EventCode": "0xC4",
         "EventName": "BR_INST_RETIRED.NEAR_CALL_R3",
         "PEBS": "1",
@@ -188,8 +148,6 @@
     },
     {
         "BriefDescription": "Return instructions retired.",
-        "Counter": "0,1,2,3",
-        "CounterHTOff": "0,1,2,3,4,5,6,7",
         "EventCode": "0xC4",
         "EventName": "BR_INST_RETIRED.NEAR_RETURN",
         "PEBS": "1",
@@ -199,8 +157,6 @@
     },
     {
         "BriefDescription": "Taken branch instructions retired.",
-        "Counter": "0,1,2,3",
-        "CounterHTOff": "0,1,2,3,4,5,6,7",
         "EventCode": "0xC4",
         "EventName": "BR_INST_RETIRED.NEAR_TAKEN",
         "PEBS": "1",
@@ -210,8 +166,6 @@
     },
     {
         "BriefDescription": "Not taken branch instructions retired.",
-        "Counter": "0,1,2,3",
-        "CounterHTOff": "0,1,2,3,4,5,6,7",
         "EventCode": "0xC4",
         "EventName": "BR_INST_RETIRED.NOT_TAKEN",
         "PublicDescription": "Counts the number of not taken branch instru=
ctions retired.",
@@ -220,8 +174,6 @@
     },
     {
         "BriefDescription": "Speculative and retired mispredicted macro co=
nditional branches",
-        "Counter": "0,1,2,3",
-        "CounterHTOff": "0,1,2,3,4,5,6,7",
         "EventCode": "0x89",
         "EventName": "BR_MISP_EXEC.ALL_BRANCHES",
         "PublicDescription": "Counts all near executed branches (not neces=
sarily retired).",
@@ -230,8 +182,6 @@
     },
     {
         "BriefDescription": "Speculative and retired mispredicted macro co=
nditional branches.",
-        "Counter": "0,1,2,3",
-        "CounterHTOff": "0,1,2,3,4,5,6,7",
         "EventCode": "0x89",
         "EventName": "BR_MISP_EXEC.ALL_CONDITIONAL",
         "SampleAfterValue": "200003",
@@ -239,8 +189,6 @@
     },
     {
         "BriefDescription": "Mispredicted indirect branches excluding call=
s and returns.",
-        "Counter": "0,1,2,3",
-        "CounterHTOff": "0,1,2,3,4,5,6,7",
         "EventCode": "0x89",
         "EventName": "BR_MISP_EXEC.ALL_INDIRECT_JUMP_NON_CALL_RET",
         "SampleAfterValue": "200003",
@@ -248,8 +196,6 @@
     },
     {
         "BriefDescription": "Not taken speculative and retired mispredicte=
d macro conditional branches.",
-        "Counter": "0,1,2,3",
-        "CounterHTOff": "0,1,2,3,4,5,6,7",
         "EventCode": "0x89",
         "EventName": "BR_MISP_EXEC.NONTAKEN_CONDITIONAL",
         "SampleAfterValue": "200003",
@@ -257,8 +203,6 @@
     },
     {
         "BriefDescription": "Taken speculative and retired mispredicted ma=
cro conditional branches.",
-        "Counter": "0,1,2,3",
-        "CounterHTOff": "0,1,2,3,4,5,6,7",
         "EventCode": "0x89",
         "EventName": "BR_MISP_EXEC.TAKEN_CONDITIONAL",
         "SampleAfterValue": "200003",
@@ -266,8 +210,6 @@
     },
     {
         "BriefDescription": "Taken speculative and retired mispredicted in=
direct branches excluding calls and returns.",
-        "Counter": "0,1,2,3",
-        "CounterHTOff": "0,1,2,3,4,5,6,7",
         "EventCode": "0x89",
         "EventName": "BR_MISP_EXEC.TAKEN_INDIRECT_JUMP_NON_CALL_RET",
         "SampleAfterValue": "200003",
@@ -275,8 +217,6 @@
     },
     {
         "BriefDescription": "Taken speculative and retired mispredicted in=
direct calls.",
-        "Counter": "0,1,2,3",
-        "CounterHTOff": "0,1,2,3,4,5,6,7",
         "EventCode": "0x89",
         "EventName": "BR_MISP_EXEC.TAKEN_INDIRECT_NEAR_CALL",
         "SampleAfterValue": "200003",
@@ -284,8 +224,6 @@
     },
     {
         "BriefDescription": "Taken speculative and retired mispredicted in=
direct branches with return mnemonic.",
-        "Counter": "0,1,2,3",
-        "CounterHTOff": "0,1,2,3,4,5,6,7",
         "EventCode": "0x89",
         "EventName": "BR_MISP_EXEC.TAKEN_RETURN_NEAR",
         "SampleAfterValue": "200003",
@@ -293,8 +231,6 @@
     },
     {
         "BriefDescription": "All mispredicted macro branch instructions re=
tired.",
-        "Counter": "0,1,2,3",
-        "CounterHTOff": "0,1,2,3,4,5,6,7",
         "EventCode": "0xC5",
         "EventName": "BR_MISP_RETIRED.ALL_BRANCHES",
         "PublicDescription": "Mispredicted branch instructions at retireme=
nt.",
@@ -302,8 +238,6 @@
     },
     {
         "BriefDescription": "Mispredicted macro branch instructions retire=
d.",
-        "Counter": "0,1,2,3",
-        "CounterHTOff": "0,1,2,3",
         "EventCode": "0xC5",
         "EventName": "BR_MISP_RETIRED.ALL_BRANCHES_PEBS",
         "PEBS": "2",
@@ -313,8 +247,6 @@
     },
     {
         "BriefDescription": "Mispredicted conditional branch instructions =
retired.",
-        "Counter": "0,1,2,3",
-        "CounterHTOff": "0,1,2,3,4,5,6,7",
         "EventCode": "0xC5",
         "EventName": "BR_MISP_RETIRED.CONDITIONAL",
         "PEBS": "1",
@@ -323,8 +255,6 @@
     },
     {
         "BriefDescription": "number of near branch instructions retired th=
at were mispredicted and taken.",
-        "Counter": "0,1,2,3",
-        "CounterHTOff": "0,1,2,3,4,5,6,7",
         "EventCode": "0xC5",
         "EventName": "BR_MISP_RETIRED.NEAR_TAKEN",
         "PEBS": "1",
@@ -334,8 +264,6 @@
     },
     {
         "BriefDescription": "Count XClk pulses when this thread is unhalte=
d and the other thread is halted.",
-        "Counter": "0,1,2,3",
-        "CounterHTOff": "0,1,2,3",
         "EventCode": "0x3c",
         "EventName": "CPU_CLK_THREAD_UNHALTED.ONE_THREAD_ACTIVE",
         "SampleAfterValue": "100003",
@@ -343,8 +271,6 @@
     },
     {
         "BriefDescription": "Reference cycles when the thread is unhalted =
(counts at 100 MHz rate)",
-        "Counter": "0,1,2,3",
-        "CounterHTOff": "0,1,2,3,4,5,6,7",
         "EventCode": "0x3C",
         "EventName": "CPU_CLK_THREAD_UNHALTED.REF_XCLK",
         "PublicDescription": "Increments at the frequency of XCLK (100 MHz=
) when not halted.",
@@ -354,8 +280,6 @@
     {
         "AnyThread": "1",
         "BriefDescription": "Reference cycles when the at least one thread=
 on the physical core is unhalted (counts at 100 MHz rate)",
-        "Counter": "0,1,2,3",
-        "CounterHTOff": "0,1,2,3,4,5,6,7",
         "EventCode": "0x3C",
         "EventName": "CPU_CLK_THREAD_UNHALTED.REF_XCLK_ANY",
         "PublicDescription": "Reference cycles when the at least one threa=
d on the physical core is unhalted (counts at 100 MHz rate).",
@@ -364,8 +288,6 @@
     },
     {
         "BriefDescription": "Count XClk pulses when this thread is unhalte=
d and the other thread is halted.",
-        "Counter": "0,1,2,3",
-        "CounterHTOff": "0,1,2,3,4,5,6,7",
         "EventCode": "0x3C",
         "EventName": "CPU_CLK_UNHALTED.ONE_THREAD_ACTIVE",
         "SampleAfterValue": "100003",
@@ -373,8 +295,6 @@
     },
     {
         "BriefDescription": "Reference cycles when the core is not in halt=
 state.",
-        "Counter": "Fixed counter 2",
-        "CounterHTOff": "Fixed counter 2",
         "EventName": "CPU_CLK_UNHALTED.REF_TSC",
         "PublicDescription": "This event counts the number of reference cy=
cles when the core is not in a halt state. The core enters the halt state w=
hen it is running the HLT instruction or the MWAIT instruction. This event =
is not affected by core frequency changes (for example, P states, TM2 trans=
itions) but has the same incrementing frequency as the time stamp counter. =
This event can approximate elapsed time while the core was not in a halt st=
ate.",
         "SampleAfterValue": "2000003",
@@ -382,8 +302,6 @@
     },
     {
         "BriefDescription": "Reference cycles when the thread is unhalted =
(counts at 100 MHz rate)",
-        "Counter": "0,1,2,3",
-        "CounterHTOff": "0,1,2,3,4,5,6,7",
         "EventCode": "0x3C",
         "EventName": "CPU_CLK_UNHALTED.REF_XCLK",
         "PublicDescription": "Reference cycles when the thread is unhalted=
. (counts at 100 MHz rate)",
@@ -393,8 +311,6 @@
     {
         "AnyThread": "1",
         "BriefDescription": "Reference cycles when the at least one thread=
 on the physical core is unhalted (counts at 100 MHz rate)",
-        "Counter": "0,1,2,3",
-        "CounterHTOff": "0,1,2,3,4,5,6,7",
         "EventCode": "0x3C",
         "EventName": "CPU_CLK_UNHALTED.REF_XCLK_ANY",
         "PublicDescription": "Reference cycles when the at least one threa=
d on the physical core is unhalted (counts at 100 MHz rate).",
@@ -403,8 +319,6 @@
     },
     {
         "BriefDescription": "Core cycles when the thread is not in halt st=
ate.",
-        "Counter": "Fixed counter 1",
-        "CounterHTOff": "Fixed counter 1",
         "EventName": "CPU_CLK_UNHALTED.THREAD",
         "PublicDescription": "This event counts the number of thread cycle=
s while the thread is not in a halt state. The thread enters the halt state=
 when it is running the HLT instruction. The core frequency may change from=
 time to time due to power or thermal throttling.",
         "SampleAfterValue": "2000003",
@@ -413,16 +327,12 @@
     {
         "AnyThread": "1",
         "BriefDescription": "Core cycles when at least one thread on the p=
hysical core is not in halt state.",
-        "Counter": "Fixed counter 1",
-        "CounterHTOff": "Fixed counter 1",
         "EventName": "CPU_CLK_UNHALTED.THREAD_ANY",
         "SampleAfterValue": "2000003",
         "UMask": "0x2"
     },
     {
         "BriefDescription": "Thread cycles when thread is not in halt stat=
e",
-        "Counter": "0,1,2,3",
-        "CounterHTOff": "0,1,2,3,4,5,6,7",
         "EventCode": "0x3C",
         "EventName": "CPU_CLK_UNHALTED.THREAD_P",
         "PublicDescription": "Counts the number of thread cycles while the=
 thread is not in a halt state. The thread enters the halt state when it is=
 running the HLT instruction. The core frequency may change from time to ti=
me due to power or thermal throttling.",
@@ -431,16 +341,12 @@
     {
         "AnyThread": "1",
         "BriefDescription": "Core cycles when at least one thread on the p=
hysical core is not in halt state.",
-        "Counter": "0,1,2,3",
-        "CounterHTOff": "0,1,2,3,4,5,6,7",
         "EventCode": "0x3C",
         "EventName": "CPU_CLK_UNHALTED.THREAD_P_ANY",
         "SampleAfterValue": "2000003"
     },
     {
         "BriefDescription": "Cycles with pending L1 cache miss loads.",
-        "Counter": "2",
-        "CounterHTOff": "2",
         "CounterMask": "8",
         "EventCode": "0xA3",
         "EventName": "CYCLE_ACTIVITY.CYCLES_L1D_PENDING",
@@ -450,8 +356,6 @@
     },
     {
         "BriefDescription": "Cycles with pending L2 cache miss loads.",
-        "Counter": "0,1,2,3",
-        "CounterHTOff": "0,1,2,3,4,5,6,7",
         "CounterMask": "1",
         "Errata": "HSD78, HSM63, HSM80",
         "EventCode": "0xa3",
@@ -462,8 +366,6 @@
     },
     {
         "BriefDescription": "Cycles with pending memory loads.",
-        "Counter": "0,1,2,3",
-        "CounterHTOff": "0,1,2,3",
         "CounterMask": "2",
         "EventCode": "0xA3",
         "EventName": "CYCLE_ACTIVITY.CYCLES_LDM_PENDING",
@@ -473,8 +375,6 @@
     },
     {
         "BriefDescription": "This event increments by 1 for every cycle wh=
ere there was no execute for this thread.",
-        "Counter": "0,1,2,3",
-        "CounterHTOff": "0,1,2,3",
         "CounterMask": "4",
         "EventCode": "0xA3",
         "EventName": "CYCLE_ACTIVITY.CYCLES_NO_EXECUTE",
@@ -484,8 +384,6 @@
     },
     {
         "BriefDescription": "Execution stalls due to L1 data cache misses"=
,
-        "Counter": "2",
-        "CounterHTOff": "2",
         "CounterMask": "12",
         "EventCode": "0xA3",
         "EventName": "CYCLE_ACTIVITY.STALLS_L1D_PENDING",
@@ -495,8 +393,6 @@
     },
     {
         "BriefDescription": "Execution stalls due to L2 cache misses.",
-        "Counter": "0,1,2,3",
-        "CounterHTOff": "0,1,2,3",
         "CounterMask": "5",
         "Errata": "HSM63, HSM80",
         "EventCode": "0xa3",
@@ -507,8 +403,6 @@
     },
     {
         "BriefDescription": "Execution stalls due to memory subsystem.",
-        "Counter": "0,1,2,3",
-        "CounterHTOff": "0,1,2,3",
         "CounterMask": "6",
         "EventCode": "0xA3",
         "EventName": "CYCLE_ACTIVITY.STALLS_LDM_PENDING",
@@ -518,8 +412,6 @@
     },
     {
         "BriefDescription": "Stall cycles because IQ is full",
-        "Counter": "0,1,2,3",
-        "CounterHTOff": "0,1,2,3,4,5,6,7",
         "EventCode": "0x87",
         "EventName": "ILD_STALL.IQ_FULL",
         "PublicDescription": "Stall cycles due to IQ is full.",
@@ -528,8 +420,6 @@
     },
     {
         "BriefDescription": "Stalls caused by changing prefix length of th=
e instruction.",
-        "Counter": "0,1,2,3",
-        "CounterHTOff": "0,1,2,3,4,5,6,7",
         "EventCode": "0x87",
         "EventName": "ILD_STALL.LCP",
         "PublicDescription": "This event counts cycles where the decoder i=
s stalled on an instruction with a length changing prefix (LCP).",
@@ -538,8 +428,6 @@
     },
     {
         "BriefDescription": "Instructions retired from execution.",
-        "Counter": "Fixed counter 0",
-        "CounterHTOff": "Fixed counter 0",
         "Errata": "HSD140, HSD143",
         "EventName": "INST_RETIRED.ANY",
         "PublicDescription": "This event counts the number of instructions=
 retired from execution. For instructions that consist of multiple micro-op=
s, this event counts the retirement of the last micro-op of the instruction=
. Counting continues during hardware interrupts, traps, and inside interrup=
t handlers. INST_RETIRED.ANY is counted by a designated fixed counter, leav=
ing the programmable counters available for other events. Faulting executio=
ns of GETSEC/VM entry/VM Exit/MWait will not count as retired instructions.=
",
@@ -548,8 +436,6 @@
     },
     {
         "BriefDescription": "Number of instructions retired. General Count=
er   - architectural event",
-        "Counter": "0,1,2,3",
-        "CounterHTOff": "0,1,2,3,4,5,6,7",
         "Errata": "HSD11, HSD140",
         "EventCode": "0xC0",
         "EventName": "INST_RETIRED.ANY_P",
@@ -558,8 +444,6 @@
     },
     {
         "BriefDescription": "Precise instruction retired event with HW to =
reduce effect of PEBS shadow in IP distribution",
-        "Counter": "1",
-        "CounterHTOff": "1",
         "Errata": "HSD140",
         "EventCode": "0xC0",
         "EventName": "INST_RETIRED.PREC_DIST",
@@ -570,8 +454,6 @@
     },
     {
         "BriefDescription": "FP operations retired. X87 FP operations that=
 have no exceptions: Counts also flows that have several X87 or flows that =
use X87 uops in the exception handling.",
-        "Counter": "0,1,2,3",
-        "CounterHTOff": "0,1,2,3,4,5,6,7",
         "EventCode": "0xC0",
         "EventName": "INST_RETIRED.X87",
         "PublicDescription": "This is a non-precise version (that is, does=
 not use PEBS) of the event that counts FP operations retired. For X87 FP o=
perations that have no exceptions counting also includes flows that have se=
veral X87, or flows that use X87 uops in the exception handling.",
@@ -580,8 +462,6 @@
     },
     {
         "BriefDescription": "Core cycles the allocator was stalled due to =
recovery from earlier clear event for this thread (e.g. misprediction or me=
mory nuke)",
-        "Counter": "0,1,2,3",
-        "CounterHTOff": "0,1,2,3,4,5,6,7",
         "CounterMask": "1",
         "EventCode": "0x0D",
         "EventName": "INT_MISC.RECOVERY_CYCLES",
@@ -592,8 +472,6 @@
     {
         "AnyThread": "1",
         "BriefDescription": "Core cycles the allocator was stalled due to =
recovery from earlier clear event for any thread running on the physical co=
re (e.g. misprediction or memory nuke)",
-        "Counter": "0,1,2,3",
-        "CounterHTOff": "0,1,2,3,4,5,6,7",
         "CounterMask": "1",
         "EventCode": "0x0D",
         "EventName": "INT_MISC.RECOVERY_CYCLES_ANY",
@@ -603,8 +481,6 @@
     },
     {
         "BriefDescription": "The number of times that split load operation=
s are temporarily blocked because all resources for handling the split acce=
sses are in use",
-        "Counter": "0,1,2,3",
-        "CounterHTOff": "0,1,2,3,4,5,6,7",
         "EventCode": "0x03",
         "EventName": "LD_BLOCKS.NO_SR",
         "PublicDescription": "The number of times that split load operatio=
ns are temporarily blocked because all resources for handling the split acc=
esses are in use.",
@@ -613,8 +489,6 @@
     },
     {
         "BriefDescription": "loads blocked by overlapping with store buffe=
r that cannot be forwarded",
-        "Counter": "0,1,2,3",
-        "CounterHTOff": "0,1,2,3,4,5,6,7",
         "EventCode": "0x03",
         "EventName": "LD_BLOCKS.STORE_FORWARD",
         "PublicDescription": "This event counts loads that followed a stor=
e to the same address, where the data could not be forwarded inside the pip=
eline from the store to the load.  The most common reason why store forward=
ing would be blocked is when a load's address range overlaps with a precedi=
ng smaller uncompleted store. The penalty for blocked store forwarding is t=
hat the load must wait for the store to write its value to the cache before=
 it can be issued.",
@@ -623,8 +497,6 @@
     },
     {
         "BriefDescription": "False dependencies in MOB due to partial comp=
are on address.",
-        "Counter": "0,1,2,3",
-        "CounterHTOff": "0,1,2,3,4,5,6,7",
         "EventCode": "0x07",
         "EventName": "LD_BLOCKS_PARTIAL.ADDRESS_ALIAS",
         "PublicDescription": "Aliasing occurs when a load is issued after =
a store and their memory addresses are offset by 4K.  This event counts the=
 number of loads that aliased with a preceding store, resulting in an exten=
ded address check in the pipeline which can have a performance impact.",
@@ -633,8 +505,6 @@
     },
     {
         "BriefDescription": "Not software-prefetch load dispatches that hi=
t FB allocated for hardware prefetch",
-        "Counter": "0,1,2,3",
-        "CounterHTOff": "0,1,2,3,4,5,6,7",
         "EventCode": "0x4c",
         "EventName": "LOAD_HIT_PRE.HW_PF",
         "PublicDescription": "Non-SW-prefetch load dispatches that hit fil=
l buffer allocated for H/W prefetch.",
@@ -643,8 +513,6 @@
     },
     {
         "BriefDescription": "Not software-prefetch load dispatches that hi=
t FB allocated for software prefetch",
-        "Counter": "0,1,2,3",
-        "CounterHTOff": "0,1,2,3,4,5,6,7",
         "EventCode": "0x4c",
         "EventName": "LOAD_HIT_PRE.SW_PF",
         "PublicDescription": "Non-SW-prefetch load dispatches that hit fil=
l buffer allocated for S/W prefetch.",
@@ -653,8 +521,6 @@
     },
     {
         "BriefDescription": "Cycles 4 Uops delivered by the LSD, but didn'=
t come from the decoder.",
-        "Counter": "0,1,2,3",
-        "CounterHTOff": "0,1,2,3,4,5,6,7",
         "CounterMask": "4",
         "EventCode": "0xA8",
         "EventName": "LSD.CYCLES_4_UOPS",
@@ -663,8 +529,6 @@
     },
     {
         "BriefDescription": "Cycles Uops delivered by the LSD, but didn't =
come from the decoder.",
-        "Counter": "0,1,2,3",
-        "CounterHTOff": "0,1,2,3,4,5,6,7",
         "CounterMask": "1",
         "EventCode": "0xA8",
         "EventName": "LSD.CYCLES_ACTIVE",
@@ -673,8 +537,6 @@
     },
     {
         "BriefDescription": "Number of Uops delivered by the LSD.",
-        "Counter": "0,1,2,3",
-        "CounterHTOff": "0,1,2,3,4,5,6,7",
         "EventCode": "0xa8",
         "EventName": "LSD.UOPS",
         "PublicDescription": "Number of uops delivered by the LSD.",
@@ -683,8 +545,6 @@
     },
     {
         "BriefDescription": "Number of machine clears (nukes) of any type.=
",
-        "Counter": "0,1,2,3",
-        "CounterHTOff": "0,1,2,3,4,5,6,7",
         "CounterMask": "1",
         "EdgeDetect": "1",
         "EventCode": "0xC3",
@@ -694,8 +554,6 @@
     },
     {
         "BriefDescription": "Cycles there was a Nuke. Account for both thr=
ead-specific and All Thread Nukes.",
-        "Counter": "0,1,2,3",
-        "CounterHTOff": "0,1,2,3,4,5,6,7",
         "EventCode": "0xC3",
         "EventName": "MACHINE_CLEARS.CYCLES",
         "SampleAfterValue": "2000003",
@@ -703,8 +561,6 @@
     },
     {
         "BriefDescription": "This event counts the number of executed Inte=
l AVX masked load operations that refer to an illegal address range with th=
e mask bits set to 0.",
-        "Counter": "0,1,2,3",
-        "CounterHTOff": "0,1,2,3,4,5,6,7",
         "EventCode": "0xC3",
         "EventName": "MACHINE_CLEARS.MASKMOV",
         "SampleAfterValue": "100003",
@@ -712,8 +568,6 @@
     },
     {
         "BriefDescription": "Self-modifying code (SMC) detected.",
-        "Counter": "0,1,2,3",
-        "CounterHTOff": "0,1,2,3,4,5,6,7",
         "EventCode": "0xC3",
         "EventName": "MACHINE_CLEARS.SMC",
         "PublicDescription": "This event is incremented when self-modifyin=
g code (SMC) is detected, which causes a machine clear.  Machine clears can=
 have a significant performance impact if they are happening frequently.",
@@ -722,8 +576,6 @@
     },
     {
         "BriefDescription": "Number of integer Move Elimination candidate =
uops that were eliminated.",
-        "Counter": "0,1,2,3",
-        "CounterHTOff": "0,1,2,3,4,5,6,7",
         "EventCode": "0x58",
         "EventName": "MOVE_ELIMINATION.INT_ELIMINATED",
         "PublicDescription": "Number of integer move elimination candidate=
 uops that were eliminated.",
@@ -732,8 +584,6 @@
     },
     {
         "BriefDescription": "Number of integer Move Elimination candidate =
uops that were not eliminated.",
-        "Counter": "0,1,2,3",
-        "CounterHTOff": "0,1,2,3,4,5,6,7",
         "EventCode": "0x58",
         "EventName": "MOVE_ELIMINATION.INT_NOT_ELIMINATED",
         "PublicDescription": "Number of integer move elimination candidate=
 uops that were not eliminated.",
@@ -742,8 +592,6 @@
     },
     {
         "BriefDescription": "Number of times any microcode assist is invok=
ed by HW upon uop writeback.",
-        "Counter": "0,1,2,3",
-        "CounterHTOff": "0,1,2,3,4,5,6,7",
         "EventCode": "0xC1",
         "EventName": "OTHER_ASSISTS.ANY_WB_ASSIST",
         "PublicDescription": "Number of microcode assists invoked by HW up=
on uop writeback.",
@@ -752,8 +600,6 @@
     },
     {
         "BriefDescription": "Resource-related stall cycles",
-        "Counter": "0,1,2,3",
-        "CounterHTOff": "0,1,2,3,4,5,6,7",
         "Errata": "HSD135",
         "EventCode": "0xA2",
         "EventName": "RESOURCE_STALLS.ANY",
@@ -763,8 +609,6 @@
     },
     {
         "BriefDescription": "Cycles stalled due to re-order buffer full.",
-        "Counter": "0,1,2,3",
-        "CounterHTOff": "0,1,2,3,4,5,6,7",
         "EventCode": "0xA2",
         "EventName": "RESOURCE_STALLS.ROB",
         "SampleAfterValue": "2000003",
@@ -772,8 +616,6 @@
     },
     {
         "BriefDescription": "Cycles stalled due to no eligible RS entry av=
ailable.",
-        "Counter": "0,1,2,3",
-        "CounterHTOff": "0,1,2,3,4,5,6,7",
         "EventCode": "0xA2",
         "EventName": "RESOURCE_STALLS.RS",
         "SampleAfterValue": "2000003",
@@ -781,8 +623,6 @@
     },
     {
         "BriefDescription": "Cycles stalled due to no store buffers availa=
ble. (not including draining form sync).",
-        "Counter": "0,1,2,3",
-        "CounterHTOff": "0,1,2,3,4,5,6,7",
         "EventCode": "0xA2",
         "EventName": "RESOURCE_STALLS.SB",
         "PublicDescription": "This event counts cycles during which no ins=
tructions were allocated because no Store Buffers (SB) were available.",
@@ -791,8 +631,6 @@
     },
     {
         "BriefDescription": "Count cases of saving new LBR",
-        "Counter": "0,1,2,3",
-        "CounterHTOff": "0,1,2,3,4,5,6,7",
         "EventCode": "0xCC",
         "EventName": "ROB_MISC_EVENTS.LBR_INSERTS",
         "PublicDescription": "Count cases of saving new LBR records by har=
dware.",
@@ -801,8 +639,6 @@
     },
     {
         "BriefDescription": "Cycles when Reservation Station (RS) is empty=
 for the thread",
-        "Counter": "0,1,2,3",
-        "CounterHTOff": "0,1,2,3,4,5,6,7",
         "EventCode": "0x5E",
         "EventName": "RS_EVENTS.EMPTY_CYCLES",
         "PublicDescription": "This event counts cycles when the Reservatio=
n Station ( RS ) is empty for the thread. The RS is a structure that buffer=
s allocated micro-ops from the Front-end. If there are many cycles when the=
 RS is empty, it may represent an underflow of instructions delivered from =
the Front-end.",
@@ -811,8 +647,6 @@
     },
     {
         "BriefDescription": "Counts end of periods where the Reservation S=
tation (RS) was empty. Could be useful to precisely locate Frontend Latency=
 Bound issues.",
-        "Counter": "0,1,2,3",
-        "CounterHTOff": "0,1,2,3,4,5,6,7",
         "CounterMask": "1",
         "EdgeDetect": "1",
         "EventCode": "0x5E",
@@ -823,8 +657,6 @@
     },
     {
         "BriefDescription": "Cycles per thread when uops are executed in p=
ort 0.",
-        "Counter": "0,1,2,3",
-        "CounterHTOff": "0,1,2,3,4,5,6,7",
         "EventCode": "0xA1",
         "EventName": "UOPS_DISPATCHED_PORT.PORT_0",
         "SampleAfterValue": "2000003",
@@ -832,8 +664,6 @@
     },
     {
         "BriefDescription": "Cycles per thread when uops are executed in p=
ort 1.",
-        "Counter": "0,1,2,3",
-        "CounterHTOff": "0,1,2,3,4,5,6,7",
         "EventCode": "0xA1",
         "EventName": "UOPS_DISPATCHED_PORT.PORT_1",
         "SampleAfterValue": "2000003",
@@ -841,8 +671,6 @@
     },
     {
         "BriefDescription": "Cycles per thread when uops are executed in p=
ort 2.",
-        "Counter": "0,1,2,3",
-        "CounterHTOff": "0,1,2,3,4,5,6,7",
         "EventCode": "0xA1",
         "EventName": "UOPS_DISPATCHED_PORT.PORT_2",
         "SampleAfterValue": "2000003",
@@ -850,8 +678,6 @@
     },
     {
         "BriefDescription": "Cycles per thread when uops are executed in p=
ort 3.",
-        "Counter": "0,1,2,3",
-        "CounterHTOff": "0,1,2,3,4,5,6,7",
         "EventCode": "0xA1",
         "EventName": "UOPS_DISPATCHED_PORT.PORT_3",
         "SampleAfterValue": "2000003",
@@ -859,8 +685,6 @@
     },
     {
         "BriefDescription": "Cycles per thread when uops are executed in p=
ort 4.",
-        "Counter": "0,1,2,3",
-        "CounterHTOff": "0,1,2,3,4,5,6,7",
         "EventCode": "0xA1",
         "EventName": "UOPS_DISPATCHED_PORT.PORT_4",
         "SampleAfterValue": "2000003",
@@ -868,8 +692,6 @@
     },
     {
         "BriefDescription": "Cycles per thread when uops are executed in p=
ort 5.",
-        "Counter": "0,1,2,3",
-        "CounterHTOff": "0,1,2,3,4,5,6,7",
         "EventCode": "0xA1",
         "EventName": "UOPS_DISPATCHED_PORT.PORT_5",
         "SampleAfterValue": "2000003",
@@ -877,8 +699,6 @@
     },
     {
         "BriefDescription": "Cycles per thread when uops are executed in p=
ort 6.",
-        "Counter": "0,1,2,3",
-        "CounterHTOff": "0,1,2,3,4,5,6,7",
         "EventCode": "0xA1",
         "EventName": "UOPS_DISPATCHED_PORT.PORT_6",
         "SampleAfterValue": "2000003",
@@ -886,8 +706,6 @@
     },
     {
         "BriefDescription": "Cycles per thread when uops are executed in p=
ort 7.",
-        "Counter": "0,1,2,3",
-        "CounterHTOff": "0,1,2,3,4,5,6,7",
         "EventCode": "0xA1",
         "EventName": "UOPS_DISPATCHED_PORT.PORT_7",
         "SampleAfterValue": "2000003",
@@ -895,8 +713,6 @@
     },
     {
         "BriefDescription": "Number of uops executed on the core.",
-        "Counter": "0,1,2,3",
-        "CounterHTOff": "0,1,2,3,4,5,6,7",
         "Errata": "HSD30, HSM31",
         "EventCode": "0xB1",
         "EventName": "UOPS_EXECUTED.CORE",
@@ -906,8 +722,6 @@
     },
     {
         "BriefDescription": "Cycles at least 1 micro-op is executed from a=
ny thread on physical core.",
-        "Counter": "0,1,2,3",
-        "CounterHTOff": "0,1,2,3,4,5,6,7",
         "CounterMask": "1",
         "Errata": "HSD30, HSM31",
         "EventCode": "0xb1",
@@ -917,8 +731,6 @@
     },
     {
         "BriefDescription": "Cycles at least 2 micro-op is executed from a=
ny thread on physical core.",
-        "Counter": "0,1,2,3",
-        "CounterHTOff": "0,1,2,3,4,5,6,7",
         "CounterMask": "2",
         "Errata": "HSD30, HSM31",
         "EventCode": "0xb1",
@@ -928,8 +740,6 @@
     },
     {
         "BriefDescription": "Cycles at least 3 micro-op is executed from a=
ny thread on physical core.",
-        "Counter": "0,1,2,3",
-        "CounterHTOff": "0,1,2,3,4,5,6,7",
         "CounterMask": "3",
         "Errata": "HSD30, HSM31",
         "EventCode": "0xb1",
@@ -939,8 +749,6 @@
     },
     {
         "BriefDescription": "Cycles at least 4 micro-op is executed from a=
ny thread on physical core.",
-        "Counter": "0,1,2,3",
-        "CounterHTOff": "0,1,2,3,4,5,6,7",
         "CounterMask": "4",
         "Errata": "HSD30, HSM31",
         "EventCode": "0xb1",
@@ -950,8 +758,6 @@
     },
     {
         "BriefDescription": "Cycles with no micro-ops executed from any th=
read on physical core.",
-        "Counter": "0,1,2,3",
-        "CounterHTOff": "0,1,2,3,4,5,6,7",
         "Errata": "HSD30, HSM31",
         "EventCode": "0xb1",
         "EventName": "UOPS_EXECUTED.CORE_CYCLES_NONE",
@@ -961,8 +767,6 @@
     },
     {
         "BriefDescription": "Cycles where at least 1 uop was executed per-=
thread",
-        "Counter": "0,1,2,3",
-        "CounterHTOff": "0,1,2,3",
         "CounterMask": "1",
         "Errata": "HSD144, HSD30, HSM31",
         "EventCode": "0xB1",
@@ -973,8 +777,6 @@
     },
     {
         "BriefDescription": "Cycles where at least 2 uops were executed pe=
r-thread",
-        "Counter": "0,1,2,3",
-        "CounterHTOff": "0,1,2,3",
         "CounterMask": "2",
         "Errata": "HSD144, HSD30, HSM31",
         "EventCode": "0xB1",
@@ -985,8 +787,6 @@
     },
     {
         "BriefDescription": "Cycles where at least 3 uops were executed pe=
r-thread",
-        "Counter": "0,1,2,3",
-        "CounterHTOff": "0,1,2,3",
         "CounterMask": "3",
         "Errata": "HSD144, HSD30, HSM31",
         "EventCode": "0xB1",
@@ -997,8 +797,6 @@
     },
     {
         "BriefDescription": "Cycles where at least 4 uops were executed pe=
r-thread.",
-        "Counter": "0,1,2,3",
-        "CounterHTOff": "0,1,2,3",
         "CounterMask": "4",
         "Errata": "HSD144, HSD30, HSM31",
         "EventCode": "0xB1",
@@ -1008,8 +806,6 @@
     },
     {
         "BriefDescription": "Counts number of cycles no uops were dispatch=
ed to be executed on this thread.",
-        "Counter": "0,1,2,3",
-        "CounterHTOff": "0,1,2,3",
         "CounterMask": "1",
         "Errata": "HSD144, HSD30, HSM31",
         "EventCode": "0xB1",
@@ -1020,8 +816,6 @@
     },
     {
         "BriefDescription": "Cycles per thread when uops are executed in p=
ort 0",
-        "Counter": "0,1,2,3",
-        "CounterHTOff": "0,1,2,3,4,5,6,7",
         "EventCode": "0xA1",
         "EventName": "UOPS_EXECUTED_PORT.PORT_0",
         "PublicDescription": "Cycles which a uop is dispatched on port 0 i=
n this thread.",
@@ -1031,8 +825,6 @@
     {
         "AnyThread": "1",
         "BriefDescription": "Cycles per core when uops are executed in por=
t 0.",
-        "Counter": "0,1,2,3",
-        "CounterHTOff": "0,1,2,3,4,5,6,7",
         "EventCode": "0xA1",
         "EventName": "UOPS_EXECUTED_PORT.PORT_0_CORE",
         "SampleAfterValue": "2000003",
@@ -1040,8 +832,6 @@
     },
     {
         "BriefDescription": "Cycles per thread when uops are executed in p=
ort 1",
-        "Counter": "0,1,2,3",
-        "CounterHTOff": "0,1,2,3,4,5,6,7",
         "EventCode": "0xA1",
         "EventName": "UOPS_EXECUTED_PORT.PORT_1",
         "PublicDescription": "Cycles which a uop is dispatched on port 1 i=
n this thread.",
@@ -1051,8 +841,6 @@
     {
         "AnyThread": "1",
         "BriefDescription": "Cycles per core when uops are executed in por=
t 1.",
-        "Counter": "0,1,2,3",
-        "CounterHTOff": "0,1,2,3,4,5,6,7",
         "EventCode": "0xA1",
         "EventName": "UOPS_EXECUTED_PORT.PORT_1_CORE",
         "SampleAfterValue": "2000003",
@@ -1060,8 +848,6 @@
     },
     {
         "BriefDescription": "Cycles per thread when uops are executed in p=
ort 2",
-        "Counter": "0,1,2,3",
-        "CounterHTOff": "0,1,2,3,4,5,6,7",
         "EventCode": "0xA1",
         "EventName": "UOPS_EXECUTED_PORT.PORT_2",
         "PublicDescription": "Cycles which a uop is dispatched on port 2 i=
n this thread.",
@@ -1071,8 +857,6 @@
     {
         "AnyThread": "1",
         "BriefDescription": "Cycles per core when uops are dispatched to p=
ort 2.",
-        "Counter": "0,1,2,3",
-        "CounterHTOff": "0,1,2,3,4,5,6,7",
         "EventCode": "0xA1",
         "EventName": "UOPS_EXECUTED_PORT.PORT_2_CORE",
         "SampleAfterValue": "2000003",
@@ -1080,8 +864,6 @@
     },
     {
         "BriefDescription": "Cycles per thread when uops are executed in p=
ort 3",
-        "Counter": "0,1,2,3",
-        "CounterHTOff": "0,1,2,3,4,5,6,7",
         "EventCode": "0xA1",
         "EventName": "UOPS_EXECUTED_PORT.PORT_3",
         "PublicDescription": "Cycles which a uop is dispatched on port 3 i=
n this thread.",
@@ -1091,8 +873,6 @@
     {
         "AnyThread": "1",
         "BriefDescription": "Cycles per core when uops are dispatched to p=
ort 3.",
-        "Counter": "0,1,2,3",
-        "CounterHTOff": "0,1,2,3,4,5,6,7",
         "EventCode": "0xA1",
         "EventName": "UOPS_EXECUTED_PORT.PORT_3_CORE",
         "SampleAfterValue": "2000003",
@@ -1100,8 +880,6 @@
     },
     {
         "BriefDescription": "Cycles per thread when uops are executed in p=
ort 4",
-        "Counter": "0,1,2,3",
-        "CounterHTOff": "0,1,2,3,4,5,6,7",
         "EventCode": "0xA1",
         "EventName": "UOPS_EXECUTED_PORT.PORT_4",
         "PublicDescription": "Cycles which a uop is dispatched on port 4 i=
n this thread.",
@@ -1111,8 +889,6 @@
     {
         "AnyThread": "1",
         "BriefDescription": "Cycles per core when uops are executed in por=
t 4.",
-        "Counter": "0,1,2,3",
-        "CounterHTOff": "0,1,2,3,4,5,6,7",
         "EventCode": "0xA1",
         "EventName": "UOPS_EXECUTED_PORT.PORT_4_CORE",
         "SampleAfterValue": "2000003",
@@ -1120,8 +896,6 @@
     },
     {
         "BriefDescription": "Cycles per thread when uops are executed in p=
ort 5",
-        "Counter": "0,1,2,3",
-        "CounterHTOff": "0,1,2,3,4,5,6,7",
         "EventCode": "0xA1",
         "EventName": "UOPS_EXECUTED_PORT.PORT_5",
         "PublicDescription": "Cycles which a uop is dispatched on port 5 i=
n this thread.",
@@ -1131,8 +905,6 @@
     {
         "AnyThread": "1",
         "BriefDescription": "Cycles per core when uops are executed in por=
t 5.",
-        "Counter": "0,1,2,3",
-        "CounterHTOff": "0,1,2,3,4,5,6,7",
         "EventCode": "0xA1",
         "EventName": "UOPS_EXECUTED_PORT.PORT_5_CORE",
         "SampleAfterValue": "2000003",
@@ -1140,8 +912,6 @@
     },
     {
         "BriefDescription": "Cycles per thread when uops are executed in p=
ort 6",
-        "Counter": "0,1,2,3",
-        "CounterHTOff": "0,1,2,3,4,5,6,7",
         "EventCode": "0xA1",
         "EventName": "UOPS_EXECUTED_PORT.PORT_6",
         "PublicDescription": "Cycles which a uop is dispatched on port 6 i=
n this thread.",
@@ -1151,8 +921,6 @@
     {
         "AnyThread": "1",
         "BriefDescription": "Cycles per core when uops are executed in por=
t 6.",
-        "Counter": "0,1,2,3",
-        "CounterHTOff": "0,1,2,3,4,5,6,7",
         "EventCode": "0xA1",
         "EventName": "UOPS_EXECUTED_PORT.PORT_6_CORE",
         "SampleAfterValue": "2000003",
@@ -1160,8 +928,6 @@
     },
     {
         "BriefDescription": "Cycles per thread when uops are executed in p=
ort 7",
-        "Counter": "0,1,2,3",
-        "CounterHTOff": "0,1,2,3,4,5,6,7",
         "EventCode": "0xA1",
         "EventName": "UOPS_EXECUTED_PORT.PORT_7",
         "PublicDescription": "Cycles which a uop is dispatched on port 7 i=
n this thread.",
@@ -1171,8 +937,6 @@
     {
         "AnyThread": "1",
         "BriefDescription": "Cycles per core when uops are dispatched to p=
ort 7.",
-        "Counter": "0,1,2,3",
-        "CounterHTOff": "0,1,2,3,4,5,6,7",
         "EventCode": "0xA1",
         "EventName": "UOPS_EXECUTED_PORT.PORT_7_CORE",
         "SampleAfterValue": "2000003",
@@ -1180,8 +944,6 @@
     },
     {
         "BriefDescription": "Uops that Resource Allocation Table (RAT) iss=
ues to Reservation Station (RS)",
-        "Counter": "0,1,2,3",
-        "CounterHTOff": "0,1,2,3,4,5,6,7",
         "EventCode": "0x0E",
         "EventName": "UOPS_ISSUED.ANY",
         "PublicDescription": "This event counts the number of uops issued =
by the Front-end of the pipeline to the Back-end. This event is counted at =
the allocation stage and will count both retired and non-retired uops.",
@@ -1191,8 +953,6 @@
     {
         "AnyThread": "1",
         "BriefDescription": "Cycles when Resource Allocation Table (RAT) d=
oes not issue Uops to Reservation Station (RS) for all threads.",
-        "Counter": "0,1,2,3",
-        "CounterHTOff": "0,1,2,3",
         "CounterMask": "1",
         "EventCode": "0x0E",
         "EventName": "UOPS_ISSUED.CORE_STALL_CYCLES",
@@ -1202,8 +962,6 @@
     },
     {
         "BriefDescription": "Number of flags-merge uops being allocated. S=
uch uops considered perf sensitive; added by GSR u-arch.",
-        "Counter": "0,1,2,3",
-        "CounterHTOff": "0,1,2,3,4,5,6,7",
         "EventCode": "0x0E",
         "EventName": "UOPS_ISSUED.FLAGS_MERGE",
         "PublicDescription": "Number of flags-merge uops allocated. Such u=
ops add delay.",
@@ -1212,8 +970,6 @@
     },
     {
         "BriefDescription": "Number of Multiply packed/scalar single preci=
sion uops allocated",
-        "Counter": "0,1,2,3",
-        "CounterHTOff": "0,1,2,3,4,5,6,7",
         "EventCode": "0x0E",
         "EventName": "UOPS_ISSUED.SINGLE_MUL",
         "PublicDescription": "Number of multiply packed/scalar single prec=
ision uops allocated.",
@@ -1222,8 +978,6 @@
     },
     {
         "BriefDescription": "Number of slow LEA uops being allocated. A uo=
p is generally considered SlowLea if it has 3 sources (e.g. 2 sources + imm=
ediate) regardless if as a result of LEA instruction or not.",
-        "Counter": "0,1,2,3",
-        "CounterHTOff": "0,1,2,3,4,5,6,7",
         "EventCode": "0x0E",
         "EventName": "UOPS_ISSUED.SLOW_LEA",
         "PublicDescription": "Number of slow LEA or similar uops allocated=
. Such uop has 3 sources (for example, 2 sources + immediate) regardless of=
 whether it is a result of LEA instruction or not.",
@@ -1232,8 +986,6 @@
     },
     {
         "BriefDescription": "Cycles when Resource Allocation Table (RAT) d=
oes not issue Uops to Reservation Station (RS) for the thread.",
-        "Counter": "0,1,2,3",
-        "CounterHTOff": "0,1,2,3",
         "CounterMask": "1",
         "EventCode": "0x0E",
         "EventName": "UOPS_ISSUED.STALL_CYCLES",
@@ -1243,8 +995,6 @@
     },
     {
         "BriefDescription": "Actually retired uops.",
-        "Counter": "0,1,2,3",
-        "CounterHTOff": "0,1,2,3,4,5,6,7",
         "EventCode": "0xC2",
         "EventName": "UOPS_RETIRED.ALL",
         "PEBS": "1",
@@ -1255,8 +1005,6 @@
     {
         "AnyThread": "1",
         "BriefDescription": "Cycles without actually retired uops.",
-        "Counter": "0,1,2,3",
-        "CounterHTOff": "0,1,2,3",
         "CounterMask": "1",
         "EventCode": "0xC2",
         "EventName": "UOPS_RETIRED.CORE_STALL_CYCLES",
@@ -1266,8 +1014,6 @@
     },
     {
         "BriefDescription": "Retirement slots used.",
-        "Counter": "0,1,2,3",
-        "CounterHTOff": "0,1,2,3,4,5,6,7",
         "EventCode": "0xC2",
         "EventName": "UOPS_RETIRED.RETIRE_SLOTS",
         "PEBS": "1",
@@ -1277,8 +1023,6 @@
     },
     {
         "BriefDescription": "Cycles without actually retired uops.",
-        "Counter": "0,1,2,3",
-        "CounterHTOff": "0,1,2,3",
         "CounterMask": "1",
         "EventCode": "0xC2",
         "EventName": "UOPS_RETIRED.STALL_CYCLES",
@@ -1288,8 +1032,6 @@
     },
     {
         "BriefDescription": "Cycles with less than 10 actually retired uop=
s.",
-        "Counter": "0,1,2,3",
-        "CounterHTOff": "0,1,2,3",
         "CounterMask": "16",
         "EventCode": "0xC2",
         "EventName": "UOPS_RETIRED.TOTAL_CYCLES",
diff --git a/tools/perf/pmu-events/arch/x86/haswellx/uncore-cache.json b/to=
ols/perf/pmu-events/arch/x86/haswellx/uncore-cache.json
index 56047f9c6f20..183bcac99642 100644
--- a/tools/perf/pmu-events/arch/x86/haswellx/uncore-cache.json
+++ b/tools/perf/pmu-events/arch/x86/haswellx/uncore-cache.json
@@ -1,446 +1,627 @@
 [
     {
-        "BriefDescription": "Bounce Control",
-        "Counter": "0,1,2,3",
-        "EventCode": "0xA",
-        "EventName": "UNC_C_BOUNCE_CONTROL",
+        "BriefDescription": "LLC prefetch misses for code reads. Derived f=
rom unc_c_tor_inserts.miss_opcode",
+        "EventCode": "0x35",
+        "EventName": "LLC_MISSES.CODE_LLC_PREFETCH",
+        "Filter": "filter_opc=3D0x191",
         "PerPkg": "1",
+        "PublicDescription": "Counts the number of entries successfully in=
serted into the TOR that match  qualifications specified by the subevent.  =
There are a number of subevent 'filters' but only a subset of the subevent =
combinations are valid.  Subevents that require an opcode or NID match requ=
ire the Cn_MSR_PMON_BOX_FILTER.{opc, nid} field to be set.  If, for example=
, one wanted to count DRD Local Misses, one should select MISS_OPC_MATCH an=
d set Cn_MSR_PMON_BOX_FILTER.opc  to DRD (0x182).; Miss transactions insert=
ed into the TOR that match an opcode.",
+        "ScaleUnit": "64Bytes",
+        "UMask": "0x3",
         "Unit": "CBO"
     },
     {
-        "BriefDescription": "Uncore Clocks",
-        "Counter": "0,1,2,3",
-        "EventName": "UNC_C_CLOCKTICKS",
+        "BriefDescription": "LLC prefetch misses for data reads. Derived f=
rom unc_c_tor_inserts.miss_opcode",
+        "EventCode": "0x35",
+        "EventName": "LLC_MISSES.DATA_LLC_PREFETCH",
+        "Filter": "filter_opc=3D0x192",
         "PerPkg": "1",
+        "PublicDescription": "Counts the number of entries successfully in=
serted into the TOR that match  qualifications specified by the subevent.  =
There are a number of subevent 'filters' but only a subset of the subevent =
combinations are valid.  Subevents that require an opcode or NID match requ=
ire the Cn_MSR_PMON_BOX_FILTER.{opc, nid} field to be set.  If, for example=
, one wanted to count DRD Local Misses, one should select MISS_OPC_MATCH an=
d set Cn_MSR_PMON_BOX_FILTER.opc  to DRD (0x182).; Miss transactions insert=
ed into the TOR that match an opcode.",
+        "ScaleUnit": "64Bytes",
+        "UMask": "0x3",
         "Unit": "CBO"
     },
     {
-        "BriefDescription": "Counter 0 Occupancy",
-        "Counter": "0,1,2,3",
-        "EventCode": "0x1F",
-        "EventName": "UNC_C_COUNTER0_OCCUPANCY",
+        "BriefDescription": "LLC misses - demand and prefetch data reads -=
 excludes LLC prefetches. Derived from unc_c_tor_inserts.miss_opcode",
+        "EventCode": "0x35",
+        "EventName": "LLC_MISSES.DATA_READ",
+        "Filter": "filter_opc=3D0x182",
         "PerPkg": "1",
+        "PublicDescription": "Counts the number of entries successfully in=
serted into the TOR that match  qualifications specified by the subevent.  =
There are a number of subevent 'filters' but only a subset of the subevent =
combinations are valid.  Subevents that require an opcode or NID match requ=
ire the Cn_MSR_PMON_BOX_FILTER.{opc, nid} field to be set.  If, for example=
, one wanted to count DRD Local Misses, one should select MISS_OPC_MATCH an=
d set Cn_MSR_PMON_BOX_FILTER.opc  to DRD (0x182).; Miss transactions insert=
ed into the TOR that match an opcode.",
+        "ScaleUnit": "64Bytes",
+        "UMask": "0x3",
         "Unit": "CBO"
     },
     {
-        "BriefDescription": "FaST wire asserted",
-        "Counter": "0,1",
-        "EventCode": "0x9",
-        "EventName": "UNC_C_FAST_ASSERTED",
+        "BriefDescription": "MMIO reads. Derived from unc_c_tor_inserts.mi=
ss_opcode",
+        "EventCode": "0x35",
+        "EventName": "LLC_MISSES.MMIO_READ",
+        "Filter": "filter_opc=3D0x187,filter_nc=3D1",
         "PerPkg": "1",
+        "PublicDescription": "Counts the number of entries successfully in=
serted into the TOR that match  qualifications specified by the subevent.  =
There are a number of subevent 'filters' but only a subset of the subevent =
combinations are valid.  Subevents that require an opcode or NID match requ=
ire the Cn_MSR_PMON_BOX_FILTER.{opc, nid} field to be set.  If, for example=
, one wanted to count DRD Local Misses, one should select MISS_OPC_MATCH an=
d set Cn_MSR_PMON_BOX_FILTER.opc  to DRD (0x182).; Miss transactions insert=
ed into the TOR that match an opcode.",
+        "ScaleUnit": "64Bytes",
+        "UMask": "0x3",
         "Unit": "CBO"
     },
     {
-        "BriefDescription": "Cache Lookups; Data Read Request",
-        "Counter": "0,1,2,3",
-        "EventCode": "0x34",
-        "EventName": "UNC_C_LLC_LOOKUP.DATA_READ",
+        "BriefDescription": "MMIO writes. Derived from unc_c_tor_inserts.m=
iss_opcode",
+        "EventCode": "0x35",
+        "EventName": "LLC_MISSES.MMIO_WRITE",
+        "Filter": "filter_opc=3D0x18f,filter_nc=3D1",
         "PerPkg": "1",
+        "PublicDescription": "Counts the number of entries successfully in=
serted into the TOR that match  qualifications specified by the subevent.  =
There are a number of subevent 'filters' but only a subset of the subevent =
combinations are valid.  Subevents that require an opcode or NID match requ=
ire the Cn_MSR_PMON_BOX_FILTER.{opc, nid} field to be set.  If, for example=
, one wanted to count DRD Local Misses, one should select MISS_OPC_MATCH an=
d set Cn_MSR_PMON_BOX_FILTER.opc  to DRD (0x182).; Miss transactions insert=
ed into the TOR that match an opcode.",
+        "ScaleUnit": "64Bytes",
         "UMask": "0x3",
         "Unit": "CBO"
     },
     {
-        "BriefDescription": "Cache Lookups; Write Requests",
-        "Counter": "0,1,2,3",
-        "EventCode": "0x34",
-        "EventName": "UNC_C_LLC_LOOKUP.WRITE",
+        "BriefDescription": "PCIe write misses (full cache line). Derived =
from unc_c_tor_inserts.miss_opcode",
+        "EventCode": "0x35",
+        "EventName": "LLC_MISSES.PCIE_NON_SNOOP_WRITE",
+        "Filter": "filter_opc=3D0x1c8,filter_tid=3D0x3e",
         "PerPkg": "1",
-        "UMask": "0x5",
+        "PublicDescription": "Counts the number of entries successfully in=
serted into the TOR that match  qualifications specified by the subevent.  =
There are a number of subevent 'filters' but only a subset of the subevent =
combinations are valid.  Subevents that require an opcode or NID match requ=
ire the Cn_MSR_PMON_BOX_FILTER.{opc, nid} field to be set.  If, for example=
, one wanted to count DRD Local Misses, one should select MISS_OPC_MATCH an=
d set Cn_MSR_PMON_BOX_FILTER.opc  to DRD (0x182).; Miss transactions insert=
ed into the TOR that match an opcode.",
+        "ScaleUnit": "64Bytes",
+        "UMask": "0x3",
         "Unit": "CBO"
     },
     {
-        "BriefDescription": "Cache Lookups; External Snoop Request",
-        "Counter": "0,1,2,3",
-        "EventCode": "0x34",
-        "EventName": "UNC_C_LLC_LOOKUP.REMOTE_SNOOP",
+        "BriefDescription": "LLC misses for PCIe read current. Derived fro=
m unc_c_tor_inserts.miss_opcode",
+        "EventCode": "0x35",
+        "EventName": "LLC_MISSES.PCIE_READ",
+        "Filter": "filter_opc=3D0x19e",
         "PerPkg": "1",
-        "UMask": "0x9",
+        "PublicDescription": "Counts the number of entries successfully in=
serted into the TOR that match  qualifications specified by the subevent.  =
There are a number of subevent 'filters' but only a subset of the subevent =
combinations are valid.  Subevents that require an opcode or NID match requ=
ire the Cn_MSR_PMON_BOX_FILTER.{opc, nid} field to be set.  If, for example=
, one wanted to count DRD Local Misses, one should select MISS_OPC_MATCH an=
d set Cn_MSR_PMON_BOX_FILTER.opc  to DRD (0x182).; Miss transactions insert=
ed into the TOR that match an opcode.",
+        "ScaleUnit": "64Bytes",
+        "UMask": "0x3",
+        "Unit": "CBO"
+    },
+    {
+        "BriefDescription": "ItoM write misses (as part of fast string mem=
cpy stores) + PCIe full line writes. Derived from unc_c_tor_inserts.miss_op=
code",
+        "EventCode": "0x35",
+        "EventName": "LLC_MISSES.PCIE_WRITE",
+        "Filter": "filter_opc=3D0x1c8",
+        "PerPkg": "1",
+        "PublicDescription": "Counts the number of entries successfully in=
serted into the TOR that match  qualifications specified by the subevent.  =
There are a number of subevent 'filters' but only a subset of the subevent =
combinations are valid.  Subevents that require an opcode or NID match requ=
ire the Cn_MSR_PMON_BOX_FILTER.{opc, nid} field to be set.  If, for example=
, one wanted to count DRD Local Misses, one should select MISS_OPC_MATCH an=
d set Cn_MSR_PMON_BOX_FILTER.opc  to DRD (0x182).; Miss transactions insert=
ed into the TOR that match an opcode.",
+        "ScaleUnit": "64Bytes",
+        "UMask": "0x3",
+        "Unit": "CBO"
+    },
+    {
+        "BriefDescription": "LLC prefetch misses for RFO. Derived from unc=
_c_tor_inserts.miss_opcode",
+        "EventCode": "0x35",
+        "EventName": "LLC_MISSES.RFO_LLC_PREFETCH",
+        "Filter": "filter_opc=3D0x190",
+        "PerPkg": "1",
+        "PublicDescription": "Counts the number of entries successfully in=
serted into the TOR that match  qualifications specified by the subevent.  =
There are a number of subevent 'filters' but only a subset of the subevent =
combinations are valid.  Subevents that require an opcode or NID match requ=
ire the Cn_MSR_PMON_BOX_FILTER.{opc, nid} field to be set.  If, for example=
, one wanted to count DRD Local Misses, one should select MISS_OPC_MATCH an=
d set Cn_MSR_PMON_BOX_FILTER.opc  to DRD (0x182).; Miss transactions insert=
ed into the TOR that match an opcode.",
+        "ScaleUnit": "64Bytes",
+        "UMask": "0x3",
+        "Unit": "CBO"
+    },
+    {
+        "BriefDescription": "LLC misses - Uncacheable reads (from cpu) . D=
erived from unc_c_tor_inserts.miss_opcode",
+        "EventCode": "0x35",
+        "EventName": "LLC_MISSES.UNCACHEABLE",
+        "Filter": "filter_opc=3D0x187",
+        "PerPkg": "1",
+        "PublicDescription": "Counts the number of entries successfully in=
serted into the TOR that match  qualifications specified by the subevent.  =
There are a number of subevent 'filters' but only a subset of the subevent =
combinations are valid.  Subevents that require an opcode or NID match requ=
ire the Cn_MSR_PMON_BOX_FILTER.{opc, nid} field to be set.  If, for example=
, one wanted to count DRD Local Misses, one should select MISS_OPC_MATCH an=
d set Cn_MSR_PMON_BOX_FILTER.opc  to DRD (0x182).; Miss transactions insert=
ed into the TOR that match an opcode.",
+        "ScaleUnit": "64Bytes",
+        "UMask": "0x3",
+        "Unit": "CBO"
+    },
+    {
+        "BriefDescription": "L2 demand and L2 prefetch code references to =
LLC. Derived from unc_c_tor_inserts.opcode",
+        "EventCode": "0x35",
+        "EventName": "LLC_REFERENCES.CODE_LLC_PREFETCH",
+        "Filter": "filter_opc=3D0x181",
+        "PerPkg": "1",
+        "PublicDescription": "Counts the number of entries successfully in=
serted into the TOR that match  qualifications specified by the subevent.  =
There are a number of subevent 'filters' but only a subset of the subevent =
combinations are valid.  Subevents that require an opcode or NID match requ=
ire the Cn_MSR_PMON_BOX_FILTER.{opc, nid} field to be set.  If, for example=
, one wanted to count DRD Local Misses, one should select MISS_OPC_MATCH an=
d set Cn_MSR_PMON_BOX_FILTER.opc  to DRD (0x182).; Transactions inserted in=
to the TOR that match an opcode (matched by Cn_MSR_PMON_BOX_FILTER.opc)",
+        "ScaleUnit": "64Bytes",
+        "UMask": "0x1",
+        "Unit": "CBO"
+    },
+    {
+        "BriefDescription": "PCIe writes (partial cache line). Derived fro=
m unc_c_tor_inserts.opcode",
+        "EventCode": "0x35",
+        "EventName": "LLC_REFERENCES.PCIE_NS_PARTIAL_WRITE",
+        "Filter": "filter_opc=3D0x180,filter_tid=3D0x3e",
+        "PerPkg": "1",
+        "PublicDescription": "Counts the number of entries successfully in=
serted into the TOR that match  qualifications specified by the subevent.  =
There are a number of subevent 'filters' but only a subset of the subevent =
combinations are valid.  Subevents that require an opcode or NID match requ=
ire the Cn_MSR_PMON_BOX_FILTER.{opc, nid} field to be set.  If, for example=
, one wanted to count DRD Local Misses, one should select MISS_OPC_MATCH an=
d set Cn_MSR_PMON_BOX_FILTER.opc  to DRD (0x182).; Transactions inserted in=
to the TOR that match an opcode (matched by Cn_MSR_PMON_BOX_FILTER.opc)",
+        "UMask": "0x1",
+        "Unit": "CBO"
+    },
+    {
+        "BriefDescription": "PCIe read current. Derived from unc_c_tor_ins=
erts.opcode",
+        "EventCode": "0x35",
+        "EventName": "LLC_REFERENCES.PCIE_READ",
+        "Filter": "filter_opc=3D0x19e",
+        "PerPkg": "1",
+        "PublicDescription": "Counts the number of entries successfully in=
serted into the TOR that match  qualifications specified by the subevent.  =
There are a number of subevent 'filters' but only a subset of the subevent =
combinations are valid.  Subevents that require an opcode or NID match requ=
ire the Cn_MSR_PMON_BOX_FILTER.{opc, nid} field to be set.  If, for example=
, one wanted to count DRD Local Misses, one should select MISS_OPC_MATCH an=
d set Cn_MSR_PMON_BOX_FILTER.opc  to DRD (0x182).; Transactions inserted in=
to the TOR that match an opcode (matched by Cn_MSR_PMON_BOX_FILTER.opc)",
+        "ScaleUnit": "64Bytes",
+        "UMask": "0x1",
+        "Unit": "CBO"
+    },
+    {
+        "BriefDescription": "PCIe write references (full cache line). Deri=
ved from unc_c_tor_inserts.opcode",
+        "EventCode": "0x35",
+        "EventName": "LLC_REFERENCES.PCIE_WRITE",
+        "Filter": "filter_opc=3D0x1c8,filter_tid=3D0x3e",
+        "PerPkg": "1",
+        "PublicDescription": "Counts the number of entries successfully in=
serted into the TOR that match  qualifications specified by the subevent.  =
There are a number of subevent 'filters' but only a subset of the subevent =
combinations are valid.  Subevents that require an opcode or NID match requ=
ire the Cn_MSR_PMON_BOX_FILTER.{opc, nid} field to be set.  If, for example=
, one wanted to count DRD Local Misses, one should select MISS_OPC_MATCH an=
d set Cn_MSR_PMON_BOX_FILTER.opc  to DRD (0x182).; Transactions inserted in=
to the TOR that match an opcode (matched by Cn_MSR_PMON_BOX_FILTER.opc)",
+        "ScaleUnit": "64Bytes",
+        "UMask": "0x1",
+        "Unit": "CBO"
+    },
+    {
+        "BriefDescription": "Streaming stores (full cache line). Derived f=
rom unc_c_tor_inserts.opcode",
+        "EventCode": "0x35",
+        "EventName": "LLC_REFERENCES.STREAMING_FULL",
+        "Filter": "filter_opc=3D0x18c",
+        "PerPkg": "1",
+        "PublicDescription": "Counts the number of entries successfully in=
serted into the TOR that match  qualifications specified by the subevent.  =
There are a number of subevent 'filters' but only a subset of the subevent =
combinations are valid.  Subevents that require an opcode or NID match requ=
ire the Cn_MSR_PMON_BOX_FILTER.{opc, nid} field to be set.  If, for example=
, one wanted to count DRD Local Misses, one should select MISS_OPC_MATCH an=
d set Cn_MSR_PMON_BOX_FILTER.opc  to DRD (0x182).; Transactions inserted in=
to the TOR that match an opcode (matched by Cn_MSR_PMON_BOX_FILTER.opc)",
+        "ScaleUnit": "64Bytes",
+        "UMask": "0x1",
+        "Unit": "CBO"
+    },
+    {
+        "BriefDescription": "Streaming stores (partial cache line). Derive=
d from unc_c_tor_inserts.opcode",
+        "EventCode": "0x35",
+        "EventName": "LLC_REFERENCES.STREAMING_PARTIAL",
+        "Filter": "filter_opc=3D0x18d",
+        "PerPkg": "1",
+        "PublicDescription": "Counts the number of entries successfully in=
serted into the TOR that match  qualifications specified by the subevent.  =
There are a number of subevent 'filters' but only a subset of the subevent =
combinations are valid.  Subevents that require an opcode or NID match requ=
ire the Cn_MSR_PMON_BOX_FILTER.{opc, nid} field to be set.  If, for example=
, one wanted to count DRD Local Misses, one should select MISS_OPC_MATCH an=
d set Cn_MSR_PMON_BOX_FILTER.opc  to DRD (0x182).; Transactions inserted in=
to the TOR that match an opcode (matched by Cn_MSR_PMON_BOX_FILTER.opc)",
+        "ScaleUnit": "64Bytes",
+        "UMask": "0x1",
+        "Unit": "CBO"
+    },
+    {
+        "BriefDescription": "Bounce Control",
+        "EventCode": "0xA",
+        "EventName": "UNC_C_BOUNCE_CONTROL",
+        "PerPkg": "1",
+        "Unit": "CBO"
+    },
+    {
+        "BriefDescription": "Uncore Clocks",
+        "EventName": "UNC_C_CLOCKTICKS",
+        "PerPkg": "1",
+        "Unit": "CBO"
+    },
+    {
+        "BriefDescription": "Counter 0 Occupancy",
+        "EventCode": "0x1F",
+        "EventName": "UNC_C_COUNTER0_OCCUPANCY",
+        "PerPkg": "1",
+        "PublicDescription": "Since occupancy counts can only be captured =
in the Cbo's 0 counter, this event allows a user to capture occupancy relat=
ed information by filtering the Cb0 occupancy count captured in Counter 0. =
  The filtering available is found in the control register - threshold, inv=
ert and edge detect.   E.g. setting threshold to 1 can effectively monitor =
how many cycles the monitored queue has an entry.",
+        "Unit": "CBO"
+    },
+    {
+        "BriefDescription": "FaST wire asserted",
+        "EventCode": "0x9",
+        "EventName": "UNC_C_FAST_ASSERTED",
+        "PerPkg": "1",
+        "PublicDescription": "Counts the number of cycles either the local=
 distress or incoming distress signals are asserted.  Incoming distress inc=
ludes both up and dn.",
         "Unit": "CBO"
     },
     {
         "BriefDescription": "All LLC Misses (code+ data rd + data wr - inc=
luding demand and prefetch)",
-        "Counter": "0,1,2,3",
         "EventCode": "0x34",
         "EventName": "UNC_C_LLC_LOOKUP.ANY",
         "Filter": "filter_state=3D0x1",
         "PerPkg": "1",
+        "PublicDescription": "Counts the number of times the LLC was acces=
sed - this includes code, data, prefetches and hints coming from L2.  This =
has numerous filters available.  Note the non-standard filtering equation. =
 This event will count requests that lookup the cache multiple times with m=
ultiple increments.  One must ALWAYS set umask bit 0 and select a state or =
states to match.  Otherwise, the event will count nothing.   CBoGlCtrl[22:1=
8] bits correspond to [FMESI] state.; Filters for any transaction originati=
ng from the IPQ or IRQ.  This does not include lookups originating from the=
 ISMQ.",
         "ScaleUnit": "64Bytes",
         "UMask": "0x11",
         "Unit": "CBO"
     },
+    {
+        "BriefDescription": "Cache Lookups; Data Read Request",
+        "EventCode": "0x34",
+        "EventName": "UNC_C_LLC_LOOKUP.DATA_READ",
+        "PerPkg": "1",
+        "PublicDescription": "Counts the number of times the LLC was acces=
sed - this includes code, data, prefetches and hints coming from L2.  This =
has numerous filters available.  Note the non-standard filtering equation. =
 This event will count requests that lookup the cache multiple times with m=
ultiple increments.  One must ALWAYS set umask bit 0 and select a state or =
states to match.  Otherwise, the event will count nothing.   CBoGlCtrl[22:1=
8] bits correspond to [FMESI] state.; Read transactions",
+        "UMask": "0x3",
+        "Unit": "CBO"
+    },
     {
         "BriefDescription": "Cache Lookups; Lookups that Match NID",
-        "Counter": "0,1,2,3",
         "EventCode": "0x34",
         "EventName": "UNC_C_LLC_LOOKUP.NID",
         "PerPkg": "1",
+        "PublicDescription": "Counts the number of times the LLC was acces=
sed - this includes code, data, prefetches and hints coming from L2.  This =
has numerous filters available.  Note the non-standard filtering equation. =
 This event will count requests that lookup the cache multiple times with m=
ultiple increments.  One must ALWAYS set umask bit 0 and select a state or =
states to match.  Otherwise, the event will count nothing.   CBoGlCtrl[22:1=
8] bits correspond to [FMESI] state.; Qualify one of the other subevents by=
 the Target NID.  The NID is programmed in Cn_MSR_PMON_BOX_FILTER.nid.   In=
 conjunction with STATE =3D I, it is possible to monitor misses to specific=
 NIDs in the system.",
         "UMask": "0x41",
         "Unit": "CBO"
     },
     {
         "BriefDescription": "Cache Lookups; Any Read Request",
-        "Counter": "0,1,2,3",
         "EventCode": "0x34",
         "EventName": "UNC_C_LLC_LOOKUP.READ",
         "PerPkg": "1",
+        "PublicDescription": "Counts the number of times the LLC was acces=
sed - this includes code, data, prefetches and hints coming from L2.  This =
has numerous filters available.  Note the non-standard filtering equation. =
 This event will count requests that lookup the cache multiple times with m=
ultiple increments.  One must ALWAYS set umask bit 0 and select a state or =
states to match.  Otherwise, the event will count nothing.   CBoGlCtrl[22:1=
8] bits correspond to [FMESI] state.; Read transactions",
         "UMask": "0x21",
         "Unit": "CBO"
     },
     {
-        "BriefDescription": "M line evictions from LLC (writebacks to memo=
ry)",
-        "Counter": "0,1,2,3",
-        "EventCode": "0x37",
-        "EventName": "UNC_C_LLC_VICTIMS.M_STATE",
+        "BriefDescription": "Cache Lookups; External Snoop Request",
+        "EventCode": "0x34",
+        "EventName": "UNC_C_LLC_LOOKUP.REMOTE_SNOOP",
         "PerPkg": "1",
-        "ScaleUnit": "64Bytes",
-        "UMask": "0x1",
+        "PublicDescription": "Counts the number of times the LLC was acces=
sed - this includes code, data, prefetches and hints coming from L2.  This =
has numerous filters available.  Note the non-standard filtering equation. =
 This event will count requests that lookup the cache multiple times with m=
ultiple increments.  One must ALWAYS set umask bit 0 and select a state or =
states to match.  Otherwise, the event will count nothing.   CBoGlCtrl[22:1=
8] bits correspond to [FMESI] state.; Filters for only snoop requests comin=
g from the remote socket(s) through the IPQ.",
+        "UMask": "0x9",
         "Unit": "CBO"
     },
     {
-        "BriefDescription": "Lines Victimized; Lines in E state",
-        "Counter": "0,1,2,3",
-        "EventCode": "0x37",
-        "EventName": "UNC_C_LLC_VICTIMS.E_STATE",
+        "BriefDescription": "Cache Lookups; Write Requests",
+        "EventCode": "0x34",
+        "EventName": "UNC_C_LLC_LOOKUP.WRITE",
         "PerPkg": "1",
-        "UMask": "0x2",
+        "PublicDescription": "Counts the number of times the LLC was acces=
sed - this includes code, data, prefetches and hints coming from L2.  This =
has numerous filters available.  Note the non-standard filtering equation. =
 This event will count requests that lookup the cache multiple times with m=
ultiple increments.  One must ALWAYS set umask bit 0 and select a state or =
states to match.  Otherwise, the event will count nothing.   CBoGlCtrl[22:1=
8] bits correspond to [FMESI] state.; Writeback transactions from L2 to the=
 LLC  This includes all write transactions -- both Cacheable and UC.",
+        "UMask": "0x5",
         "Unit": "CBO"
     },
     {
-        "BriefDescription": "Lines in S State",
-        "Counter": "0,1,2,3",
+        "BriefDescription": "Lines Victimized; Lines in E state",
         "EventCode": "0x37",
-        "EventName": "UNC_C_LLC_VICTIMS.S_STATE",
+        "EventName": "UNC_C_LLC_VICTIMS.E_STATE",
         "PerPkg": "1",
-        "UMask": "0x4",
+        "PublicDescription": "Counts the number of lines that were victimi=
zed on a fill.  This can be filtered by the state that the line was in.",
+        "UMask": "0x2",
         "Unit": "CBO"
     },
     {
         "BriefDescription": "Lines Victimized",
-        "Counter": "0,1,2,3",
         "EventCode": "0x37",
         "EventName": "UNC_C_LLC_VICTIMS.F_STATE",
         "PerPkg": "1",
+        "PublicDescription": "Counts the number of lines that were victimi=
zed on a fill.  This can be filtered by the state that the line was in.",
         "UMask": "0x8",
         "Unit": "CBO"
     },
     {
-        "BriefDescription": "Lines Victimized; Victimized Lines that Match=
 NID",
-        "Counter": "0,1,2,3",
+        "BriefDescription": "Lines Victimized; Lines in S State",
         "EventCode": "0x37",
-        "EventName": "UNC_C_LLC_VICTIMS.NID",
+        "EventName": "UNC_C_LLC_VICTIMS.I_STATE",
         "PerPkg": "1",
-        "UMask": "0x40",
+        "PublicDescription": "Counts the number of lines that were victimi=
zed on a fill.  This can be filtered by the state that the line was in.",
+        "UMask": "0x4",
         "Unit": "CBO"
     },
     {
         "BriefDescription": "Lines Victimized",
-        "Counter": "0,1,2,3",
         "EventCode": "0x37",
         "EventName": "UNC_C_LLC_VICTIMS.MISS",
         "PerPkg": "1",
+        "PublicDescription": "Counts the number of lines that were victimi=
zed on a fill.  This can be filtered by the state that the line was in.",
         "UMask": "0x10",
         "Unit": "CBO"
     },
     {
-        "BriefDescription": "Cbo Misc; Silent Snoop Eviction",
-        "Counter": "0,1,2,3",
-        "EventCode": "0x39",
-        "EventName": "UNC_C_MISC.RSPI_WAS_FSE",
+        "BriefDescription": "M line evictions from LLC (writebacks to memo=
ry)",
+        "EventCode": "0x37",
+        "EventName": "UNC_C_LLC_VICTIMS.M_STATE",
         "PerPkg": "1",
+        "PublicDescription": "Counts the number of lines that were victimi=
zed on a fill.  This can be filtered by the state that the line was in.",
+        "ScaleUnit": "64Bytes",
         "UMask": "0x1",
         "Unit": "CBO"
     },
     {
-        "BriefDescription": "Cbo Misc; Write Combining Aliasing",
-        "Counter": "0,1,2,3",
+        "BriefDescription": "Lines Victimized; Victimized Lines that Match=
 NID",
+        "EventCode": "0x37",
+        "EventName": "UNC_C_LLC_VICTIMS.NID",
+        "PerPkg": "1",
+        "PublicDescription": "Counts the number of lines that were victimi=
zed on a fill.  This can be filtered by the state that the line was in.; Qu=
alify one of the other subevents by the Target NID.  The NID is programmed =
in Cn_MSR_PMON_BOX_FILTER.nid.   In conjunction with STATE =3D I, it is pos=
sible to monitor misses to specific NIDs in the system.",
+        "UMask": "0x40",
+        "Unit": "CBO"
+    },
+    {
+        "BriefDescription": "Lines in S State",
+        "EventCode": "0x37",
+        "EventName": "UNC_C_LLC_VICTIMS.S_STATE",
+        "PerPkg": "1",
+        "PublicDescription": "Counts the number of lines that were victimi=
zed on a fill.  This can be filtered by the state that the line was in.",
+        "UMask": "0x4",
+        "Unit": "CBO"
+    },
+    {
+        "BriefDescription": "Cbo Misc; DRd hitting non-M with raw CV=3D0",
         "EventCode": "0x39",
-        "EventName": "UNC_C_MISC.WC_ALIASING",
+        "EventName": "UNC_C_MISC.CVZERO_PREFETCH_MISS",
         "PerPkg": "1",
-        "UMask": "0x2",
+        "PublicDescription": "Miscellaneous events in the Cbo.",
+        "UMask": "0x20",
         "Unit": "CBO"
     },
     {
-        "BriefDescription": "Cbo Misc",
-        "Counter": "0,1,2,3",
+        "BriefDescription": "Cbo Misc; Clean Victim with raw CV=3D0",
         "EventCode": "0x39",
-        "EventName": "UNC_C_MISC.STARTED",
+        "EventName": "UNC_C_MISC.CVZERO_PREFETCH_VICTIM",
         "PerPkg": "1",
-        "UMask": "0x4",
+        "PublicDescription": "Miscellaneous events in the Cbo.",
+        "UMask": "0x10",
         "Unit": "CBO"
     },
     {
         "BriefDescription": "Cbo Misc; RFO HitS",
-        "Counter": "0,1,2,3",
         "EventCode": "0x39",
         "EventName": "UNC_C_MISC.RFO_HIT_S",
         "PerPkg": "1",
+        "PublicDescription": "Miscellaneous events in the Cbo.; Number of =
times that an RFO hit in S state.  This is useful for determining if it mig=
ht be good for a workload to use RspIWB instead of RspSWB.",
         "UMask": "0x8",
         "Unit": "CBO"
     },
     {
-        "BriefDescription": "Cbo Misc; Clean Victim with raw CV=3D0",
-        "Counter": "0,1,2,3",
+        "BriefDescription": "Cbo Misc; Silent Snoop Eviction",
         "EventCode": "0x39",
-        "EventName": "UNC_C_MISC.CVZERO_PREFETCH_VICTIM",
+        "EventName": "UNC_C_MISC.RSPI_WAS_FSE",
         "PerPkg": "1",
-        "UMask": "0x10",
+        "PublicDescription": "Miscellaneous events in the Cbo.; Counts the=
 number of times when a Snoop hit in FSE states and triggered a silent evic=
tion.  This is useful because this information is lost in the PRE encodings=
.",
+        "UMask": "0x1",
         "Unit": "CBO"
     },
     {
-        "BriefDescription": "Cbo Misc; DRd hitting non-M with raw CV=3D0",
-        "Counter": "0,1,2,3",
+        "BriefDescription": "Cbo Misc",
         "EventCode": "0x39",
-        "EventName": "UNC_C_MISC.CVZERO_PREFETCH_MISS",
+        "EventName": "UNC_C_MISC.STARTED",
         "PerPkg": "1",
-        "UMask": "0x20",
+        "PublicDescription": "Miscellaneous events in the Cbo.",
+        "UMask": "0x4",
+        "Unit": "CBO"
+    },
+    {
+        "BriefDescription": "Cbo Misc; Write Combining Aliasing",
+        "EventCode": "0x39",
+        "EventName": "UNC_C_MISC.WC_ALIASING",
+        "PerPkg": "1",
+        "PublicDescription": "Miscellaneous events in the Cbo.; Counts the=
 number of times that a USWC write (WCIL(F)) transaction hit in the LLC in =
M state, triggering a WBMtoI followed by the USWC write.  This occurs when =
there is WC aliasing.",
+        "UMask": "0x2",
         "Unit": "CBO"
     },
     {
         "BriefDescription": "LRU Queue; LRU Age 0",
-        "Counter": "0,1,2,3",
         "EventCode": "0x3C",
         "EventName": "UNC_C_QLRU.AGE0",
         "PerPkg": "1",
+        "PublicDescription": "How often age was set to 0",
         "UMask": "0x1",
         "Unit": "CBO"
     },
     {
         "BriefDescription": "LRU Queue; LRU Age 1",
-        "Counter": "0,1,2,3",
         "EventCode": "0x3C",
         "EventName": "UNC_C_QLRU.AGE1",
         "PerPkg": "1",
+        "PublicDescription": "How often age was set to 1",
         "UMask": "0x2",
         "Unit": "CBO"
     },
     {
         "BriefDescription": "LRU Queue; LRU Age 2",
-        "Counter": "0,1,2,3",
         "EventCode": "0x3C",
         "EventName": "UNC_C_QLRU.AGE2",
         "PerPkg": "1",
+        "PublicDescription": "How often age was set to 2",
         "UMask": "0x4",
         "Unit": "CBO"
     },
     {
         "BriefDescription": "LRU Queue; LRU Age 3",
-        "Counter": "0,1,2,3",
         "EventCode": "0x3C",
         "EventName": "UNC_C_QLRU.AGE3",
         "PerPkg": "1",
+        "PublicDescription": "How often age was set to 3",
         "UMask": "0x8",
         "Unit": "CBO"
     },
     {
         "BriefDescription": "LRU Queue; LRU Bits Decremented",
-        "Counter": "0,1,2,3",
         "EventCode": "0x3C",
         "EventName": "UNC_C_QLRU.LRU_DECREMENT",
         "PerPkg": "1",
+        "PublicDescription": "How often all LRU bits were decremented by 1=
",
         "UMask": "0x10",
         "Unit": "CBO"
     },
     {
         "BriefDescription": "LRU Queue; Non-0 Aged Victim",
-        "Counter": "0,1,2,3",
         "EventCode": "0x3C",
         "EventName": "UNC_C_QLRU.VICTIM_NON_ZERO",
         "PerPkg": "1",
+        "PublicDescription": "How often we picked a victim that had a non-=
zero age",
         "UMask": "0x20",
         "Unit": "CBO"
     },
     {
-        "BriefDescription": "AD Ring In Use; Up and Even",
-        "Counter": "0,1,2,3",
+        "BriefDescription": "AD Ring In Use; All",
         "EventCode": "0x1B",
-        "EventName": "UNC_C_RING_AD_USED.UP_EVEN",
+        "EventName": "UNC_C_RING_AD_USED.ALL",
         "PerPkg": "1",
-        "UMask": "0x1",
+        "PublicDescription": "Counts the number of cycles that the AD ring=
 is being used at this ring stop.  This includes when packets are passing b=
y and when packets are being sunk, but does not include when packets are be=
ing sent from the ring stop.  We really have two rings in HSX -- a clockwis=
e ring and a counter-clockwise ring.  On the left side of the ring, the UP =
direction is on the clockwise ring and DN is on the counter-clockwise ring.=
  On the right side of the ring, this is reversed.  The first half of the C=
Bos are on the left side of the ring, and the 2nd half are on the right sid=
e of the ring.  In other words (for example), in a 4c part, Cbo 0 UP AD is =
NOT the same ring as CBo 2 UP AD because they are on opposite sides of the =
ring.",
+        "UMask": "0xf",
         "Unit": "CBO"
     },
     {
-        "BriefDescription": "AD Ring In Use; Up and Odd",
-        "Counter": "0,1,2,3",
+        "BriefDescription": "AD Ring In Use; Down",
         "EventCode": "0x1B",
-        "EventName": "UNC_C_RING_AD_USED.UP_ODD",
+        "EventName": "UNC_C_RING_AD_USED.DOWN",
         "PerPkg": "1",
-        "UMask": "0x2",
+        "PublicDescription": "Counts the number of cycles that the AD ring=
 is being used at this ring stop.  This includes when packets are passing b=
y and when packets are being sunk, but does not include when packets are be=
ing sent from the ring stop.  We really have two rings in HSX -- a clockwis=
e ring and a counter-clockwise ring.  On the left side of the ring, the UP =
direction is on the clockwise ring and DN is on the counter-clockwise ring.=
  On the right side of the ring, this is reversed.  The first half of the C=
Bos are on the left side of the ring, and the 2nd half are on the right sid=
e of the ring.  In other words (for example), in a 4c part, Cbo 0 UP AD is =
NOT the same ring as CBo 2 UP AD because they are on opposite sides of the =
ring.",
+        "UMask": "0xc",
         "Unit": "CBO"
     },
     {
         "BriefDescription": "AD Ring In Use; Down and Even",
-        "Counter": "0,1,2,3",
         "EventCode": "0x1B",
         "EventName": "UNC_C_RING_AD_USED.DOWN_EVEN",
         "PerPkg": "1",
+        "PublicDescription": "Counts the number of cycles that the AD ring=
 is being used at this ring stop.  This includes when packets are passing b=
y and when packets are being sunk, but does not include when packets are be=
ing sent from the ring stop.  We really have two rings in HSX -- a clockwis=
e ring and a counter-clockwise ring.  On the left side of the ring, the UP =
direction is on the clockwise ring and DN is on the counter-clockwise ring.=
  On the right side of the ring, this is reversed.  The first half of the C=
Bos are on the left side of the ring, and the 2nd half are on the right sid=
e of the ring.  In other words (for example), in a 4c part, Cbo 0 UP AD is =
NOT the same ring as CBo 2 UP AD because they are on opposite sides of the =
ring.; Filters for the Down and Even ring polarity.",
         "UMask": "0x4",
         "Unit": "CBO"
     },
     {
         "BriefDescription": "AD Ring In Use; Down and Odd",
-        "Counter": "0,1,2,3",
         "EventCode": "0x1B",
         "EventName": "UNC_C_RING_AD_USED.DOWN_ODD",
         "PerPkg": "1",
+        "PublicDescription": "Counts the number of cycles that the AD ring=
 is being used at this ring stop.  This includes when packets are passing b=
y and when packets are being sunk, but does not include when packets are be=
ing sent from the ring stop.  We really have two rings in HSX -- a clockwis=
e ring and a counter-clockwise ring.  On the left side of the ring, the UP =
direction is on the clockwise ring and DN is on the counter-clockwise ring.=
  On the right side of the ring, this is reversed.  The first half of the C=
Bos are on the left side of the ring, and the 2nd half are on the right sid=
e of the ring.  In other words (for example), in a 4c part, Cbo 0 UP AD is =
NOT the same ring as CBo 2 UP AD because they are on opposite sides of the =
ring.; Filters for the Down and Odd ring polarity.",
         "UMask": "0x8",
         "Unit": "CBO"
     },
     {
         "BriefDescription": "AD Ring In Use; Up",
-        "Counter": "0,1,2,3",
         "EventCode": "0x1B",
         "EventName": "UNC_C_RING_AD_USED.UP",
         "PerPkg": "1",
+        "PublicDescription": "Counts the number of cycles that the AD ring=
 is being used at this ring stop.  This includes when packets are passing b=
y and when packets are being sunk, but does not include when packets are be=
ing sent from the ring stop.  We really have two rings in HSX -- a clockwis=
e ring and a counter-clockwise ring.  On the left side of the ring, the UP =
direction is on the clockwise ring and DN is on the counter-clockwise ring.=
  On the right side of the ring, this is reversed.  The first half of the C=
Bos are on the left side of the ring, and the 2nd half are on the right sid=
e of the ring.  In other words (for example), in a 4c part, Cbo 0 UP AD is =
NOT the same ring as CBo 2 UP AD because they are on opposite sides of the =
ring.",
         "UMask": "0x3",
         "Unit": "CBO"
     },
     {
-        "BriefDescription": "AD Ring In Use; Down",
-        "Counter": "0,1,2,3",
+        "BriefDescription": "AD Ring In Use; Up and Even",
         "EventCode": "0x1B",
-        "EventName": "UNC_C_RING_AD_USED.DOWN",
+        "EventName": "UNC_C_RING_AD_USED.UP_EVEN",
         "PerPkg": "1",
-        "UMask": "0xC",
+        "PublicDescription": "Counts the number of cycles that the AD ring=
 is being used at this ring stop.  This includes when packets are passing b=
y and when packets are being sunk, but does not include when packets are be=
ing sent from the ring stop.  We really have two rings in HSX -- a clockwis=
e ring and a counter-clockwise ring.  On the left side of the ring, the UP =
direction is on the clockwise ring and DN is on the counter-clockwise ring.=
  On the right side of the ring, this is reversed.  The first half of the C=
Bos are on the left side of the ring, and the 2nd half are on the right sid=
e of the ring.  In other words (for example), in a 4c part, Cbo 0 UP AD is =
NOT the same ring as CBo 2 UP AD because they are on opposite sides of the =
ring.; Filters for the Up and Even ring polarity.",
+        "UMask": "0x1",
         "Unit": "CBO"
     },
     {
-        "BriefDescription": "AD Ring In Use; All",
-        "Counter": "0,1,2,3",
+        "BriefDescription": "AD Ring In Use; Up and Odd",
         "EventCode": "0x1B",
-        "EventName": "UNC_C_RING_AD_USED.ALL",
+        "EventName": "UNC_C_RING_AD_USED.UP_ODD",
         "PerPkg": "1",
-        "UMask": "0xF",
+        "PublicDescription": "Counts the number of cycles that the AD ring=
 is being used at this ring stop.  This includes when packets are passing b=
y and when packets are being sunk, but does not include when packets are be=
ing sent from the ring stop.  We really have two rings in HSX -- a clockwis=
e ring and a counter-clockwise ring.  On the left side of the ring, the UP =
direction is on the clockwise ring and DN is on the counter-clockwise ring.=
  On the right side of the ring, this is reversed.  The first half of the C=
Bos are on the left side of the ring, and the 2nd half are on the right sid=
e of the ring.  In other words (for example), in a 4c part, Cbo 0 UP AD is =
NOT the same ring as CBo 2 UP AD because they are on opposite sides of the =
ring.; Filters for the Up and Odd ring polarity.",
+        "UMask": "0x2",
         "Unit": "CBO"
     },
     {
-        "BriefDescription": "AK Ring In Use; Up and Even",
-        "Counter": "0,1,2,3",
+        "BriefDescription": "AK Ring In Use; All",
         "EventCode": "0x1C",
-        "EventName": "UNC_C_RING_AK_USED.UP_EVEN",
+        "EventName": "UNC_C_RING_AK_USED.ALL",
         "PerPkg": "1",
-        "UMask": "0x1",
+        "PublicDescription": "Counts the number of cycles that the AK ring=
 is being used at this ring stop.  This includes when packets are passing b=
y and when packets are being sunk, but does not include when packets are be=
ing sent from the ring stop.We really have two rings in HSX -- a clockwise =
ring and a counter-clockwise ring.  On the left side of the ring, the UP di=
rection is on the clockwise ring and DN is on the counter-clockwise ring.  =
On the right side of the ring, this is reversed.  The first half of the CBo=
s are on the left side of the ring, and the 2nd half are on the right side =
of the ring.  In other words (for example), in a 4c part, Cbo 0 UP AD is NO=
T the same ring as CBo 2 UP AD because they are on opposite sides of the ri=
ng.",
+        "UMask": "0xf",
         "Unit": "CBO"
     },
     {
-        "BriefDescription": "AK Ring In Use; Up and Odd",
-        "Counter": "0,1,2,3",
+        "BriefDescription": "AK Ring In Use; Down",
         "EventCode": "0x1C",
-        "EventName": "UNC_C_RING_AK_USED.UP_ODD",
+        "EventName": "UNC_C_RING_AK_USED.DOWN",
         "PerPkg": "1",
-        "UMask": "0x2",
+        "PublicDescription": "Counts the number of cycles that the AK ring=
 is being used at this ring stop.  This includes when packets are passing b=
y and when packets are being sunk, but does not include when packets are be=
ing sent from the ring stop.We really have two rings in HSX -- a clockwise =
ring and a counter-clockwise ring.  On the left side of the ring, the UP di=
rection is on the clockwise ring and DN is on the counter-clockwise ring.  =
On the right side of the ring, this is reversed.  The first half of the CBo=
s are on the left side of the ring, and the 2nd half are on the right side =
of the ring.  In other words (for example), in a 4c part, Cbo 0 UP AD is NO=
T the same ring as CBo 2 UP AD because they are on opposite sides of the ri=
ng.",
+        "UMask": "0xc",
         "Unit": "CBO"
     },
     {
         "BriefDescription": "AK Ring In Use; Down and Even",
-        "Counter": "0,1,2,3",
         "EventCode": "0x1C",
         "EventName": "UNC_C_RING_AK_USED.DOWN_EVEN",
         "PerPkg": "1",
+        "PublicDescription": "Counts the number of cycles that the AK ring=
 is being used at this ring stop.  This includes when packets are passing b=
y and when packets are being sunk, but does not include when packets are be=
ing sent from the ring stop.We really have two rings in HSX -- a clockwise =
ring and a counter-clockwise ring.  On the left side of the ring, the UP di=
rection is on the clockwise ring and DN is on the counter-clockwise ring.  =
On the right side of the ring, this is reversed.  The first half of the CBo=
s are on the left side of the ring, and the 2nd half are on the right side =
of the ring.  In other words (for example), in a 4c part, Cbo 0 UP AD is NO=
T the same ring as CBo 2 UP AD because they are on opposite sides of the ri=
ng.; Filters for the Down and Even ring polarity.",
         "UMask": "0x4",
         "Unit": "CBO"
     },
     {
         "BriefDescription": "AK Ring In Use; Down and Odd",
-        "Counter": "0,1,2,3",
         "EventCode": "0x1C",
         "EventName": "UNC_C_RING_AK_USED.DOWN_ODD",
         "PerPkg": "1",
+        "PublicDescription": "Counts the number of cycles that the AK ring=
 is being used at this ring stop.  This includes when packets are passing b=
y and when packets are being sunk, but does not include when packets are be=
ing sent from the ring stop.We really have two rings in HSX -- a clockwise =
ring and a counter-clockwise ring.  On the left side of the ring, the UP di=
rection is on the clockwise ring and DN is on the counter-clockwise ring.  =
On the right side of the ring, this is reversed.  The first half of the CBo=
s are on the left side of the ring, and the 2nd half are on the right side =
of the ring.  In other words (for example), in a 4c part, Cbo 0 UP AD is NO=
T the same ring as CBo 2 UP AD because they are on opposite sides of the ri=
ng.; Filters for the Down and Odd ring polarity.",
         "UMask": "0x8",
         "Unit": "CBO"
     },
     {
         "BriefDescription": "AK Ring In Use; Up",
-        "Counter": "0,1,2,3",
         "EventCode": "0x1C",
         "EventName": "UNC_C_RING_AK_USED.UP",
         "PerPkg": "1",
+        "PublicDescription": "Counts the number of cycles that the AK ring=
 is being used at this ring stop.  This includes when packets are passing b=
y and when packets are being sunk, but does not include when packets are be=
ing sent from the ring stop.We really have two rings in HSX -- a clockwise =
ring and a counter-clockwise ring.  On the left side of the ring, the UP di=
rection is on the clockwise ring and DN is on the counter-clockwise ring.  =
On the right side of the ring, this is reversed.  The first half of the CBo=
s are on the left side of the ring, and the 2nd half are on the right side =
of the ring.  In other words (for example), in a 4c part, Cbo 0 UP AD is NO=
T the same ring as CBo 2 UP AD because they are on opposite sides of the ri=
ng.",
         "UMask": "0x3",
         "Unit": "CBO"
     },
     {
-        "BriefDescription": "AK Ring In Use; Down",
-        "Counter": "0,1,2,3",
+        "BriefDescription": "AK Ring In Use; Up and Even",
         "EventCode": "0x1C",
-        "EventName": "UNC_C_RING_AK_USED.DOWN",
+        "EventName": "UNC_C_RING_AK_USED.UP_EVEN",
         "PerPkg": "1",
-        "UMask": "0xC",
+        "PublicDescription": "Counts the number of cycles that the AK ring=
 is being used at this ring stop.  This includes when packets are passing b=
y and when packets are being sunk, but does not include when packets are be=
ing sent from the ring stop.We really have two rings in HSX -- a clockwise =
ring and a counter-clockwise ring.  On the left side of the ring, the UP di=
rection is on the clockwise ring and DN is on the counter-clockwise ring.  =
On the right side of the ring, this is reversed.  The first half of the CBo=
s are on the left side of the ring, and the 2nd half are on the right side =
of the ring.  In other words (for example), in a 4c part, Cbo 0 UP AD is NO=
T the same ring as CBo 2 UP AD because they are on opposite sides of the ri=
ng.; Filters for the Up and Even ring polarity.",
+        "UMask": "0x1",
         "Unit": "CBO"
     },
     {
-        "BriefDescription": "AK Ring In Use; All",
-        "Counter": "0,1,2,3",
+        "BriefDescription": "AK Ring In Use; Up and Odd",
         "EventCode": "0x1C",
-        "EventName": "UNC_C_RING_AK_USED.ALL",
+        "EventName": "UNC_C_RING_AK_USED.UP_ODD",
         "PerPkg": "1",
-        "UMask": "0xF",
+        "PublicDescription": "Counts the number of cycles that the AK ring=
 is being used at this ring stop.  This includes when packets are passing b=
y and when packets are being sunk, but does not include when packets are be=
ing sent from the ring stop.We really have two rings in HSX -- a clockwise =
ring and a counter-clockwise ring.  On the left side of the ring, the UP di=
rection is on the clockwise ring and DN is on the counter-clockwise ring.  =
On the right side of the ring, this is reversed.  The first half of the CBo=
s are on the left side of the ring, and the 2nd half are on the right side =
of the ring.  In other words (for example), in a 4c part, Cbo 0 UP AD is NO=
T the same ring as CBo 2 UP AD because they are on opposite sides of the ri=
ng.; Filters for the Up and Odd ring polarity.",
+        "UMask": "0x2",
         "Unit": "CBO"
     },
     {
-        "BriefDescription": "BL Ring in Use; Up and Even",
-        "Counter": "0,1,2,3",
+        "BriefDescription": "BL Ring in Use; Down",
         "EventCode": "0x1D",
-        "EventName": "UNC_C_RING_BL_USED.UP_EVEN",
+        "EventName": "UNC_C_RING_BL_USED.ALL",
         "PerPkg": "1",
-        "UMask": "0x1",
+        "PublicDescription": "Counts the number of cycles that the BL ring=
 is being used at this ring stop.  This includes when packets are passing b=
y and when packets are being sunk, but does not include when packets are be=
ing sent from the ring stop.We really have two rings in HSX -- a clockwise =
ring and a counter-clockwise ring.  On the left side of the ring, the UP di=
rection is on the clockwise ring and DN is on the counter-clockwise ring.  =
On the right side of the ring, this is reversed.  The first half of the CBo=
s are on the left side of the ring, and the 2nd half are on the right side =
of the ring.  In other words (for example), in a 4c part, Cbo 0 UP AD is NO=
T the same ring as CBo 2 UP AD because they are on opposite sides of the ri=
ng.",
+        "UMask": "0xf",
         "Unit": "CBO"
     },
     {
-        "BriefDescription": "BL Ring in Use; Up and Odd",
-        "Counter": "0,1,2,3",
+        "BriefDescription": "BL Ring in Use; Down",
         "EventCode": "0x1D",
-        "EventName": "UNC_C_RING_BL_USED.UP_ODD",
+        "EventName": "UNC_C_RING_BL_USED.DOWN",
         "PerPkg": "1",
-        "UMask": "0x2",
+        "PublicDescription": "Counts the number of cycles that the BL ring=
 is being used at this ring stop.  This includes when packets are passing b=
y and when packets are being sunk, but does not include when packets are be=
ing sent from the ring stop.We really have two rings in HSX -- a clockwise =
ring and a counter-clockwise ring.  On the left side of the ring, the UP di=
rection is on the clockwise ring and DN is on the counter-clockwise ring.  =
On the right side of the ring, this is reversed.  The first half of the CBo=
s are on the left side of the ring, and the 2nd half are on the right side =
of the ring.  In other words (for example), in a 4c part, Cbo 0 UP AD is NO=
T the same ring as CBo 2 UP AD because they are on opposite sides of the ri=
ng.",
+        "UMask": "0xc",
         "Unit": "CBO"
     },
     {
         "BriefDescription": "BL Ring in Use; Down and Even",
-        "Counter": "0,1,2,3",
         "EventCode": "0x1D",
         "EventName": "UNC_C_RING_BL_USED.DOWN_EVEN",
         "PerPkg": "1",
+        "PublicDescription": "Counts the number of cycles that the BL ring=
 is being used at this ring stop.  This includes when packets are passing b=
y and when packets are being sunk, but does not include when packets are be=
ing sent from the ring stop.We really have two rings in HSX -- a clockwise =
ring and a counter-clockwise ring.  On the left side of the ring, the UP di=
rection is on the clockwise ring and DN is on the counter-clockwise ring.  =
On the right side of the ring, this is reversed.  The first half of the CBo=
s are on the left side of the ring, and the 2nd half are on the right side =
of the ring.  In other words (for example), in a 4c part, Cbo 0 UP AD is NO=
T the same ring as CBo 2 UP AD because they are on opposite sides of the ri=
ng.; Filters for the Down and Even ring polarity.",
         "UMask": "0x4",
         "Unit": "CBO"
     },
     {
         "BriefDescription": "BL Ring in Use; Down and Odd",
-        "Counter": "0,1,2,3",
         "EventCode": "0x1D",
         "EventName": "UNC_C_RING_BL_USED.DOWN_ODD",
         "PerPkg": "1",
+        "PublicDescription": "Counts the number of cycles that the BL ring=
 is being used at this ring stop.  This includes when packets are passing b=
y and when packets are being sunk, but does not include when packets are be=
ing sent from the ring stop.We really have two rings in HSX -- a clockwise =
ring and a counter-clockwise ring.  On the left side of the ring, the UP di=
rection is on the clockwise ring and DN is on the counter-clockwise ring.  =
On the right side of the ring, this is reversed.  The first half of the CBo=
s are on the left side of the ring, and the 2nd half are on the right side =
of the ring.  In other words (for example), in a 4c part, Cbo 0 UP AD is NO=
T the same ring as CBo 2 UP AD because they are on opposite sides of the ri=
ng.; Filters for the Down and Odd ring polarity.",
         "UMask": "0x8",
         "Unit": "CBO"
     },
     {
         "BriefDescription": "BL Ring in Use; Up",
-        "Counter": "0,1,2,3",
         "EventCode": "0x1D",
         "EventName": "UNC_C_RING_BL_USED.UP",
         "PerPkg": "1",
+        "PublicDescription": "Counts the number of cycles that the BL ring=
 is being used at this ring stop.  This includes when packets are passing b=
y and when packets are being sunk, but does not include when packets are be=
ing sent from the ring stop.We really have two rings in HSX -- a clockwise =
ring and a counter-clockwise ring.  On the left side of the ring, the UP di=
rection is on the clockwise ring and DN is on the counter-clockwise ring.  =
On the right side of the ring, this is reversed.  The first half of the CBo=
s are on the left side of the ring, and the 2nd half are on the right side =
of the ring.  In other words (for example), in a 4c part, Cbo 0 UP AD is NO=
T the same ring as CBo 2 UP AD because they are on opposite sides of the ri=
ng.",
         "UMask": "0x3",
         "Unit": "CBO"
     },
     {
-        "BriefDescription": "BL Ring in Use; Down",
-        "Counter": "0,1,2,3",
+        "BriefDescription": "BL Ring in Use; Up and Even",
         "EventCode": "0x1D",
-        "EventName": "UNC_C_RING_BL_USED.DOWN",
+        "EventName": "UNC_C_RING_BL_USED.UP_EVEN",
         "PerPkg": "1",
-        "UMask": "0xC",
+        "PublicDescription": "Counts the number of cycles that the BL ring=
 is being used at this ring stop.  This includes when packets are passing b=
y and when packets are being sunk, but does not include when packets are be=
ing sent from the ring stop.We really have two rings in HSX -- a clockwise =
ring and a counter-clockwise ring.  On the left side of the ring, the UP di=
rection is on the clockwise ring and DN is on the counter-clockwise ring.  =
On the right side of the ring, this is reversed.  The first half of the CBo=
s are on the left side of the ring, and the 2nd half are on the right side =
of the ring.  In other words (for example), in a 4c part, Cbo 0 UP AD is NO=
T the same ring as CBo 2 UP AD because they are on opposite sides of the ri=
ng.; Filters for the Up and Even ring polarity.",
+        "UMask": "0x1",
         "Unit": "CBO"
     },
     {
-        "BriefDescription": "BL Ring in Use; Down",
-        "Counter": "0,1,2,3",
+        "BriefDescription": "BL Ring in Use; Up and Odd",
         "EventCode": "0x1D",
-        "EventName": "UNC_C_RING_BL_USED.ALL",
+        "EventName": "UNC_C_RING_BL_USED.UP_ODD",
         "PerPkg": "1",
-        "UMask": "0xF",
+        "PublicDescription": "Counts the number of cycles that the BL ring=
 is being used at this ring stop.  This includes when packets are passing b=
y and when packets are being sunk, but does not include when packets are be=
ing sent from the ring stop.We really have two rings in HSX -- a clockwise =
ring and a counter-clockwise ring.  On the left side of the ring, the UP di=
rection is on the clockwise ring and DN is on the counter-clockwise ring.  =
On the right side of the ring, this is reversed.  The first half of the CBo=
s are on the left side of the ring, and the 2nd half are on the right side =
of the ring.  In other words (for example), in a 4c part, Cbo 0 UP AD is NO=
T the same ring as CBo 2 UP AD because they are on opposite sides of the ri=
ng.; Filters for the Up and Odd ring polarity.",
+        "UMask": "0x2",
         "Unit": "CBO"
     },
     {
         "BriefDescription": "Number of LLC responses that bounced on the R=
ing.; AD",
-        "Counter": "0,1,2,3",
         "EventCode": "0x5",
         "EventName": "UNC_C_RING_BOUNCES.AD",
         "PerPkg": "1",
@@ -449,7 +630,6 @@
     },
     {
         "BriefDescription": "Number of LLC responses that bounced on the R=
ing.; AK",
-        "Counter": "0,1,2,3",
         "EventCode": "0x5",
         "EventName": "UNC_C_RING_BOUNCES.AK",
         "PerPkg": "1",
@@ -458,7 +638,6 @@
     },
     {
         "BriefDescription": "Number of LLC responses that bounced on the R=
ing.; BL",
-        "Counter": "0,1,2,3",
         "EventCode": "0x5",
         "EventName": "UNC_C_RING_BOUNCES.BL",
         "PerPkg": "1",
@@ -466,8 +645,7 @@
         "Unit": "CBO"
     },
     {
-        "BriefDescription": "Number of LLC responses that bounced on the R=
ing.; Snoops of processor's cache",
-        "Counter": "0,1,2,3",
+        "BriefDescription": "Number of LLC responses that bounced on the R=
ing.; Snoops of processor's cache.",
         "EventCode": "0x5",
         "EventName": "UNC_C_RING_BOUNCES.IV",
         "PerPkg": "1",
@@ -476,43 +654,42 @@
     },
     {
         "BriefDescription": "BL Ring in Use; Any",
-        "Counter": "0,1,2,3",
         "EventCode": "0x1E",
         "EventName": "UNC_C_RING_IV_USED.ANY",
         "PerPkg": "1",
-        "UMask": "0xF",
+        "PublicDescription": "Counts the number of cycles that the IV ring=
 is being used at this ring stop.  This includes when packets are passing b=
y and when packets are being sunk, but does not include when packets are be=
ing sent from the ring stop.  There is only 1 IV ring in HSX  Therefore, if=
 one wants to monitor the Even ring, they should select both UP_EVEN and DN=
_EVEN.  To monitor the Odd ring, they should select both UP_ODD and DN_ODD.=
; Filters any polarity",
+        "UMask": "0xf",
         "Unit": "CBO"
     },
     {
         "BriefDescription": "BL Ring in Use; Any",
-        "Counter": "0,1,2,3",
         "EventCode": "0x1E",
-        "EventName": "UNC_C_RING_IV_USED.UP",
+        "EventName": "UNC_C_RING_IV_USED.DN",
         "PerPkg": "1",
-        "UMask": "0x3",
+        "PublicDescription": "Counts the number of cycles that the IV ring=
 is being used at this ring stop.  This includes when packets are passing b=
y and when packets are being sunk, but does not include when packets are be=
ing sent from the ring stop.  There is only 1 IV ring in HSX  Therefore, if=
 one wants to monitor the Even ring, they should select both UP_EVEN and DN=
_EVEN.  To monitor the Odd ring, they should select both UP_ODD and DN_ODD.=
; Filters any polarity",
+        "UMask": "0xc",
         "Unit": "CBO"
     },
     {
         "BriefDescription": "BL Ring in Use; Down",
-        "Counter": "0,1,2,3",
         "EventCode": "0x1E",
         "EventName": "UNC_C_RING_IV_USED.DOWN",
         "PerPkg": "1",
-        "UMask": "0xCC",
+        "PublicDescription": "Counts the number of cycles that the IV ring=
 is being used at this ring stop.  This includes when packets are passing b=
y and when packets are being sunk, but does not include when packets are be=
ing sent from the ring stop.  There is only 1 IV ring in HSX  Therefore, if=
 one wants to monitor the Even ring, they should select both UP_EVEN and DN=
_EVEN.  To monitor the Odd ring, they should select both UP_ODD and DN_ODD.=
; Filters for Down polarity",
+        "UMask": "0xcc",
         "Unit": "CBO"
     },
     {
         "BriefDescription": "BL Ring in Use; Any",
-        "Counter": "0,1,2,3",
         "EventCode": "0x1E",
-        "EventName": "UNC_C_RING_IV_USED.DN",
+        "EventName": "UNC_C_RING_IV_USED.UP",
         "PerPkg": "1",
-        "UMask": "0xC",
+        "PublicDescription": "Counts the number of cycles that the IV ring=
 is being used at this ring stop.  This includes when packets are passing b=
y and when packets are being sunk, but does not include when packets are be=
ing sent from the ring stop.  There is only 1 IV ring in HSX  Therefore, if=
 one wants to monitor the Even ring, they should select both UP_EVEN and DN=
_EVEN.  To monitor the Odd ring, they should select both UP_ODD and DN_ODD.=
; Filters any polarity",
+        "UMask": "0x3",
         "Unit": "CBO"
     },
     {
         "BriefDescription": "UNC_C_RING_SINK_STARVED.AD",
-        "Counter": "0,1,2,3",
         "EventCode": "0x6",
         "EventName": "UNC_C_RING_SINK_STARVED.AD",
         "PerPkg": "1",
@@ -521,7 +698,6 @@
     },
     {
         "BriefDescription": "UNC_C_RING_SINK_STARVED.AK",
-        "Counter": "0,1,2,3",
         "EventCode": "0x6",
         "EventName": "UNC_C_RING_SINK_STARVED.AK",
         "PerPkg": "1",
@@ -529,396 +705,404 @@
         "Unit": "CBO"
     },
     {
-        "BriefDescription": "UNC_C_RING_SINK_STARVED.IV",
-        "Counter": "0,1,2,3",
+        "BriefDescription": "UNC_C_RING_SINK_STARVED.BL",
         "EventCode": "0x6",
-        "EventName": "UNC_C_RING_SINK_STARVED.IV",
+        "EventName": "UNC_C_RING_SINK_STARVED.BL",
         "PerPkg": "1",
-        "UMask": "0x8",
+        "UMask": "0x4",
         "Unit": "CBO"
     },
     {
-        "BriefDescription": "UNC_C_RING_SINK_STARVED.BL",
-        "Counter": "0,1,2,3",
+        "BriefDescription": "UNC_C_RING_SINK_STARVED.IV",
         "EventCode": "0x6",
-        "EventName": "UNC_C_RING_SINK_STARVED.BL",
+        "EventName": "UNC_C_RING_SINK_STARVED.IV",
         "PerPkg": "1",
-        "UMask": "0x4",
+        "UMask": "0x8",
         "Unit": "CBO"
     },
     {
-        "BriefDescription": "Number of cycles the Cbo is actively throttli=
ng traffic onto the Ring in order to limit bounce traffic",
-        "Counter": "0,1,2,3",
+        "BriefDescription": "Number of cycles the Cbo is actively throttli=
ng traffic onto the Ring in order to limit bounce traffic.",
         "EventCode": "0x7",
         "EventName": "UNC_C_RING_SRC_THRTL",
         "PerPkg": "1",
         "Unit": "CBO"
     },
+    {
+        "BriefDescription": "Ingress Arbiter Blocking Cycles; IRQ",
+        "EventCode": "0x12",
+        "EventName": "UNC_C_RxR_EXT_STARVED.IPQ",
+        "PerPkg": "1",
+        "PublicDescription": "Counts cycles in external starvation.  This =
occurs when one of the ingress queues is being starved by the other queues.=
; IPQ is externally startved and therefore we are blocking the IRQ.",
+        "UMask": "0x2",
+        "Unit": "CBO"
+    },
     {
         "BriefDescription": "Ingress Arbiter Blocking Cycles; IPQ",
-        "Counter": "0,1,2,3",
         "EventCode": "0x12",
         "EventName": "UNC_C_RxR_EXT_STARVED.IRQ",
         "PerPkg": "1",
+        "PublicDescription": "Counts cycles in external starvation.  This =
occurs when one of the ingress queues is being starved by the other queues.=
; IRQ is externally starved and therefore we are blocking the IPQ.",
         "UMask": "0x1",
         "Unit": "CBO"
     },
     {
-        "BriefDescription": "Ingress Arbiter Blocking Cycles; IRQ",
-        "Counter": "0,1,2,3",
+        "BriefDescription": "Ingress Arbiter Blocking Cycles; ISMQ_BID",
         "EventCode": "0x12",
-        "EventName": "UNC_C_RxR_EXT_STARVED.IPQ",
+        "EventName": "UNC_C_RxR_EXT_STARVED.ISMQ_BIDS",
         "PerPkg": "1",
-        "UMask": "0x2",
+        "PublicDescription": "Counts cycles in external starvation.  This =
occurs when one of the ingress queues is being starved by the other queues.=
; Number of times that the ISMQ Bid.",
+        "UMask": "0x8",
         "Unit": "CBO"
     },
     {
         "BriefDescription": "Ingress Arbiter Blocking Cycles; PRQ",
-        "Counter": "0,1,2,3",
         "EventCode": "0x12",
         "EventName": "UNC_C_RxR_EXT_STARVED.PRQ",
         "PerPkg": "1",
+        "PublicDescription": "Counts cycles in external starvation.  This =
occurs when one of the ingress queues is being starved by the other queues.=
",
         "UMask": "0x4",
         "Unit": "CBO"
     },
-    {
-        "BriefDescription": "Ingress Arbiter Blocking Cycles; ISMQ_BID",
-        "Counter": "0,1,2,3",
-        "EventCode": "0x12",
-        "EventName": "UNC_C_RxR_EXT_STARVED.ISMQ_BIDS",
+    {
+        "BriefDescription": "Ingress Allocations; IPQ",
+        "EventCode": "0x13",
+        "EventName": "UNC_C_RxR_INSERTS.IPQ",
         "PerPkg": "1",
-        "UMask": "0x8",
+        "PublicDescription": "Counts number of allocations per cycle into =
the specified Ingress queue.",
+        "UMask": "0x4",
         "Unit": "CBO"
     },
     {
         "BriefDescription": "Ingress Allocations; IRQ",
-        "Counter": "0,1,2,3",
         "EventCode": "0x13",
         "EventName": "UNC_C_RxR_INSERTS.IRQ",
         "PerPkg": "1",
+        "PublicDescription": "Counts number of allocations per cycle into =
the specified Ingress queue.",
         "UMask": "0x1",
         "Unit": "CBO"
     },
     {
         "BriefDescription": "Ingress Allocations; IRQ Rejected",
-        "Counter": "0,1,2,3",
         "EventCode": "0x13",
         "EventName": "UNC_C_RxR_INSERTS.IRQ_REJ",
         "PerPkg": "1",
+        "PublicDescription": "Counts number of allocations per cycle into =
the specified Ingress queue.",
         "UMask": "0x2",
         "Unit": "CBO"
     },
-    {
-        "BriefDescription": "Ingress Allocations; IPQ",
-        "Counter": "0,1,2,3",
-        "EventCode": "0x13",
-        "EventName": "UNC_C_RxR_INSERTS.IPQ",
-        "PerPkg": "1",
-        "UMask": "0x4",
-        "Unit": "CBO"
-    },
     {
         "BriefDescription": "Ingress Allocations; PRQ",
-        "Counter": "0,1,2,3",
         "EventCode": "0x13",
         "EventName": "UNC_C_RxR_INSERTS.PRQ",
         "PerPkg": "1",
+        "PublicDescription": "Counts number of allocations per cycle into =
the specified Ingress queue.",
         "UMask": "0x10",
         "Unit": "CBO"
     },
     {
         "BriefDescription": "Ingress Allocations; PRQ",
-        "Counter": "0,1,2,3",
         "EventCode": "0x13",
         "EventName": "UNC_C_RxR_INSERTS.PRQ_REJ",
         "PerPkg": "1",
+        "PublicDescription": "Counts number of allocations per cycle into =
the specified Ingress queue.",
         "UMask": "0x20",
         "Unit": "CBO"
     },
     {
-        "BriefDescription": "Ingress Internal Starvation Cycles; IRQ",
-        "Counter": "0,1,2,3",
+        "BriefDescription": "Ingress Internal Starvation Cycles; IPQ",
         "EventCode": "0x14",
-        "EventName": "UNC_C_RxR_INT_STARVED.IRQ",
+        "EventName": "UNC_C_RxR_INT_STARVED.IPQ",
         "PerPkg": "1",
-        "UMask": "0x1",
+        "PublicDescription": "Counts cycles in internal starvation.  This =
occurs when one (or more) of the entries in the ingress queue are being sta=
rved out by other entries in that queue.; Cycles with the IPQ in Internal S=
tarvation.",
+        "UMask": "0x4",
         "Unit": "CBO"
     },
     {
-        "BriefDescription": "Ingress Internal Starvation Cycles; IPQ",
-        "Counter": "0,1,2,3",
+        "BriefDescription": "Ingress Internal Starvation Cycles; IRQ",
         "EventCode": "0x14",
-        "EventName": "UNC_C_RxR_INT_STARVED.IPQ",
+        "EventName": "UNC_C_RxR_INT_STARVED.IRQ",
         "PerPkg": "1",
-        "UMask": "0x4",
+        "PublicDescription": "Counts cycles in internal starvation.  This =
occurs when one (or more) of the entries in the ingress queue are being sta=
rved out by other entries in that queue.; Cycles with the IRQ in Internal S=
tarvation.",
+        "UMask": "0x1",
         "Unit": "CBO"
     },
     {
         "BriefDescription": "Ingress Internal Starvation Cycles; ISMQ",
-        "Counter": "0,1,2,3",
         "EventCode": "0x14",
         "EventName": "UNC_C_RxR_INT_STARVED.ISMQ",
         "PerPkg": "1",
+        "PublicDescription": "Counts cycles in internal starvation.  This =
occurs when one (or more) of the entries in the ingress queue are being sta=
rved out by other entries in that queue.; Cycles with the ISMQ in Internal =
Starvation.",
         "UMask": "0x8",
         "Unit": "CBO"
     },
     {
         "BriefDescription": "Ingress Internal Starvation Cycles; PRQ",
-        "Counter": "0,1,2,3",
         "EventCode": "0x14",
         "EventName": "UNC_C_RxR_INT_STARVED.PRQ",
         "PerPkg": "1",
+        "PublicDescription": "Counts cycles in internal starvation.  This =
occurs when one (or more) of the entries in the ingress queue are being sta=
rved out by other entries in that queue.",
         "UMask": "0x10",
         "Unit": "CBO"
     },
+    {
+        "BriefDescription": "Probe Queue Retries; Address Conflict",
+        "EventCode": "0x31",
+        "EventName": "UNC_C_RxR_IPQ_RETRY.ADDR_CONFLICT",
+        "PerPkg": "1",
+        "PublicDescription": "Number of times a snoop (probe) request had =
to retry.  Filters exist to cover some of the common cases retries.; Counts=
 the number of times that a request form the IPQ was retried because of a T=
OR reject from an address conflicts.  Address conflicts out of the IPQ shou=
ld be rare.  They will generally only occur if two different sockets are se=
nding requests to the same address at the same time.  This is a true confli=
ct case, unlike the IPQ Address Conflict which is commonly caused by prefet=
ching characteristics.",
+        "UMask": "0x4",
+        "Unit": "CBO"
+    },
     {
         "BriefDescription": "Probe Queue Retries; Any Reject",
-        "Counter": "0,1,2,3",
         "EventCode": "0x31",
         "EventName": "UNC_C_RxR_IPQ_RETRY.ANY",
         "PerPkg": "1",
+        "PublicDescription": "Number of times a snoop (probe) request had =
to retry.  Filters exist to cover some of the common cases retries.; Counts=
 the number of times that a request form the IPQ was retried because of a T=
OR reject.  TOR rejects from the IPQ can be caused by the Egress being full=
 or Address Conflicts.",
         "UMask": "0x1",
         "Unit": "CBO"
     },
     {
         "BriefDescription": "Probe Queue Retries; No Egress Credits",
-        "Counter": "0,1,2,3",
         "EventCode": "0x31",
         "EventName": "UNC_C_RxR_IPQ_RETRY.FULL",
         "PerPkg": "1",
+        "PublicDescription": "Number of times a snoop (probe) request had =
to retry.  Filters exist to cover some of the common cases retries.; Counts=
 the number of times that a request form the IPQ was retried because of a T=
OR reject from the Egress being full.  IPQ requests make use of the AD Egre=
ss for regular responses, the BL egress to forward data, and the AK egress =
to return credits.",
         "UMask": "0x2",
         "Unit": "CBO"
     },
-    {
-        "BriefDescription": "Probe Queue Retries; Address Conflict",
-        "Counter": "0,1,2,3",
-        "EventCode": "0x31",
-        "EventName": "UNC_C_RxR_IPQ_RETRY.ADDR_CONFLICT",
-        "PerPkg": "1",
-        "UMask": "0x4",
-        "Unit": "CBO"
-    },
     {
         "BriefDescription": "Probe Queue Retries; No QPI Credits",
-        "Counter": "0,1,2,3",
         "EventCode": "0x31",
         "EventName": "UNC_C_RxR_IPQ_RETRY.QPI_CREDITS",
         "PerPkg": "1",
+        "PublicDescription": "Number of times a snoop (probe) request had =
to retry.  Filters exist to cover some of the common cases retries.",
         "UMask": "0x10",
         "Unit": "CBO"
     },
     {
         "BriefDescription": "Probe Queue Retries; No AD Sbo Credits",
-        "Counter": "0,1,2,3",
         "EventCode": "0x28",
         "EventName": "UNC_C_RxR_IPQ_RETRY2.AD_SBO",
         "PerPkg": "1",
+        "PublicDescription": "Number of times a snoop (probe) request had =
to retry.  Filters exist to cover some of the common cases retries.; Counts=
 the number of times that a request from the IPQ was retried because of it =
lacked credits to send an AD packet to the Sbo.",
         "UMask": "0x1",
         "Unit": "CBO"
     },
     {
         "BriefDescription": "Probe Queue Retries; Target Node Filter",
-        "Counter": "0,1,2,3",
         "EventCode": "0x28",
         "EventName": "UNC_C_RxR_IPQ_RETRY2.TARGET",
         "PerPkg": "1",
+        "PublicDescription": "Number of times a snoop (probe) request had =
to retry.  Filters exist to cover some of the common cases retries.; Counts=
 the number of times that a request from the IPQ was retried filtered by th=
e Target NodeID as specified in the Cbox's Filter register.",
         "UMask": "0x40",
         "Unit": "CBO"
     },
+    {
+        "BriefDescription": "Ingress Request Queue Rejects; Address Confli=
ct",
+        "EventCode": "0x32",
+        "EventName": "UNC_C_RxR_IRQ_RETRY.ADDR_CONFLICT",
+        "PerPkg": "1",
+        "PublicDescription": "Counts the number of times that a request fr=
om the IRQ was retried because of an address match in the TOR.  In order to=
 maintain coherency, requests to the same address are not allowed to pass e=
ach other up in the Cbo.  Therefore, if there is an outstanding request to =
a given address, one cannot issue another request to that address until it =
is complete.  This comes up most commonly with prefetches.  Outstanding pre=
fetches occasionally will not complete their memory fetch and a demand requ=
est to the same address will then sit in the IRQ and get retried until the =
prefetch fills the data into the LLC.  Therefore, it will not be uncommon t=
o see this case in high bandwidth streaming workloads when the LLC Prefetch=
er in the core is enabled.",
+        "UMask": "0x4",
+        "Unit": "CBO"
+    },
     {
         "BriefDescription": "Ingress Request Queue Rejects; Any Reject",
-        "Counter": "0,1,2,3",
         "EventCode": "0x32",
         "EventName": "UNC_C_RxR_IRQ_RETRY.ANY",
         "PerPkg": "1",
+        "PublicDescription": "Counts the number of IRQ retries that occur.=
  Requests from the IRQ are retried if they are rejected from the TOR pipel=
ine for a variety of reasons.  Some of the most common reasons include if t=
he Egress is full, there are no RTIDs, or there is a Physical Address match=
 to another outstanding request.",
         "UMask": "0x1",
         "Unit": "CBO"
     },
     {
         "BriefDescription": "Ingress Request Queue Rejects; No Egress Cred=
its",
-        "Counter": "0,1,2,3",
         "EventCode": "0x32",
         "EventName": "UNC_C_RxR_IRQ_RETRY.FULL",
         "PerPkg": "1",
+        "PublicDescription": "Counts the number of times that a request fr=
om the IRQ was retried because it failed to acquire an entry in the Egress.=
  The egress is the buffer that queues up for allocating onto the ring.  IR=
Q requests can make use of all four rings and all four Egresses.  If any of=
 the queues that a given request needs to make use of are full, the request=
 will be retried.",
         "UMask": "0x2",
         "Unit": "CBO"
     },
     {
-        "BriefDescription": "Ingress Request Queue Rejects; Address Confli=
ct",
-        "Counter": "0,1,2,3",
+        "BriefDescription": "Ingress Request Queue Rejects; No IIO Credits=
",
         "EventCode": "0x32",
-        "EventName": "UNC_C_RxR_IRQ_RETRY.ADDR_CONFLICT",
+        "EventName": "UNC_C_RxR_IRQ_RETRY.IIO_CREDITS",
         "PerPkg": "1",
-        "UMask": "0x4",
+        "PublicDescription": "Number of times a request attempted to acqui=
re the NCS/NCB credit for sending messages on BL to the IIO.  There is a si=
ngle credit in each CBo that is shared between the NCS and NCB message clas=
ses for sending transactions on the BL ring (such as read data) to the IIO.=
",
+        "UMask": "0x20",
         "Unit": "CBO"
     },
     {
-        "BriefDescription": "Ingress Request Queue Rejects; No RTIDs",
-        "Counter": "0,1,2,3",
+        "BriefDescription": "Ingress Request Queue Rejects",
         "EventCode": "0x32",
-        "EventName": "UNC_C_RxR_IRQ_RETRY.RTID",
+        "EventName": "UNC_C_RxR_IRQ_RETRY.NID",
         "PerPkg": "1",
-        "UMask": "0x8",
+        "PublicDescription": "Qualify one of the other subevents by a give=
n RTID destination NID.  The NID is programmed in Cn_MSR_PMON_BOX_FILTER1.n=
id.",
+        "UMask": "0x40",
         "Unit": "CBO"
     },
     {
         "BriefDescription": "Ingress Request Queue Rejects; No QPI Credits=
",
-        "Counter": "0,1,2,3",
         "EventCode": "0x32",
         "EventName": "UNC_C_RxR_IRQ_RETRY.QPI_CREDITS",
         "PerPkg": "1",
+        "PublicDescription": "Number of requests rejects because of lack o=
f QPI Ingress credits.  These credits are required in order to send transac=
tions to the QPI agent.  Please see the QPI_IGR_CREDITS events for more inf=
ormation.",
         "UMask": "0x10",
         "Unit": "CBO"
     },
     {
-        "BriefDescription": "Ingress Request Queue Rejects; No IIO Credits=
",
-        "Counter": "0,1,2,3",
-        "EventCode": "0x32",
-        "EventName": "UNC_C_RxR_IRQ_RETRY.IIO_CREDITS",
-        "PerPkg": "1",
-        "UMask": "0x20",
-        "Unit": "CBO"
-    },
-    {
-        "BriefDescription": "Ingress Request Queue Rejects",
-        "Counter": "0,1,2,3",
+        "BriefDescription": "Ingress Request Queue Rejects; No RTIDs",
         "EventCode": "0x32",
-        "EventName": "UNC_C_RxR_IRQ_RETRY.NID",
+        "EventName": "UNC_C_RxR_IRQ_RETRY.RTID",
         "PerPkg": "1",
-        "UMask": "0x40",
+        "PublicDescription": "Counts the number of times that requests fro=
m the IRQ were retried because there were no RTIDs available.  RTIDs are re=
quired after a request misses the LLC and needs to send snoops and/or reque=
sts to memory.  If there are no RTIDs available, requests will queue up in =
the IRQ and retry until one becomes available.  Note that there are multipl=
e RTID pools for the different sockets.  There may be cases where the local=
 RTIDs are all used, but requests destined for remote memory can still acqu=
ire an RTID because there are remote RTIDs available.  This event does not =
provide any filtering for this case.",
+        "UMask": "0x8",
         "Unit": "CBO"
     },
     {
         "BriefDescription": "Ingress Request Queue Rejects; No AD Sbo Cred=
its",
-        "Counter": "0,1,2,3",
         "EventCode": "0x29",
         "EventName": "UNC_C_RxR_IRQ_RETRY2.AD_SBO",
         "PerPkg": "1",
+        "PublicDescription": "Counts the number of times that a request fr=
om the IPQ was retried because of it lacked credits to send an AD packet to=
 the Sbo.",
         "UMask": "0x1",
         "Unit": "CBO"
     },
     {
         "BriefDescription": "Ingress Request Queue Rejects; No BL Sbo Cred=
its",
-        "Counter": "0,1,2,3",
         "EventCode": "0x29",
         "EventName": "UNC_C_RxR_IRQ_RETRY2.BL_SBO",
         "PerPkg": "1",
+        "PublicDescription": "Counts the number of times that a request fr=
om the IPQ was retried because of it lacked credits to send an BL packet to=
 the Sbo.",
         "UMask": "0x2",
         "Unit": "CBO"
     },
     {
         "BriefDescription": "Ingress Request Queue Rejects; Target Node Fi=
lter",
-        "Counter": "0,1,2,3",
         "EventCode": "0x29",
         "EventName": "UNC_C_RxR_IRQ_RETRY2.TARGET",
         "PerPkg": "1",
+        "PublicDescription": "Counts the number of times that a request fr=
om the IPQ was retried filtered by the Target NodeID as specified in the Cb=
ox's Filter register.",
         "UMask": "0x40",
         "Unit": "CBO"
     },
     {
         "BriefDescription": "ISMQ Retries; Any Reject",
-        "Counter": "0,1,2,3",
         "EventCode": "0x33",
         "EventName": "UNC_C_RxR_ISMQ_RETRY.ANY",
         "PerPkg": "1",
+        "PublicDescription": "Number of times a transaction flowing throug=
h the ISMQ had to retry.  Transaction pass through the ISMQ as responses fo=
r requests that already exist in the Cbo.  Some examples include: when data=
 is returned or when snoop responses come back from the cores.; Counts the =
total number of times that a request from the ISMQ retried because of a TOR=
 reject.  ISMQ requests generally will not need to retry (or at least ISMQ =
retries are less common than IRQ retries).  ISMQ requests will retry if the=
y are not able to acquire a needed Egress credit to get onto the ring, or f=
or cache evictions that need to acquire an RTID.  Most ISMQ requests alread=
y have an RTID, so eviction retries will be less common here.",
         "UMask": "0x1",
         "Unit": "CBO"
     },
     {
         "BriefDescription": "ISMQ Retries; No Egress Credits",
-        "Counter": "0,1,2,3",
         "EventCode": "0x33",
         "EventName": "UNC_C_RxR_ISMQ_RETRY.FULL",
         "PerPkg": "1",
+        "PublicDescription": "Number of times a transaction flowing throug=
h the ISMQ had to retry.  Transaction pass through the ISMQ as responses fo=
r requests that already exist in the Cbo.  Some examples include: when data=
 is returned or when snoop responses come back from the cores.; Counts the =
number of times that a request from the ISMQ retried because of a TOR rejec=
t caused by a lack of Egress credits. The egress is the buffer that queues =
up for allocating onto the ring.  If any of the Egress queues that a given =
request needs to make use of are full, the request will be retried.",
         "UMask": "0x2",
         "Unit": "CBO"
     },
     {
-        "BriefDescription": "ISMQ Retries; No RTIDs",
-        "Counter": "0,1,2,3",
+        "BriefDescription": "ISMQ Retries; No IIO Credits",
         "EventCode": "0x33",
-        "EventName": "UNC_C_RxR_ISMQ_RETRY.RTID",
+        "EventName": "UNC_C_RxR_ISMQ_RETRY.IIO_CREDITS",
         "PerPkg": "1",
-        "UMask": "0x8",
+        "PublicDescription": "Number of times a transaction flowing throug=
h the ISMQ had to retry.  Transaction pass through the ISMQ as responses fo=
r requests that already exist in the Cbo.  Some examples include: when data=
 is returned or when snoop responses come back from the cores.; Number of t=
imes a request attempted to acquire the NCS/NCB credit for sending messages=
 on BL to the IIO.  There is a single credit in each CBo that is shared bet=
ween the NCS and NCB message classes for sending transactions on the BL rin=
g (such as read data) to the IIO.",
+        "UMask": "0x20",
         "Unit": "CBO"
     },
     {
-        "BriefDescription": "ISMQ Retries; No QPI Credits",
-        "Counter": "0,1,2,3",
+        "BriefDescription": "ISMQ Retries",
         "EventCode": "0x33",
-        "EventName": "UNC_C_RxR_ISMQ_RETRY.QPI_CREDITS",
+        "EventName": "UNC_C_RxR_ISMQ_RETRY.NID",
         "PerPkg": "1",
-        "UMask": "0x10",
+        "PublicDescription": "Number of times a transaction flowing throug=
h the ISMQ had to retry.  Transaction pass through the ISMQ as responses fo=
r requests that already exist in the Cbo.  Some examples include: when data=
 is returned or when snoop responses come back from the cores.; Qualify one=
 of the other subevents by a given RTID destination NID.  The NID is progra=
mmed in Cn_MSR_PMON_BOX_FILTER1.nid.",
+        "UMask": "0x40",
         "Unit": "CBO"
     },
     {
-        "BriefDescription": "ISMQ Retries; No IIO Credits",
-        "Counter": "0,1,2,3",
+        "BriefDescription": "ISMQ Retries; No QPI Credits",
         "EventCode": "0x33",
-        "EventName": "UNC_C_RxR_ISMQ_RETRY.IIO_CREDITS",
+        "EventName": "UNC_C_RxR_ISMQ_RETRY.QPI_CREDITS",
         "PerPkg": "1",
-        "UMask": "0x20",
+        "PublicDescription": "Number of times a transaction flowing throug=
h the ISMQ had to retry.  Transaction pass through the ISMQ as responses fo=
r requests that already exist in the Cbo.  Some examples include: when data=
 is returned or when snoop responses come back from the cores.",
+        "UMask": "0x10",
         "Unit": "CBO"
     },
     {
-        "BriefDescription": "ISMQ Retries",
-        "Counter": "0,1,2,3",
+        "BriefDescription": "ISMQ Retries; No RTIDs",
         "EventCode": "0x33",
-        "EventName": "UNC_C_RxR_ISMQ_RETRY.WB_CREDITS",
+        "EventName": "UNC_C_RxR_ISMQ_RETRY.RTID",
         "PerPkg": "1",
-        "UMask": "0x80",
+        "PublicDescription": "Number of times a transaction flowing throug=
h the ISMQ had to retry.  Transaction pass through the ISMQ as responses fo=
r requests that already exist in the Cbo.  Some examples include: when data=
 is returned or when snoop responses come back from the cores.; Counts the =
number of times that a request from the ISMQ retried because of a TOR rejec=
t caused by no RTIDs.  M-state cache evictions are serviced through the ISM=
Q, and must acquire an RTID in order to write back to memory.  If no RTIDs =
are available, they will be retried.",
+        "UMask": "0x8",
         "Unit": "CBO"
     },
     {
         "BriefDescription": "ISMQ Retries",
-        "Counter": "0,1,2,3",
         "EventCode": "0x33",
-        "EventName": "UNC_C_RxR_ISMQ_RETRY.NID",
+        "EventName": "UNC_C_RxR_ISMQ_RETRY.WB_CREDITS",
         "PerPkg": "1",
-        "UMask": "0x40",
+        "PublicDescription": "Number of times a transaction flowing throug=
h the ISMQ had to retry.  Transaction pass through the ISMQ as responses fo=
r requests that already exist in the Cbo.  Some examples include: when data=
 is returned or when snoop responses come back from the cores.; Qualify one=
 of the other subevents by a given RTID destination NID.  The NID is progra=
mmed in Cn_MSR_PMON_BOX_FILTER1.nid.",
+        "UMask": "0x80",
         "Unit": "CBO"
     },
     {
         "BriefDescription": "ISMQ Request Queue Rejects; No AD Sbo Credits=
",
-        "Counter": "0,1,2,3",
         "EventCode": "0x2A",
         "EventName": "UNC_C_RxR_ISMQ_RETRY2.AD_SBO",
         "PerPkg": "1",
+        "PublicDescription": "Counts the number of times that a request fr=
om the ISMQ was retried because of it lacked credits to send an AD packet t=
o the Sbo.",
         "UMask": "0x1",
         "Unit": "CBO"
     },
     {
         "BriefDescription": "ISMQ Request Queue Rejects; No BL Sbo Credits=
",
-        "Counter": "0,1,2,3",
         "EventCode": "0x2A",
         "EventName": "UNC_C_RxR_ISMQ_RETRY2.BL_SBO",
         "PerPkg": "1",
+        "PublicDescription": "Counts the number of times that a request fr=
om the ISMQ was retried because of it lacked credits to send an BL packet t=
o the Sbo.",
         "UMask": "0x2",
         "Unit": "CBO"
     },
     {
         "BriefDescription": "ISMQ Request Queue Rejects; Target Node Filte=
r",
-        "Counter": "0,1,2,3",
         "EventCode": "0x2A",
         "EventName": "UNC_C_RxR_ISMQ_RETRY2.TARGET",
         "PerPkg": "1",
+        "PublicDescription": "Counts the number of times that a request fr=
om the ISMQ was retried filtered by the Target NodeID as specified in the C=
box's Filter register.",
         "UMask": "0x40",
         "Unit": "CBO"
     },
+    {
+        "BriefDescription": "Ingress Occupancy; IPQ",
+        "EventCode": "0x11",
+        "EventName": "UNC_C_RxR_OCCUPANCY.IPQ",
+        "PerPkg": "1",
+        "PublicDescription": "Counts number of entries in the specified In=
gress queue in each cycle.",
+        "UMask": "0x4",
+        "Unit": "CBO"
+    },
     {
         "BriefDescription": "Ingress Occupancy; IRQ",
         "EventCode": "0x11",
         "EventName": "UNC_C_RxR_OCCUPANCY.IRQ",
         "PerPkg": "1",
+        "PublicDescription": "Counts number of entries in the specified In=
gress queue in each cycle.",
         "UMask": "0x1",
         "Unit": "CBO"
     },
     {
-        "BriefDescription": "Ingress Occupancy; IPQ",
+        "BriefDescription": "Ingress Occupancy; IRQ Rejected",
         "EventCode": "0x11",
-        "EventName": "UNC_C_RxR_OCCUPANCY.IPQ",
+        "EventName": "UNC_C_RxR_OCCUPANCY.IRQ_REJ",
         "PerPkg": "1",
-        "UMask": "0x4",
+        "PublicDescription": "Counts number of entries in the specified In=
gress queue in each cycle.",
+        "UMask": "0x2",
         "Unit": "CBO"
     },
     {
@@ -926,24 +1110,25 @@
         "EventCode": "0x11",
         "EventName": "UNC_C_RxR_OCCUPANCY.PRQ_REJ",
         "PerPkg": "1",
+        "PublicDescription": "Counts number of entries in the specified In=
gress queue in each cycle.",
         "UMask": "0x20",
         "Unit": "CBO"
     },
     {
         "BriefDescription": "SBo Credits Acquired; For AD Ring",
-        "Counter": "0,1,2,3",
         "EventCode": "0x3D",
         "EventName": "UNC_C_SBO_CREDITS_ACQUIRED.AD",
         "PerPkg": "1",
+        "PublicDescription": "Number of Sbo credits acquired in a given cy=
cle, per ring.  Each Cbo is assigned an Sbo it can communicate with.",
         "UMask": "0x1",
         "Unit": "CBO"
     },
     {
         "BriefDescription": "SBo Credits Acquired; For BL Ring",
-        "Counter": "0,1,2,3",
         "EventCode": "0x3D",
         "EventName": "UNC_C_SBO_CREDITS_ACQUIRED.BL",
         "PerPkg": "1",
+        "PublicDescription": "Number of Sbo credits acquired in a given cy=
cle, per ring.  Each Cbo is assigned an Sbo it can communicate with.",
         "UMask": "0x2",
         "Unit": "CBO"
     },
@@ -952,6 +1137,7 @@
         "EventCode": "0x3E",
         "EventName": "UNC_C_SBO_CREDIT_OCCUPANCY.AD",
         "PerPkg": "1",
+        "PublicDescription": "Number of Sbo credits in use in a given cycl=
e, per ring.  Each Cbo is assigned an Sbo it can communicate with.",
         "UMask": "0x1",
         "Unit": "CBO"
     },
@@ -960,361 +1146,188 @@
         "EventCode": "0x3E",
         "EventName": "UNC_C_SBO_CREDIT_OCCUPANCY.BL",
         "PerPkg": "1",
+        "PublicDescription": "Number of Sbo credits in use in a given cycl=
e, per ring.  Each Cbo is assigned an Sbo it can communicate with.",
         "UMask": "0x2",
         "Unit": "CBO"
     },
-    {
-        "BriefDescription": "TOR Inserts; Opcode Match",
-        "Counter": "0,1,2,3",
-        "EventCode": "0x35",
-        "EventName": "UNC_C_TOR_INSERTS.OPCODE",
-        "PerPkg": "1",
-        "UMask": "0x1",
-        "Unit": "CBO"
-    },
-    {
-        "BriefDescription": "PCIe writes (partial cache line). Derived fro=
m unc_c_tor_inserts.opcode",
-        "Counter": "0,1,2,3",
-        "EventCode": "0x35",
-        "EventName": "LLC_REFERENCES.PCIE_NS_PARTIAL_WRITE",
-        "Filter": "filter_opc=3D0x180,filter_tid=3D0x3e",
-        "PerPkg": "1",
-        "UMask": "0x1",
-        "Unit": "CBO"
-    },
-    {
-        "BriefDescription": "L2 demand and L2 prefetch code references to =
LLC. Derived from unc_c_tor_inserts.opcode",
-        "Counter": "0,1,2,3",
-        "EventCode": "0x35",
-        "EventName": "LLC_REFERENCES.CODE_LLC_PREFETCH",
-        "Filter": "filter_opc=3D0x181",
-        "PerPkg": "1",
-        "ScaleUnit": "64Bytes",
-        "UMask": "0x1",
-        "Unit": "CBO"
-    },
-    {
-        "BriefDescription": "Streaming stores (full cache line). Derived f=
rom unc_c_tor_inserts.opcode",
-        "Counter": "0,1,2,3",
-        "EventCode": "0x35",
-        "EventName": "LLC_REFERENCES.STREAMING_FULL",
-        "Filter": "filter_opc=3D0x18c",
-        "PerPkg": "1",
-        "ScaleUnit": "64Bytes",
-        "UMask": "0x1",
-        "Unit": "CBO"
-    },
-    {
-        "BriefDescription": "Streaming stores (partial cache line). Derive=
d from unc_c_tor_inserts.opcode",
-        "Counter": "0,1,2,3",
-        "EventCode": "0x35",
-        "EventName": "LLC_REFERENCES.STREAMING_PARTIAL",
-        "Filter": "filter_opc=3D0x18d",
-        "PerPkg": "1",
-        "ScaleUnit": "64Bytes",
-        "UMask": "0x1",
-        "Unit": "CBO"
-    },
-    {
-        "BriefDescription": "PCIe read current. Derived from unc_c_tor_ins=
erts.opcode",
-        "Counter": "0,1,2,3",
-        "EventCode": "0x35",
-        "EventName": "LLC_REFERENCES.PCIE_READ",
-        "Filter": "filter_opc=3D0x19e",
-        "PerPkg": "1",
-        "ScaleUnit": "64Bytes",
-        "UMask": "0x1",
-        "Unit": "CBO"
-    },
-    {
-        "BriefDescription": "PCIe write references (full cache line). Deri=
ved from unc_c_tor_inserts.opcode",
-        "Counter": "0,1,2,3",
-        "EventCode": "0x35",
-        "EventName": "LLC_REFERENCES.PCIE_WRITE",
-        "Filter": "filter_opc=3D0x1c8,filter_tid=3D0x3e",
-        "PerPkg": "1",
-        "ScaleUnit": "64Bytes",
-        "UMask": "0x1",
-        "Unit": "CBO"
-    },
-    {
-        "BriefDescription": "TOR Inserts; Evictions",
-        "Counter": "0,1,2,3",
-        "EventCode": "0x35",
-        "EventName": "UNC_C_TOR_INSERTS.EVICTION",
-        "PerPkg": "1",
-        "UMask": "0x4",
-        "Unit": "CBO"
-    },
     {
         "BriefDescription": "TOR Inserts; All",
-        "Counter": "0,1,2,3",
         "EventCode": "0x35",
         "EventName": "UNC_C_TOR_INSERTS.ALL",
         "PerPkg": "1",
+        "PublicDescription": "Counts the number of entries successfully in=
serted into the TOR that match  qualifications specified by the subevent.  =
There are a number of subevent 'filters' but only a subset of the subevent =
combinations are valid.  Subevents that require an opcode or NID match requ=
ire the Cn_MSR_PMON_BOX_FILTER.{opc, nid} field to be set.  If, for example=
, one wanted to count DRD Local Misses, one should select MISS_OPC_MATCH an=
d set Cn_MSR_PMON_BOX_FILTER.opc  to DRD (0x182).; All transactions inserte=
d into the TOR.    This includes requests that reside in the TOR for a shor=
t time, such as LLC Hits that do not need to snoop cores or requests that g=
et rejected and have to be retried through one of the ingress queues.  The =
TOR is more commonly a bottleneck in skews with smaller core counts, where =
the ratio of RTIDs to TOR entries is larger.  Note that there are reserved =
TOR entries for various request types, so it is possible that a given reque=
st type be blocked with an occupancy that is less than 20.  Also note that =
generally requests will not be able to arbitrate into the TOR pipeline if t=
here are no available TOR slots.",
         "UMask": "0x8",
         "Unit": "CBO"
     },
     {
-        "BriefDescription": "TOR Inserts; Writebacks",
-        "Counter": "0,1,2,3",
-        "EventCode": "0x35",
-        "EventName": "UNC_C_TOR_INSERTS.WB",
-        "PerPkg": "1",
-        "UMask": "0x10",
-        "Unit": "CBO"
-    },
-    {
-        "BriefDescription": "TOR Inserts; Miss Opcode Match",
-        "Counter": "0,1,2,3",
-        "EventCode": "0x35",
-        "EventName": "UNC_C_TOR_INSERTS.MISS_OPCODE",
-        "PerPkg": "1",
-        "UMask": "0x3",
-        "Unit": "CBO"
-    },
-    {
-        "BriefDescription": "LLC misses - demand and prefetch data reads -=
 excludes LLC prefetches. Derived from unc_c_tor_inserts.miss_opcode",
-        "Counter": "0,1,2,3",
-        "EventCode": "0x35",
-        "EventName": "LLC_MISSES.DATA_READ",
-        "Filter": "filter_opc=3D0x182",
-        "PerPkg": "1",
-        "ScaleUnit": "64Bytes",
-        "UMask": "0x3",
-        "Unit": "CBO"
-    },
-    {
-        "BriefDescription": "LLC misses - Uncacheable reads (from cpu) . D=
erived from unc_c_tor_inserts.miss_opcode",
-        "Counter": "0,1,2,3",
-        "EventCode": "0x35",
-        "EventName": "LLC_MISSES.UNCACHEABLE",
-        "Filter": "filter_opc=3D0x187",
-        "PerPkg": "1",
-        "ScaleUnit": "64Bytes",
-        "UMask": "0x3",
-        "Unit": "CBO"
-    },
-    {
-        "BriefDescription": "MMIO reads. Derived from unc_c_tor_inserts.mi=
ss_opcode",
-        "Counter": "0,1,2,3",
-        "EventCode": "0x35",
-        "EventName": "LLC_MISSES.MMIO_READ",
-        "Filter": "filter_opc=3D0x187,filter_nc=3D1",
-        "PerPkg": "1",
-        "ScaleUnit": "64Bytes",
-        "UMask": "0x3",
-        "Unit": "CBO"
-    },
-    {
-        "BriefDescription": "MMIO writes. Derived from unc_c_tor_inserts.m=
iss_opcode",
-        "Counter": "0,1,2,3",
-        "EventCode": "0x35",
-        "EventName": "LLC_MISSES.MMIO_WRITE",
-        "Filter": "filter_opc=3D0x18f,filter_nc=3D1",
-        "PerPkg": "1",
-        "ScaleUnit": "64Bytes",
-        "UMask": "0x3",
-        "Unit": "CBO"
-    },
-    {
-        "BriefDescription": "LLC prefetch misses for RFO. Derived from unc=
_c_tor_inserts.miss_opcode",
-        "Counter": "0,1,2,3",
+        "BriefDescription": "TOR Inserts; Evictions",
         "EventCode": "0x35",
-        "EventName": "LLC_MISSES.RFO_LLC_PREFETCH",
-        "Filter": "filter_opc=3D0x190",
+        "EventName": "UNC_C_TOR_INSERTS.EVICTION",
         "PerPkg": "1",
-        "ScaleUnit": "64Bytes",
-        "UMask": "0x3",
+        "PublicDescription": "Counts the number of entries successfully in=
serted into the TOR that match  qualifications specified by the subevent.  =
There are a number of subevent 'filters' but only a subset of the subevent =
combinations are valid.  Subevents that require an opcode or NID match requ=
ire the Cn_MSR_PMON_BOX_FILTER.{opc, nid} field to be set.  If, for example=
, one wanted to count DRD Local Misses, one should select MISS_OPC_MATCH an=
d set Cn_MSR_PMON_BOX_FILTER.opc  to DRD (0x182).; Eviction transactions in=
serted into the TOR.  Evictions can be quick, such as when the line is in t=
he F, S, or E states and no core valid bits are set.  They can also be long=
er if either CV bits are set (so the cores need to be snooped) and/or if th=
ere is a HitM (in which case it is necessary to write the request out to me=
mory).",
+        "UMask": "0x4",
         "Unit": "CBO"
     },
     {
-        "BriefDescription": "LLC prefetch misses for code reads. Derived f=
rom unc_c_tor_inserts.miss_opcode",
-        "Counter": "0,1,2,3",
+        "BriefDescription": "TOR Inserts; Local Memory",
         "EventCode": "0x35",
-        "EventName": "LLC_MISSES.CODE_LLC_PREFETCH",
-        "Filter": "filter_opc=3D0x191",
+        "EventName": "UNC_C_TOR_INSERTS.LOCAL",
         "PerPkg": "1",
-        "ScaleUnit": "64Bytes",
-        "UMask": "0x3",
+        "PublicDescription": "Counts the number of entries successfully in=
serted into the TOR that match  qualifications specified by the subevent.  =
There are a number of subevent 'filters' but only a subset of the subevent =
combinations are valid.  Subevents that require an opcode or NID match requ=
ire the Cn_MSR_PMON_BOX_FILTER.{opc, nid} field to be set.  If, for example=
, one wanted to count DRD Local Misses, one should select MISS_OPC_MATCH an=
d set Cn_MSR_PMON_BOX_FILTER.opc  to DRD (0x182).; All transactions inserte=
d into the TOR that are satisfied by locally HOMed memory.",
+        "UMask": "0x28",
         "Unit": "CBO"
     },
     {
-        "BriefDescription": "LLC prefetch misses for data reads. Derived f=
rom unc_c_tor_inserts.miss_opcode",
-        "Counter": "0,1,2,3",
+        "BriefDescription": "TOR Inserts; Local Memory - Opcode Matched",
         "EventCode": "0x35",
-        "EventName": "LLC_MISSES.DATA_LLC_PREFETCH",
-        "Filter": "filter_opc=3D0x192",
+        "EventName": "UNC_C_TOR_INSERTS.LOCAL_OPCODE",
         "PerPkg": "1",
-        "ScaleUnit": "64Bytes",
-        "UMask": "0x3",
+        "PublicDescription": "Counts the number of entries successfully in=
serted into the TOR that match qualifications specified by the subevent. Th=
ere are a number of subevent 'filters' but only a subset of the subevent co=
mbinations are valid.  Subevents that require an opcode or NID match requir=
e the Cn_MSR_PMON_BOX_FILTER.{opc, nid} field to be set.  If, for example, =
one wanted to count DRD Local Misses, one should select MISS_OPC_MATCH and =
set Cn_MSR_PMON_BOX_FILTER.opc  to DRD (0x182).; All transactions, satisfie=
d by an opcode,  inserted into the TOR that are satisfied by locally HOMed =
memory.",
+        "UMask": "0x21",
         "Unit": "CBO"
     },
     {
-        "BriefDescription": "LLC misses for PCIe read current. Derived fro=
m unc_c_tor_inserts.miss_opcode",
-        "Counter": "0,1,2,3",
+        "BriefDescription": "TOR Inserts; Misses to Local Memory",
         "EventCode": "0x35",
-        "EventName": "LLC_MISSES.PCIE_READ",
-        "Filter": "filter_opc=3D0x19e",
+        "EventName": "UNC_C_TOR_INSERTS.MISS_LOCAL",
         "PerPkg": "1",
-        "ScaleUnit": "64Bytes",
-        "UMask": "0x3",
+        "PublicDescription": "Counts the number of entries successfully in=
serted into the TOR that match  qualifications specified by the subevent.  =
There are a number of subevent 'filters' but only a subset of the subevent =
combinations are valid.  Subevents that require an opcode or NID match requ=
ire the Cn_MSR_PMON_BOX_FILTER.{opc, nid} field to be set.  If, for example=
, one wanted to count DRD Local Misses, one should select MISS_OPC_MATCH an=
d set Cn_MSR_PMON_BOX_FILTER.opc  to DRD (0x182).; Miss transactions insert=
ed into the TOR that are satisfied by locally HOMed memory.",
+        "UMask": "0x2a",
         "Unit": "CBO"
     },
     {
-        "BriefDescription": "ItoM write misses (as part of fast string mem=
cpy stores) + PCIe full line writes. Derived from unc_c_tor_inserts.miss_op=
code",
-        "Counter": "0,1,2,3",
+        "BriefDescription": "TOR Inserts; Misses to Local Memory - Opcode =
Matched",
         "EventCode": "0x35",
-        "EventName": "LLC_MISSES.PCIE_WRITE",
-        "Filter": "filter_opc=3D0x1c8",
+        "EventName": "UNC_C_TOR_INSERTS.MISS_LOCAL_OPCODE",
         "PerPkg": "1",
-        "ScaleUnit": "64Bytes",
-        "UMask": "0x3",
+        "PublicDescription": "Counts the number of entries successfully in=
serted into the TOR that match  qualifications specified by the subevent.  =
There are a number of subevent 'filters' but only a subset of the subevent =
combinations are valid.  Subevents that require an opcode or NID match requ=
ire the Cn_MSR_PMON_BOX_FILTER.{opc, nid} field to be set.  If, for example=
, one wanted to count DRD Local Misses, one should select MISS_OPC_MATCH an=
d set Cn_MSR_PMON_BOX_FILTER.opc  to DRD (0x182).; Miss transactions, satis=
fied by an opcode, inserted into the TOR that are satisfied by locally HOMe=
d memory.",
+        "UMask": "0x23",
         "Unit": "CBO"
     },
     {
-        "BriefDescription": "PCIe write misses (full cache line). Derived =
from unc_c_tor_inserts.miss_opcode",
-        "Counter": "0,1,2,3",
+        "BriefDescription": "TOR Inserts; Miss Opcode Match",
         "EventCode": "0x35",
-        "EventName": "LLC_MISSES.PCIE_NON_SNOOP_WRITE",
-        "Filter": "filter_opc=3D0x1c8,filter_tid=3D0x3e",
+        "EventName": "UNC_C_TOR_INSERTS.MISS_OPCODE",
         "PerPkg": "1",
-        "ScaleUnit": "64Bytes",
+        "PublicDescription": "Counts the number of entries successfully in=
serted into the TOR that match  qualifications specified by the subevent.  =
There are a number of subevent 'filters' but only a subset of the subevent =
combinations are valid.  Subevents that require an opcode or NID match requ=
ire the Cn_MSR_PMON_BOX_FILTER.{opc, nid} field to be set.  If, for example=
, one wanted to count DRD Local Misses, one should select MISS_OPC_MATCH an=
d set Cn_MSR_PMON_BOX_FILTER.opc  to DRD (0x182).; Miss transactions insert=
ed into the TOR that match an opcode.",
         "UMask": "0x3",
         "Unit": "CBO"
     },
     {
-        "BriefDescription": "TOR Inserts; NID and Opcode Matched",
-        "Counter": "0,1,2,3",
+        "BriefDescription": "TOR Inserts; Misses to Remote Memory",
         "EventCode": "0x35",
-        "EventName": "UNC_C_TOR_INSERTS.NID_OPCODE",
+        "EventName": "UNC_C_TOR_INSERTS.MISS_REMOTE",
         "PerPkg": "1",
-        "UMask": "0x41",
+        "PublicDescription": "Counts the number of entries successfully in=
serted into the TOR that match  qualifications specified by the subevent.  =
There are a number of subevent 'filters' but only a subset of the subevent =
combinations are valid.  Subevents that require an opcode or NID match requ=
ire the Cn_MSR_PMON_BOX_FILTER.{opc, nid} field to be set.  If, for example=
, one wanted to count DRD Local Misses, one should select MISS_OPC_MATCH an=
d set Cn_MSR_PMON_BOX_FILTER.opc  to DRD (0x182).; Miss transactions insert=
ed into the TOR that are satisfied by remote caches or remote memory.",
+        "UMask": "0x8a",
         "Unit": "CBO"
     },
     {
-        "BriefDescription": "TOR Inserts; NID Matched Evictions",
-        "Counter": "0,1,2,3",
+        "BriefDescription": "TOR Inserts; Misses to Remote Memory - Opcode=
 Matched",
         "EventCode": "0x35",
-        "EventName": "UNC_C_TOR_INSERTS.NID_EVICTION",
+        "EventName": "UNC_C_TOR_INSERTS.MISS_REMOTE_OPCODE",
         "PerPkg": "1",
-        "UMask": "0x44",
+        "PublicDescription": "Counts the number of entries successfully in=
serted into the TOR that match  qualifications specified by the subevent.  =
There are a number of subevent 'filters' but only a subset of the subevent =
combinations are valid.  Subevents that require an opcode or NID match requ=
ire the Cn_MSR_PMON_BOX_FILTER.{opc, nid} field to be set.  If, for example=
, one wanted to count DRD Local Misses, one should select MISS_OPC_MATCH an=
d set Cn_MSR_PMON_BOX_FILTER.opc  to DRD (0x182).; Miss transactions, satis=
fied by an opcode,  inserted into the TOR that are satisfied by remote cach=
es or remote memory.",
+        "UMask": "0x83",
         "Unit": "CBO"
     },
     {
         "BriefDescription": "TOR Inserts; NID Matched",
-        "Counter": "0,1,2,3",
         "EventCode": "0x35",
         "EventName": "UNC_C_TOR_INSERTS.NID_ALL",
         "PerPkg": "1",
+        "PublicDescription": "Counts the number of entries successfully in=
serted into the TOR that match  qualifications specified by the subevent.  =
There are a number of subevent 'filters' but only a subset of the subevent =
combinations are valid.  Subevents that require an opcode or NID match requ=
ire the Cn_MSR_PMON_BOX_FILTER.{opc, nid} field to be set.  If, for example=
, one wanted to count DRD Local Misses, one should select MISS_OPC_MATCH an=
d set Cn_MSR_PMON_BOX_FILTER.opc  to DRD (0x182).; All NID matched (matches=
 an RTID destination) transactions inserted into the TOR.  The NID is progr=
ammed in Cn_MSR_PMON_BOX_FILTER.nid.  In conjunction with STATE =3D I, it i=
s possible to monitor misses to specific NIDs in the system.",
         "UMask": "0x48",
         "Unit": "CBO"
     },
     {
-        "BriefDescription": "TOR Inserts; NID Matched Writebacks",
-        "Counter": "0,1,2,3",
+        "BriefDescription": "TOR Inserts; NID Matched Evictions",
         "EventCode": "0x35",
-        "EventName": "UNC_C_TOR_INSERTS.NID_WB",
+        "EventName": "UNC_C_TOR_INSERTS.NID_EVICTION",
         "PerPkg": "1",
-        "UMask": "0x50",
+        "PublicDescription": "Counts the number of entries successfully in=
serted into the TOR that match  qualifications specified by the subevent.  =
There are a number of subevent 'filters' but only a subset of the subevent =
combinations are valid.  Subevents that require an opcode or NID match requ=
ire the Cn_MSR_PMON_BOX_FILTER.{opc, nid} field to be set.  If, for example=
, one wanted to count DRD Local Misses, one should select MISS_OPC_MATCH an=
d set Cn_MSR_PMON_BOX_FILTER.opc  to DRD (0x182).; NID matched eviction tra=
nsactions inserted into the TOR.",
+        "UMask": "0x44",
         "Unit": "CBO"
     },
     {
-        "BriefDescription": "TOR Inserts; NID and Opcode Matched Miss",
-        "Counter": "0,1,2,3",
+        "BriefDescription": "TOR Inserts; NID Matched Miss All",
         "EventCode": "0x35",
-        "EventName": "UNC_C_TOR_INSERTS.NID_MISS_OPCODE",
+        "EventName": "UNC_C_TOR_INSERTS.NID_MISS_ALL",
         "PerPkg": "1",
-        "UMask": "0x43",
+        "PublicDescription": "Counts the number of entries successfully in=
serted into the TOR that match  qualifications specified by the subevent.  =
There are a number of subevent 'filters' but only a subset of the subevent =
combinations are valid.  Subevents that require an opcode or NID match requ=
ire the Cn_MSR_PMON_BOX_FILTER.{opc, nid} field to be set.  If, for example=
, one wanted to count DRD Local Misses, one should select MISS_OPC_MATCH an=
d set Cn_MSR_PMON_BOX_FILTER.opc  to DRD (0x182).; All NID matched miss req=
uests that were inserted into the TOR.",
+        "UMask": "0x4a",
         "Unit": "CBO"
     },
     {
-        "BriefDescription": "TOR Inserts; NID Matched Miss All",
-        "Counter": "0,1,2,3",
+        "BriefDescription": "TOR Inserts; NID and Opcode Matched Miss",
         "EventCode": "0x35",
-        "EventName": "UNC_C_TOR_INSERTS.NID_MISS_ALL",
+        "EventName": "UNC_C_TOR_INSERTS.NID_MISS_OPCODE",
         "PerPkg": "1",
-        "UMask": "0x4A",
+        "PublicDescription": "Counts the number of entries successfully in=
serted into the TOR that match  qualifications specified by the subevent.  =
There are a number of subevent 'filters' but only a subset of the subevent =
combinations are valid.  Subevents that require an opcode or NID match requ=
ire the Cn_MSR_PMON_BOX_FILTER.{opc, nid} field to be set.  If, for example=
, one wanted to count DRD Local Misses, one should select MISS_OPC_MATCH an=
d set Cn_MSR_PMON_BOX_FILTER.opc  to DRD (0x182).; Miss transactions insert=
ed into the TOR that match a NID and an opcode.",
+        "UMask": "0x43",
         "Unit": "CBO"
     },
     {
-        "BriefDescription": "TOR Inserts; Misses to Local Memory",
-        "Counter": "0,1,2,3",
+        "BriefDescription": "TOR Inserts; NID and Opcode Matched",
         "EventCode": "0x35",
-        "EventName": "UNC_C_TOR_INSERTS.MISS_LOCAL",
+        "EventName": "UNC_C_TOR_INSERTS.NID_OPCODE",
         "PerPkg": "1",
-        "UMask": "0x2A",
+        "PublicDescription": "Counts the number of entries successfully in=
serted into the TOR that match  qualifications specified by the subevent.  =
There are a number of subevent 'filters' but only a subset of the subevent =
combinations are valid.  Subevents that require an opcode or NID match requ=
ire the Cn_MSR_PMON_BOX_FILTER.{opc, nid} field to be set.  If, for example=
, one wanted to count DRD Local Misses, one should select MISS_OPC_MATCH an=
d set Cn_MSR_PMON_BOX_FILTER.opc  to DRD (0x182).; Transactions inserted in=
to the TOR that match a NID and an opcode.",
+        "UMask": "0x41",
         "Unit": "CBO"
     },
     {
-        "BriefDescription": "TOR Inserts; Misses to Remote Memory",
-        "Counter": "0,1,2,3",
+        "BriefDescription": "TOR Inserts; NID Matched Writebacks",
         "EventCode": "0x35",
-        "EventName": "UNC_C_TOR_INSERTS.MISS_REMOTE",
+        "EventName": "UNC_C_TOR_INSERTS.NID_WB",
         "PerPkg": "1",
-        "UMask": "0x8A",
+        "PublicDescription": "Counts the number of entries successfully in=
serted into the TOR that match  qualifications specified by the subevent.  =
There are a number of subevent 'filters' but only a subset of the subevent =
combinations are valid.  Subevents that require an opcode or NID match requ=
ire the Cn_MSR_PMON_BOX_FILTER.{opc, nid} field to be set.  If, for example=
, one wanted to count DRD Local Misses, one should select MISS_OPC_MATCH an=
d set Cn_MSR_PMON_BOX_FILTER.opc  to DRD (0x182).; NID matched write transa=
ctions inserted into the TOR.",
+        "UMask": "0x50",
         "Unit": "CBO"
     },
     {
-        "BriefDescription": "TOR Inserts; Local Memory",
-        "Counter": "0,1,2,3",
+        "BriefDescription": "TOR Inserts; Opcode Match",
         "EventCode": "0x35",
-        "EventName": "UNC_C_TOR_INSERTS.LOCAL",
+        "EventName": "UNC_C_TOR_INSERTS.OPCODE",
         "PerPkg": "1",
-        "UMask": "0x28",
+        "PublicDescription": "Counts the number of entries successfully in=
serted into the TOR that match  qualifications specified by the subevent.  =
There are a number of subevent 'filters' but only a subset of the subevent =
combinations are valid.  Subevents that require an opcode or NID match requ=
ire the Cn_MSR_PMON_BOX_FILTER.{opc, nid} field to be set.  If, for example=
, one wanted to count DRD Local Misses, one should select MISS_OPC_MATCH an=
d set Cn_MSR_PMON_BOX_FILTER.opc  to DRD (0x182).; Transactions inserted in=
to the TOR that match an opcode (matched by Cn_MSR_PMON_BOX_FILTER.opc)",
+        "UMask": "0x1",
         "Unit": "CBO"
     },
     {
         "BriefDescription": "TOR Inserts; Remote Memory",
-        "Counter": "0,1,2,3",
         "EventCode": "0x35",
         "EventName": "UNC_C_TOR_INSERTS.REMOTE",
         "PerPkg": "1",
+        "PublicDescription": "Counts the number of entries successfully in=
serted into the TOR that match  qualifications specified by the subevent.  =
There are a number of subevent 'filters' but only a subset of the subevent =
combinations are valid.  Subevents that require an opcode or NID match requ=
ire the Cn_MSR_PMON_BOX_FILTER.{opc, nid} field to be set.  If, for example=
, one wanted to count DRD Local Misses, one should select MISS_OPC_MATCH an=
d set Cn_MSR_PMON_BOX_FILTER.opc  to DRD (0x182).; All transactions inserte=
d into the TOR that are satisfied by remote caches or remote memory.",
         "UMask": "0x88",
         "Unit": "CBO"
     },
     {
-        "BriefDescription": "TOR Inserts; Misses to Local Memory - Opcode =
Matched",
-        "Counter": "0,1,2,3",
-        "EventCode": "0x35",
-        "EventName": "UNC_C_TOR_INSERTS.MISS_LOCAL_OPCODE",
-        "PerPkg": "1",
-        "UMask": "0x23",
-        "Unit": "CBO"
-    },
-    {
-        "BriefDescription": "TOR Inserts; Misses to Remote Memory - Opcode=
 Matched",
-        "Counter": "0,1,2,3",
-        "EventCode": "0x35",
-        "EventName": "UNC_C_TOR_INSERTS.MISS_REMOTE_OPCODE",
-        "PerPkg": "1",
-        "UMask": "0x83",
-        "Unit": "CBO"
-    },
-    {
-        "BriefDescription": "TOR Inserts; Local Memory - Opcode Matched",
-        "Counter": "0,1,2,3",
+        "BriefDescription": "TOR Inserts; Remote Memory - Opcode Matched",
         "EventCode": "0x35",
-        "EventName": "UNC_C_TOR_INSERTS.LOCAL_OPCODE",
+        "EventName": "UNC_C_TOR_INSERTS.REMOTE_OPCODE",
         "PerPkg": "1",
-        "UMask": "0x21",
+        "PublicDescription": "Counts the number of entries successfully in=
serted into the TOR that match  qualifications specified by the subevent.  =
There are a number of subevent 'filters' but only a subset of the subevent =
combinations are valid.  Subevents that require an opcode or NID match requ=
ire the Cn_MSR_PMON_BOX_FILTER.{opc, nid} field to be set.  If, for example=
, one wanted to count DRD Local Misses, one should select MISS_OPC_MATCH an=
d set Cn_MSR_PMON_BOX_FILTER.opc  to DRD (0x182).; All transactions, satisf=
ied by an opcode,  inserted into the TOR that are satisfied by remote cache=
s or remote memory.",
+        "UMask": "0x81",
         "Unit": "CBO"
     },
     {
-        "BriefDescription": "TOR Inserts; Remote Memory - Opcode Matched",
-        "Counter": "0,1,2,3",
+        "BriefDescription": "TOR Inserts; Writebacks",
         "EventCode": "0x35",
-        "EventName": "UNC_C_TOR_INSERTS.REMOTE_OPCODE",
+        "EventName": "UNC_C_TOR_INSERTS.WB",
         "PerPkg": "1",
-        "UMask": "0x81",
+        "PublicDescription": "Counts the number of entries successfully in=
serted into the TOR that match  qualifications specified by the subevent.  =
There are a number of subevent 'filters' but only a subset of the subevent =
combinations are valid.  Subevents that require an opcode or NID match requ=
ire the Cn_MSR_PMON_BOX_FILTER.{opc, nid} field to be set.  If, for example=
, one wanted to count DRD Local Misses, one should select MISS_OPC_MATCH an=
d set Cn_MSR_PMON_BOX_FILTER.opc  to DRD (0x182).; Write transactions inser=
ted into the TOR.   This does not include RFO, but actual operations that c=
ontain data being sent from the core.",
+        "UMask": "0x10",
         "Unit": "CBO"
     },
     {
-        "BriefDescription": "TOR Occupancy; Opcode Match",
+        "BriefDescription": "TOR Occupancy; Any",
         "EventCode": "0x36",
-        "EventName": "UNC_C_TOR_OCCUPANCY.OPCODE",
+        "EventName": "UNC_C_TOR_OCCUPANCY.ALL",
         "PerPkg": "1",
-        "UMask": "0x1",
+        "PublicDescription": "For each cycle, this event accumulates the n=
umber of valid entries in the TOR that match qualifications specified by th=
e subevent.   There are a number of subevent 'filters' but only a subset of=
 the subevent combinations are valid.  Subevents that require an opcode or =
NID match require the Cn_MSR_PMON_BOX_FILTER.{opc, nid} field to be set.  I=
f, for example, one wanted to count DRD Local Misses, one should select MIS=
S_OPC_MATCH and set Cn_MSR_PMON_BOX_FILTER.opc to DRD (0x182); All valid TO=
R entries.  This includes requests that reside in the TOR for a short time,=
 such as LLC Hits that do not need to snoop cores or requests that get reje=
cted and have to be retried through one of the ingress queues.  The TOR is =
more commonly a bottleneck in skews with smaller core counts, where the rat=
io of RTIDs to TOR entries is larger.  Note that there are reserved TOR ent=
ries for various request types, so it is possible that a given request type=
 be blocked with an occupancy that is less than 20.  Also note that general=
ly requests will not be able to arbitrate into the TOR pipeline if there ar=
e no available TOR slots.",
+        "UMask": "0x8",
         "Unit": "CBO"
     },
     {
@@ -1322,33 +1335,36 @@
         "EventCode": "0x36",
         "EventName": "UNC_C_TOR_OCCUPANCY.EVICTION",
         "PerPkg": "1",
+        "PublicDescription": "For each cycle, this event accumulates the n=
umber of valid entries in the TOR that match qualifications specified by th=
e subevent.   There are a number of subevent 'filters' but only a subset of=
 the subevent combinations are valid.  Subevents that require an opcode or =
NID match require the Cn_MSR_PMON_BOX_FILTER.{opc, nid} field to be set.  I=
f, for example, one wanted to count DRD Local Misses, one should select MIS=
S_OPC_MATCH and set Cn_MSR_PMON_BOX_FILTER.opc to DRD (0x182); Number of ou=
tstanding eviction transactions in the TOR.  Evictions can be quick, such a=
s when the line is in the F, S, or E states and no core valid bits are set.=
  They can also be longer if either CV bits are set (so the cores need to b=
e snooped) and/or if there is a HitM (in which case it is necessary to writ=
e the request out to memory).",
         "UMask": "0x4",
         "Unit": "CBO"
     },
     {
-        "BriefDescription": "TOR Occupancy; Any",
+        "BriefDescription": "Occupancy counter for LLC data reads (demand =
and L2 prefetch). Derived from unc_c_tor_occupancy.miss_opcode",
         "EventCode": "0x36",
-        "EventName": "UNC_C_TOR_OCCUPANCY.ALL",
+        "EventName": "UNC_C_TOR_OCCUPANCY.LLC_DATA_READ",
+        "Filter": "filter_opc=3D0x182",
         "PerPkg": "1",
-        "UMask": "0x8",
+        "PublicDescription": "For each cycle, this event accumulates the n=
umber of valid entries in the TOR that match qualifications specified by th=
e subevent.   There are a number of subevent 'filters' but only a subset of=
 the subevent combinations are valid.  Subevents that require an opcode or =
NID match require the Cn_MSR_PMON_BOX_FILTER.{opc, nid} field to be set.  I=
f, for example, one wanted to count DRD Local Misses, one should select MIS=
S_OPC_MATCH and set Cn_MSR_PMON_BOX_FILTER.opc to DRD (0x182); TOR entries =
for miss transactions that match an opcode. This generally means that the r=
equest was sent to memory or MMIO.",
+        "UMask": "0x3",
         "Unit": "CBO"
     },
     {
-        "BriefDescription": "Occupancy counter for LLC data reads (demand =
and L2 prefetch). Derived from unc_c_tor_occupancy.miss_opcode",
+        "BriefDescription": "TOR Occupancy",
         "EventCode": "0x36",
-        "EventName": "UNC_C_TOR_OCCUPANCY.LLC_DATA_READ",
-        "Filter": "filter_opc=3D0x182",
+        "EventName": "UNC_C_TOR_OCCUPANCY.LOCAL",
         "PerPkg": "1",
-        "UMask": "0x3",
+        "PublicDescription": "For each cycle, this event accumulates the n=
umber of valid entries in the TOR that match qualifications specified by th=
e subevent.   There are a number of subevent 'filters' but only a subset of=
 the subevent combinations are valid.  Subevents that require an opcode or =
NID match require the Cn_MSR_PMON_BOX_FILTER.{opc, nid} field to be set.  I=
f, for example, one wanted to count DRD Local Misses, one should select MIS=
S_OPC_MATCH and set Cn_MSR_PMON_BOX_FILTER.opc to DRD (0x182)",
+        "UMask": "0x28",
         "Unit": "CBO"
     },
     {
-        "BriefDescription": "Occupancy counter for LLC data reads (demand =
and L2 prefetch)",
+        "BriefDescription": "TOR Occupancy; Local Memory - Opcode Matched"=
,
         "EventCode": "0x36",
-        "EventName": "UNC_C_TOR_OCCUPANCY.MISS_OPCODE",
-        "Filter": "filter_opc=3D0x182",
+        "EventName": "UNC_C_TOR_OCCUPANCY.LOCAL_OPCODE",
         "PerPkg": "1",
-        "UMask": "0x3",
+        "PublicDescription": "For each cycle, this event accumulates the n=
umber of valid entries in the TOR that match qualifications specified by th=
e subevent.   There are a number of subevent 'filters' but only a subset of=
 the subevent combinations are valid.  Subevents that require an opcode or =
NID match require the Cn_MSR_PMON_BOX_FILTER.{opc, nid} field to be set.  I=
f, for example, one wanted to count DRD Local Misses, one should select MIS=
S_OPC_MATCH and set Cn_MSR_PMON_BOX_FILTER.opc to DRD (0x182); Number of ou=
tstanding  transactions, satisfied by an opcode,  in the TOR that are satis=
fied by locally HOMed memory.",
+        "UMask": "0x21",
         "Unit": "CBO"
     },
     {
@@ -1356,103 +1372,125 @@
         "EventCode": "0x36",
         "EventName": "UNC_C_TOR_OCCUPANCY.MISS_ALL",
         "PerPkg": "1",
-        "UMask": "0xA",
+        "PublicDescription": "For each cycle, this event accumulates the n=
umber of valid entries in the TOR that match qualifications specified by th=
e subevent.   There are a number of subevent 'filters' but only a subset of=
 the subevent combinations are valid.  Subevents that require an opcode or =
NID match require the Cn_MSR_PMON_BOX_FILTER.{opc, nid} field to be set.  I=
f, for example, one wanted to count DRD Local Misses, one should select MIS=
S_OPC_MATCH and set Cn_MSR_PMON_BOX_FILTER.opc to DRD (0x182); Number of ou=
tstanding miss requests in the TOR.  'Miss' means the allocation requires a=
n RTID.  This generally means that the request was sent to memory or MMIO."=
,
+        "UMask": "0xa",
         "Unit": "CBO"
     },
     {
-        "BriefDescription": "TOR Occupancy; NID and Opcode Matched",
+        "BriefDescription": "TOR Occupancy",
         "EventCode": "0x36",
-        "EventName": "UNC_C_TOR_OCCUPANCY.NID_OPCODE",
+        "EventName": "UNC_C_TOR_OCCUPANCY.MISS_LOCAL",
         "PerPkg": "1",
-        "UMask": "0x41",
+        "PublicDescription": "For each cycle, this event accumulates the n=
umber of valid entries in the TOR that match qualifications specified by th=
e subevent.   There are a number of subevent 'filters' but only a subset of=
 the subevent combinations are valid.  Subevents that require an opcode or =
NID match require the Cn_MSR_PMON_BOX_FILTER.{opc, nid} field to be set.  I=
f, for example, one wanted to count DRD Local Misses, one should select MIS=
S_OPC_MATCH and set Cn_MSR_PMON_BOX_FILTER.opc to DRD (0x182)",
+        "UMask": "0x2a",
         "Unit": "CBO"
     },
     {
-        "BriefDescription": "TOR Occupancy; NID Matched Evictions",
+        "BriefDescription": "TOR Occupancy; Misses to Local Memory - Opcod=
e Matched",
         "EventCode": "0x36",
-        "EventName": "UNC_C_TOR_OCCUPANCY.NID_EVICTION",
+        "EventName": "UNC_C_TOR_OCCUPANCY.MISS_LOCAL_OPCODE",
         "PerPkg": "1",
-        "UMask": "0x44",
+        "PublicDescription": "For each cycle, this event accumulates the n=
umber of valid entries in the TOR that match qualifications specified by th=
e subevent.   There are a number of subevent 'filters' but only a subset of=
 the subevent combinations are valid.  Subevents that require an opcode or =
NID match require the Cn_MSR_PMON_BOX_FILTER.{opc, nid} field to be set.  I=
f, for example, one wanted to count DRD Local Misses, one should select MIS=
S_OPC_MATCH and set Cn_MSR_PMON_BOX_FILTER.opc to DRD (0x182); Number of ou=
tstanding Miss transactions, satisfied by an opcode, in the TOR that are sa=
tisfied by locally HOMed memory.",
+        "UMask": "0x23",
         "Unit": "CBO"
     },
     {
-        "BriefDescription": "TOR Occupancy; NID Matched",
+        "BriefDescription": "TOR Occupancy; Miss Opcode Match",
         "EventCode": "0x36",
-        "EventName": "UNC_C_TOR_OCCUPANCY.NID_ALL",
+        "EventName": "UNC_C_TOR_OCCUPANCY.MISS_OPCODE",
         "PerPkg": "1",
-        "UMask": "0x48",
+        "PublicDescription": "For each cycle, this event accumulates the n=
umber of valid entries in the TOR that match qualifications specified by th=
e subevent.   There are a number of subevent 'filters' but only a subset of=
 the subevent combinations are valid.  Subevents that require an opcode or =
NID match require the Cn_MSR_PMON_BOX_FILTER.{opc, nid} field to be set.  I=
f, for example, one wanted to count DRD Local Misses, one should select MIS=
S_OPC_MATCH and set Cn_MSR_PMON_BOX_FILTER.opc to DRD (0x182); TOR entries =
for miss transactions that match an opcode. This generally means that the r=
equest was sent to memory or MMIO.",
+        "UMask": "0x3",
         "Unit": "CBO"
     },
     {
-        "BriefDescription": "TOR Occupancy; NID and Opcode Matched Miss",
+        "BriefDescription": "TOR Occupancy",
         "EventCode": "0x36",
-        "EventName": "UNC_C_TOR_OCCUPANCY.NID_MISS_OPCODE",
+        "EventName": "UNC_C_TOR_OCCUPANCY.MISS_REMOTE",
         "PerPkg": "1",
-        "UMask": "0x43",
+        "PublicDescription": "For each cycle, this event accumulates the n=
umber of valid entries in the TOR that match qualifications specified by th=
e subevent.   There are a number of subevent 'filters' but only a subset of=
 the subevent combinations are valid.  Subevents that require an opcode or =
NID match require the Cn_MSR_PMON_BOX_FILTER.{opc, nid} field to be set.  I=
f, for example, one wanted to count DRD Local Misses, one should select MIS=
S_OPC_MATCH and set Cn_MSR_PMON_BOX_FILTER.opc to DRD (0x182)",
+        "UMask": "0x8a",
+        "Unit": "CBO"
+    },
+    {
+        "BriefDescription": "TOR Occupancy; Misses to Remote Memory - Opco=
de Matched",
+        "EventCode": "0x36",
+        "EventName": "UNC_C_TOR_OCCUPANCY.MISS_REMOTE_OPCODE",
+        "PerPkg": "1",
+        "PublicDescription": "For each cycle, this event accumulates the n=
umber of valid entries in the TOR that match qualifications specified by th=
e subevent.   There are a number of subevent 'filters' but only a subset of=
 the subevent combinations are valid.  Subevents that require an opcode or =
NID match require the Cn_MSR_PMON_BOX_FILTER.{opc, nid} field to be set.  I=
f, for example, one wanted to count DRD Local Misses, one should select MIS=
S_OPC_MATCH and set Cn_MSR_PMON_BOX_FILTER.opc to DRD (0x182); Number of ou=
tstanding Miss transactions, satisfied by an opcode, in the TOR that are sa=
tisfied by remote caches or remote memory.",
+        "UMask": "0x83",
         "Unit": "CBO"
     },
     {
         "BriefDescription": "TOR Occupancy; NID Matched",
         "EventCode": "0x36",
-        "EventName": "UNC_C_TOR_OCCUPANCY.NID_MISS_ALL",
+        "EventName": "UNC_C_TOR_OCCUPANCY.NID_ALL",
         "PerPkg": "1",
-        "UMask": "0x4A",
+        "PublicDescription": "For each cycle, this event accumulates the n=
umber of valid entries in the TOR that match qualifications specified by th=
e subevent.   There are a number of subevent 'filters' but only a subset of=
 the subevent combinations are valid.  Subevents that require an opcode or =
NID match require the Cn_MSR_PMON_BOX_FILTER.{opc, nid} field to be set.  I=
f, for example, one wanted to count DRD Local Misses, one should select MIS=
S_OPC_MATCH and set Cn_MSR_PMON_BOX_FILTER.opc to DRD (0x182); Number of NI=
D matched outstanding requests in the TOR.  The NID is programmed in Cn_MSR=
_PMON_BOX_FILTER.nid.In conjunction with STATE =3D I, it is possible to mon=
itor misses to specific NIDs in the system.",
+        "UMask": "0x48",
         "Unit": "CBO"
     },
     {
-        "BriefDescription": "TOR Occupancy",
+        "BriefDescription": "TOR Occupancy; NID Matched Evictions",
         "EventCode": "0x36",
-        "EventName": "UNC_C_TOR_OCCUPANCY.MISS_LOCAL",
+        "EventName": "UNC_C_TOR_OCCUPANCY.NID_EVICTION",
         "PerPkg": "1",
-        "UMask": "0x2A",
+        "PublicDescription": "For each cycle, this event accumulates the n=
umber of valid entries in the TOR that match qualifications specified by th=
e subevent.   There are a number of subevent 'filters' but only a subset of=
 the subevent combinations are valid.  Subevents that require an opcode or =
NID match require the Cn_MSR_PMON_BOX_FILTER.{opc, nid} field to be set.  I=
f, for example, one wanted to count DRD Local Misses, one should select MIS=
S_OPC_MATCH and set Cn_MSR_PMON_BOX_FILTER.opc to DRD (0x182); Number of ou=
tstanding NID matched eviction transactions in the TOR .",
+        "UMask": "0x44",
         "Unit": "CBO"
     },
     {
-        "BriefDescription": "TOR Occupancy",
+        "BriefDescription": "TOR Occupancy; NID Matched",
         "EventCode": "0x36",
-        "EventName": "UNC_C_TOR_OCCUPANCY.MISS_REMOTE",
+        "EventName": "UNC_C_TOR_OCCUPANCY.NID_MISS_ALL",
         "PerPkg": "1",
-        "UMask": "0x8A",
+        "PublicDescription": "For each cycle, this event accumulates the n=
umber of valid entries in the TOR that match qualifications specified by th=
e subevent.   There are a number of subevent 'filters' but only a subset of=
 the subevent combinations are valid.  Subevents that require an opcode or =
NID match require the Cn_MSR_PMON_BOX_FILTER.{opc, nid} field to be set.  I=
f, for example, one wanted to count DRD Local Misses, one should select MIS=
S_OPC_MATCH and set Cn_MSR_PMON_BOX_FILTER.opc to DRD (0x182); Number of ou=
tstanding Miss requests in the TOR that match a NID.",
+        "UMask": "0x4a",
         "Unit": "CBO"
     },
     {
-        "BriefDescription": "TOR Occupancy",
+        "BriefDescription": "TOR Occupancy; NID and Opcode Matched Miss",
         "EventCode": "0x36",
-        "EventName": "UNC_C_TOR_OCCUPANCY.LOCAL",
+        "EventName": "UNC_C_TOR_OCCUPANCY.NID_MISS_OPCODE",
         "PerPkg": "1",
-        "UMask": "0x28",
+        "PublicDescription": "For each cycle, this event accumulates the n=
umber of valid entries in the TOR that match qualifications specified by th=
e subevent.   There are a number of subevent 'filters' but only a subset of=
 the subevent combinations are valid.  Subevents that require an opcode or =
NID match require the Cn_MSR_PMON_BOX_FILTER.{opc, nid} field to be set.  I=
f, for example, one wanted to count DRD Local Misses, one should select MIS=
S_OPC_MATCH and set Cn_MSR_PMON_BOX_FILTER.opc to DRD (0x182); Number of ou=
tstanding Miss requests in the TOR that match a NID and an opcode.",
+        "UMask": "0x43",
         "Unit": "CBO"
     },
     {
-        "BriefDescription": "TOR Occupancy",
+        "BriefDescription": "TOR Occupancy; NID and Opcode Matched",
         "EventCode": "0x36",
-        "EventName": "UNC_C_TOR_OCCUPANCY.REMOTE",
+        "EventName": "UNC_C_TOR_OCCUPANCY.NID_OPCODE",
         "PerPkg": "1",
-        "UMask": "0x88",
+        "PublicDescription": "For each cycle, this event accumulates the n=
umber of valid entries in the TOR that match qualifications specified by th=
e subevent.   There are a number of subevent 'filters' but only a subset of=
 the subevent combinations are valid.  Subevents that require an opcode or =
NID match require the Cn_MSR_PMON_BOX_FILTER.{opc, nid} field to be set.  I=
f, for example, one wanted to count DRD Local Misses, one should select MIS=
S_OPC_MATCH and set Cn_MSR_PMON_BOX_FILTER.opc to DRD (0x182); TOR entries =
that match a NID and an opcode.",
+        "UMask": "0x41",
         "Unit": "CBO"
     },
     {
-        "BriefDescription": "TOR Occupancy; Misses to Local Memory - Opcod=
e Matched",
+        "BriefDescription": "TOR Occupancy; NID Matched Writebacks",
         "EventCode": "0x36",
-        "EventName": "UNC_C_TOR_OCCUPANCY.MISS_LOCAL_OPCODE",
+        "EventName": "UNC_C_TOR_OCCUPANCY.NID_WB",
         "PerPkg": "1",
-        "UMask": "0x23",
+        "PublicDescription": "For each cycle, this event accumulates the n=
umber of valid entries in the TOR that match qualifications specified by th=
e subevent.   There are a number of subevent 'filters' but only a subset of=
 the subevent combinations are valid.  Subevents that require an opcode or =
NID match require the Cn_MSR_PMON_BOX_FILTER.{opc, nid} field to be set.  I=
f, for example, one wanted to count DRD Local Misses, one should select MIS=
S_OPC_MATCH and set Cn_MSR_PMON_BOX_FILTER.opc to DRD (0x182); NID matched =
write transactions int the TOR.",
+        "UMask": "0x50",
         "Unit": "CBO"
     },
     {
-        "BriefDescription": "TOR Occupancy; Misses to Remote Memory - Opco=
de Matched",
+        "BriefDescription": "TOR Occupancy; Opcode Match",
         "EventCode": "0x36",
-        "EventName": "UNC_C_TOR_OCCUPANCY.MISS_REMOTE_OPCODE",
+        "EventName": "UNC_C_TOR_OCCUPANCY.OPCODE",
         "PerPkg": "1",
-        "UMask": "0x83",
+        "PublicDescription": "For each cycle, this event accumulates the n=
umber of valid entries in the TOR that match qualifications specified by th=
e subevent.   There are a number of subevent 'filters' but only a subset of=
 the subevent combinations are valid.  Subevents that require an opcode or =
NID match require the Cn_MSR_PMON_BOX_FILTER.{opc, nid} field to be set.  I=
f, for example, one wanted to count DRD Local Misses, one should select MIS=
S_OPC_MATCH and set Cn_MSR_PMON_BOX_FILTER.opc to DRD (0x182); TOR entries =
that match an opcode (matched by Cn_MSR_PMON_BOX_FILTER.opc).",
+        "UMask": "0x1",
         "Unit": "CBO"
     },
     {
-        "BriefDescription": "TOR Occupancy; Local Memory - Opcode Matched"=
,
+        "BriefDescription": "TOR Occupancy",
         "EventCode": "0x36",
-        "EventName": "UNC_C_TOR_OCCUPANCY.LOCAL_OPCODE",
+        "EventName": "UNC_C_TOR_OCCUPANCY.REMOTE",
         "PerPkg": "1",
-        "UMask": "0x21",
+        "PublicDescription": "For each cycle, this event accumulates the n=
umber of valid entries in the TOR that match qualifications specified by th=
e subevent.   There are a number of subevent 'filters' but only a subset of=
 the subevent combinations are valid.  Subevents that require an opcode or =
NID match require the Cn_MSR_PMON_BOX_FILTER.{opc, nid} field to be set.  I=
f, for example, one wanted to count DRD Local Misses, one should select MIS=
S_OPC_MATCH and set Cn_MSR_PMON_BOX_FILTER.opc to DRD (0x182)",
+        "UMask": "0x88",
         "Unit": "CBO"
     },
     {
@@ -1460,6 +1498,7 @@
         "EventCode": "0x36",
         "EventName": "UNC_C_TOR_OCCUPANCY.REMOTE_OPCODE",
         "PerPkg": "1",
+        "PublicDescription": "For each cycle, this event accumulates the n=
umber of valid entries in the TOR that match qualifications specified by th=
e subevent.   There are a number of subevent 'filters' but only a subset of=
 the subevent combinations are valid.  Subevents that require an opcode or =
NID match require the Cn_MSR_PMON_BOX_FILTER.{opc, nid} field to be set.  I=
f, for example, one wanted to count DRD Local Misses, one should select MIS=
S_OPC_MATCH and set Cn_MSR_PMON_BOX_FILTER.opc to DRD (0x182); Number of ou=
tstanding  transactions, satisfied by an opcode,  in the TOR that are satis=
fied by remote caches or remote memory.",
         "UMask": "0x81",
         "Unit": "CBO"
     },
@@ -1468,20 +1507,12 @@
         "EventCode": "0x36",
         "EventName": "UNC_C_TOR_OCCUPANCY.WB",
         "PerPkg": "1",
+        "PublicDescription": "For each cycle, this event accumulates the n=
umber of valid entries in the TOR that match qualifications specified by th=
e subevent.   There are a number of subevent 'filters' but only a subset of=
 the subevent combinations are valid.  Subevents that require an opcode or =
NID match require the Cn_MSR_PMON_BOX_FILTER.{opc, nid} field to be set.  I=
f, for example, one wanted to count DRD Local Misses, one should select MIS=
S_OPC_MATCH and set Cn_MSR_PMON_BOX_FILTER.opc to DRD (0x182); Write transa=
ctions in the TOR.   This does not include RFO, but actual operations that =
contain data being sent from the core.",
         "UMask": "0x10",
         "Unit": "CBO"
     },
-    {
-        "BriefDescription": "TOR Occupancy; NID Matched Writebacks",
-        "EventCode": "0x36",
-        "EventName": "UNC_C_TOR_OCCUPANCY.NID_WB",
-        "PerPkg": "1",
-        "UMask": "0x50",
-        "Unit": "CBO"
-    },
     {
         "BriefDescription": "Onto AD Ring",
-        "Counter": "0,1,2,3",
         "EventCode": "0x4",
         "EventName": "UNC_C_TxR_ADS_USED.AD",
         "PerPkg": "1",
@@ -1490,7 +1521,6 @@
     },
     {
         "BriefDescription": "Onto AK Ring",
-        "Counter": "0,1,2,3",
         "EventCode": "0x4",
         "EventName": "UNC_C_TxR_ADS_USED.AK",
         "PerPkg": "1",
@@ -1499,7 +1529,6 @@
     },
     {
         "BriefDescription": "Onto BL Ring",
-        "Counter": "0,1,2,3",
         "EventCode": "0x4",
         "EventName": "UNC_C_TxR_ADS_USED.BL",
         "PerPkg": "1",
@@ -1508,386 +1537,307 @@
     },
     {
         "BriefDescription": "Egress Allocations; AD - Cachebo",
-        "Counter": "0,1,2,3",
         "EventCode": "0x2",
         "EventName": "UNC_C_TxR_INSERTS.AD_CACHE",
         "PerPkg": "1",
+        "PublicDescription": "Number of allocations into the Cbo Egress.  =
The Egress is used to queue up requests destined for the ring.; Ring transa=
ctions from the Cachebo destined for the AD ring.  Some example include out=
bound requests, snoop requests, and snoop responses.",
         "UMask": "0x1",
         "Unit": "CBO"
     },
     {
-        "BriefDescription": "Egress Allocations; AK - Cachebo",
-        "Counter": "0,1,2,3",
-        "EventCode": "0x2",
-        "EventName": "UNC_C_TxR_INSERTS.AK_CACHE",
-        "PerPkg": "1",
-        "UMask": "0x2",
-        "Unit": "CBO"
-    },
-    {
-        "BriefDescription": "Egress Allocations; BL - Cacheno",
-        "Counter": "0,1,2,3",
-        "EventCode": "0x2",
-        "EventName": "UNC_C_TxR_INSERTS.BL_CACHE",
-        "PerPkg": "1",
-        "UMask": "0x4",
-        "Unit": "CBO"
-    },
-    {
-        "BriefDescription": "Egress Allocations; IV - Cachebo",
-        "Counter": "0,1,2,3",
+        "BriefDescription": "Egress Allocations; AD - Corebo",
         "EventCode": "0x2",
-        "EventName": "UNC_C_TxR_INSERTS.IV_CACHE",
+        "EventName": "UNC_C_TxR_INSERTS.AD_CORE",
         "PerPkg": "1",
-        "UMask": "0x8",
+        "PublicDescription": "Number of allocations into the Cbo Egress.  =
The Egress is used to queue up requests destined for the ring.; Ring transa=
ctions from the Corebo destined for the AD ring.  This is commonly used for=
 outbound requests.",
+        "UMask": "0x10",
         "Unit": "CBO"
     },
     {
-        "BriefDescription": "Egress Allocations; AD - Corebo",
-        "Counter": "0,1,2,3",
+        "BriefDescription": "Egress Allocations; AK - Cachebo",
         "EventCode": "0x2",
-        "EventName": "UNC_C_TxR_INSERTS.AD_CORE",
+        "EventName": "UNC_C_TxR_INSERTS.AK_CACHE",
         "PerPkg": "1",
-        "UMask": "0x10",
+        "PublicDescription": "Number of allocations into the Cbo Egress.  =
The Egress is used to queue up requests destined for the ring.; Ring transa=
ctions from the Cachebo destined for the AK ring.  This is commonly used fo=
r credit returns and GO responses.",
+        "UMask": "0x2",
         "Unit": "CBO"
     },
     {
         "BriefDescription": "Egress Allocations; AK - Corebo",
-        "Counter": "0,1,2,3",
         "EventCode": "0x2",
         "EventName": "UNC_C_TxR_INSERTS.AK_CORE",
         "PerPkg": "1",
+        "PublicDescription": "Number of allocations into the Cbo Egress.  =
The Egress is used to queue up requests destined for the ring.; Ring transa=
ctions from the Corebo destined for the AK ring.  This is commonly used for=
 snoop responses coming from the core and destined for a Cachebo.",
         "UMask": "0x20",
         "Unit": "CBO"
     },
     {
-        "BriefDescription": "Egress Allocations; BL - Corebo",
-        "Counter": "0,1,2,3",
+        "BriefDescription": "Egress Allocations; BL - Cacheno",
         "EventCode": "0x2",
-        "EventName": "UNC_C_TxR_INSERTS.BL_CORE",
-        "PerPkg": "1",
-        "UMask": "0x40",
-        "Unit": "CBO"
-    },
-    {
-        "BriefDescription": "Injection Starvation; Onto AK Ring",
-        "Counter": "0,1,2,3",
-        "EventCode": "0x3",
-        "EventName": "UNC_C_TxR_STARVED.AK_BOTH",
+        "EventName": "UNC_C_TxR_INSERTS.BL_CACHE",
         "PerPkg": "1",
-        "UMask": "0x2",
+        "PublicDescription": "Number of allocations into the Cbo Egress.  =
The Egress is used to queue up requests destined for the ring.; Ring transa=
ctions from the Cachebo destined for the BL ring.  This is commonly used to=
 send data from the cache to various destinations.",
+        "UMask": "0x4",
         "Unit": "CBO"
     },
     {
-        "BriefDescription": "Injection Starvation; Onto BL Ring",
-        "Counter": "0,1,2,3",
-        "EventCode": "0x3",
-        "EventName": "UNC_C_TxR_STARVED.BL_BOTH",
+        "BriefDescription": "Egress Allocations; BL - Corebo",
+        "EventCode": "0x2",
+        "EventName": "UNC_C_TxR_INSERTS.BL_CORE",
         "PerPkg": "1",
-        "UMask": "0x4",
+        "PublicDescription": "Number of allocations into the Cbo Egress.  =
The Egress is used to queue up requests destined for the ring.; Ring transa=
ctions from the Corebo destined for the BL ring.  This is commonly used for=
 transferring writeback data to the cache.",
+        "UMask": "0x40",
         "Unit": "CBO"
     },
     {
-        "BriefDescription": "Injection Starvation; Onto IV Ring",
-        "Counter": "0,1,2,3",
-        "EventCode": "0x3",
-        "EventName": "UNC_C_TxR_STARVED.IV",
+        "BriefDescription": "Egress Allocations; IV - Cachebo",
+        "EventCode": "0x2",
+        "EventName": "UNC_C_TxR_INSERTS.IV_CACHE",
         "PerPkg": "1",
+        "PublicDescription": "Number of allocations into the Cbo Egress.  =
The Egress is used to queue up requests destined for the ring.; Ring transa=
ctions from the Cachebo destined for the IV ring.  This is commonly used fo=
r snoops to the cores.",
         "UMask": "0x8",
         "Unit": "CBO"
     },
     {
         "BriefDescription": "Injection Starvation; Onto AD Ring (to core)"=
,
-        "Counter": "0,1,2,3",
         "EventCode": "0x3",
         "EventName": "UNC_C_TxR_STARVED.AD_CORE",
         "PerPkg": "1",
+        "PublicDescription": "Counts injection starvation.  This starvatio=
n is triggered when the Egress cannot send a transaction onto the ring for =
a long period of time.; cycles that the core AD egress spent in starvation"=
,
         "UMask": "0x10",
         "Unit": "CBO"
     },
     {
-        "BriefDescription": "Ingress Occupancy; IRQ Rejected",
-        "EventCode": "0x11",
-        "EventName": "UNC_C_RxR_OCCUPANCY.IRQ_REJ",
+        "BriefDescription": "Injection Starvation; Onto AK Ring",
+        "EventCode": "0x3",
+        "EventName": "UNC_C_TxR_STARVED.AK_BOTH",
         "PerPkg": "1",
+        "PublicDescription": "Counts injection starvation.  This starvatio=
n is triggered when the Egress cannot send a transaction onto the ring for =
a long period of time.; cycles that both AK egresses spent in starvation",
         "UMask": "0x2",
         "Unit": "CBO"
     },
     {
-        "BriefDescription": "Lines Victimized; Lines in S State",
-        "Counter": "0,1,2,3",
-        "EventCode": "0x37",
-        "EventName": "UNC_C_LLC_VICTIMS.I_STATE",
+        "BriefDescription": "Injection Starvation; Onto BL Ring",
+        "EventCode": "0x3",
+        "EventName": "UNC_C_TxR_STARVED.BL_BOTH",
         "PerPkg": "1",
+        "PublicDescription": "Counts injection starvation.  This starvatio=
n is triggered when the Egress cannot send a transaction onto the ring for =
a long period of time.; cycles that both BL egresses spent in starvation",
         "UMask": "0x4",
         "Unit": "CBO"
     },
     {
-        "BriefDescription": "QPI Address/Opcode Match; Address & Opcode Ma=
tch",
-        "Counter": "0,1,2,3",
-        "EventCode": "0x20",
-        "EventName": "UNC_H_ADDR_OPC_MATCH.FILT",
-        "PerPkg": "1",
-        "UMask": "0x3",
-        "Unit": "HA"
-    },
-    {
-        "BriefDescription": "QPI Address/Opcode Match; Address",
-        "Counter": "0,1,2,3",
-        "EventCode": "0x20",
-        "EventName": "UNC_H_ADDR_OPC_MATCH.ADDR",
-        "PerPkg": "1",
-        "UMask": "0x1",
-        "Unit": "HA"
-    },
-    {
-        "BriefDescription": "QPI Address/Opcode Match; Opcode",
-        "Counter": "0,1,2,3",
-        "EventCode": "0x20",
-        "EventName": "UNC_H_ADDR_OPC_MATCH.OPC",
-        "PerPkg": "1",
-        "UMask": "0x2",
-        "Unit": "HA"
-    },
-    {
-        "BriefDescription": "QPI Address/Opcode Match; AD Opcodes",
-        "Counter": "0,1,2,3",
-        "EventCode": "0x20",
-        "EventName": "UNC_H_ADDR_OPC_MATCH.AD",
-        "PerPkg": "1",
-        "UMask": "0x4",
-        "Unit": "HA"
-    },
-    {
-        "BriefDescription": "QPI Address/Opcode Match; BL Opcodes",
-        "Counter": "0,1,2,3",
-        "EventCode": "0x20",
-        "EventName": "UNC_H_ADDR_OPC_MATCH.BL",
+        "BriefDescription": "Injection Starvation; Onto IV Ring",
+        "EventCode": "0x3",
+        "EventName": "UNC_C_TxR_STARVED.IV",
         "PerPkg": "1",
+        "PublicDescription": "Counts injection starvation.  This starvatio=
n is triggered when the Egress cannot send a transaction onto the ring for =
a long period of time.; cycles that the cachebo IV egress spent in starvati=
on",
         "UMask": "0x8",
-        "Unit": "HA"
-    },
-    {
-        "BriefDescription": "QPI Address/Opcode Match; AK Opcodes",
-        "Counter": "0,1,2,3",
-        "EventCode": "0x20",
-        "EventName": "UNC_H_ADDR_OPC_MATCH.AK",
-        "PerPkg": "1",
-        "UMask": "0x10",
-        "Unit": "HA"
+        "Unit": "CBO"
     },
     {
         "BriefDescription": "BT Cycles Not Empty",
-        "Counter": "0,1,2,3",
         "EventCode": "0x42",
         "EventName": "UNC_H_BT_CYCLES_NE",
         "PerPkg": "1",
+        "PublicDescription": "Cycles the Backup Tracker (BT) is not empty.=
 The BT is the actual HOM tracker in IVT.",
         "Unit": "HA"
     },
     {
-        "BriefDescription": "BT to HT Not Issued; Incoming Snoop Hazard",
-        "Counter": "0,1,2,3",
+        "BriefDescription": "BT to HT Not Issued; Incoming Data Hazard",
         "EventCode": "0x51",
-        "EventName": "UNC_H_BT_TO_HT_NOT_ISSUED.INCOMING_SNP_HAZARD",
+        "EventName": "UNC_H_BT_TO_HT_NOT_ISSUED.INCOMING_BL_HAZARD",
         "PerPkg": "1",
-        "UMask": "0x2",
+        "PublicDescription": "Counts the number of cycles when the HA does=
 not issue transaction from BT to HT.; Cycles unable to issue from BT due t=
o incoming BL data hazard",
+        "UMask": "0x4",
         "Unit": "HA"
     },
     {
-        "BriefDescription": "BT to HT Not Issued; Incoming Data Hazard",
-        "Counter": "0,1,2,3",
+        "BriefDescription": "BT to HT Not Issued; Incoming Snoop Hazard",
         "EventCode": "0x51",
-        "EventName": "UNC_H_BT_TO_HT_NOT_ISSUED.INCOMING_BL_HAZARD",
+        "EventName": "UNC_H_BT_TO_HT_NOT_ISSUED.INCOMING_SNP_HAZARD",
         "PerPkg": "1",
-        "UMask": "0x4",
+        "PublicDescription": "Counts the number of cycles when the HA does=
 not issue transaction from BT to HT.; Cycles unable to issue from BT due t=
o incoming snoop hazard",
+        "UMask": "0x2",
         "Unit": "HA"
     },
     {
         "BriefDescription": "BT to HT Not Issued; Incoming Data Hazard",
-        "Counter": "0,1,2,3",
         "EventCode": "0x51",
         "EventName": "UNC_H_BT_TO_HT_NOT_ISSUED.RSPACKCFLT_HAZARD",
         "PerPkg": "1",
+        "PublicDescription": "Counts the number of cycles when the HA does=
 not issue transaction from BT to HT.; Cycles unable to issue from BT due t=
o incoming BL data hazard",
         "UMask": "0x8",
         "Unit": "HA"
     },
     {
         "BriefDescription": "BT to HT Not Issued; Incoming Data Hazard",
-        "Counter": "0,1,2,3",
         "EventCode": "0x51",
         "EventName": "UNC_H_BT_TO_HT_NOT_ISSUED.WBMDATA_HAZARD",
         "PerPkg": "1",
+        "PublicDescription": "Counts the number of cycles when the HA does=
 not issue transaction from BT to HT.; Cycles unable to issue from BT due t=
o incoming BL data hazard",
         "UMask": "0x10",
         "Unit": "HA"
     },
     {
-        "BriefDescription": "HA to iMC Bypass; Taken",
-        "Counter": "0,1,2,3",
+        "BriefDescription": "HA to iMC Bypass; Not Taken",
         "EventCode": "0x14",
-        "EventName": "UNC_H_BYPASS_IMC.TAKEN",
+        "EventName": "UNC_H_BYPASS_IMC.NOT_TAKEN",
         "PerPkg": "1",
-        "UMask": "0x1",
+        "PublicDescription": "Counts the number of times when the HA was a=
ble to bypass was attempted.  This is a latency optimization for situations=
 when there is light loadings on the memory subsystem.  This can be filted =
by when the bypass was taken and when it was not.; Filter for transactions =
that could not take the bypass.",
+        "UMask": "0x2",
         "Unit": "HA"
     },
     {
-        "BriefDescription": "HA to iMC Bypass; Not Taken",
-        "Counter": "0,1,2,3",
+        "BriefDescription": "HA to iMC Bypass; Taken",
         "EventCode": "0x14",
-        "EventName": "UNC_H_BYPASS_IMC.NOT_TAKEN",
+        "EventName": "UNC_H_BYPASS_IMC.TAKEN",
         "PerPkg": "1",
-        "UMask": "0x2",
+        "PublicDescription": "Counts the number of times when the HA was a=
ble to bypass was attempted.  This is a latency optimization for situations=
 when there is light loadings on the memory subsystem.  This can be filted =
by when the bypass was taken and when it was not.; Filter for transactions =
that succeeded in taking the bypass.",
+        "UMask": "0x1",
         "Unit": "HA"
     },
     {
         "BriefDescription": "uclks",
-        "Counter": "0,1,2,3",
         "EventName": "UNC_H_CLOCKTICKS",
         "PerPkg": "1",
+        "PublicDescription": "Counts the number of uclks in the HA.  This =
will be slightly different than the count in the Ubox because of enable/fre=
eze delays.  The HA is on the other side of the die from the fixed Ubox ucl=
k counter, so the drift could be somewhat larger than in units that are clo=
ser like the QPI Agent.",
         "Unit": "HA"
     },
     {
         "BriefDescription": "Direct2Core Messages Sent",
-        "Counter": "0,1,2,3",
         "EventCode": "0x11",
         "EventName": "UNC_H_DIRECT2CORE_COUNT",
         "PerPkg": "1",
+        "PublicDescription": "Number of Direct2Core messages sent",
         "Unit": "HA"
     },
     {
         "BriefDescription": "Cycles when Direct2Core was Disabled",
-        "Counter": "0,1,2,3",
         "EventCode": "0x12",
         "EventName": "UNC_H_DIRECT2CORE_CYCLES_DISABLED",
         "PerPkg": "1",
+        "PublicDescription": "Number of cycles in which Direct2Core was di=
sabled",
         "Unit": "HA"
     },
     {
         "BriefDescription": "Number of Reads that had Direct2Core Overridd=
en",
-        "Counter": "0,1,2,3",
         "EventCode": "0x13",
         "EventName": "UNC_H_DIRECT2CORE_TXN_OVERRIDE",
         "PerPkg": "1",
+        "PublicDescription": "Number of Reads where Direct2Core overridden=
",
         "Unit": "HA"
     },
     {
         "BriefDescription": "Directory Lat Opt Return",
-        "Counter": "0,1,2,3",
         "EventCode": "0x41",
         "EventName": "UNC_H_DIRECTORY_LAT_OPT",
         "PerPkg": "1",
+        "PublicDescription": "Directory Latency Optimization Data Return P=
ath Taken. When directory mode is enabled and the directory returned for a =
read is Dir=3DI, then data can be returned using a faster path if certain c=
onditions are met (credits, free pipeline, etc).",
         "Unit": "HA"
     },
     {
-        "BriefDescription": "Directory Lookups; Snoop Needed",
-        "Counter": "0,1,2,3",
+        "BriefDescription": "Directory Lookups; Snoop Not Needed",
         "EventCode": "0xC",
-        "EventName": "UNC_H_DIRECTORY_LOOKUP.SNP",
+        "EventName": "UNC_H_DIRECTORY_LOOKUP.NO_SNP",
         "PerPkg": "1",
-        "UMask": "0x1",
+        "PublicDescription": "Counts the number of transactions that looke=
d up the directory.  Can be filtered by requests that had to snoop and thos=
e that did not have to.; Filters for transactions that did not have to send=
 any snoops because the directory bit was clear.",
+        "UMask": "0x2",
         "Unit": "HA"
     },
     {
-        "BriefDescription": "Directory Lookups; Snoop Not Needed",
-        "Counter": "0,1,2,3",
+        "BriefDescription": "Directory Lookups; Snoop Needed",
         "EventCode": "0xC",
-        "EventName": "UNC_H_DIRECTORY_LOOKUP.NO_SNP",
+        "EventName": "UNC_H_DIRECTORY_LOOKUP.SNP",
         "PerPkg": "1",
-        "UMask": "0x2",
+        "PublicDescription": "Counts the number of transactions that looke=
d up the directory.  Can be filtered by requests that had to snoop and thos=
e that did not have to.; Filters for transactions that had to send one or m=
ore snoops because the directory bit was set.",
+        "UMask": "0x1",
         "Unit": "HA"
     },
     {
-        "BriefDescription": "Directory Updates; Directory Set",
-        "Counter": "0,1,2,3",
+        "BriefDescription": "Directory Updates; Any Directory Update",
         "EventCode": "0xD",
-        "EventName": "UNC_H_DIRECTORY_UPDATE.SET",
+        "EventName": "UNC_H_DIRECTORY_UPDATE.ANY",
         "PerPkg": "1",
-        "UMask": "0x1",
+        "PublicDescription": "Counts the number of directory updates that =
were required.  These result in writes to the memory controller.  This can =
be filtered by directory sets and directory clears.",
+        "UMask": "0x3",
         "Unit": "HA"
     },
     {
         "BriefDescription": "Directory Updates; Directory Clear",
-        "Counter": "0,1,2,3",
         "EventCode": "0xD",
         "EventName": "UNC_H_DIRECTORY_UPDATE.CLEAR",
         "PerPkg": "1",
+        "PublicDescription": "Counts the number of directory updates that =
were required.  These result in writes to the memory controller.  This can =
be filtered by directory sets and directory clears.; Filter for directory c=
lears.  This occurs when snoops were sent and all returned with RspI.",
         "UMask": "0x2",
         "Unit": "HA"
     },
     {
-        "BriefDescription": "Directory Updates; Any Directory Update",
-        "Counter": "0,1,2,3",
+        "BriefDescription": "Directory Updates; Directory Set",
         "EventCode": "0xD",
-        "EventName": "UNC_H_DIRECTORY_UPDATE.ANY",
+        "EventName": "UNC_H_DIRECTORY_UPDATE.SET",
         "PerPkg": "1",
-        "UMask": "0x3",
+        "PublicDescription": "Counts the number of directory updates that =
were required.  These result in writes to the memory controller.  This can =
be filtered by directory sets and directory clears.; Filter for directory s=
ets.  This occurs when a remote read transaction requests memory, bringing =
it to a remote cache.",
+        "UMask": "0x1",
         "Unit": "HA"
     },
     {
-        "BriefDescription": "Counts Number of Hits in HitMe Cache; op is R=
dCode, RdData, RdDataMigratory, RdInvOwn, RdCur or InvItoE",
-        "Counter": "0,1,2,3",
+        "BriefDescription": "Counts Number of Hits in HitMe Cache; op is A=
ckCnfltWbI",
         "EventCode": "0x71",
-        "EventName": "UNC_H_HITME_HIT.READ_OR_INVITOE",
+        "EventName": "UNC_H_HITME_HIT.ACKCNFLTWBI",
         "PerPkg": "1",
-        "UMask": "0x1",
+        "UMask": "0x4",
         "Unit": "HA"
     },
     {
-        "BriefDescription": "Counts Number of Hits in HitMe Cache; op is W=
bMtoI",
-        "Counter": "0,1,2,3",
+        "BriefDescription": "Counts Number of Hits in HitMe Cache; All Req=
uests",
         "EventCode": "0x71",
-        "EventName": "UNC_H_HITME_HIT.WBMTOI",
+        "EventName": "UNC_H_HITME_HIT.ALL",
         "PerPkg": "1",
-        "UMask": "0x2",
+        "UMask": "0xff",
         "Unit": "HA"
     },
     {
-        "BriefDescription": "Counts Number of Hits in HitMe Cache; op is A=
ckCnfltWbI",
-        "Counter": "0,1,2,3",
+        "BriefDescription": "Counts Number of Hits in HitMe Cache; Allocat=
ions",
         "EventCode": "0x71",
-        "EventName": "UNC_H_HITME_HIT.ACKCNFLTWBI",
+        "EventName": "UNC_H_HITME_HIT.ALLOCS",
         "PerPkg": "1",
-        "UMask": "0x4",
+        "UMask": "0x70",
         "Unit": "HA"
     },
     {
-        "BriefDescription": "Counts Number of Hits in HitMe Cache; op is W=
bMtoE or WbMtoS",
-        "Counter": "0,1,2,3",
+        "BriefDescription": "Counts Number of Hits in HitMe Cache; Allocat=
ions",
         "EventCode": "0x71",
-        "EventName": "UNC_H_HITME_HIT.WBMTOE_OR_S",
+        "EventName": "UNC_H_HITME_HIT.EVICTS",
         "PerPkg": "1",
-        "UMask": "0x8",
+        "UMask": "0x42",
         "Unit": "HA"
     },
     {
-        "BriefDescription": "Counts Number of Hits in HitMe Cache; op is R=
spIFwd or RspIFwdWb for a remote request",
-        "Counter": "0,1,2,3",
+        "BriefDescription": "Counts Number of Hits in HitMe Cache; HOM Req=
uests",
         "EventCode": "0x71",
-        "EventName": "UNC_H_HITME_HIT.RSPFWDI_REMOTE",
+        "EventName": "UNC_H_HITME_HIT.HOM",
         "PerPkg": "1",
-        "UMask": "0x10",
+        "UMask": "0xf",
         "Unit": "HA"
     },
     {
-        "BriefDescription": "Counts Number of Hits in HitMe Cache; op is R=
spIFwd or RspIFwdWb for a local request",
-        "Counter": "0,1,2,3",
+        "BriefDescription": "Counts Number of Hits in HitMe Cache; Invalid=
ations",
         "EventCode": "0x71",
-        "EventName": "UNC_H_HITME_HIT.RSPFWDI_LOCAL",
+        "EventName": "UNC_H_HITME_HIT.INVALS",
         "PerPkg": "1",
-        "UMask": "0x20",
+        "UMask": "0x26",
         "Unit": "HA"
     },
     {
-        "BriefDescription": "Counts Number of Hits in HitMe Cache; op is R=
sSFwd or RspSFwdWb",
-        "Counter": "0,1,2,3",
+        "BriefDescription": "Counts Number of Hits in HitMe Cache; op is R=
dCode, RdData, RdDataMigratory, RdInvOwn, RdCur or InvItoE",
         "EventCode": "0x71",
-        "EventName": "UNC_H_HITME_HIT.RSPFWDS",
+        "EventName": "UNC_H_HITME_HIT.READ_OR_INVITOE",
         "PerPkg": "1",
-        "UMask": "0x40",
+        "UMask": "0x1",
         "Unit": "HA"
     },
     {
         "BriefDescription": "Counts Number of Hits in HitMe Cache; op is R=
spI, RspIWb, RspS, RspSWb, RspCnflt or RspCnfltWbI",
-        "Counter": "0,1,2,3",
         "EventCode": "0x71",
         "EventName": "UNC_H_HITME_HIT.RSP",
         "PerPkg": "1",
@@ -1895,98 +1845,87 @@
         "Unit": "HA"
     },
     {
-        "BriefDescription": "Counts Number of Hits in HitMe Cache; Allocat=
ions",
-        "Counter": "0,1,2,3",
+        "BriefDescription": "Counts Number of Hits in HitMe Cache; op is R=
spIFwd or RspIFwdWb for a local request",
         "EventCode": "0x71",
-        "EventName": "UNC_H_HITME_HIT.ALLOCS",
+        "EventName": "UNC_H_HITME_HIT.RSPFWDI_LOCAL",
         "PerPkg": "1",
-        "UMask": "0x70",
+        "UMask": "0x20",
         "Unit": "HA"
     },
     {
-        "BriefDescription": "Counts Number of Hits in HitMe Cache; Allocat=
ions",
-        "Counter": "0,1,2,3",
+        "BriefDescription": "Counts Number of Hits in HitMe Cache; op is R=
spIFwd or RspIFwdWb for a remote request",
         "EventCode": "0x71",
-        "EventName": "UNC_H_HITME_HIT.EVICTS",
+        "EventName": "UNC_H_HITME_HIT.RSPFWDI_REMOTE",
         "PerPkg": "1",
-        "UMask": "0x42",
+        "UMask": "0x10",
         "Unit": "HA"
     },
     {
-        "BriefDescription": "Counts Number of Hits in HitMe Cache; Invalid=
ations",
-        "Counter": "0,1,2,3",
+        "BriefDescription": "Counts Number of Hits in HitMe Cache; op is R=
sSFwd or RspSFwdWb",
         "EventCode": "0x71",
-        "EventName": "UNC_H_HITME_HIT.INVALS",
+        "EventName": "UNC_H_HITME_HIT.RSPFWDS",
         "PerPkg": "1",
-        "UMask": "0x26",
+        "UMask": "0x40",
         "Unit": "HA"
     },
     {
-        "BriefDescription": "Counts Number of Hits in HitMe Cache; All Req=
uests",
-        "Counter": "0,1,2,3",
+        "BriefDescription": "Counts Number of Hits in HitMe Cache; op is W=
bMtoE or WbMtoS",
         "EventCode": "0x71",
-        "EventName": "UNC_H_HITME_HIT.ALL",
+        "EventName": "UNC_H_HITME_HIT.WBMTOE_OR_S",
         "PerPkg": "1",
-        "UMask": "0xFF",
+        "UMask": "0x8",
         "Unit": "HA"
     },
     {
-        "BriefDescription": "Counts Number of Hits in HitMe Cache; HOM Req=
uests",
-        "Counter": "0,1,2,3",
+        "BriefDescription": "Counts Number of Hits in HitMe Cache; op is W=
bMtoI",
         "EventCode": "0x71",
-        "EventName": "UNC_H_HITME_HIT.HOM",
+        "EventName": "UNC_H_HITME_HIT.WBMTOI",
         "PerPkg": "1",
-        "UMask": "0xF",
+        "UMask": "0x2",
         "Unit": "HA"
     },
     {
-        "BriefDescription": "Accumulates Number of PV bits set on HitMe Ca=
che Hits; op is RdCode, RdData, RdDataMigratory, RdInvOwn, RdCur or InvItoE=
",
-        "Counter": "0,1,2,3",
+        "BriefDescription": "Accumulates Number of PV bits set on HitMe Ca=
che Hits; op is AckCnfltWbI",
         "EventCode": "0x72",
-        "EventName": "UNC_H_HITME_HIT_PV_BITS_SET.READ_OR_INVITOE",
+        "EventName": "UNC_H_HITME_HIT_PV_BITS_SET.ACKCNFLTWBI",
         "PerPkg": "1",
-        "UMask": "0x1",
+        "UMask": "0x4",
         "Unit": "HA"
     },
     {
-        "BriefDescription": "Accumulates Number of PV bits set on HitMe Ca=
che Hits; op is WbMtoI",
-        "Counter": "0,1,2,3",
+        "BriefDescription": "Accumulates Number of PV bits set on HitMe Ca=
che Hits; All Requests",
         "EventCode": "0x72",
-        "EventName": "UNC_H_HITME_HIT_PV_BITS_SET.WBMTOI",
+        "EventName": "UNC_H_HITME_HIT_PV_BITS_SET.ALL",
         "PerPkg": "1",
-        "UMask": "0x2",
+        "UMask": "0xff",
         "Unit": "HA"
     },
     {
-        "BriefDescription": "Accumulates Number of PV bits set on HitMe Ca=
che Hits; op is AckCnfltWbI",
-        "Counter": "0,1,2,3",
+        "BriefDescription": "Accumulates Number of PV bits set on HitMe Ca=
che Hits; HOM Requests",
         "EventCode": "0x72",
-        "EventName": "UNC_H_HITME_HIT_PV_BITS_SET.ACKCNFLTWBI",
+        "EventName": "UNC_H_HITME_HIT_PV_BITS_SET.HOM",
         "PerPkg": "1",
-        "UMask": "0x4",
+        "UMask": "0xf",
         "Unit": "HA"
     },
     {
-        "BriefDescription": "Accumulates Number of PV bits set on HitMe Ca=
che Hits; op is WbMtoE or WbMtoS",
-        "Counter": "0,1,2,3",
+        "BriefDescription": "Accumulates Number of PV bits set on HitMe Ca=
che Hits; op is RdCode, RdData, RdDataMigratory, RdInvOwn, RdCur or InvItoE=
",
         "EventCode": "0x72",
-        "EventName": "UNC_H_HITME_HIT_PV_BITS_SET.WBMTOE_OR_S",
+        "EventName": "UNC_H_HITME_HIT_PV_BITS_SET.READ_OR_INVITOE",
         "PerPkg": "1",
-        "UMask": "0x8",
+        "UMask": "0x1",
         "Unit": "HA"
     },
     {
-        "BriefDescription": "Accumulates Number of PV bits set on HitMe Ca=
che Hits; op is RspIFwd or RspIFwdWb for a remote request",
-        "Counter": "0,1,2,3",
+        "BriefDescription": "Accumulates Number of PV bits set on HitMe Ca=
che Hits; op is RspI, RspIWb, RspS, RspSWb, RspCnflt or RspCnfltWbI",
         "EventCode": "0x72",
-        "EventName": "UNC_H_HITME_HIT_PV_BITS_SET.RSPFWDI_REMOTE",
+        "EventName": "UNC_H_HITME_HIT_PV_BITS_SET.RSP",
         "PerPkg": "1",
-        "UMask": "0x10",
+        "UMask": "0x80",
         "Unit": "HA"
     },
     {
         "BriefDescription": "Accumulates Number of PV bits set on HitMe Ca=
che Hits; op is RspIFwd or RspIFwdWb for a local request",
-        "Counter": "0,1,2,3",
         "EventCode": "0x72",
         "EventName": "UNC_H_HITME_HIT_PV_BITS_SET.RSPFWDI_LOCAL",
         "PerPkg": "1",
@@ -1994,107 +1933,87 @@
         "Unit": "HA"
     },
     {
-        "BriefDescription": "Accumulates Number of PV bits set on HitMe Ca=
che Hits; op is RsSFwd or RspSFwdWb",
-        "Counter": "0,1,2,3",
+        "BriefDescription": "Accumulates Number of PV bits set on HitMe Ca=
che Hits; op is RspIFwd or RspIFwdWb for a remote request",
         "EventCode": "0x72",
-        "EventName": "UNC_H_HITME_HIT_PV_BITS_SET.RSPFWDS",
+        "EventName": "UNC_H_HITME_HIT_PV_BITS_SET.RSPFWDI_REMOTE",
         "PerPkg": "1",
-        "UMask": "0x40",
+        "UMask": "0x10",
         "Unit": "HA"
     },
     {
-        "BriefDescription": "Accumulates Number of PV bits set on HitMe Ca=
che Hits; op is RspI, RspIWb, RspS, RspSWb, RspCnflt or RspCnfltWbI",
-        "Counter": "0,1,2,3",
+        "BriefDescription": "Accumulates Number of PV bits set on HitMe Ca=
che Hits; op is RsSFwd or RspSFwdWb",
         "EventCode": "0x72",
-        "EventName": "UNC_H_HITME_HIT_PV_BITS_SET.RSP",
+        "EventName": "UNC_H_HITME_HIT_PV_BITS_SET.RSPFWDS",
         "PerPkg": "1",
-        "UMask": "0x80",
+        "UMask": "0x40",
         "Unit": "HA"
     },
     {
-        "BriefDescription": "Accumulates Number of PV bits set on HitMe Ca=
che Hits; All Requests",
-        "Counter": "0,1,2,3",
+        "BriefDescription": "Accumulates Number of PV bits set on HitMe Ca=
che Hits; op is WbMtoE or WbMtoS",
         "EventCode": "0x72",
-        "EventName": "UNC_H_HITME_HIT_PV_BITS_SET.ALL",
+        "EventName": "UNC_H_HITME_HIT_PV_BITS_SET.WBMTOE_OR_S",
         "PerPkg": "1",
-        "UMask": "0xFF",
+        "UMask": "0x8",
         "Unit": "HA"
     },
     {
-        "BriefDescription": "Accumulates Number of PV bits set on HitMe Ca=
che Hits; HOM Requests",
-        "Counter": "0,1,2,3",
+        "BriefDescription": "Accumulates Number of PV bits set on HitMe Ca=
che Hits; op is WbMtoI",
         "EventCode": "0x72",
-        "EventName": "UNC_H_HITME_HIT_PV_BITS_SET.HOM",
-        "PerPkg": "1",
-        "UMask": "0xF",
-        "Unit": "HA"
-    },
-    {
-        "BriefDescription": "Counts Number of times HitMe Cache is accesse=
d; op is RdCode, RdData, RdDataMigratory, RdInvOwn, RdCur or InvItoE",
-        "Counter": "0,1,2,3",
-        "EventCode": "0x70",
-        "EventName": "UNC_H_HITME_LOOKUP.READ_OR_INVITOE",
+        "EventName": "UNC_H_HITME_HIT_PV_BITS_SET.WBMTOI",
         "PerPkg": "1",
-        "UMask": "0x1",
+        "UMask": "0x2",
         "Unit": "HA"
     },
     {
-        "BriefDescription": "Counts Number of times HitMe Cache is accesse=
d; op is WbMtoI",
-        "Counter": "0,1,2,3",
+        "BriefDescription": "Counts Number of times HitMe Cache is accesse=
d; op is AckCnfltWbI",
         "EventCode": "0x70",
-        "EventName": "UNC_H_HITME_LOOKUP.WBMTOI",
+        "EventName": "UNC_H_HITME_LOOKUP.ACKCNFLTWBI",
         "PerPkg": "1",
-        "UMask": "0x2",
+        "UMask": "0x4",
         "Unit": "HA"
     },
     {
-        "BriefDescription": "Counts Number of times HitMe Cache is accesse=
d; op is AckCnfltWbI",
-        "Counter": "0,1,2,3",
+        "BriefDescription": "Counts Number of times HitMe Cache is accesse=
d; All Requests",
         "EventCode": "0x70",
-        "EventName": "UNC_H_HITME_LOOKUP.ACKCNFLTWBI",
+        "EventName": "UNC_H_HITME_LOOKUP.ALL",
         "PerPkg": "1",
-        "UMask": "0x4",
+        "UMask": "0xff",
         "Unit": "HA"
     },
     {
-        "BriefDescription": "Counts Number of times HitMe Cache is accesse=
d; op is WbMtoE or WbMtoS",
-        "Counter": "0,1,2,3",
+        "BriefDescription": "Counts Number of times HitMe Cache is accesse=
d; Allocations",
         "EventCode": "0x70",
-        "EventName": "UNC_H_HITME_LOOKUP.WBMTOE_OR_S",
+        "EventName": "UNC_H_HITME_LOOKUP.ALLOCS",
         "PerPkg": "1",
-        "UMask": "0x8",
+        "UMask": "0x70",
         "Unit": "HA"
     },
     {
-        "BriefDescription": "Counts Number of times HitMe Cache is accesse=
d; op is RspIFwd or RspIFwdWb for a remote request",
-        "Counter": "0,1,2,3",
+        "BriefDescription": "Counts Number of times HitMe Cache is accesse=
d; HOM Requests",
         "EventCode": "0x70",
-        "EventName": "UNC_H_HITME_LOOKUP.RSPFWDI_REMOTE",
+        "EventName": "UNC_H_HITME_LOOKUP.HOM",
         "PerPkg": "1",
-        "UMask": "0x10",
+        "UMask": "0xf",
         "Unit": "HA"
     },
     {
-        "BriefDescription": "Counts Number of times HitMe Cache is accesse=
d; op is RspIFwd or RspIFwdWb for a local request",
-        "Counter": "0,1,2,3",
+        "BriefDescription": "Counts Number of times HitMe Cache is accesse=
d; Invalidations",
         "EventCode": "0x70",
-        "EventName": "UNC_H_HITME_LOOKUP.RSPFWDI_LOCAL",
+        "EventName": "UNC_H_HITME_LOOKUP.INVALS",
         "PerPkg": "1",
-        "UMask": "0x20",
+        "UMask": "0x26",
         "Unit": "HA"
     },
     {
-        "BriefDescription": "Counts Number of times HitMe Cache is accesse=
d; op is RsSFwd or RspSFwdWb",
-        "Counter": "0,1,2,3",
+        "BriefDescription": "Counts Number of times HitMe Cache is accesse=
d; op is RdCode, RdData, RdDataMigratory, RdInvOwn, RdCur or InvItoE",
         "EventCode": "0x70",
-        "EventName": "UNC_H_HITME_LOOKUP.RSPFWDS",
+        "EventName": "UNC_H_HITME_LOOKUP.READ_OR_INVITOE",
         "PerPkg": "1",
-        "UMask": "0x40",
+        "UMask": "0x1",
         "Unit": "HA"
     },
     {
         "BriefDescription": "Counts Number of times HitMe Cache is accesse=
d; op is RspI, RspIWb, RspS, RspSWb, RspCnflt or RspCnfltWbI",
-        "Counter": "0,1,2,3",
         "EventCode": "0x70",
         "EventName": "UNC_H_HITME_LOOKUP.RSP",
         "PerPkg": "1",
@@ -2102,1536 +2021,1537 @@
         "Unit": "HA"
     },
     {
-        "BriefDescription": "Counts Number of times HitMe Cache is accesse=
d; Allocations",
-        "Counter": "0,1,2,3",
+        "BriefDescription": "Counts Number of times HitMe Cache is accesse=
d; op is RspIFwd or RspIFwdWb for a local request",
         "EventCode": "0x70",
-        "EventName": "UNC_H_HITME_LOOKUP.ALLOCS",
+        "EventName": "UNC_H_HITME_LOOKUP.RSPFWDI_LOCAL",
         "PerPkg": "1",
-        "UMask": "0x70",
+        "UMask": "0x20",
         "Unit": "HA"
     },
     {
-        "BriefDescription": "Counts Number of times HitMe Cache is accesse=
d; Invalidations",
-        "Counter": "0,1,2,3",
+        "BriefDescription": "Counts Number of times HitMe Cache is accesse=
d; op is RspIFwd or RspIFwdWb for a remote request",
         "EventCode": "0x70",
-        "EventName": "UNC_H_HITME_LOOKUP.INVALS",
+        "EventName": "UNC_H_HITME_LOOKUP.RSPFWDI_REMOTE",
         "PerPkg": "1",
-        "UMask": "0x26",
+        "UMask": "0x10",
         "Unit": "HA"
     },
     {
-        "BriefDescription": "Counts Number of times HitMe Cache is accesse=
d; All Requests",
-        "Counter": "0,1,2,3",
+        "BriefDescription": "Counts Number of times HitMe Cache is accesse=
d; op is RsSFwd or RspSFwdWb",
         "EventCode": "0x70",
-        "EventName": "UNC_H_HITME_LOOKUP.ALL",
+        "EventName": "UNC_H_HITME_LOOKUP.RSPFWDS",
         "PerPkg": "1",
-        "UMask": "0xFF",
+        "UMask": "0x40",
         "Unit": "HA"
     },
     {
-        "BriefDescription": "Counts Number of times HitMe Cache is accesse=
d; HOM Requests",
-        "Counter": "0,1,2,3",
+        "BriefDescription": "Counts Number of times HitMe Cache is accesse=
d; op is WbMtoE or WbMtoS",
         "EventCode": "0x70",
-        "EventName": "UNC_H_HITME_LOOKUP.HOM",
+        "EventName": "UNC_H_HITME_LOOKUP.WBMTOE_OR_S",
+        "PerPkg": "1",
+        "UMask": "0x8",
+        "Unit": "HA"
+    },
+    {
+        "BriefDescription": "Counts Number of times HitMe Cache is accesse=
d; op is WbMtoI",
+        "EventCode": "0x70",
+        "EventName": "UNC_H_HITME_LOOKUP.WBMTOI",
         "PerPkg": "1",
-        "UMask": "0xF",
+        "UMask": "0x2",
         "Unit": "HA"
     },
     {
         "BriefDescription": "Cycles without QPI Ingress Credits; AD to QPI=
 Link 0",
-        "Counter": "0,1,2,3",
         "EventCode": "0x22",
         "EventName": "UNC_H_IGR_NO_CREDIT_CYCLES.AD_QPI0",
         "PerPkg": "1",
+        "PublicDescription": "Counts the number of cycles when the HA does=
 not have credits to send messages to the QPI Agent.  This can be filtered =
by the different credit pools and the different links.",
         "UMask": "0x1",
         "Unit": "HA"
     },
     {
         "BriefDescription": "Cycles without QPI Ingress Credits; AD to QPI=
 Link 1",
-        "Counter": "0,1,2,3",
         "EventCode": "0x22",
         "EventName": "UNC_H_IGR_NO_CREDIT_CYCLES.AD_QPI1",
         "PerPkg": "1",
+        "PublicDescription": "Counts the number of cycles when the HA does=
 not have credits to send messages to the QPI Agent.  This can be filtered =
by the different credit pools and the different links.",
         "UMask": "0x2",
         "Unit": "HA"
     },
     {
         "BriefDescription": "Cycles without QPI Ingress Credits; BL to QPI=
 Link 0",
-        "Counter": "0,1,2,3",
         "EventCode": "0x22",
-        "EventName": "UNC_H_IGR_NO_CREDIT_CYCLES.BL_QPI0",
+        "EventName": "UNC_H_IGR_NO_CREDIT_CYCLES.AD_QPI2",
         "PerPkg": "1",
-        "UMask": "0x4",
+        "PublicDescription": "Counts the number of cycles when the HA does=
 not have credits to send messages to the QPI Agent.  This can be filtered =
by the different credit pools and the different links.",
+        "UMask": "0x10",
         "Unit": "HA"
     },
     {
-        "BriefDescription": "Cycles without QPI Ingress Credits; BL to QPI=
 Link 1",
-        "Counter": "0,1,2,3",
+        "BriefDescription": "Cycles without QPI Ingress Credits; BL to QPI=
 Link 0",
         "EventCode": "0x22",
-        "EventName": "UNC_H_IGR_NO_CREDIT_CYCLES.BL_QPI1",
+        "EventName": "UNC_H_IGR_NO_CREDIT_CYCLES.BL_QPI0",
         "PerPkg": "1",
-        "UMask": "0x8",
+        "PublicDescription": "Counts the number of cycles when the HA does=
 not have credits to send messages to the QPI Agent.  This can be filtered =
by the different credit pools and the different links.",
+        "UMask": "0x4",
         "Unit": "HA"
     },
     {
-        "BriefDescription": "Cycles without QPI Ingress Credits; BL to QPI=
 Link 0",
-        "Counter": "0,1,2,3",
+        "BriefDescription": "Cycles without QPI Ingress Credits; BL to QPI=
 Link 1",
         "EventCode": "0x22",
-        "EventName": "UNC_H_IGR_NO_CREDIT_CYCLES.AD_QPI2",
+        "EventName": "UNC_H_IGR_NO_CREDIT_CYCLES.BL_QPI1",
         "PerPkg": "1",
-        "UMask": "0x10",
+        "PublicDescription": "Counts the number of cycles when the HA does=
 not have credits to send messages to the QPI Agent.  This can be filtered =
by the different credit pools and the different links.",
+        "UMask": "0x8",
         "Unit": "HA"
     },
     {
         "BriefDescription": "Cycles without QPI Ingress Credits; BL to QPI=
 Link 1",
-        "Counter": "0,1,2,3",
         "EventCode": "0x22",
         "EventName": "UNC_H_IGR_NO_CREDIT_CYCLES.BL_QPI2",
         "PerPkg": "1",
+        "PublicDescription": "Counts the number of cycles when the HA does=
 not have credits to send messages to the QPI Agent.  This can be filtered =
by the different credit pools and the different links.",
         "UMask": "0x20",
         "Unit": "HA"
     },
     {
         "BriefDescription": "HA to iMC Normal Priority Reads Issued; Norma=
l Priority",
-        "Counter": "0,1,2,3",
         "EventCode": "0x17",
         "EventName": "UNC_H_IMC_READS.NORMAL",
         "PerPkg": "1",
+        "PublicDescription": "Count of the number of reads issued to any o=
f the memory controller channels.  This can be filtered by the priority of =
the reads.",
         "UMask": "0x1",
         "Unit": "HA"
     },
     {
         "BriefDescription": "Retry Events",
-        "Counter": "0,1,2,3",
         "EventCode": "0x1E",
         "EventName": "UNC_H_IMC_RETRY",
         "PerPkg": "1",
         "Unit": "HA"
     },
     {
-        "BriefDescription": "HA to iMC Full Line Writes Issued; Full Line =
Non-ISOCH",
-        "Counter": "0,1,2,3",
+        "BriefDescription": "HA to iMC Full Line Writes Issued; All Writes=
",
         "EventCode": "0x1A",
-        "EventName": "UNC_H_IMC_WRITES.FULL",
+        "EventName": "UNC_H_IMC_WRITES.ALL",
         "PerPkg": "1",
-        "UMask": "0x1",
+        "PublicDescription": "Counts the total number of full line writes =
issued from the HA into the memory controller.  This counts for all four ch=
annels.  It can be filtered by full/partial and ISOCH/non-ISOCH.",
+        "UMask": "0xf",
         "Unit": "HA"
     },
     {
-        "BriefDescription": "HA to iMC Full Line Writes Issued; Partial No=
n-ISOCH",
-        "Counter": "0,1,2,3",
+        "BriefDescription": "HA to iMC Full Line Writes Issued; Full Line =
Non-ISOCH",
         "EventCode": "0x1A",
-        "EventName": "UNC_H_IMC_WRITES.PARTIAL",
+        "EventName": "UNC_H_IMC_WRITES.FULL",
         "PerPkg": "1",
-        "UMask": "0x2",
+        "PublicDescription": "Counts the total number of full line writes =
issued from the HA into the memory controller.  This counts for all four ch=
annels.  It can be filtered by full/partial and ISOCH/non-ISOCH.",
+        "UMask": "0x1",
         "Unit": "HA"
     },
     {
         "BriefDescription": "HA to iMC Full Line Writes Issued; ISOCH Full=
 Line",
-        "Counter": "0,1,2,3",
         "EventCode": "0x1A",
         "EventName": "UNC_H_IMC_WRITES.FULL_ISOCH",
         "PerPkg": "1",
+        "PublicDescription": "Counts the total number of full line writes =
issued from the HA into the memory controller.  This counts for all four ch=
annels.  It can be filtered by full/partial and ISOCH/non-ISOCH.",
         "UMask": "0x4",
         "Unit": "HA"
     },
     {
-        "BriefDescription": "HA to iMC Full Line Writes Issued; ISOCH Part=
ial",
-        "Counter": "0,1,2,3",
+        "BriefDescription": "HA to iMC Full Line Writes Issued; Partial No=
n-ISOCH",
         "EventCode": "0x1A",
-        "EventName": "UNC_H_IMC_WRITES.PARTIAL_ISOCH",
+        "EventName": "UNC_H_IMC_WRITES.PARTIAL",
         "PerPkg": "1",
-        "UMask": "0x8",
+        "PublicDescription": "Counts the total number of full line writes =
issued from the HA into the memory controller.  This counts for all four ch=
annels.  It can be filtered by full/partial and ISOCH/non-ISOCH.",
+        "UMask": "0x2",
         "Unit": "HA"
     },
     {
-        "BriefDescription": "HA to iMC Full Line Writes Issued; All Writes=
",
-        "Counter": "0,1,2,3",
+        "BriefDescription": "HA to iMC Full Line Writes Issued; ISOCH Part=
ial",
         "EventCode": "0x1A",
-        "EventName": "UNC_H_IMC_WRITES.ALL",
+        "EventName": "UNC_H_IMC_WRITES.PARTIAL_ISOCH",
         "PerPkg": "1",
-        "UMask": "0xF",
+        "PublicDescription": "Counts the total number of full line writes =
issued from the HA into the memory controller.  This counts for all four ch=
annels.  It can be filtered by full/partial and ISOCH/non-ISOCH.",
+        "UMask": "0x8",
         "Unit": "HA"
     },
     {
         "BriefDescription": "IOT Backpressure",
-        "Counter": "0,1,2",
         "EventCode": "0x61",
-        "EventName": "UNC_H_IOT_BACKPRESSURE.SAT",
+        "EventName": "UNC_H_IOT_BACKPRESSURE.HUB",
         "PerPkg": "1",
-        "UMask": "0x1",
+        "UMask": "0x2",
         "Unit": "HA"
     },
     {
         "BriefDescription": "IOT Backpressure",
-        "Counter": "0,1,2",
         "EventCode": "0x61",
-        "EventName": "UNC_H_IOT_BACKPRESSURE.HUB",
+        "EventName": "UNC_H_IOT_BACKPRESSURE.SAT",
         "PerPkg": "1",
-        "UMask": "0x2",
+        "UMask": "0x1",
         "Unit": "HA"
     },
     {
         "BriefDescription": "IOT Common Trigger Sequencer - Lo",
-        "Counter": "0,1,2",
         "EventCode": "0x64",
         "EventName": "UNC_H_IOT_CTS_EAST_LO.CTS0",
         "PerPkg": "1",
+        "PublicDescription": "Debug Mask/Match Tie-Ins",
         "UMask": "0x1",
         "Unit": "HA"
     },
     {
         "BriefDescription": "IOT Common Trigger Sequencer - Lo",
-        "Counter": "0,1,2",
         "EventCode": "0x64",
         "EventName": "UNC_H_IOT_CTS_EAST_LO.CTS1",
         "PerPkg": "1",
+        "PublicDescription": "Debug Mask/Match Tie-Ins",
         "UMask": "0x2",
         "Unit": "HA"
     },
     {
         "BriefDescription": "IOT Common Trigger Sequencer - Hi",
-        "Counter": "0,1,2",
         "EventCode": "0x65",
         "EventName": "UNC_H_IOT_CTS_HI.CTS2",
         "PerPkg": "1",
+        "PublicDescription": "Debug Mask/Match Tie-Ins",
         "UMask": "0x1",
         "Unit": "HA"
     },
     {
         "BriefDescription": "IOT Common Trigger Sequencer - Hi",
-        "Counter": "0,1,2",
         "EventCode": "0x65",
         "EventName": "UNC_H_IOT_CTS_HI.CTS3",
         "PerPkg": "1",
+        "PublicDescription": "Debug Mask/Match Tie-Ins",
         "UMask": "0x2",
         "Unit": "HA"
     },
     {
         "BriefDescription": "IOT Common Trigger Sequencer - Lo",
-        "Counter": "0,1,2",
         "EventCode": "0x62",
         "EventName": "UNC_H_IOT_CTS_WEST_LO.CTS0",
         "PerPkg": "1",
+        "PublicDescription": "Debug Mask/Match Tie-Ins",
         "UMask": "0x1",
         "Unit": "HA"
     },
     {
         "BriefDescription": "IOT Common Trigger Sequencer - Lo",
-        "Counter": "0,1,2",
         "EventCode": "0x62",
         "EventName": "UNC_H_IOT_CTS_WEST_LO.CTS1",
         "PerPkg": "1",
+        "PublicDescription": "Debug Mask/Match Tie-Ins",
         "UMask": "0x2",
         "Unit": "HA"
     },
     {
-        "BriefDescription": "OSB Snoop Broadcast; Local Reads",
-        "Counter": "0,1,2,3",
+        "BriefDescription": "OSB Snoop Broadcast; Cancelled",
         "EventCode": "0x53",
-        "EventName": "UNC_H_OSB.READS_LOCAL",
+        "EventName": "UNC_H_OSB.CANCELLED",
         "PerPkg": "1",
-        "UMask": "0x2",
+        "PublicDescription": "Count of OSB snoop broadcasts. Counts by 1 p=
er request causing OSB snoops to be broadcast. Does not count all the snoop=
s generated by OSB.; OSB Snoop broadcast cancelled due to D2C or Other. OSB=
 cancel is counted when OSB local read is not allowed even when the transac=
tion in local InItoE. It also counts D2C OSB cancel, but also includes the =
cases were D2C was not set in the first place for the transaction coming fr=
om the ring.",
+        "UMask": "0x10",
         "Unit": "HA"
     },
     {
         "BriefDescription": "OSB Snoop Broadcast; Local InvItoE",
-        "Counter": "0,1,2,3",
         "EventCode": "0x53",
         "EventName": "UNC_H_OSB.INVITOE_LOCAL",
         "PerPkg": "1",
+        "PublicDescription": "Count of OSB snoop broadcasts. Counts by 1 p=
er request causing OSB snoops to be broadcast. Does not count all the snoop=
s generated by OSB.",
         "UMask": "0x4",
         "Unit": "HA"
     },
     {
-        "BriefDescription": "OSB Snoop Broadcast; Remote",
-        "Counter": "0,1,2,3",
+        "BriefDescription": "OSB Snoop Broadcast; Local Reads",
         "EventCode": "0x53",
-        "EventName": "UNC_H_OSB.REMOTE",
+        "EventName": "UNC_H_OSB.READS_LOCAL",
         "PerPkg": "1",
-        "UMask": "0x8",
+        "PublicDescription": "Count of OSB snoop broadcasts. Counts by 1 p=
er request causing OSB snoops to be broadcast. Does not count all the snoop=
s generated by OSB.",
+        "UMask": "0x2",
         "Unit": "HA"
     },
     {
-        "BriefDescription": "OSB Snoop Broadcast; Cancelled",
-        "Counter": "0,1,2,3",
+        "BriefDescription": "OSB Snoop Broadcast; Reads Local -  Useful",
         "EventCode": "0x53",
-        "EventName": "UNC_H_OSB.CANCELLED",
+        "EventName": "UNC_H_OSB.READS_LOCAL_USEFUL",
         "PerPkg": "1",
-        "UMask": "0x10",
+        "PublicDescription": "Count of OSB snoop broadcasts. Counts by 1 p=
er request causing OSB snoops to be broadcast. Does not count all the snoop=
s generated by OSB.",
+        "UMask": "0x20",
         "Unit": "HA"
     },
     {
-        "BriefDescription": "OSB Snoop Broadcast; Reads Local -  Useful",
-        "Counter": "0,1,2,3",
+        "BriefDescription": "OSB Snoop Broadcast; Remote",
         "EventCode": "0x53",
-        "EventName": "UNC_H_OSB.READS_LOCAL_USEFUL",
+        "EventName": "UNC_H_OSB.REMOTE",
         "PerPkg": "1",
-        "UMask": "0x20",
+        "PublicDescription": "Count of OSB snoop broadcasts. Counts by 1 p=
er request causing OSB snoops to be broadcast. Does not count all the snoop=
s generated by OSB.",
+        "UMask": "0x8",
         "Unit": "HA"
     },
     {
         "BriefDescription": "OSB Snoop Broadcast; Remote - Useful",
-        "Counter": "0,1,2,3",
         "EventCode": "0x53",
         "EventName": "UNC_H_OSB.REMOTE_USEFUL",
         "PerPkg": "1",
+        "PublicDescription": "Count of OSB snoop broadcasts. Counts by 1 p=
er request causing OSB snoops to be broadcast. Does not count all the snoop=
s generated by OSB.",
         "UMask": "0x40",
         "Unit": "HA"
     },
     {
         "BriefDescription": "OSB Early Data Return; All",
-        "Counter": "0,1,2,3",
         "EventCode": "0x54",
         "EventName": "UNC_H_OSB_EDR.ALL",
         "PerPkg": "1",
+        "PublicDescription": "Counts the number of transactions that broad=
cast snoop due to OSB, but found clean data in memory and was able to do ea=
rly data return",
         "UMask": "0x1",
         "Unit": "HA"
     },
     {
         "BriefDescription": "OSB Early Data Return; Reads to Local  I",
-        "Counter": "0,1,2,3",
         "EventCode": "0x54",
         "EventName": "UNC_H_OSB_EDR.READS_LOCAL_I",
         "PerPkg": "1",
+        "PublicDescription": "Counts the number of transactions that broad=
cast snoop due to OSB, but found clean data in memory and was able to do ea=
rly data return",
         "UMask": "0x2",
         "Unit": "HA"
     },
     {
-        "BriefDescription": "OSB Early Data Return; Reads to Remote I",
-        "Counter": "0,1,2,3",
+        "BriefDescription": "OSB Early Data Return; Reads to Local S",
         "EventCode": "0x54",
-        "EventName": "UNC_H_OSB_EDR.READS_REMOTE_I",
+        "EventName": "UNC_H_OSB_EDR.READS_LOCAL_S",
         "PerPkg": "1",
-        "UMask": "0x4",
+        "PublicDescription": "Counts the number of transactions that broad=
cast snoop due to OSB, but found clean data in memory and was able to do ea=
rly data return",
+        "UMask": "0x8",
         "Unit": "HA"
     },
     {
-        "BriefDescription": "OSB Early Data Return; Reads to Local S",
-        "Counter": "0,1,2,3",
+        "BriefDescription": "OSB Early Data Return; Reads to Remote I",
         "EventCode": "0x54",
-        "EventName": "UNC_H_OSB_EDR.READS_LOCAL_S",
+        "EventName": "UNC_H_OSB_EDR.READS_REMOTE_I",
         "PerPkg": "1",
-        "UMask": "0x8",
+        "PublicDescription": "Counts the number of transactions that broad=
cast snoop due to OSB, but found clean data in memory and was able to do ea=
rly data return",
+        "UMask": "0x4",
         "Unit": "HA"
     },
     {
         "BriefDescription": "OSB Early Data Return; Reads to Remote S",
-        "Counter": "0,1,2,3",
         "EventCode": "0x54",
         "EventName": "UNC_H_OSB_EDR.READS_REMOTE_S",
         "PerPkg": "1",
+        "PublicDescription": "Counts the number of transactions that broad=
cast snoop due to OSB, but found clean data in memory and was able to do ea=
rly data return",
         "UMask": "0x10",
         "Unit": "HA"
     },
     {
-        "BriefDescription": "Read and Write Requests; Reads",
-        "Counter": "0,1,2,3",
+        "BriefDescription": "Read and Write Requests; Local InvItoEs",
         "EventCode": "0x1",
-        "EventName": "UNC_H_REQUESTS.READS",
+        "EventName": "UNC_H_REQUESTS.INVITOE_LOCAL",
         "PerPkg": "1",
-        "UMask": "0x3",
+        "PublicDescription": "Counts the total number of read requests mad=
e into the Home Agent. Reads include all read opcodes (including RFO).  Wri=
tes include all writes (streaming, evictions, HitM, etc).; This filter incl=
udes only InvItoEs coming from the local socket.",
+        "UMask": "0x10",
         "Unit": "HA"
     },
     {
-        "BriefDescription": "Read and Write Requests; Writes",
-        "Counter": "0,1,2,3",
+        "BriefDescription": "Read and Write Requests; Remote InvItoEs",
         "EventCode": "0x1",
-        "EventName": "UNC_H_REQUESTS.WRITES",
+        "EventName": "UNC_H_REQUESTS.INVITOE_REMOTE",
+        "PerPkg": "1",
+        "PublicDescription": "Counts the total number of read requests mad=
e into the Home Agent. Reads include all read opcodes (including RFO).  Wri=
tes include all writes (streaming, evictions, HitM, etc).; This filter incl=
udes only InvItoEs coming from remote sockets.",
+        "UMask": "0x20",
+        "Unit": "HA"
+    },
+    {
+        "BriefDescription": "Read and Write Requests; Reads",
+        "EventCode": "0x1",
+        "EventName": "UNC_H_REQUESTS.READS",
         "PerPkg": "1",
-        "UMask": "0xC",
+        "PublicDescription": "Counts the total number of read requests mad=
e into the Home Agent. Reads include all read opcodes (including RFO).  Wri=
tes include all writes (streaming, evictions, HitM, etc).; Incoming ead req=
uests.  This is a good proxy for LLC Read Misses (including RFOs).",
+        "UMask": "0x3",
         "Unit": "HA"
     },
     {
         "BriefDescription": "Read and Write Requests; Local Reads",
-        "Counter": "0,1,2,3",
         "EventCode": "0x1",
         "EventName": "UNC_H_REQUESTS.READS_LOCAL",
         "PerPkg": "1",
+        "PublicDescription": "Counts the total number of read requests mad=
e into the Home Agent. Reads include all read opcodes (including RFO).  Wri=
tes include all writes (streaming, evictions, HitM, etc).; This filter incl=
udes only read requests coming from the local socket.  This is a good proxy=
 for LLC Read Misses (including RFOs) from the local socket.",
         "UMask": "0x1",
         "Unit": "HA"
     },
     {
         "BriefDescription": "Read and Write Requests; Remote Reads",
-        "Counter": "0,1,2,3",
         "EventCode": "0x1",
         "EventName": "UNC_H_REQUESTS.READS_REMOTE",
         "PerPkg": "1",
+        "PublicDescription": "Counts the total number of read requests mad=
e into the Home Agent. Reads include all read opcodes (including RFO).  Wri=
tes include all writes (streaming, evictions, HitM, etc).; This filter incl=
udes only read requests coming from the remote socket.  This is a good prox=
y for LLC Read Misses (including RFOs) from the remote socket.",
         "UMask": "0x2",
         "Unit": "HA"
     },
+    {
+        "BriefDescription": "Read and Write Requests; Writes",
+        "EventCode": "0x1",
+        "EventName": "UNC_H_REQUESTS.WRITES",
+        "PerPkg": "1",
+        "PublicDescription": "Counts the total number of read requests mad=
e into the Home Agent. Reads include all read opcodes (including RFO).  Wri=
tes include all writes (streaming, evictions, HitM, etc).; Incoming write r=
equests.",
+        "UMask": "0xc",
+        "Unit": "HA"
+    },
     {
         "BriefDescription": "Read and Write Requests; Local Writes",
-        "Counter": "0,1,2,3",
         "EventCode": "0x1",
         "EventName": "UNC_H_REQUESTS.WRITES_LOCAL",
         "PerPkg": "1",
+        "PublicDescription": "Counts the total number of read requests mad=
e into the Home Agent. Reads include all read opcodes (including RFO).  Wri=
tes include all writes (streaming, evictions, HitM, etc).; This filter incl=
udes only writes coming from the local socket.",
         "UMask": "0x4",
         "Unit": "HA"
     },
     {
         "BriefDescription": "Read and Write Requests; Remote Writes",
-        "Counter": "0,1,2,3",
         "EventCode": "0x1",
         "EventName": "UNC_H_REQUESTS.WRITES_REMOTE",
         "PerPkg": "1",
+        "PublicDescription": "Counts the total number of read requests mad=
e into the Home Agent. Reads include all read opcodes (including RFO).  Wri=
tes include all writes (streaming, evictions, HitM, etc).; This filter incl=
udes only writes coming from remote sockets.",
         "UMask": "0x8",
         "Unit": "HA"
     },
     {
-        "BriefDescription": "Read and Write Requests; Local InvItoEs",
-        "Counter": "0,1,2,3",
-        "EventCode": "0x1",
-        "EventName": "UNC_H_REQUESTS.INVITOE_LOCAL",
-        "PerPkg": "1",
-        "UMask": "0x10",
-        "Unit": "HA"
-    },
-    {
-        "BriefDescription": "Read and Write Requests; Remote InvItoEs",
-        "Counter": "0,1,2,3",
-        "EventCode": "0x1",
-        "EventName": "UNC_H_REQUESTS.INVITOE_REMOTE",
-        "PerPkg": "1",
-        "UMask": "0x20",
-        "Unit": "HA"
-    },
-    {
-        "BriefDescription": "HA AD Ring in Use; Clockwise and Even",
-        "Counter": "0,1,2,3",
-        "EventCode": "0x3E",
-        "EventName": "UNC_H_RING_AD_USED.CW_EVEN",
-        "PerPkg": "1",
-        "UMask": "0x1",
-        "Unit": "HA"
-    },
-    {
-        "BriefDescription": "HA AD Ring in Use; Clockwise and Odd",
-        "Counter": "0,1,2,3",
+        "BriefDescription": "HA AD Ring in Use; Counterclockwise",
         "EventCode": "0x3E",
-        "EventName": "UNC_H_RING_AD_USED.CW_ODD",
+        "EventName": "UNC_H_RING_AD_USED.CCW",
         "PerPkg": "1",
-        "UMask": "0x2",
+        "PublicDescription": "Counts the number of cycles that the AD ring=
 is being used at this ring stop.  This includes when packets are passing b=
y and when packets are being sunk, but does not include when packets are be=
ing sent from the ring stop.",
+        "UMask": "0xc",
         "Unit": "HA"
     },
     {
         "BriefDescription": "HA AD Ring in Use; Counterclockwise and Even"=
,
-        "Counter": "0,1,2,3",
         "EventCode": "0x3E",
         "EventName": "UNC_H_RING_AD_USED.CCW_EVEN",
         "PerPkg": "1",
+        "PublicDescription": "Counts the number of cycles that the AD ring=
 is being used at this ring stop.  This includes when packets are passing b=
y and when packets are being sunk, but does not include when packets are be=
ing sent from the ring stop.; Filters for the Counterclockwise and Even rin=
g polarity.",
         "UMask": "0x4",
         "Unit": "HA"
     },
     {
         "BriefDescription": "HA AD Ring in Use; Counterclockwise and Odd",
-        "Counter": "0,1,2,3",
         "EventCode": "0x3E",
         "EventName": "UNC_H_RING_AD_USED.CCW_ODD",
         "PerPkg": "1",
+        "PublicDescription": "Counts the number of cycles that the AD ring=
 is being used at this ring stop.  This includes when packets are passing b=
y and when packets are being sunk, but does not include when packets are be=
ing sent from the ring stop.; Filters for the Counterclockwise and Odd ring=
 polarity.",
         "UMask": "0x8",
         "Unit": "HA"
     },
     {
         "BriefDescription": "HA AD Ring in Use; Clockwise",
-        "Counter": "0,1,2,3",
         "EventCode": "0x3E",
         "EventName": "UNC_H_RING_AD_USED.CW",
         "PerPkg": "1",
+        "PublicDescription": "Counts the number of cycles that the AD ring=
 is being used at this ring stop.  This includes when packets are passing b=
y and when packets are being sunk, but does not include when packets are be=
ing sent from the ring stop.",
         "UMask": "0x3",
         "Unit": "HA"
     },
     {
-        "BriefDescription": "HA AD Ring in Use; Counterclockwise",
-        "Counter": "0,1,2,3",
+        "BriefDescription": "HA AD Ring in Use; Clockwise and Even",
         "EventCode": "0x3E",
-        "EventName": "UNC_H_RING_AD_USED.CCW",
+        "EventName": "UNC_H_RING_AD_USED.CW_EVEN",
         "PerPkg": "1",
-        "UMask": "0xC",
+        "PublicDescription": "Counts the number of cycles that the AD ring=
 is being used at this ring stop.  This includes when packets are passing b=
y and when packets are being sunk, but does not include when packets are be=
ing sent from the ring stop.; Filters for the Clockwise and Even ring polar=
ity.",
+        "UMask": "0x1",
         "Unit": "HA"
     },
     {
-        "BriefDescription": "HA AK Ring in Use; Clockwise and Even",
-        "Counter": "0,1,2,3",
-        "EventCode": "0x3F",
-        "EventName": "UNC_H_RING_AK_USED.CW_EVEN",
+        "BriefDescription": "HA AD Ring in Use; Clockwise and Odd",
+        "EventCode": "0x3E",
+        "EventName": "UNC_H_RING_AD_USED.CW_ODD",
         "PerPkg": "1",
-        "UMask": "0x1",
+        "PublicDescription": "Counts the number of cycles that the AD ring=
 is being used at this ring stop.  This includes when packets are passing b=
y and when packets are being sunk, but does not include when packets are be=
ing sent from the ring stop.; Filters for the Clockwise and Odd ring polari=
ty.",
+        "UMask": "0x2",
         "Unit": "HA"
     },
     {
-        "BriefDescription": "HA AK Ring in Use; Clockwise and Odd",
-        "Counter": "0,1,2,3",
+        "BriefDescription": "HA AK Ring in Use; Counterclockwise",
         "EventCode": "0x3F",
-        "EventName": "UNC_H_RING_AK_USED.CW_ODD",
+        "EventName": "UNC_H_RING_AK_USED.CCW",
         "PerPkg": "1",
-        "UMask": "0x2",
+        "PublicDescription": "Counts the number of cycles that the AK ring=
 is being used at this ring stop.  This includes when packets are passing b=
y and when packets are being sunk, but does not include when packets are be=
ing sent from the ring stop.",
+        "UMask": "0xc",
         "Unit": "HA"
     },
     {
         "BriefDescription": "HA AK Ring in Use; Counterclockwise and Even"=
,
-        "Counter": "0,1,2,3",
         "EventCode": "0x3F",
         "EventName": "UNC_H_RING_AK_USED.CCW_EVEN",
         "PerPkg": "1",
+        "PublicDescription": "Counts the number of cycles that the AK ring=
 is being used at this ring stop.  This includes when packets are passing b=
y and when packets are being sunk, but does not include when packets are be=
ing sent from the ring stop.; Filters for the Counterclockwise and Even rin=
g polarity.",
         "UMask": "0x4",
         "Unit": "HA"
     },
     {
         "BriefDescription": "HA AK Ring in Use; Counterclockwise and Odd",
-        "Counter": "0,1,2,3",
         "EventCode": "0x3F",
         "EventName": "UNC_H_RING_AK_USED.CCW_ODD",
         "PerPkg": "1",
+        "PublicDescription": "Counts the number of cycles that the AK ring=
 is being used at this ring stop.  This includes when packets are passing b=
y and when packets are being sunk, but does not include when packets are be=
ing sent from the ring stop.; Filters for the Counterclockwise and Odd ring=
 polarity.",
         "UMask": "0x8",
         "Unit": "HA"
     },
     {
         "BriefDescription": "HA AK Ring in Use; Clockwise",
-        "Counter": "0,1,2,3",
         "EventCode": "0x3F",
         "EventName": "UNC_H_RING_AK_USED.CW",
         "PerPkg": "1",
+        "PublicDescription": "Counts the number of cycles that the AK ring=
 is being used at this ring stop.  This includes when packets are passing b=
y and when packets are being sunk, but does not include when packets are be=
ing sent from the ring stop.",
         "UMask": "0x3",
         "Unit": "HA"
     },
     {
-        "BriefDescription": "HA AK Ring in Use; Counterclockwise",
-        "Counter": "0,1,2,3",
+        "BriefDescription": "HA AK Ring in Use; Clockwise and Even",
         "EventCode": "0x3F",
-        "EventName": "UNC_H_RING_AK_USED.CCW",
+        "EventName": "UNC_H_RING_AK_USED.CW_EVEN",
         "PerPkg": "1",
-        "UMask": "0xC",
+        "PublicDescription": "Counts the number of cycles that the AK ring=
 is being used at this ring stop.  This includes when packets are passing b=
y and when packets are being sunk, but does not include when packets are be=
ing sent from the ring stop.; Filters for the Clockwise and Even ring polar=
ity.",
+        "UMask": "0x1",
         "Unit": "HA"
     },
     {
-        "BriefDescription": "HA BL Ring in Use; Clockwise and Even",
-        "Counter": "0,1,2,3",
-        "EventCode": "0x40",
-        "EventName": "UNC_H_RING_BL_USED.CW_EVEN",
+        "BriefDescription": "HA AK Ring in Use; Clockwise and Odd",
+        "EventCode": "0x3F",
+        "EventName": "UNC_H_RING_AK_USED.CW_ODD",
         "PerPkg": "1",
-        "UMask": "0x1",
+        "PublicDescription": "Counts the number of cycles that the AK ring=
 is being used at this ring stop.  This includes when packets are passing b=
y and when packets are being sunk, but does not include when packets are be=
ing sent from the ring stop.; Filters for the Clockwise and Odd ring polari=
ty.",
+        "UMask": "0x2",
         "Unit": "HA"
     },
     {
-        "BriefDescription": "HA BL Ring in Use; Clockwise and Odd",
-        "Counter": "0,1,2,3",
+        "BriefDescription": "HA BL Ring in Use; Counterclockwise",
         "EventCode": "0x40",
-        "EventName": "UNC_H_RING_BL_USED.CW_ODD",
+        "EventName": "UNC_H_RING_BL_USED.CCW",
         "PerPkg": "1",
-        "UMask": "0x2",
+        "PublicDescription": "Counts the number of cycles that the BL ring=
 is being used at this ring stop.  This includes when packets are passing b=
y and when packets are being sunk, but does not include when packets are be=
ing sent from the ring stop.",
+        "UMask": "0xc",
         "Unit": "HA"
     },
     {
         "BriefDescription": "HA BL Ring in Use; Counterclockwise and Even"=
,
-        "Counter": "0,1,2,3",
         "EventCode": "0x40",
         "EventName": "UNC_H_RING_BL_USED.CCW_EVEN",
         "PerPkg": "1",
+        "PublicDescription": "Counts the number of cycles that the BL ring=
 is being used at this ring stop.  This includes when packets are passing b=
y and when packets are being sunk, but does not include when packets are be=
ing sent from the ring stop.; Filters for the Counterclockwise and Even rin=
g polarity.",
         "UMask": "0x4",
         "Unit": "HA"
     },
     {
         "BriefDescription": "HA BL Ring in Use; Counterclockwise and Odd",
-        "Counter": "0,1,2,3",
         "EventCode": "0x40",
         "EventName": "UNC_H_RING_BL_USED.CCW_ODD",
         "PerPkg": "1",
+        "PublicDescription": "Counts the number of cycles that the BL ring=
 is being used at this ring stop.  This includes when packets are passing b=
y and when packets are being sunk, but does not include when packets are be=
ing sent from the ring stop.; Filters for the Counterclockwise and Odd ring=
 polarity.",
         "UMask": "0x8",
         "Unit": "HA"
     },
     {
         "BriefDescription": "HA BL Ring in Use; Clockwise",
-        "Counter": "0,1,2,3",
         "EventCode": "0x40",
         "EventName": "UNC_H_RING_BL_USED.CW",
         "PerPkg": "1",
+        "PublicDescription": "Counts the number of cycles that the BL ring=
 is being used at this ring stop.  This includes when packets are passing b=
y and when packets are being sunk, but does not include when packets are be=
ing sent from the ring stop.",
         "UMask": "0x3",
         "Unit": "HA"
     },
     {
-        "BriefDescription": "HA BL Ring in Use; Counterclockwise",
-        "Counter": "0,1,2,3",
+        "BriefDescription": "HA BL Ring in Use; Clockwise and Even",
         "EventCode": "0x40",
-        "EventName": "UNC_H_RING_BL_USED.CCW",
+        "EventName": "UNC_H_RING_BL_USED.CW_EVEN",
+        "PerPkg": "1",
+        "PublicDescription": "Counts the number of cycles that the BL ring=
 is being used at this ring stop.  This includes when packets are passing b=
y and when packets are being sunk, but does not include when packets are be=
ing sent from the ring stop.; Filters for the Clockwise and Even ring polar=
ity.",
+        "UMask": "0x1",
+        "Unit": "HA"
+    },
+    {
+        "BriefDescription": "HA BL Ring in Use; Clockwise and Odd",
+        "EventCode": "0x40",
+        "EventName": "UNC_H_RING_BL_USED.CW_ODD",
         "PerPkg": "1",
-        "UMask": "0xC",
+        "PublicDescription": "Counts the number of cycles that the BL ring=
 is being used at this ring stop.  This includes when packets are passing b=
y and when packets are being sunk, but does not include when packets are be=
ing sent from the ring stop.; Filters for the Clockwise and Odd ring polari=
ty.",
+        "UMask": "0x2",
         "Unit": "HA"
     },
     {
         "BriefDescription": "iMC RPQ Credits Empty - Regular; Channel 0",
-        "Counter": "0,1,2,3",
         "EventCode": "0x15",
         "EventName": "UNC_H_RPQ_CYCLES_NO_REG_CREDITS.CHN0",
         "PerPkg": "1",
+        "PublicDescription": "Counts the number of cycles when there are n=
o regular credits available for posting reads from the HA into the iMC.  In=
 order to send reads into the memory controller, the HA must first acquire =
a credit for the iMC's RPQ (read pending queue).  This queue is broken into=
 regular credits/buffers that are used by general reads, and special reques=
ts such as ISOCH reads.  This count only tracks the regular credits  Common=
 high banwidth workloads should be able to make use of all of the regular b=
uffers, but it will be difficult (and uncommon) to make use of both the reg=
ular and special buffers at the same time.  One can filter based on the mem=
ory controller channel.  One or more channels can be tracked at a given tim=
e.; Filter for memory controller channel 0 only.",
         "UMask": "0x1",
         "Unit": "HA"
     },
     {
         "BriefDescription": "iMC RPQ Credits Empty - Regular; Channel 1",
-        "Counter": "0,1,2,3",
         "EventCode": "0x15",
         "EventName": "UNC_H_RPQ_CYCLES_NO_REG_CREDITS.CHN1",
         "PerPkg": "1",
+        "PublicDescription": "Counts the number of cycles when there are n=
o regular credits available for posting reads from the HA into the iMC.  In=
 order to send reads into the memory controller, the HA must first acquire =
a credit for the iMC's RPQ (read pending queue).  This queue is broken into=
 regular credits/buffers that are used by general reads, and special reques=
ts such as ISOCH reads.  This count only tracks the regular credits  Common=
 high banwidth workloads should be able to make use of all of the regular b=
uffers, but it will be difficult (and uncommon) to make use of both the reg=
ular and special buffers at the same time.  One can filter based on the mem=
ory controller channel.  One or more channels can be tracked at a given tim=
e.; Filter for memory controller channel 1 only.",
         "UMask": "0x2",
         "Unit": "HA"
     },
     {
         "BriefDescription": "iMC RPQ Credits Empty - Regular; Channel 2",
-        "Counter": "0,1,2,3",
         "EventCode": "0x15",
         "EventName": "UNC_H_RPQ_CYCLES_NO_REG_CREDITS.CHN2",
         "PerPkg": "1",
+        "PublicDescription": "Counts the number of cycles when there are n=
o regular credits available for posting reads from the HA into the iMC.  In=
 order to send reads into the memory controller, the HA must first acquire =
a credit for the iMC's RPQ (read pending queue).  This queue is broken into=
 regular credits/buffers that are used by general reads, and special reques=
ts such as ISOCH reads.  This count only tracks the regular credits  Common=
 high banwidth workloads should be able to make use of all of the regular b=
uffers, but it will be difficult (and uncommon) to make use of both the reg=
ular and special buffers at the same time.  One can filter based on the mem=
ory controller channel.  One or more channels can be tracked at a given tim=
e.; Filter for memory controller channel 2 only.",
         "UMask": "0x4",
         "Unit": "HA"
     },
     {
         "BriefDescription": "iMC RPQ Credits Empty - Regular; Channel 3",
-        "Counter": "0,1,2,3",
         "EventCode": "0x15",
         "EventName": "UNC_H_RPQ_CYCLES_NO_REG_CREDITS.CHN3",
         "PerPkg": "1",
+        "PublicDescription": "Counts the number of cycles when there are n=
o regular credits available for posting reads from the HA into the iMC.  In=
 order to send reads into the memory controller, the HA must first acquire =
a credit for the iMC's RPQ (read pending queue).  This queue is broken into=
 regular credits/buffers that are used by general reads, and special reques=
ts such as ISOCH reads.  This count only tracks the regular credits  Common=
 high banwidth workloads should be able to make use of all of the regular b=
uffers, but it will be difficult (and uncommon) to make use of both the reg=
ular and special buffers at the same time.  One can filter based on the mem=
ory controller channel.  One or more channels can be tracked at a given tim=
e.; Filter for memory controller channel 3 only.",
         "UMask": "0x8",
         "Unit": "HA"
     },
     {
         "BriefDescription": "iMC RPQ Credits Empty - Special; Channel 0",
-        "Counter": "0,1,2,3",
         "EventCode": "0x16",
         "EventName": "UNC_H_RPQ_CYCLES_NO_SPEC_CREDITS.CHN0",
         "PerPkg": "1",
+        "PublicDescription": "Counts the number of cycles when there are n=
o special credits available for posting reads from the HA into the iMC.  In=
 order to send reads into the memory controller, the HA must first acquire =
a credit for the iMC's RPQ (read pending queue).  This queue is broken into=
 regular credits/buffers that are used by general reads, and special reques=
ts such as ISOCH reads.  This count only tracks the special credits.  This =
statistic is generally not interesting for general IA workloads, but may be=
 of interest for understanding the characteristics of systems using ISOCH. =
 One can filter based on the memory controller channel.  One or more channe=
ls can be tracked at a given time.; Filter for memory controller channel 0 =
only.",
         "UMask": "0x1",
         "Unit": "HA"
     },
     {
         "BriefDescription": "iMC RPQ Credits Empty - Special; Channel 1",
-        "Counter": "0,1,2,3",
         "EventCode": "0x16",
         "EventName": "UNC_H_RPQ_CYCLES_NO_SPEC_CREDITS.CHN1",
         "PerPkg": "1",
+        "PublicDescription": "Counts the number of cycles when there are n=
o special credits available for posting reads from the HA into the iMC.  In=
 order to send reads into the memory controller, the HA must first acquire =
a credit for the iMC's RPQ (read pending queue).  This queue is broken into=
 regular credits/buffers that are used by general reads, and special reques=
ts such as ISOCH reads.  This count only tracks the special credits.  This =
statistic is generally not interesting for general IA workloads, but may be=
 of interest for understanding the characteristics of systems using ISOCH. =
 One can filter based on the memory controller channel.  One or more channe=
ls can be tracked at a given time.; Filter for memory controller channel 1 =
only.",
         "UMask": "0x2",
         "Unit": "HA"
     },
     {
         "BriefDescription": "iMC RPQ Credits Empty - Special; Channel 2",
-        "Counter": "0,1,2,3",
         "EventCode": "0x16",
         "EventName": "UNC_H_RPQ_CYCLES_NO_SPEC_CREDITS.CHN2",
         "PerPkg": "1",
+        "PublicDescription": "Counts the number of cycles when there are n=
o special credits available for posting reads from the HA into the iMC.  In=
 order to send reads into the memory controller, the HA must first acquire =
a credit for the iMC's RPQ (read pending queue).  This queue is broken into=
 regular credits/buffers that are used by general reads, and special reques=
ts such as ISOCH reads.  This count only tracks the special credits.  This =
statistic is generally not interesting for general IA workloads, but may be=
 of interest for understanding the characteristics of systems using ISOCH. =
 One can filter based on the memory controller channel.  One or more channe=
ls can be tracked at a given time.; Filter for memory controller channel 2 =
only.",
         "UMask": "0x4",
         "Unit": "HA"
     },
     {
         "BriefDescription": "iMC RPQ Credits Empty - Special; Channel 3",
-        "Counter": "0,1,2,3",
         "EventCode": "0x16",
         "EventName": "UNC_H_RPQ_CYCLES_NO_SPEC_CREDITS.CHN3",
         "PerPkg": "1",
+        "PublicDescription": "Counts the number of cycles when there are n=
o special credits available for posting reads from the HA into the iMC.  In=
 order to send reads into the memory controller, the HA must first acquire =
a credit for the iMC's RPQ (read pending queue).  This queue is broken into=
 regular credits/buffers that are used by general reads, and special reques=
ts such as ISOCH reads.  This count only tracks the special credits.  This =
statistic is generally not interesting for general IA workloads, but may be=
 of interest for understanding the characteristics of systems using ISOCH. =
 One can filter based on the memory controller channel.  One or more channe=
ls can be tracked at a given time.; Filter for memory controller channel 3 =
only.",
         "UMask": "0x8",
         "Unit": "HA"
     },
     {
         "BriefDescription": "SBo0 Credits Acquired; For AD Ring",
-        "Counter": "0,1,2,3",
         "EventCode": "0x68",
         "EventName": "UNC_H_SBO0_CREDITS_ACQUIRED.AD",
         "PerPkg": "1",
+        "PublicDescription": "Number of Sbo 0 credits acquired in a given =
cycle, per ring.",
         "UMask": "0x1",
         "Unit": "HA"
     },
     {
         "BriefDescription": "SBo0 Credits Acquired; For BL Ring",
-        "Counter": "0,1,2,3",
         "EventCode": "0x68",
         "EventName": "UNC_H_SBO0_CREDITS_ACQUIRED.BL",
         "PerPkg": "1",
+        "PublicDescription": "Number of Sbo 0 credits acquired in a given =
cycle, per ring.",
         "UMask": "0x2",
         "Unit": "HA"
     },
     {
         "BriefDescription": "SBo0 Credits Occupancy; For AD Ring",
-        "Counter": "0,1,2,3",
         "EventCode": "0x6A",
         "EventName": "UNC_H_SBO0_CREDIT_OCCUPANCY.AD",
         "PerPkg": "1",
+        "PublicDescription": "Number of Sbo 0 credits in use in a given cy=
cle, per ring.",
         "UMask": "0x1",
         "Unit": "HA"
     },
     {
         "BriefDescription": "SBo0 Credits Occupancy; For BL Ring",
-        "Counter": "0,1,2,3",
         "EventCode": "0x6A",
         "EventName": "UNC_H_SBO0_CREDIT_OCCUPANCY.BL",
         "PerPkg": "1",
+        "PublicDescription": "Number of Sbo 0 credits in use in a given cy=
cle, per ring.",
         "UMask": "0x2",
         "Unit": "HA"
     },
     {
         "BriefDescription": "SBo1 Credits Acquired; For AD Ring",
-        "Counter": "0,1,2,3",
         "EventCode": "0x69",
         "EventName": "UNC_H_SBO1_CREDITS_ACQUIRED.AD",
         "PerPkg": "1",
+        "PublicDescription": "Number of Sbo 1 credits acquired in a given =
cycle, per ring.",
         "UMask": "0x1",
         "Unit": "HA"
     },
     {
         "BriefDescription": "SBo1 Credits Acquired; For BL Ring",
-        "Counter": "0,1,2,3",
         "EventCode": "0x69",
         "EventName": "UNC_H_SBO1_CREDITS_ACQUIRED.BL",
         "PerPkg": "1",
+        "PublicDescription": "Number of Sbo 1 credits acquired in a given =
cycle, per ring.",
         "UMask": "0x2",
         "Unit": "HA"
     },
     {
         "BriefDescription": "SBo1 Credits Occupancy; For AD Ring",
-        "Counter": "0,1,2,3",
         "EventCode": "0x6B",
         "EventName": "UNC_H_SBO1_CREDIT_OCCUPANCY.AD",
         "PerPkg": "1",
+        "PublicDescription": "Number of Sbo 1 credits in use in a given cy=
cle, per ring.",
         "UMask": "0x1",
         "Unit": "HA"
     },
     {
         "BriefDescription": "SBo1 Credits Occupancy; For BL Ring",
-        "Counter": "0,1,2,3",
         "EventCode": "0x6B",
         "EventName": "UNC_H_SBO1_CREDIT_OCCUPANCY.BL",
         "PerPkg": "1",
+        "PublicDescription": "Number of Sbo 1 credits in use in a given cy=
cle, per ring.",
         "UMask": "0x2",
         "Unit": "HA"
     },
     {
         "BriefDescription": "Data beat the Snoop Responses; Local Requests=
",
-        "Counter": "0,1,2,3",
         "EventCode": "0xA",
         "EventName": "UNC_H_SNOOPS_RSP_AFTER_DATA.LOCAL",
         "PerPkg": "1",
+        "PublicDescription": "Counts the number of reads when the snoop wa=
s on the critical path to the data return.; This filter includes only reque=
sts coming from the local socket.",
         "UMask": "0x1",
         "Unit": "HA"
     },
     {
         "BriefDescription": "Data beat the Snoop Responses; Remote Request=
s",
-        "Counter": "0,1,2,3",
         "EventCode": "0xA",
         "EventName": "UNC_H_SNOOPS_RSP_AFTER_DATA.REMOTE",
         "PerPkg": "1",
+        "PublicDescription": "Counts the number of reads when the snoop wa=
s on the critical path to the data return.; This filter includes only reque=
sts coming from remote sockets.",
         "UMask": "0x2",
         "Unit": "HA"
     },
+    {
+        "BriefDescription": "Cycles with Snoops Outstanding; All Requests"=
,
+        "EventCode": "0x8",
+        "EventName": "UNC_H_SNOOP_CYCLES_NE.ALL",
+        "PerPkg": "1",
+        "PublicDescription": "Counts cycles when one or more snoops are ou=
tstanding.; Tracked for snoops from both local and remote sockets.",
+        "UMask": "0x3",
+        "Unit": "HA"
+    },
     {
         "BriefDescription": "Cycles with Snoops Outstanding; Local Request=
s",
-        "Counter": "0,1,2,3",
         "EventCode": "0x8",
         "EventName": "UNC_H_SNOOP_CYCLES_NE.LOCAL",
         "PerPkg": "1",
+        "PublicDescription": "Counts cycles when one or more snoops are ou=
tstanding.; This filter includes only requests coming from the local socket=
.",
         "UMask": "0x1",
         "Unit": "HA"
     },
     {
         "BriefDescription": "Cycles with Snoops Outstanding; Remote Reques=
ts",
-        "Counter": "0,1,2,3",
         "EventCode": "0x8",
         "EventName": "UNC_H_SNOOP_CYCLES_NE.REMOTE",
         "PerPkg": "1",
+        "PublicDescription": "Counts cycles when one or more snoops are ou=
tstanding.; This filter includes only requests coming from remote sockets."=
,
         "UMask": "0x2",
         "Unit": "HA"
     },
-    {
-        "BriefDescription": "Cycles with Snoops Outstanding; All Requests"=
,
-        "Counter": "0,1,2,3",
-        "EventCode": "0x8",
-        "EventName": "UNC_H_SNOOP_CYCLES_NE.ALL",
-        "PerPkg": "1",
-        "UMask": "0x3",
-        "Unit": "HA"
-    },
     {
         "BriefDescription": "Tracker Snoops Outstanding Accumulator; Local=
 Requests",
-        "Counter": "0,1,2,3",
         "EventCode": "0x9",
         "EventName": "UNC_H_SNOOP_OCCUPANCY.LOCAL",
         "PerPkg": "1",
+        "PublicDescription": "Accumulates the occupancy of either the loca=
l HA tracker pool that have snoops pending in every cycle.    This can be u=
sed in conjection with the not empty stat to calculate average queue occupa=
ncy or the allocations stat in order to calculate average queue latency.  H=
A trackers are allocated as soon as a request enters the HA if an HT (HomeT=
racker) entry is available and this occupancy is decremented when all the s=
noop responses have returned.; This filter includes only requests coming fr=
om the local socket.",
         "UMask": "0x1",
         "Unit": "HA"
     },
     {
         "BriefDescription": "Tracker Snoops Outstanding Accumulator; Remot=
e Requests",
-        "Counter": "0,1,2,3",
         "EventCode": "0x9",
         "EventName": "UNC_H_SNOOP_OCCUPANCY.REMOTE",
         "PerPkg": "1",
+        "PublicDescription": "Accumulates the occupancy of either the loca=
l HA tracker pool that have snoops pending in every cycle.    This can be u=
sed in conjection with the not empty stat to calculate average queue occupa=
ncy or the allocations stat in order to calculate average queue latency.  H=
A trackers are allocated as soon as a request enters the HA if an HT (HomeT=
racker) entry is available and this occupancy is decremented when all the s=
noop responses have returned.; This filter includes only requests coming fr=
om remote sockets.",
         "UMask": "0x2",
         "Unit": "HA"
     },
+    {
+        "BriefDescription": "Snoop Responses Received; RSPCNFLCT*",
+        "EventCode": "0x21",
+        "EventName": "UNC_H_SNOOP_RESP.RSPCNFLCT",
+        "PerPkg": "1",
+        "PublicDescription": "Counts the total number of RspI snoop respon=
ses received.  Whenever a snoops are issued, one or more snoop responses wi=
ll be returned depending on the topology of the system.   In systems larger=
 than 2s, when multiple snoops are returned this will count all the snoops =
that are received.  For example, if 3 snoops were issued and returned RspI,=
 RspS, and RspSFwd; then each of these sub-events would increment by 1.; Fi=
lters for snoops responses of RspConflict.  This is returned when a snoop f=
inds an existing outstanding transaction in a remote caching agent when it =
CAMs that caching agent.  This triggers conflict resolution hardware.  This=
 covers both RspCnflct and RspCnflctWbI.",
+        "UMask": "0x40",
+        "Unit": "HA"
+    },
     {
         "BriefDescription": "Snoop Responses Received; RspI",
-        "Counter": "0,1,2,3",
         "EventCode": "0x21",
         "EventName": "UNC_H_SNOOP_RESP.RSPI",
         "PerPkg": "1",
+        "PublicDescription": "Counts the total number of RspI snoop respon=
ses received.  Whenever a snoops are issued, one or more snoop responses wi=
ll be returned depending on the topology of the system.   In systems larger=
 than 2s, when multiple snoops are returned this will count all the snoops =
that are received.  For example, if 3 snoops were issued and returned RspI,=
 RspS, and RspSFwd; then each of these sub-events would increment by 1.; Fi=
lters for snoops responses of RspI.  RspI is returned when the remote cache=
 does not have the data, or when the remote cache silently evicts data (suc=
h as when an RFO hits non-modified data).",
         "UMask": "0x1",
         "Unit": "HA"
     },
+    {
+        "BriefDescription": "M line forwarded from remote cache with no wr=
iteback to memory",
+        "EventCode": "0x21",
+        "EventName": "UNC_H_SNOOP_RESP.RSPIFWD",
+        "PerPkg": "1",
+        "PublicDescription": "Counts the total number of RspI snoop respon=
ses received.  Whenever a snoops are issued, one or more snoop responses wi=
ll be returned depending on the topology of the system.   In systems larger=
 than 2s, when multiple snoops are returned this will count all the snoops =
that are received.  For example, if 3 snoops were issued and returned RspI,=
 RspS, and RspSFwd; then each of these sub-events would increment by 1.; Fi=
lters for snoop responses of RspIFwd.  This is returned when a remote cachi=
ng agent forwards data and the requesting agent is able to acquire the data=
 in E or M states.  This is commonly returned with RFO transactions.  It ca=
n be either a HitM or a HitFE.",
+        "ScaleUnit": "64Bytes",
+        "UMask": "0x4",
+        "Unit": "HA"
+    },
     {
         "BriefDescription": "Shared line response from remote cache",
-        "Counter": "0,1,2,3",
         "EventCode": "0x21",
         "EventName": "UNC_H_SNOOP_RESP.RSPS",
         "PerPkg": "1",
+        "PublicDescription": "Counts the total number of RspI snoop respon=
ses received.  Whenever a snoops are issued, one or more snoop responses wi=
ll be returned depending on the topology of the system.   In systems larger=
 than 2s, when multiple snoops are returned this will count all the snoops =
that are received.  For example, if 3 snoops were issued and returned RspI,=
 RspS, and RspSFwd; then each of these sub-events would increment by 1.; Fi=
lters for snoop responses of RspS.  RspS is returned when a remote cache ha=
s data but is not forwarding it.  It is a way to let the requesting socket =
know that it cannot allocate the data in E state.  No data is sent with S R=
spS.",
         "ScaleUnit": "64Bytes",
         "UMask": "0x2",
         "Unit": "HA"
     },
     {
-        "BriefDescription": "M line forwarded from remote cache with no wr=
iteback to memory",
-        "Counter": "0,1,2,3",
+        "BriefDescription": "Shared line forwarded from remote cache",
         "EventCode": "0x21",
-        "EventName": "UNC_H_SNOOP_RESP.RSPIFWD",
+        "EventName": "UNC_H_SNOOP_RESP.RSPSFWD",
         "PerPkg": "1",
+        "PublicDescription": "Counts the total number of RspI snoop respon=
ses received.  Whenever a snoops are issued, one or more snoop responses wi=
ll be returned depending on the topology of the system.   In systems larger=
 than 2s, when multiple snoops are returned this will count all the snoops =
that are received.  For example, if 3 snoops were issued and returned RspI,=
 RspS, and RspSFwd; then each of these sub-events would increment by 1.; Fi=
lters for a snoop response of RspSFwd.  This is returned when a remote cach=
ing agent forwards data but holds on to its currently copy.  This is common=
 for data and code reads that hit in a remote socket in E or F state.",
         "ScaleUnit": "64Bytes",
-        "UMask": "0x4",
+        "UMask": "0x8",
         "Unit": "HA"
     },
     {
-        "BriefDescription": "Shared line forwarded from remote cache",
-        "Counter": "0,1,2,3",
+        "BriefDescription": "M line forwarded from remote cache along with=
 writeback to memory",
         "EventCode": "0x21",
-        "EventName": "UNC_H_SNOOP_RESP.RSPSFWD",
+        "EventName": "UNC_H_SNOOP_RESP.RSP_FWD_WB",
         "PerPkg": "1",
+        "PublicDescription": "Counts the total number of RspI snoop respon=
ses received.  Whenever a snoops are issued, one or more snoop responses wi=
ll be returned depending on the topology of the system.   In systems larger=
 than 2s, when multiple snoops are returned this will count all the snoops =
that are received.  For example, if 3 snoops were issued and returned RspI,=
 RspS, and RspSFwd; then each of these sub-events would increment by 1.; Fi=
lters for a snoop response of Rsp*Fwd*WB.  This snoop response is only used=
 in 4s systems.  It is used when a snoop HITM's in a remote caching agent a=
nd it directly forwards data to a requestor, and simultaneously returns dat=
a to the home to be written back to memory.",
         "ScaleUnit": "64Bytes",
-        "UMask": "0x8",
+        "UMask": "0x20",
         "Unit": "HA"
     },
     {
         "BriefDescription": "Snoop Responses Received; Rsp*WB",
-        "Counter": "0,1,2,3",
         "EventCode": "0x21",
         "EventName": "UNC_H_SNOOP_RESP.RSP_WB",
         "PerPkg": "1",
+        "PublicDescription": "Counts the total number of RspI snoop respon=
ses received.  Whenever a snoops are issued, one or more snoop responses wi=
ll be returned depending on the topology of the system.   In systems larger=
 than 2s, when multiple snoops are returned this will count all the snoops =
that are received.  For example, if 3 snoops were issued and returned RspI,=
 RspS, and RspSFwd; then each of these sub-events would increment by 1.; Fi=
lters for a snoop response of RspIWB or RspSWB.  This is returned when a no=
n-RFO request hits in M state.  Data and Code Reads can return either RspIW=
B or RspSWB depending on how the system has been configured.  InvItoE trans=
actions will also return RspIWB because they must acquire ownership.",
         "UMask": "0x10",
         "Unit": "HA"
     },
     {
-        "BriefDescription": "M line forwarded from remote cache along with=
 writeback to memory",
-        "Counter": "0,1,2,3",
-        "EventCode": "0x21",
-        "EventName": "UNC_H_SNOOP_RESP.RSP_FWD_WB",
+        "BriefDescription": "Snoop Responses Received Local; Other",
+        "EventCode": "0x60",
+        "EventName": "UNC_H_SNP_RESP_RECV_LOCAL.OTHER",
         "PerPkg": "1",
-        "ScaleUnit": "64Bytes",
-        "UMask": "0x20",
+        "PublicDescription": "Number of snoop responses received for a Loc=
al  request; Filters for all other snoop responses.",
+        "UMask": "0x80",
         "Unit": "HA"
     },
     {
-        "BriefDescription": "Snoop Responses Received; RSPCNFLCT*",
-        "Counter": "0,1,2,3",
-        "EventCode": "0x21",
-        "EventName": "UNC_H_SNOOP_RESP.RSPCNFLCT",
+        "BriefDescription": "Snoop Responses Received Local; RspCnflct",
+        "EventCode": "0x60",
+        "EventName": "UNC_H_SNP_RESP_RECV_LOCAL.RSPCNFLCT",
         "PerPkg": "1",
+        "PublicDescription": "Number of snoop responses received for a Loc=
al  request; Filters for snoops responses of RspConflict.  This is returned=
 when a snoop finds an existing outstanding transaction in a remote caching=
 agent when it CAMs that caching agent.  This triggers conflict resolution =
hardware.  This covers both RspCnflct and RspCnflctWbI.",
         "UMask": "0x40",
         "Unit": "HA"
     },
     {
         "BriefDescription": "Snoop Responses Received Local; RspI",
-        "Counter": "0,1,2,3",
         "EventCode": "0x60",
         "EventName": "UNC_H_SNP_RESP_RECV_LOCAL.RSPI",
         "PerPkg": "1",
+        "PublicDescription": "Number of snoop responses received for a Loc=
al  request; Filters for snoops responses of RspI.  RspI is returned when t=
he remote cache does not have the data, or when the remote cache silently e=
victs data (such as when an RFO hits non-modified data).",
         "UMask": "0x1",
         "Unit": "HA"
     },
-    {
-        "BriefDescription": "Snoop Responses Received Local; RspS",
-        "Counter": "0,1,2,3",
-        "EventCode": "0x60",
-        "EventName": "UNC_H_SNP_RESP_RECV_LOCAL.RSPS",
-        "PerPkg": "1",
-        "UMask": "0x2",
-        "Unit": "HA"
-    },
     {
         "BriefDescription": "Snoop Responses Received Local; RspIFwd",
-        "Counter": "0,1,2,3",
         "EventCode": "0x60",
         "EventName": "UNC_H_SNP_RESP_RECV_LOCAL.RSPIFWD",
         "PerPkg": "1",
+        "PublicDescription": "Number of snoop responses received for a Loc=
al  request; Filters for snoop responses of RspIFwd.  This is returned when=
 a remote caching agent forwards data and the requesting agent is able to a=
cquire the data in E or M states.  This is commonly returned with RFO trans=
actions.  It can be either a HitM or a HitFE.",
         "UMask": "0x4",
         "Unit": "HA"
     },
     {
-        "BriefDescription": "Snoop Responses Received Local; RspSFwd",
-        "Counter": "0,1,2,3",
+        "BriefDescription": "Snoop Responses Received Local; RspS",
         "EventCode": "0x60",
-        "EventName": "UNC_H_SNP_RESP_RECV_LOCAL.RSPSFWD",
+        "EventName": "UNC_H_SNP_RESP_RECV_LOCAL.RSPS",
         "PerPkg": "1",
-        "UMask": "0x8",
+        "PublicDescription": "Number of snoop responses received for a Loc=
al  request; Filters for snoop responses of RspS.  RspS is returned when a =
remote cache has data but is not forwarding it.  It is a way to let the req=
uesting socket know that it cannot allocate the data in E state.  No data i=
s sent with S RspS.",
+        "UMask": "0x2",
         "Unit": "HA"
     },
     {
-        "BriefDescription": "Snoop Responses Received Local; Rsp*WB",
-        "Counter": "0,1,2,3",
+        "BriefDescription": "Snoop Responses Received Local; RspSFwd",
         "EventCode": "0x60",
-        "EventName": "UNC_H_SNP_RESP_RECV_LOCAL.RSPxWB",
+        "EventName": "UNC_H_SNP_RESP_RECV_LOCAL.RSPSFWD",
         "PerPkg": "1",
-        "UMask": "0x10",
+        "PublicDescription": "Number of snoop responses received for a Loc=
al  request; Filters for a snoop response of RspSFwd.  This is returned whe=
n a remote caching agent forwards data but holds on to its currently copy. =
 This is common for data and code reads that hit in a remote socket in E or=
 F state.",
+        "UMask": "0x8",
         "Unit": "HA"
     },
     {
         "BriefDescription": "Snoop Responses Received Local; Rsp*FWD*WB",
-        "Counter": "0,1,2,3",
         "EventCode": "0x60",
         "EventName": "UNC_H_SNP_RESP_RECV_LOCAL.RSPxFWDxWB",
         "PerPkg": "1",
+        "PublicDescription": "Number of snoop responses received for a Loc=
al  request; Filters for a snoop response of Rsp*Fwd*WB.  This snoop respon=
se is only used in 4s systems.  It is used when a snoop HITM's in a remote =
caching agent and it directly forwards data to a requestor, and simultaneou=
sly returns data to the home to be written back to memory.",
         "UMask": "0x20",
         "Unit": "HA"
     },
     {
-        "BriefDescription": "Snoop Responses Received Local; RspCnflct",
-        "Counter": "0,1,2,3",
-        "EventCode": "0x60",
-        "EventName": "UNC_H_SNP_RESP_RECV_LOCAL.RSPCNFLCT",
-        "PerPkg": "1",
-        "UMask": "0x40",
-        "Unit": "HA"
-    },
-    {
-        "BriefDescription": "Snoop Responses Received Local; Other",
-        "Counter": "0,1,2,3",
+        "BriefDescription": "Snoop Responses Received Local; Rsp*WB",
         "EventCode": "0x60",
-        "EventName": "UNC_H_SNP_RESP_RECV_LOCAL.OTHER",
+        "EventName": "UNC_H_SNP_RESP_RECV_LOCAL.RSPxWB",
         "PerPkg": "1",
-        "UMask": "0x80",
+        "PublicDescription": "Number of snoop responses received for a Loc=
al  request; Filters for a snoop response of RspIWB or RspSWB.  This is ret=
urned when a non-RFO request hits in M state.  Data and Code Reads can retu=
rn either RspIWB or RspSWB depending on how the system has been configured.=
  InvItoE transactions will also return RspIWB because they must acquire ow=
nership.",
+        "UMask": "0x10",
         "Unit": "HA"
     },
     {
         "BriefDescription": "Stall on No Sbo Credits; For SBo0, AD Ring",
-        "Counter": "0,1,2,3",
         "EventCode": "0x6C",
         "EventName": "UNC_H_STALL_NO_SBO_CREDIT.SBO0_AD",
         "PerPkg": "1",
+        "PublicDescription": "Number of cycles Egress is stalled waiting f=
or an Sbo credit to become available.  Per Sbo, per Ring.",
         "UMask": "0x1",
         "Unit": "HA"
     },
     {
-        "BriefDescription": "Stall on No Sbo Credits; For SBo1, AD Ring",
-        "Counter": "0,1,2,3",
+        "BriefDescription": "Stall on No Sbo Credits; For SBo0, BL Ring",
         "EventCode": "0x6C",
-        "EventName": "UNC_H_STALL_NO_SBO_CREDIT.SBO1_AD",
+        "EventName": "UNC_H_STALL_NO_SBO_CREDIT.SBO0_BL",
         "PerPkg": "1",
-        "UMask": "0x2",
+        "PublicDescription": "Number of cycles Egress is stalled waiting f=
or an Sbo credit to become available.  Per Sbo, per Ring.",
+        "UMask": "0x4",
         "Unit": "HA"
     },
     {
-        "BriefDescription": "Stall on No Sbo Credits; For SBo0, BL Ring",
-        "Counter": "0,1,2,3",
+        "BriefDescription": "Stall on No Sbo Credits; For SBo1, AD Ring",
         "EventCode": "0x6C",
-        "EventName": "UNC_H_STALL_NO_SBO_CREDIT.SBO0_BL",
+        "EventName": "UNC_H_STALL_NO_SBO_CREDIT.SBO1_AD",
         "PerPkg": "1",
-        "UMask": "0x4",
+        "PublicDescription": "Number of cycles Egress is stalled waiting f=
or an Sbo credit to become available.  Per Sbo, per Ring.",
+        "UMask": "0x2",
         "Unit": "HA"
     },
     {
         "BriefDescription": "Stall on No Sbo Credits; For SBo1, BL Ring",
-        "Counter": "0,1,2,3",
         "EventCode": "0x6C",
         "EventName": "UNC_H_STALL_NO_SBO_CREDIT.SBO1_BL",
         "PerPkg": "1",
+        "PublicDescription": "Number of cycles Egress is stalled waiting f=
or an Sbo credit to become available.  Per Sbo, per Ring.",
         "UMask": "0x8",
         "Unit": "HA"
     },
     {
         "BriefDescription": "HA Requests to a TAD Region - Group 0; TAD Re=
gion 0",
-        "Counter": "0,1,2,3",
         "EventCode": "0x1B",
         "EventName": "UNC_H_TAD_REQUESTS_G0.REGION0",
         "PerPkg": "1",
+        "PublicDescription": "Counts the number of HA requests to a given =
TAD region.  There are up to 11 TAD (target address decode) regions in each=
 home agent.  All requests destined for the memory controller must first be=
 decoded to determine which TAD region they are in.  This event is filtered=
 based on the TAD region ID, and covers regions 0 to 7.  This event is usef=
ul for understanding how applications are using the memory that is spread a=
cross the different memory regions.  It is particularly useful for Monroe s=
ystems that use the TAD to enable individual channels to enter self-refresh=
 to save power.; Filters request made to TAD Region 0",
         "UMask": "0x1",
         "Unit": "HA"
     },
     {
         "BriefDescription": "HA Requests to a TAD Region - Group 0; TAD Re=
gion 1",
-        "Counter": "0,1,2,3",
         "EventCode": "0x1B",
         "EventName": "UNC_H_TAD_REQUESTS_G0.REGION1",
         "PerPkg": "1",
+        "PublicDescription": "Counts the number of HA requests to a given =
TAD region.  There are up to 11 TAD (target address decode) regions in each=
 home agent.  All requests destined for the memory controller must first be=
 decoded to determine which TAD region they are in.  This event is filtered=
 based on the TAD region ID, and covers regions 0 to 7.  This event is usef=
ul for understanding how applications are using the memory that is spread a=
cross the different memory regions.  It is particularly useful for Monroe s=
ystems that use the TAD to enable individual channels to enter self-refresh=
 to save power.; Filters request made to TAD Region 1",
         "UMask": "0x2",
         "Unit": "HA"
     },
     {
         "BriefDescription": "HA Requests to a TAD Region - Group 0; TAD Re=
gion 2",
-        "Counter": "0,1,2,3",
         "EventCode": "0x1B",
         "EventName": "UNC_H_TAD_REQUESTS_G0.REGION2",
         "PerPkg": "1",
+        "PublicDescription": "Counts the number of HA requests to a given =
TAD region.  There are up to 11 TAD (target address decode) regions in each=
 home agent.  All requests destined for the memory controller must first be=
 decoded to determine which TAD region they are in.  This event is filtered=
 based on the TAD region ID, and covers regions 0 to 7.  This event is usef=
ul for understanding how applications are using the memory that is spread a=
cross the different memory regions.  It is particularly useful for Monroe s=
ystems that use the TAD to enable individual channels to enter self-refresh=
 to save power.; Filters request made to TAD Region 2",
         "UMask": "0x4",
         "Unit": "HA"
     },
     {
         "BriefDescription": "HA Requests to a TAD Region - Group 0; TAD Re=
gion 3",
-        "Counter": "0,1,2,3",
         "EventCode": "0x1B",
         "EventName": "UNC_H_TAD_REQUESTS_G0.REGION3",
         "PerPkg": "1",
+        "PublicDescription": "Counts the number of HA requests to a given =
TAD region.  There are up to 11 TAD (target address decode) regions in each=
 home agent.  All requests destined for the memory controller must first be=
 decoded to determine which TAD region they are in.  This event is filtered=
 based on the TAD region ID, and covers regions 0 to 7.  This event is usef=
ul for understanding how applications are using the memory that is spread a=
cross the different memory regions.  It is particularly useful for Monroe s=
ystems that use the TAD to enable individual channels to enter self-refresh=
 to save power.; Filters request made to TAD Region 3",
         "UMask": "0x8",
         "Unit": "HA"
     },
     {
         "BriefDescription": "HA Requests to a TAD Region - Group 0; TAD Re=
gion 4",
-        "Counter": "0,1,2,3",
         "EventCode": "0x1B",
         "EventName": "UNC_H_TAD_REQUESTS_G0.REGION4",
         "PerPkg": "1",
+        "PublicDescription": "Counts the number of HA requests to a given =
TAD region.  There are up to 11 TAD (target address decode) regions in each=
 home agent.  All requests destined for the memory controller must first be=
 decoded to determine which TAD region they are in.  This event is filtered=
 based on the TAD region ID, and covers regions 0 to 7.  This event is usef=
ul for understanding how applications are using the memory that is spread a=
cross the different memory regions.  It is particularly useful for Monroe s=
ystems that use the TAD to enable individual channels to enter self-refresh=
 to save power.; Filters request made to TAD Region 4",
         "UMask": "0x10",
         "Unit": "HA"
     },
     {
         "BriefDescription": "HA Requests to a TAD Region - Group 0; TAD Re=
gion 5",
-        "Counter": "0,1,2,3",
         "EventCode": "0x1B",
         "EventName": "UNC_H_TAD_REQUESTS_G0.REGION5",
         "PerPkg": "1",
+        "PublicDescription": "Counts the number of HA requests to a given =
TAD region.  There are up to 11 TAD (target address decode) regions in each=
 home agent.  All requests destined for the memory controller must first be=
 decoded to determine which TAD region they are in.  This event is filtered=
 based on the TAD region ID, and covers regions 0 to 7.  This event is usef=
ul for understanding how applications are using the memory that is spread a=
cross the different memory regions.  It is particularly useful for Monroe s=
ystems that use the TAD to enable individual channels to enter self-refresh=
 to save power.; Filters request made to TAD Region 5",
         "UMask": "0x20",
         "Unit": "HA"
     },
     {
         "BriefDescription": "HA Requests to a TAD Region - Group 0; TAD Re=
gion 6",
-        "Counter": "0,1,2,3",
         "EventCode": "0x1B",
         "EventName": "UNC_H_TAD_REQUESTS_G0.REGION6",
         "PerPkg": "1",
+        "PublicDescription": "Counts the number of HA requests to a given =
TAD region.  There are up to 11 TAD (target address decode) regions in each=
 home agent.  All requests destined for the memory controller must first be=
 decoded to determine which TAD region they are in.  This event is filtered=
 based on the TAD region ID, and covers regions 0 to 7.  This event is usef=
ul for understanding how applications are using the memory that is spread a=
cross the different memory regions.  It is particularly useful for Monroe s=
ystems that use the TAD to enable individual channels to enter self-refresh=
 to save power.; Filters request made to TAD Region 6",
         "UMask": "0x40",
         "Unit": "HA"
     },
     {
         "BriefDescription": "HA Requests to a TAD Region - Group 0; TAD Re=
gion 7",
-        "Counter": "0,1,2,3",
         "EventCode": "0x1B",
         "EventName": "UNC_H_TAD_REQUESTS_G0.REGION7",
         "PerPkg": "1",
+        "PublicDescription": "Counts the number of HA requests to a given =
TAD region.  There are up to 11 TAD (target address decode) regions in each=
 home agent.  All requests destined for the memory controller must first be=
 decoded to determine which TAD region they are in.  This event is filtered=
 based on the TAD region ID, and covers regions 0 to 7.  This event is usef=
ul for understanding how applications are using the memory that is spread a=
cross the different memory regions.  It is particularly useful for Monroe s=
ystems that use the TAD to enable individual channels to enter self-refresh=
 to save power.; Filters request made to TAD Region 7",
         "UMask": "0x80",
         "Unit": "HA"
     },
+    {
+        "BriefDescription": "HA Requests to a TAD Region - Group 1; TAD Re=
gion 10",
+        "EventCode": "0x1C",
+        "EventName": "UNC_H_TAD_REQUESTS_G1.REGION10",
+        "PerPkg": "1",
+        "PublicDescription": "Counts the number of HA requests to a given =
TAD region.  There are up to 11 TAD (target address decode) regions in each=
 home agent.  All requests destined for the memory controller must first be=
 decoded to determine which TAD region they are in.  This event is filtered=
 based on the TAD region ID, and covers regions 8 to 10.  This event is use=
ful for understanding how applications are using the memory that is spread =
across the different memory regions.  It is particularly useful for Monroe =
systems that use the TAD to enable individual channels to enter self-refres=
h to save power.; Filters request made to TAD Region 10",
+        "UMask": "0x4",
+        "Unit": "HA"
+    },
+    {
+        "BriefDescription": "HA Requests to a TAD Region - Group 1; TAD Re=
gion 11",
+        "EventCode": "0x1C",
+        "EventName": "UNC_H_TAD_REQUESTS_G1.REGION11",
+        "PerPkg": "1",
+        "PublicDescription": "Counts the number of HA requests to a given =
TAD region.  There are up to 11 TAD (target address decode) regions in each=
 home agent.  All requests destined for the memory controller must first be=
 decoded to determine which TAD region they are in.  This event is filtered=
 based on the TAD region ID, and covers regions 8 to 10.  This event is use=
ful for understanding how applications are using the memory that is spread =
across the different memory regions.  It is particularly useful for Monroe =
systems that use the TAD to enable individual channels to enter self-refres=
h to save power.; Filters request made to TAD Region 11",
+        "UMask": "0x8",
+        "Unit": "HA"
+    },
     {
         "BriefDescription": "HA Requests to a TAD Region - Group 1; TAD Re=
gion 8",
-        "Counter": "0,1,2,3",
         "EventCode": "0x1C",
         "EventName": "UNC_H_TAD_REQUESTS_G1.REGION8",
         "PerPkg": "1",
+        "PublicDescription": "Counts the number of HA requests to a given =
TAD region.  There are up to 11 TAD (target address decode) regions in each=
 home agent.  All requests destined for the memory controller must first be=
 decoded to determine which TAD region they are in.  This event is filtered=
 based on the TAD region ID, and covers regions 8 to 10.  This event is use=
ful for understanding how applications are using the memory that is spread =
across the different memory regions.  It is particularly useful for Monroe =
systems that use the TAD to enable individual channels to enter self-refres=
h to save power.; Filters request made to TAD Region 8",
         "UMask": "0x1",
         "Unit": "HA"
     },
     {
         "BriefDescription": "HA Requests to a TAD Region - Group 1; TAD Re=
gion 9",
-        "Counter": "0,1,2,3",
         "EventCode": "0x1C",
         "EventName": "UNC_H_TAD_REQUESTS_G1.REGION9",
         "PerPkg": "1",
+        "PublicDescription": "Counts the number of HA requests to a given =
TAD region.  There are up to 11 TAD (target address decode) regions in each=
 home agent.  All requests destined for the memory controller must first be=
 decoded to determine which TAD region they are in.  This event is filtered=
 based on the TAD region ID, and covers regions 8 to 10.  This event is use=
ful for understanding how applications are using the memory that is spread =
across the different memory regions.  It is particularly useful for Monroe =
systems that use the TAD to enable individual channels to enter self-refres=
h to save power.; Filters request made to TAD Region 9",
         "UMask": "0x2",
         "Unit": "HA"
     },
     {
-        "BriefDescription": "HA Requests to a TAD Region - Group 1; TAD Re=
gion 10",
-        "Counter": "0,1,2,3",
-        "EventCode": "0x1C",
-        "EventName": "UNC_H_TAD_REQUESTS_G1.REGION10",
+        "BriefDescription": "Tracker Cycles Full; Cycles Completely Used",
+        "EventCode": "0x2",
+        "EventName": "UNC_H_TRACKER_CYCLES_FULL.ALL",
         "PerPkg": "1",
-        "UMask": "0x4",
+        "PublicDescription": "Counts the number of cycles when the local H=
A tracker pool is completely used.  This can be used with edge detect to id=
entify the number of situations when the pool became fully utilized.  This =
should not be confused with RTID credit usage -- which must be tracked insi=
de each cbo individually -- but represents the actual tracker buffer struct=
ure.  In other words, the system could be starved for RTIDs but not fill up=
 the HA trackers.  HA trackers are allocated as soon as a request enters th=
e HA and is released after the snoop response and data return (or post in t=
he case of a write) and the response is returned on the ring.; Counts the n=
umber of cycles when the HA tracker pool (HT) is completely used including =
reserved HT entries.  It will not return valid count when BT is disabled.",
+        "UMask": "0x2",
         "Unit": "HA"
     },
     {
-        "BriefDescription": "HA Requests to a TAD Region - Group 1; TAD Re=
gion 11",
-        "Counter": "0,1,2,3",
-        "EventCode": "0x1C",
-        "EventName": "UNC_H_TAD_REQUESTS_G1.REGION11",
+        "BriefDescription": "Tracker Cycles Full; Cycles GP Completely Use=
d",
+        "EventCode": "0x2",
+        "EventName": "UNC_H_TRACKER_CYCLES_FULL.GP",
         "PerPkg": "1",
-        "UMask": "0x8",
+        "PublicDescription": "Counts the number of cycles when the local H=
A tracker pool is completely used.  This can be used with edge detect to id=
entify the number of situations when the pool became fully utilized.  This =
should not be confused with RTID credit usage -- which must be tracked insi=
de each cbo individually -- but represents the actual tracker buffer struct=
ure.  In other words, the system could be starved for RTIDs but not fill up=
 the HA trackers.  HA trackers are allocated as soon as a request enters th=
e HA and is released after the snoop response and data return (or post in t=
he case of a write) and the response is returned on the ring.; Counts the n=
umber of cycles when the general purpose (GP) HA tracker pool (HT) is compl=
etely used.  It will not return valid count when BT is disabled.",
+        "UMask": "0x1",
         "Unit": "HA"
     },
     {
-        "BriefDescription": "Tracker Cycles Full; Cycles GP Completely Use=
d",
-        "Counter": "0,1,2,3",
-        "EventCode": "0x2",
-        "EventName": "UNC_H_TRACKER_CYCLES_FULL.GP",
+        "BriefDescription": "Tracker Cycles Not Empty; All Requests",
+        "EventCode": "0x3",
+        "EventName": "UNC_H_TRACKER_CYCLES_NE.ALL",
         "PerPkg": "1",
+        "PublicDescription": "Counts the number of cycles when the local H=
A tracker pool is not empty.  This can be used with edge detect to identify=
 the number of situations when the pool became empty.  This should not be c=
onfused with RTID credit usage -- which must be tracked inside each cbo ind=
ividually -- but represents the actual tracker buffer structure.  In other =
words, this buffer could be completely empty, but there may still be credit=
s in use by the CBos.  This stat can be used in conjunction with the occupa=
ncy accumulation stat in order to calculate average queue occpancy.  HA tra=
ckers are allocated as soon as a request enters the HA if an HT (Home Track=
er) entry is available and is released after the snoop response and data re=
turn (or post in the case of a write) and the response is returned on the r=
ing.; Requests coming from both local and remote sockets.",
+        "UMask": "0x3",
+        "Unit": "HA"
+    },
+    {
+        "BriefDescription": "Tracker Cycles Not Empty; Local Requests",
+        "EventCode": "0x3",
+        "EventName": "UNC_H_TRACKER_CYCLES_NE.LOCAL",
+        "PerPkg": "1",
+        "PublicDescription": "Counts the number of cycles when the local H=
A tracker pool is not empty.  This can be used with edge detect to identify=
 the number of situations when the pool became empty.  This should not be c=
onfused with RTID credit usage -- which must be tracked inside each cbo ind=
ividually -- but represents the actual tracker buffer structure.  In other =
words, this buffer could be completely empty, but there may still be credit=
s in use by the CBos.  This stat can be used in conjunction with the occupa=
ncy accumulation stat in order to calculate average queue occpancy.  HA tra=
ckers are allocated as soon as a request enters the HA if an HT (Home Track=
er) entry is available and is released after the snoop response and data re=
turn (or post in the case of a write) and the response is returned on the r=
ing.; This filter includes only requests coming from the local socket.",
         "UMask": "0x1",
         "Unit": "HA"
     },
     {
-        "BriefDescription": "Tracker Cycles Full; Cycles Completely Used",
-        "Counter": "0,1,2,3",
-        "EventCode": "0x2",
-        "EventName": "UNC_H_TRACKER_CYCLES_FULL.ALL",
+        "BriefDescription": "Tracker Cycles Not Empty; Remote Requests",
+        "EventCode": "0x3",
+        "EventName": "UNC_H_TRACKER_CYCLES_NE.REMOTE",
         "PerPkg": "1",
+        "PublicDescription": "Counts the number of cycles when the local H=
A tracker pool is not empty.  This can be used with edge detect to identify=
 the number of situations when the pool became empty.  This should not be c=
onfused with RTID credit usage -- which must be tracked inside each cbo ind=
ividually -- but represents the actual tracker buffer structure.  In other =
words, this buffer could be completely empty, but there may still be credit=
s in use by the CBos.  This stat can be used in conjunction with the occupa=
ncy accumulation stat in order to calculate average queue occpancy.  HA tra=
ckers are allocated as soon as a request enters the HA if an HT (Home Track=
er) entry is available and is released after the snoop response and data re=
turn (or post in the case of a write) and the response is returned on the r=
ing.; This filter includes only requests coming from remote sockets.",
         "UMask": "0x2",
         "Unit": "HA"
     },
+    {
+        "BriefDescription": "Tracker Occupancy Accumultor; Local InvItoE R=
equests",
+        "EventCode": "0x4",
+        "EventName": "UNC_H_TRACKER_OCCUPANCY.INVITOE_LOCAL",
+        "PerPkg": "1",
+        "PublicDescription": "Accumulates the occupancy of the local HA tr=
acker pool in every cycle.  This can be used in conjection with the not emp=
ty stat to calculate average queue occupancy or the allocations stat in ord=
er to calculate average queue latency.  HA trackers are allocated as soon a=
s a request enters the HA if a HT (Home Tracker) entry is available and is =
released after the snoop response and data return (or post in the case of a=
 write) and the response is returned on the ring.",
+        "UMask": "0x40",
+        "Unit": "HA"
+    },
+    {
+        "BriefDescription": "Tracker Occupancy Accumultor; Remote InvItoE =
Requests",
+        "EventCode": "0x4",
+        "EventName": "UNC_H_TRACKER_OCCUPANCY.INVITOE_REMOTE",
+        "PerPkg": "1",
+        "PublicDescription": "Accumulates the occupancy of the local HA tr=
acker pool in every cycle.  This can be used in conjection with the not emp=
ty stat to calculate average queue occupancy or the allocations stat in ord=
er to calculate average queue latency.  HA trackers are allocated as soon a=
s a request enters the HA if a HT (Home Tracker) entry is available and is =
released after the snoop response and data return (or post in the case of a=
 write) and the response is returned on the ring.",
+        "UMask": "0x80",
+        "Unit": "HA"
+    },
     {
         "BriefDescription": "Tracker Occupancy Accumultor; Local Read Requ=
ests",
-        "Counter": "0,1,2,3",
         "EventCode": "0x4",
         "EventName": "UNC_H_TRACKER_OCCUPANCY.READS_LOCAL",
         "PerPkg": "1",
+        "PublicDescription": "Accumulates the occupancy of the local HA tr=
acker pool in every cycle.  This can be used in conjection with the not emp=
ty stat to calculate average queue occupancy or the allocations stat in ord=
er to calculate average queue latency.  HA trackers are allocated as soon a=
s a request enters the HA if a HT (Home Tracker) entry is available and is =
released after the snoop response and data return (or post in the case of a=
 write) and the response is returned on the ring.",
         "UMask": "0x4",
         "Unit": "HA"
     },
     {
         "BriefDescription": "Tracker Occupancy Accumultor; Remote Read Req=
uests",
-        "Counter": "0,1,2,3",
         "EventCode": "0x4",
         "EventName": "UNC_H_TRACKER_OCCUPANCY.READS_REMOTE",
         "PerPkg": "1",
+        "PublicDescription": "Accumulates the occupancy of the local HA tr=
acker pool in every cycle.  This can be used in conjection with the not emp=
ty stat to calculate average queue occupancy or the allocations stat in ord=
er to calculate average queue latency.  HA trackers are allocated as soon a=
s a request enters the HA if a HT (Home Tracker) entry is available and is =
released after the snoop response and data return (or post in the case of a=
 write) and the response is returned on the ring.",
         "UMask": "0x8",
         "Unit": "HA"
     },
     {
         "BriefDescription": "Tracker Occupancy Accumultor; Local Write Req=
uests",
-        "Counter": "0,1,2,3",
         "EventCode": "0x4",
         "EventName": "UNC_H_TRACKER_OCCUPANCY.WRITES_LOCAL",
         "PerPkg": "1",
+        "PublicDescription": "Accumulates the occupancy of the local HA tr=
acker pool in every cycle.  This can be used in conjection with the not emp=
ty stat to calculate average queue occupancy or the allocations stat in ord=
er to calculate average queue latency.  HA trackers are allocated as soon a=
s a request enters the HA if a HT (Home Tracker) entry is available and is =
released after the snoop response and data return (or post in the case of a=
 write) and the response is returned on the ring.",
         "UMask": "0x10",
         "Unit": "HA"
     },
     {
         "BriefDescription": "Tracker Occupancy Accumultor; Remote Write Re=
quests",
-        "Counter": "0,1,2,3",
         "EventCode": "0x4",
         "EventName": "UNC_H_TRACKER_OCCUPANCY.WRITES_REMOTE",
         "PerPkg": "1",
+        "PublicDescription": "Accumulates the occupancy of the local HA tr=
acker pool in every cycle.  This can be used in conjection with the not emp=
ty stat to calculate average queue occupancy or the allocations stat in ord=
er to calculate average queue latency.  HA trackers are allocated as soon a=
s a request enters the HA if a HT (Home Tracker) entry is available and is =
released after the snoop response and data return (or post in the case of a=
 write) and the response is returned on the ring.",
         "UMask": "0x20",
         "Unit": "HA"
     },
-    {
-        "BriefDescription": "Tracker Occupancy Accumultor; Local InvItoE R=
equests",
-        "Counter": "0,1,2,3",
-        "EventCode": "0x4",
-        "EventName": "UNC_H_TRACKER_OCCUPANCY.INVITOE_LOCAL",
-        "PerPkg": "1",
-        "UMask": "0x40",
-        "Unit": "HA"
-    },
-    {
-        "BriefDescription": "Tracker Occupancy Accumultor; Remote InvItoE =
Requests",
-        "Counter": "0,1,2,3",
-        "EventCode": "0x4",
-        "EventName": "UNC_H_TRACKER_OCCUPANCY.INVITOE_REMOTE",
-        "PerPkg": "1",
-        "UMask": "0x80",
-        "Unit": "HA"
-    },
     {
         "BriefDescription": "Data Pending Occupancy Accumultor; Local Requ=
ests",
-        "Counter": "0,1,2,3",
         "EventCode": "0x5",
         "EventName": "UNC_H_TRACKER_PENDING_OCCUPANCY.LOCAL",
         "PerPkg": "1",
+        "PublicDescription": "Accumulates the number of transactions that =
have data from the memory controller until they get scheduled to the Egress=
.  This can be used to calculate the queuing latency for two things.  (1) I=
f the system is waiting for snoops, this will increase.  (2) If the system =
can't schedule to the Egress because of either (a) Egress Credits or (b) QP=
I BL IGR credits for remote requests.; This filter includes only requests c=
oming from the local socket.",
         "UMask": "0x1",
         "Unit": "HA"
     },
     {
         "BriefDescription": "Data Pending Occupancy Accumultor; Remote Req=
uests",
-        "Counter": "0,1,2,3",
         "EventCode": "0x5",
         "EventName": "UNC_H_TRACKER_PENDING_OCCUPANCY.REMOTE",
         "PerPkg": "1",
+        "PublicDescription": "Accumulates the number of transactions that =
have data from the memory controller until they get scheduled to the Egress=
.  This can be used to calculate the queuing latency for two things.  (1) I=
f the system is waiting for snoops, this will increase.  (2) If the system =
can't schedule to the Egress because of either (a) Egress Credits or (b) QP=
I BL IGR credits for remote requests.; This filter includes only requests c=
oming from remote sockets.",
         "UMask": "0x2",
         "Unit": "HA"
     },
     {
         "BriefDescription": "Outbound NDR Ring Transactions; Non-data Resp=
onses",
-        "Counter": "0,1,2,3",
         "EventCode": "0xF",
         "EventName": "UNC_H_TxR_AD.HOM",
         "PerPkg": "1",
+        "PublicDescription": "Counts the number of outbound transactions o=
n the AD ring.  This can be filtered by the NDR and SNP message classes.  S=
ee the filter descriptions for more details.; Filter for outbound NDR trans=
actions sent on the AD ring.  NDR stands for non-data response and is gener=
ally used for completions that do not include data.  AD NDR is used for tra=
nsactions to remote sockets.",
         "UMask": "0x4",
         "Unit": "HA"
     },
+    {
+        "BriefDescription": "AD Egress Full; All",
+        "EventCode": "0x2A",
+        "EventName": "UNC_H_TxR_AD_CYCLES_FULL.ALL",
+        "PerPkg": "1",
+        "PublicDescription": "AD Egress Full; Cycles full from both schedu=
lers",
+        "UMask": "0x3",
+        "Unit": "HA"
+    },
     {
         "BriefDescription": "AD Egress Full; Scheduler 0",
-        "Counter": "0,1,2,3",
         "EventCode": "0x2A",
         "EventName": "UNC_H_TxR_AD_CYCLES_FULL.SCHED0",
         "PerPkg": "1",
+        "PublicDescription": "AD Egress Full; Filter for cycles full  from=
 scheduler bank 0",
         "UMask": "0x1",
         "Unit": "HA"
     },
     {
         "BriefDescription": "AD Egress Full; Scheduler 1",
-        "Counter": "0,1,2,3",
         "EventCode": "0x2A",
         "EventName": "UNC_H_TxR_AD_CYCLES_FULL.SCHED1",
         "PerPkg": "1",
+        "PublicDescription": "AD Egress Full; Filter for cycles full  from=
 scheduler bank 1",
         "UMask": "0x2",
         "Unit": "HA"
     },
     {
-        "BriefDescription": "AD Egress Full; All",
-        "Counter": "0,1,2,3",
-        "EventCode": "0x2A",
-        "EventName": "UNC_H_TxR_AD_CYCLES_FULL.ALL",
+        "BriefDescription": "AD Egress Not Empty; All",
+        "EventCode": "0x29",
+        "EventName": "UNC_H_TxR_AD_CYCLES_NE.ALL",
         "PerPkg": "1",
+        "PublicDescription": "AD Egress Not Empty; Cycles full from both s=
chedulers",
         "UMask": "0x3",
         "Unit": "HA"
     },
     {
         "BriefDescription": "AD Egress Not Empty; Scheduler 0",
-        "Counter": "0,1,2,3",
         "EventCode": "0x29",
         "EventName": "UNC_H_TxR_AD_CYCLES_NE.SCHED0",
         "PerPkg": "1",
+        "PublicDescription": "AD Egress Not Empty; Filter for cycles not e=
mpty  from scheduler bank 0",
         "UMask": "0x1",
         "Unit": "HA"
     },
     {
         "BriefDescription": "AD Egress Not Empty; Scheduler 1",
-        "Counter": "0,1,2,3",
         "EventCode": "0x29",
         "EventName": "UNC_H_TxR_AD_CYCLES_NE.SCHED1",
         "PerPkg": "1",
+        "PublicDescription": "AD Egress Not Empty; Filter for cycles not e=
mpty from scheduler bank 1",
         "UMask": "0x2",
         "Unit": "HA"
     },
     {
-        "BriefDescription": "AD Egress Not Empty; All",
-        "Counter": "0,1,2,3",
-        "EventCode": "0x29",
-        "EventName": "UNC_H_TxR_AD_CYCLES_NE.ALL",
+        "BriefDescription": "AD Egress Allocations; All",
+        "EventCode": "0x27",
+        "EventName": "UNC_H_TxR_AD_INSERTS.ALL",
         "PerPkg": "1",
+        "PublicDescription": "AD Egress Allocations; Allocations from both=
 schedulers",
         "UMask": "0x3",
         "Unit": "HA"
     },
     {
         "BriefDescription": "AD Egress Allocations; Scheduler 0",
-        "Counter": "0,1,2,3",
         "EventCode": "0x27",
         "EventName": "UNC_H_TxR_AD_INSERTS.SCHED0",
         "PerPkg": "1",
+        "PublicDescription": "AD Egress Allocations; Filter for allocation=
s from scheduler bank 0",
         "UMask": "0x1",
         "Unit": "HA"
     },
     {
         "BriefDescription": "AD Egress Allocations; Scheduler 1",
-        "Counter": "0,1,2,3",
         "EventCode": "0x27",
         "EventName": "UNC_H_TxR_AD_INSERTS.SCHED1",
         "PerPkg": "1",
+        "PublicDescription": "AD Egress Allocations; Filter for allocation=
s from scheduler bank 1",
         "UMask": "0x2",
         "Unit": "HA"
     },
     {
-        "BriefDescription": "AD Egress Allocations; All",
-        "Counter": "0,1,2,3",
-        "EventCode": "0x27",
-        "EventName": "UNC_H_TxR_AD_INSERTS.ALL",
+        "BriefDescription": "AK Egress Full; All",
+        "EventCode": "0x32",
+        "EventName": "UNC_H_TxR_AK_CYCLES_FULL.ALL",
         "PerPkg": "1",
+        "PublicDescription": "AK Egress Full; Cycles full from both schedu=
lers",
         "UMask": "0x3",
         "Unit": "HA"
     },
     {
         "BriefDescription": "AK Egress Full; Scheduler 0",
-        "Counter": "0,1,2,3",
         "EventCode": "0x32",
         "EventName": "UNC_H_TxR_AK_CYCLES_FULL.SCHED0",
         "PerPkg": "1",
+        "PublicDescription": "AK Egress Full; Filter for cycles full  from=
 scheduler bank 0",
         "UMask": "0x1",
         "Unit": "HA"
     },
     {
         "BriefDescription": "AK Egress Full; Scheduler 1",
-        "Counter": "0,1,2,3",
         "EventCode": "0x32",
         "EventName": "UNC_H_TxR_AK_CYCLES_FULL.SCHED1",
         "PerPkg": "1",
+        "PublicDescription": "AK Egress Full; Filter for cycles full  from=
 scheduler bank 1",
         "UMask": "0x2",
         "Unit": "HA"
     },
     {
-        "BriefDescription": "AK Egress Full; All",
-        "Counter": "0,1,2,3",
-        "EventCode": "0x32",
-        "EventName": "UNC_H_TxR_AK_CYCLES_FULL.ALL",
+        "BriefDescription": "AK Egress Not Empty; All",
+        "EventCode": "0x31",
+        "EventName": "UNC_H_TxR_AK_CYCLES_NE.ALL",
         "PerPkg": "1",
+        "PublicDescription": "AK Egress Not Empty; Cycles full from both s=
chedulers",
         "UMask": "0x3",
         "Unit": "HA"
     },
     {
         "BriefDescription": "AK Egress Not Empty; Scheduler 0",
-        "Counter": "0,1,2,3",
         "EventCode": "0x31",
         "EventName": "UNC_H_TxR_AK_CYCLES_NE.SCHED0",
         "PerPkg": "1",
+        "PublicDescription": "AK Egress Not Empty; Filter for cycles not e=
mpty  from scheduler bank 0",
         "UMask": "0x1",
         "Unit": "HA"
     },
     {
         "BriefDescription": "AK Egress Not Empty; Scheduler 1",
-        "Counter": "0,1,2,3",
         "EventCode": "0x31",
         "EventName": "UNC_H_TxR_AK_CYCLES_NE.SCHED1",
         "PerPkg": "1",
+        "PublicDescription": "AK Egress Not Empty; Filter for cycles not e=
mpty from scheduler bank 1",
         "UMask": "0x2",
         "Unit": "HA"
     },
     {
-        "BriefDescription": "AK Egress Not Empty; All",
-        "Counter": "0,1,2,3",
-        "EventCode": "0x31",
-        "EventName": "UNC_H_TxR_AK_CYCLES_NE.ALL",
+        "BriefDescription": "AK Egress Allocations; All",
+        "EventCode": "0x2F",
+        "EventName": "UNC_H_TxR_AK_INSERTS.ALL",
         "PerPkg": "1",
+        "PublicDescription": "AK Egress Allocations; Allocations from both=
 schedulers",
         "UMask": "0x3",
         "Unit": "HA"
     },
     {
         "BriefDescription": "AK Egress Allocations; Scheduler 0",
-        "Counter": "0,1,2,3",
         "EventCode": "0x2F",
         "EventName": "UNC_H_TxR_AK_INSERTS.SCHED0",
         "PerPkg": "1",
+        "PublicDescription": "AK Egress Allocations; Filter for allocation=
s from scheduler bank 0",
         "UMask": "0x1",
         "Unit": "HA"
     },
     {
         "BriefDescription": "AK Egress Allocations; Scheduler 1",
-        "Counter": "0,1,2,3",
         "EventCode": "0x2F",
         "EventName": "UNC_H_TxR_AK_INSERTS.SCHED1",
         "PerPkg": "1",
+        "PublicDescription": "AK Egress Allocations; Filter for allocation=
s from scheduler bank 1",
         "UMask": "0x2",
         "Unit": "HA"
     },
-    {
-        "BriefDescription": "AK Egress Allocations; All",
-        "Counter": "0,1,2,3",
-        "EventCode": "0x2F",
-        "EventName": "UNC_H_TxR_AK_INSERTS.ALL",
-        "PerPkg": "1",
-        "UMask": "0x3",
-        "Unit": "HA"
-    },
     {
         "BriefDescription": "Outbound DRS Ring Transactions to Cache; Data=
 to Cache",
-        "Counter": "0,1,2,3",
         "EventCode": "0x10",
         "EventName": "UNC_H_TxR_BL.DRS_CACHE",
         "PerPkg": "1",
+        "PublicDescription": "Counts the number of DRS messages sent out o=
n the BL ring.   This can be filtered by the destination.; Filter for data =
being sent to the cache.",
         "UMask": "0x1",
         "Unit": "HA"
     },
     {
         "BriefDescription": "Outbound DRS Ring Transactions to Cache; Data=
 to Core",
-        "Counter": "0,1,2,3",
         "EventCode": "0x10",
         "EventName": "UNC_H_TxR_BL.DRS_CORE",
         "PerPkg": "1",
+        "PublicDescription": "Counts the number of DRS messages sent out o=
n the BL ring.   This can be filtered by the destination.; Filter for data =
being sent directly to the requesting core.",
         "UMask": "0x2",
         "Unit": "HA"
     },
     {
         "BriefDescription": "Outbound DRS Ring Transactions to Cache; Data=
 to QPI",
-        "Counter": "0,1,2,3",
         "EventCode": "0x10",
         "EventName": "UNC_H_TxR_BL.DRS_QPI",
         "PerPkg": "1",
+        "PublicDescription": "Counts the number of DRS messages sent out o=
n the BL ring.   This can be filtered by the destination.; Filter for data =
being sent to a remote socket over QPI.",
         "UMask": "0x4",
         "Unit": "HA"
     },
+    {
+        "BriefDescription": "BL Egress Full; All",
+        "EventCode": "0x36",
+        "EventName": "UNC_H_TxR_BL_CYCLES_FULL.ALL",
+        "PerPkg": "1",
+        "PublicDescription": "BL Egress Full; Cycles full from both schedu=
lers",
+        "UMask": "0x3",
+        "Unit": "HA"
+    },
     {
         "BriefDescription": "BL Egress Full; Scheduler 0",
-        "Counter": "0,1,2,3",
         "EventCode": "0x36",
         "EventName": "UNC_H_TxR_BL_CYCLES_FULL.SCHED0",
         "PerPkg": "1",
+        "PublicDescription": "BL Egress Full; Filter for cycles full  from=
 scheduler bank 0",
         "UMask": "0x1",
         "Unit": "HA"
     },
     {
         "BriefDescription": "BL Egress Full; Scheduler 1",
-        "Counter": "0,1,2,3",
         "EventCode": "0x36",
         "EventName": "UNC_H_TxR_BL_CYCLES_FULL.SCHED1",
         "PerPkg": "1",
+        "PublicDescription": "BL Egress Full; Filter for cycles full  from=
 scheduler bank 1",
         "UMask": "0x2",
         "Unit": "HA"
     },
     {
-        "BriefDescription": "BL Egress Full; All",
-        "Counter": "0,1,2,3",
-        "EventCode": "0x36",
-        "EventName": "UNC_H_TxR_BL_CYCLES_FULL.ALL",
+        "BriefDescription": "BL Egress Not Empty; All",
+        "EventCode": "0x35",
+        "EventName": "UNC_H_TxR_BL_CYCLES_NE.ALL",
         "PerPkg": "1",
+        "PublicDescription": "BL Egress Not Empty; Cycles full from both s=
chedulers",
         "UMask": "0x3",
         "Unit": "HA"
     },
     {
         "BriefDescription": "BL Egress Not Empty; Scheduler 0",
-        "Counter": "0,1,2,3",
         "EventCode": "0x35",
         "EventName": "UNC_H_TxR_BL_CYCLES_NE.SCHED0",
         "PerPkg": "1",
+        "PublicDescription": "BL Egress Not Empty; Filter for cycles not e=
mpty  from scheduler bank 0",
         "UMask": "0x1",
         "Unit": "HA"
     },
     {
         "BriefDescription": "BL Egress Not Empty; Scheduler 1",
-        "Counter": "0,1,2,3",
         "EventCode": "0x35",
         "EventName": "UNC_H_TxR_BL_CYCLES_NE.SCHED1",
         "PerPkg": "1",
+        "PublicDescription": "BL Egress Not Empty; Filter for cycles not e=
mpty from scheduler bank 1",
         "UMask": "0x2",
         "Unit": "HA"
     },
     {
-        "BriefDescription": "BL Egress Not Empty; All",
-        "Counter": "0,1,2,3",
-        "EventCode": "0x35",
-        "EventName": "UNC_H_TxR_BL_CYCLES_NE.ALL",
+        "BriefDescription": "BL Egress Allocations; All",
+        "EventCode": "0x33",
+        "EventName": "UNC_H_TxR_BL_INSERTS.ALL",
         "PerPkg": "1",
+        "PublicDescription": "BL Egress Allocations; Allocations from both=
 schedulers",
         "UMask": "0x3",
         "Unit": "HA"
     },
     {
         "BriefDescription": "BL Egress Allocations; Scheduler 0",
-        "Counter": "0,1,2,3",
         "EventCode": "0x33",
         "EventName": "UNC_H_TxR_BL_INSERTS.SCHED0",
         "PerPkg": "1",
+        "PublicDescription": "BL Egress Allocations; Filter for allocation=
s from scheduler bank 0",
         "UMask": "0x1",
         "Unit": "HA"
     },
     {
         "BriefDescription": "BL Egress Allocations; Scheduler 1",
-        "Counter": "0,1,2,3",
         "EventCode": "0x33",
         "EventName": "UNC_H_TxR_BL_INSERTS.SCHED1",
         "PerPkg": "1",
+        "PublicDescription": "BL Egress Allocations; Filter for allocation=
s from scheduler bank 1",
         "UMask": "0x2",
         "Unit": "HA"
     },
-    {
-        "BriefDescription": "BL Egress Allocations; All",
-        "Counter": "0,1,2,3",
-        "EventCode": "0x33",
-        "EventName": "UNC_H_TxR_BL_INSERTS.ALL",
-        "PerPkg": "1",
-        "UMask": "0x3",
-        "Unit": "HA"
-    },
     {
         "BriefDescription": "Injection Starvation; For AK Ring",
-        "Counter": "0,1,2,3",
         "EventCode": "0x6D",
         "EventName": "UNC_H_TxR_STARVED.AK",
         "PerPkg": "1",
+        "PublicDescription": "Counts injection starvation.  This starvatio=
n is triggered when the Egress cannot send a transaction onto the ring for =
a long period of time.",
         "UMask": "0x1",
         "Unit": "HA"
     },
     {
         "BriefDescription": "Injection Starvation; For BL Ring",
-        "Counter": "0,1,2,3",
         "EventCode": "0x6D",
         "EventName": "UNC_H_TxR_STARVED.BL",
         "PerPkg": "1",
+        "PublicDescription": "Counts injection starvation.  This starvatio=
n is triggered when the Egress cannot send a transaction onto the ring for =
a long period of time.",
         "UMask": "0x2",
         "Unit": "HA"
     },
     {
         "BriefDescription": "HA iMC CHN0 WPQ Credits Empty - Regular; Chan=
nel 0",
-        "Counter": "0,1,2,3",
         "EventCode": "0x18",
         "EventName": "UNC_H_WPQ_CYCLES_NO_REG_CREDITS.CHN0",
         "PerPkg": "1",
+        "PublicDescription": "Counts the number of cycles when there are n=
o regular credits available for posting writes from the HA into the iMC.  I=
n order to send writes into the memory controller, the HA must first acquir=
e a credit for the iMC's WPQ (write pending queue).  This queue is broken i=
nto regular credits/buffers that are used by general writes, and special re=
quests such as ISOCH writes.  This count only tracks the regular credits  C=
ommon high banwidth workloads should be able to make use of all of the regu=
lar buffers, but it will be difficult (and uncommon) to make use of both th=
e regular and special buffers at the same time.  One can filter based on th=
e memory controller channel.  One or more channels can be tracked at a give=
n time.; Filter for memory controller channel 0 only.",
         "UMask": "0x1",
         "Unit": "HA"
     },
     {
         "BriefDescription": "HA iMC CHN0 WPQ Credits Empty - Regular; Chan=
nel 1",
-        "Counter": "0,1,2,3",
         "EventCode": "0x18",
         "EventName": "UNC_H_WPQ_CYCLES_NO_REG_CREDITS.CHN1",
         "PerPkg": "1",
+        "PublicDescription": "Counts the number of cycles when there are n=
o regular credits available for posting writes from the HA into the iMC.  I=
n order to send writes into the memory controller, the HA must first acquir=
e a credit for the iMC's WPQ (write pending queue).  This queue is broken i=
nto regular credits/buffers that are used by general writes, and special re=
quests such as ISOCH writes.  This count only tracks the regular credits  C=
ommon high banwidth workloads should be able to make use of all of the regu=
lar buffers, but it will be difficult (and uncommon) to make use of both th=
e regular and special buffers at the same time.  One can filter based on th=
e memory controller channel.  One or more channels can be tracked at a give=
n time.; Filter for memory controller channel 1 only.",
         "UMask": "0x2",
         "Unit": "HA"
     },
     {
         "BriefDescription": "HA iMC CHN0 WPQ Credits Empty - Regular; Chan=
nel 2",
-        "Counter": "0,1,2,3",
         "EventCode": "0x18",
         "EventName": "UNC_H_WPQ_CYCLES_NO_REG_CREDITS.CHN2",
         "PerPkg": "1",
+        "PublicDescription": "Counts the number of cycles when there are n=
o regular credits available for posting writes from the HA into the iMC.  I=
n order to send writes into the memory controller, the HA must first acquir=
e a credit for the iMC's WPQ (write pending queue).  This queue is broken i=
nto regular credits/buffers that are used by general writes, and special re=
quests such as ISOCH writes.  This count only tracks the regular credits  C=
ommon high banwidth workloads should be able to make use of all of the regu=
lar buffers, but it will be difficult (and uncommon) to make use of both th=
e regular and special buffers at the same time.  One can filter based on th=
e memory controller channel.  One or more channels can be tracked at a give=
n time.; Filter for memory controller channel 2 only.",
         "UMask": "0x4",
         "Unit": "HA"
     },
     {
         "BriefDescription": "HA iMC CHN0 WPQ Credits Empty - Regular; Chan=
nel 3",
-        "Counter": "0,1,2,3",
         "EventCode": "0x18",
         "EventName": "UNC_H_WPQ_CYCLES_NO_REG_CREDITS.CHN3",
         "PerPkg": "1",
+        "PublicDescription": "Counts the number of cycles when there are n=
o regular credits available for posting writes from the HA into the iMC.  I=
n order to send writes into the memory controller, the HA must first acquir=
e a credit for the iMC's WPQ (write pending queue).  This queue is broken i=
nto regular credits/buffers that are used by general writes, and special re=
quests such as ISOCH writes.  This count only tracks the regular credits  C=
ommon high banwidth workloads should be able to make use of all of the regu=
lar buffers, but it will be difficult (and uncommon) to make use of both th=
e regular and special buffers at the same time.  One can filter based on th=
e memory controller channel.  One or more channels can be tracked at a give=
n time.; Filter for memory controller channel 3 only.",
         "UMask": "0x8",
         "Unit": "HA"
     },
     {
         "BriefDescription": "HA iMC CHN0 WPQ Credits Empty - Special; Chan=
nel 0",
-        "Counter": "0,1,2,3",
         "EventCode": "0x19",
         "EventName": "UNC_H_WPQ_CYCLES_NO_SPEC_CREDITS.CHN0",
         "PerPkg": "1",
+        "PublicDescription": "Counts the number of cycles when there are n=
o special credits available for posting writes from the HA into the iMC.  I=
n order to send writes into the memory controller, the HA must first acquir=
e a credit for the iMC's WPQ (write pending queue).  This queue is broken i=
nto regular credits/buffers that are used by general writes, and special re=
quests such as ISOCH writes.  This count only tracks the special credits.  =
This statistic is generally not interesting for general IA workloads, but m=
ay be of interest for understanding the characteristics of systems using IS=
OCH.  One can filter based on the memory controller channel.  One or more c=
hannels can be tracked at a given time.; Filter for memory controller chann=
el 0 only.",
         "UMask": "0x1",
         "Unit": "HA"
     },
     {
         "BriefDescription": "HA iMC CHN0 WPQ Credits Empty - Special; Chan=
nel 1",
-        "Counter": "0,1,2,3",
         "EventCode": "0x19",
         "EventName": "UNC_H_WPQ_CYCLES_NO_SPEC_CREDITS.CHN1",
         "PerPkg": "1",
+        "PublicDescription": "Counts the number of cycles when there are n=
o special credits available for posting writes from the HA into the iMC.  I=
n order to send writes into the memory controller, the HA must first acquir=
e a credit for the iMC's WPQ (write pending queue).  This queue is broken i=
nto regular credits/buffers that are used by general writes, and special re=
quests such as ISOCH writes.  This count only tracks the special credits.  =
This statistic is generally not interesting for general IA workloads, but m=
ay be of interest for understanding the characteristics of systems using IS=
OCH.  One can filter based on the memory controller channel.  One or more c=
hannels can be tracked at a given time.; Filter for memory controller chann=
el 1 only.",
         "UMask": "0x2",
         "Unit": "HA"
     },
     {
         "BriefDescription": "HA iMC CHN0 WPQ Credits Empty - Special; Chan=
nel 2",
-        "Counter": "0,1,2,3",
         "EventCode": "0x19",
         "EventName": "UNC_H_WPQ_CYCLES_NO_SPEC_CREDITS.CHN2",
         "PerPkg": "1",
+        "PublicDescription": "Counts the number of cycles when there are n=
o special credits available for posting writes from the HA into the iMC.  I=
n order to send writes into the memory controller, the HA must first acquir=
e a credit for the iMC's WPQ (write pending queue).  This queue is broken i=
nto regular credits/buffers that are used by general writes, and special re=
quests such as ISOCH writes.  This count only tracks the special credits.  =
This statistic is generally not interesting for general IA workloads, but m=
ay be of interest for understanding the characteristics of systems using IS=
OCH.  One can filter based on the memory controller channel.  One or more c=
hannels can be tracked at a given time.; Filter for memory controller chann=
el 2 only.",
         "UMask": "0x4",
         "Unit": "HA"
     },
     {
         "BriefDescription": "HA iMC CHN0 WPQ Credits Empty - Special; Chan=
nel 3",
-        "Counter": "0,1,2,3",
         "EventCode": "0x19",
         "EventName": "UNC_H_WPQ_CYCLES_NO_SPEC_CREDITS.CHN3",
         "PerPkg": "1",
+        "PublicDescription": "Counts the number of cycles when there are n=
o special credits available for posting writes from the HA into the iMC.  I=
n order to send writes into the memory controller, the HA must first acquir=
e a credit for the iMC's WPQ (write pending queue).  This queue is broken i=
nto regular credits/buffers that are used by general writes, and special re=
quests such as ISOCH writes.  This count only tracks the special credits.  =
This statistic is generally not interesting for general IA workloads, but m=
ay be of interest for understanding the characteristics of systems using IS=
OCH.  One can filter based on the memory controller channel.  One or more c=
hannels can be tracked at a given time.; Filter for memory controller chann=
el 3 only.",
         "UMask": "0x8",
         "Unit": "HA"
-    },
-    {
-        "BriefDescription": "Tracker Cycles Not Empty; Local Requests",
-        "Counter": "0,1,2,3",
-        "EventCode": "0x3",
-        "EventName": "UNC_H_TRACKER_CYCLES_NE.LOCAL",
-        "PerPkg": "1",
-        "UMask": "0x1",
-        "Unit": "HA"
-    },
-    {
-        "BriefDescription": "Tracker Cycles Not Empty; Remote Requests",
-        "Counter": "0,1,2,3",
-        "EventCode": "0x3",
-        "EventName": "UNC_H_TRACKER_CYCLES_NE.REMOTE",
-        "PerPkg": "1",
-        "UMask": "0x2",
-        "Unit": "HA"
-    },
-    {
-        "BriefDescription": "Tracker Cycles Not Empty; All Requests",
-        "Counter": "0,1,2,3",
-        "EventCode": "0x3",
-        "EventName": "UNC_H_TRACKER_CYCLES_NE.ALL",
-        "PerPkg": "1",
-        "UMask": "0x3",
-        "Unit": "HA"
     }
 ]
diff --git a/tools/perf/pmu-events/arch/x86/haswellx/uncore-interconnect.js=
on b/tools/perf/pmu-events/arch/x86/haswellx/uncore-interconnect.json
index eb0a05fbb704..15059b17cd19 100644
--- a/tools/perf/pmu-events/arch/x86/haswellx/uncore-interconnect.json
+++ b/tools/perf/pmu-events/arch/x86/haswellx/uncore-interconnect.json
@@ -1,1452 +1,1332 @@
 [
+    {
+        "BriefDescription": "Number of non data (control) flits transmitte=
d . Derived from unc_q_txl_flits_g0.non_data",
+        "EventName": "QPI_CTL_BANDWIDTH_TX",
+        "PerPkg": "1",
+        "PublicDescription": "Counts the number of flits transmitted acros=
s the QPI Link.  It includes filters for Idle, protocol, and Data Flits.  E=
ach flit is made up of 80 bits of information (in addition to some ECC data=
).  In full-width (L0) mode, flits are made up of four fits, each of which =
contains 20 bits of data (along with some additional ECC data).   In half-w=
idth (L0p) mode, the fits are only 10 bits, and therefore it takes twice as=
 many fits to transmit a flit.  When one talks about QPI speed (for example=
, 8.0 GT/s), the transfers here refer to fits.  Therefore, in L0, the syste=
m will transfer 1 flit at the rate of 1/4th the QPI speed.  One can calcula=
te the bandwidth of the link by taking: flits*80b/time.  Note that this is =
not the same as data bandwidth.  For example, when we are transferring a 64=
B cacheline across QPI, we will break it into 9 flits -- 1 with header info=
rmation and 8 with 64 bits of actual data and an additional 16 bits of othe=
r information.  To calculate data bandwidth, one should therefore do: data =
flits * 8B / time (for L0) or 4B instead of 8B for L0p.; Number of non-NULL=
 non-data flits transmitted across QPI.  This basically tracks the protocol=
 overhead on the QPI link.  One can get a good picture of the QPI-link char=
acteristics by evaluating the protocol flits, data flits, and idle/null fli=
ts.  This includes the header flits for data packets.",
+        "ScaleUnit": "8Bytes",
+        "UMask": "0x4",
+        "Unit": "QPI LL"
+    },
+    {
+        "BriefDescription": "Number of data flits transmitted . Derived fr=
om unc_q_txl_flits_g0.data",
+        "EventName": "QPI_DATA_BANDWIDTH_TX",
+        "PerPkg": "1",
+        "PublicDescription": "Counts the number of flits transmitted acros=
s the QPI Link.  It includes filters for Idle, protocol, and Data Flits.  E=
ach flit is made up of 80 bits of information (in addition to some ECC data=
).  In full-width (L0) mode, flits are made up of four fits, each of which =
contains 20 bits of data (along with some additional ECC data).   In half-w=
idth (L0p) mode, the fits are only 10 bits, and therefore it takes twice as=
 many fits to transmit a flit.  When one talks about QPI speed (for example=
, 8.0 GT/s), the transfers here refer to fits.  Therefore, in L0, the syste=
m will transfer 1 flit at the rate of 1/4th the QPI speed.  One can calcula=
te the bandwidth of the link by taking: flits*80b/time.  Note that this is =
not the same as data bandwidth.  For example, when we are transferring a 64=
B cacheline across QPI, we will break it into 9 flits -- 1 with header info=
rmation and 8 with 64 bits of actual data and an additional 16 bits of othe=
r information.  To calculate data bandwidth, one should therefore do: data =
flits * 8B / time (for L0) or 4B instead of 8B for L0p.; Number of data fli=
ts transmitted over QPI.  Each flit contains 64b of data.  This includes bo=
th DRS and NCB data flits (coherent and non-coherent).  This can be used to=
 calculate the data bandwidth of the QPI link.  One can get a good picture =
of the QPI-link characteristics by evaluating the protocol flits, data flit=
s, and idle/null flits.  This does not include the header flits that go in =
data packets.",
+        "ScaleUnit": "8Bytes",
+        "UMask": "0x2",
+        "Unit": "QPI LL"
+    },
     {
         "BriefDescription": "Number of qfclks",
-        "Counter": "0,1,2,3",
         "EventCode": "0x14",
         "EventName": "UNC_Q_CLOCKTICKS",
         "PerPkg": "1",
+        "PublicDescription": "Counts the number of clocks in the QPI LL.  =
This clock runs at 1/4th the GT/s speed of the QPI link.  For example, a 4G=
T/s link will have qfclk or 1GHz.  HSX does not support dynamic link speeds=
, so this frequency is fixed.",
         "Unit": "QPI LL"
     },
     {
         "BriefDescription": "Count of CTO Events",
-        "Counter": "0,1,2,3",
         "EventCode": "0x38",
         "EventName": "UNC_Q_CTO_COUNT",
-        "ExtSel": "1",
         "PerPkg": "1",
-        "Unit": "QPI LL"
-    },
-    {
-        "BriefDescription": "Direct 2 Core Spawning; Spawn Success",
-        "Counter": "0,1,2,3",
-        "EventCode": "0x13",
-        "EventName": "UNC_Q_DIRECT2CORE.SUCCESS_RBT_HIT",
-        "PerPkg": "1",
-        "UMask": "0x1",
+        "PublicDescription": "Counts the number of CTO (cluster trigger ou=
ts) events that were asserted across the two slots.  If both slots trigger =
in a given cycle, the event will increment by 2.  You can use edge detect t=
o count the number of cases when both events triggered.",
         "Unit": "QPI LL"
     },
     {
         "BriefDescription": "Direct 2 Core Spawning; Spawn Failure - Egres=
s Credits",
-        "Counter": "0,1,2,3",
         "EventCode": "0x13",
         "EventName": "UNC_Q_DIRECT2CORE.FAILURE_CREDITS",
         "PerPkg": "1",
+        "PublicDescription": "Counts the number of DRS packets that we att=
empted to do direct2core on.  There are 4 mutually exclusive filters.  Filt=
er [0] can be used to get successful spawns, while [1:3] provide the differ=
ent failure cases.  Note that this does not count packets that are not cand=
idates for Direct2Core.  The only candidates for Direct2Core are DRS packet=
s destined for Cbos.; The spawn failed because there were not enough Egress=
 credits.  Had there been enough credits, the spawn would have worked as th=
e RBT bit was set and the RBT tag matched.",
         "UMask": "0x2",
         "Unit": "QPI LL"
     },
     {
-        "BriefDescription": "Direct 2 Core Spawning; Spawn Failure - RBT I=
nvalid",
-        "Counter": "0,1,2,3",
+        "BriefDescription": "Direct 2 Core Spawning; Spawn Failure - Egres=
s and RBT Miss",
         "EventCode": "0x13",
-        "EventName": "UNC_Q_DIRECT2CORE.FAILURE_RBT_HIT",
+        "EventName": "UNC_Q_DIRECT2CORE.FAILURE_CREDITS_MISS",
         "PerPkg": "1",
-        "UMask": "0x4",
+        "PublicDescription": "Counts the number of DRS packets that we att=
empted to do direct2core on.  There are 4 mutually exclusive filters.  Filt=
er [0] can be used to get successful spawns, while [1:3] provide the differ=
ent failure cases.  Note that this does not count packets that are not cand=
idates for Direct2Core.  The only candidates for Direct2Core are DRS packet=
s destined for Cbos.; The spawn failed because the RBT tag did not match an=
d there weren't enough Egress credits.   The valid bit was set.",
+        "UMask": "0x20",
         "Unit": "QPI LL"
     },
     {
         "BriefDescription": "Direct 2 Core Spawning; Spawn Failure - Egres=
s and RBT Invalid",
-        "Counter": "0,1,2,3",
         "EventCode": "0x13",
         "EventName": "UNC_Q_DIRECT2CORE.FAILURE_CREDITS_RBT",
         "PerPkg": "1",
+        "PublicDescription": "Counts the number of DRS packets that we att=
empted to do direct2core on.  There are 4 mutually exclusive filters.  Filt=
er [0] can be used to get successful spawns, while [1:3] provide the differ=
ent failure cases.  Note that this does not count packets that are not cand=
idates for Direct2Core.  The only candidates for Direct2Core are DRS packet=
s destined for Cbos.; The spawn failed because there were not enough Egress=
 credits AND the RBT bit was not set, but the RBT tag matched.",
         "UMask": "0x8",
         "Unit": "QPI LL"
     },
+    {
+        "BriefDescription": "Direct 2 Core Spawning; Spawn Failure - Egres=
s and RBT Miss, Invalid",
+        "EventCode": "0x13",
+        "EventName": "UNC_Q_DIRECT2CORE.FAILURE_CREDITS_RBT_MISS",
+        "PerPkg": "1",
+        "PublicDescription": "Counts the number of DRS packets that we att=
empted to do direct2core on.  There are 4 mutually exclusive filters.  Filt=
er [0] can be used to get successful spawns, while [1:3] provide the differ=
ent failure cases.  Note that this does not count packets that are not cand=
idates for Direct2Core.  The only candidates for Direct2Core are DRS packet=
s destined for Cbos.; The spawn failed because the RBT tag did not match, t=
he valid bit was not set and there weren't enough Egress credits.",
+        "UMask": "0x80",
+        "Unit": "QPI LL"
+    },
     {
         "BriefDescription": "Direct 2 Core Spawning; Spawn Failure - RBT M=
iss",
-        "Counter": "0,1,2,3",
         "EventCode": "0x13",
         "EventName": "UNC_Q_DIRECT2CORE.FAILURE_MISS",
         "PerPkg": "1",
+        "PublicDescription": "Counts the number of DRS packets that we att=
empted to do direct2core on.  There are 4 mutually exclusive filters.  Filt=
er [0] can be used to get successful spawns, while [1:3] provide the differ=
ent failure cases.  Note that this does not count packets that are not cand=
idates for Direct2Core.  The only candidates for Direct2Core are DRS packet=
s destined for Cbos.; The spawn failed because the RBT tag did not match al=
though the valid bit was set and there were enough Egress credits.",
         "UMask": "0x10",
         "Unit": "QPI LL"
     },
     {
-        "BriefDescription": "Direct 2 Core Spawning; Spawn Failure - Egres=
s and RBT Miss",
-        "Counter": "0,1,2,3",
+        "BriefDescription": "Direct 2 Core Spawning; Spawn Failure - RBT I=
nvalid",
         "EventCode": "0x13",
-        "EventName": "UNC_Q_DIRECT2CORE.FAILURE_CREDITS_MISS",
+        "EventName": "UNC_Q_DIRECT2CORE.FAILURE_RBT_HIT",
         "PerPkg": "1",
-        "UMask": "0x20",
+        "PublicDescription": "Counts the number of DRS packets that we att=
empted to do direct2core on.  There are 4 mutually exclusive filters.  Filt=
er [0] can be used to get successful spawns, while [1:3] provide the differ=
ent failure cases.  Note that this does not count packets that are not cand=
idates for Direct2Core.  The only candidates for Direct2Core are DRS packet=
s destined for Cbos.; The spawn failed because the route-back table (RBT) s=
pecified that the transaction should not trigger a direct2core transaction.=
  This is common for IO transactions.  There were enough Egress credits and=
 the RBT tag matched but the valid bit was not set.",
+        "UMask": "0x4",
         "Unit": "QPI LL"
     },
     {
         "BriefDescription": "Direct 2 Core Spawning; Spawn Failure - RBT M=
iss and Invalid",
-        "Counter": "0,1,2,3",
         "EventCode": "0x13",
         "EventName": "UNC_Q_DIRECT2CORE.FAILURE_RBT_MISS",
         "PerPkg": "1",
+        "PublicDescription": "Counts the number of DRS packets that we att=
empted to do direct2core on.  There are 4 mutually exclusive filters.  Filt=
er [0] can be used to get successful spawns, while [1:3] provide the differ=
ent failure cases.  Note that this does not count packets that are not cand=
idates for Direct2Core.  The only candidates for Direct2Core are DRS packet=
s destined for Cbos.; The spawn failed because the RBT tag did not match an=
d the valid bit was not set although there were enough Egress credits.",
         "UMask": "0x40",
         "Unit": "QPI LL"
     },
     {
-        "BriefDescription": "Direct 2 Core Spawning; Spawn Failure - Egres=
s and RBT Miss, Invalid",
-        "Counter": "0,1,2,3",
+        "BriefDescription": "Direct 2 Core Spawning; Spawn Success",
         "EventCode": "0x13",
-        "EventName": "UNC_Q_DIRECT2CORE.FAILURE_CREDITS_RBT_MISS",
+        "EventName": "UNC_Q_DIRECT2CORE.SUCCESS_RBT_HIT",
         "PerPkg": "1",
-        "UMask": "0x80",
+        "PublicDescription": "Counts the number of DRS packets that we att=
empted to do direct2core on.  There are 4 mutually exclusive filters.  Filt=
er [0] can be used to get successful spawns, while [1:3] provide the differ=
ent failure cases.  Note that this does not count packets that are not cand=
idates for Direct2Core.  The only candidates for Direct2Core are DRS packet=
s destined for Cbos.; The spawn was successful.  There were sufficient cred=
its, the RBT valid bit was set and there was an RBT tag match.  The message=
 was marked to spawn direct2core.",
+        "UMask": "0x1",
         "Unit": "QPI LL"
     },
     {
         "BriefDescription": "Cycles in L1",
-        "Counter": "0,1,2,3",
         "EventCode": "0x12",
         "EventName": "UNC_Q_L1_POWER_CYCLES",
         "PerPkg": "1",
+        "PublicDescription": "Number of QPI qfclk cycles spent in L1 power=
 mode.  L1 is a mode that totally shuts down a QPI link.  Use edge detect t=
o count the number of instances when the QPI link entered L1.  Link power s=
tates are per link and per direction, so for example the Tx direction could=
 be in one state while Rx was in another. Because L1 totally shuts down the=
 link, it takes a good amount of time to exit this mode.",
         "Unit": "QPI LL"
     },
     {
         "BriefDescription": "Cycles in L0p",
-        "Counter": "0,1,2,3",
         "EventCode": "0x10",
         "EventName": "UNC_Q_RxL0P_POWER_CYCLES",
         "PerPkg": "1",
+        "PublicDescription": "Number of QPI qfclk cycles spent in L0p powe=
r mode.  L0p is a mode where we disable 1/2 of the QPI lanes, decreasing ou=
r bandwidth in order to save power.  It increases snoop and data transfer l=
atencies and decreases overall bandwidth.  This mode can be very useful in =
NUMA optimized workloads that largely only utilize QPI for snoops and their=
 responses.  Use edge detect to count the number of instances when the QPI =
link entered L0p.  Link power states are per link and per direction, so for=
 example the Tx direction could be in one state while Rx was in another.",
         "Unit": "QPI LL"
     },
     {
         "BriefDescription": "Cycles in L0",
-        "Counter": "0,1,2,3",
         "EventCode": "0xF",
         "EventName": "UNC_Q_RxL0_POWER_CYCLES",
         "PerPkg": "1",
+        "PublicDescription": "Number of QPI qfclk cycles spent in L0 power=
 mode in the Link Layer.  L0 is the default mode which provides the highest=
 performance with the most power.  Use edge detect to count the number of i=
nstances that the link entered L0.  Link power states are per link and per =
direction, so for example the Tx direction could be in one state while Rx w=
as in another.  The phy layer  sometimes leaves L0 for training, which will=
 not be captured by this event.",
         "Unit": "QPI LL"
     },
     {
         "BriefDescription": "Rx Flit Buffer Bypassed",
-        "Counter": "0,1,2,3",
         "EventCode": "0x9",
         "EventName": "UNC_Q_RxL_BYPASSED",
         "PerPkg": "1",
+        "PublicDescription": "Counts the number of times that an incoming =
flit was able to bypass the flit buffer and pass directly across the BGF an=
d into the Egress.  This is a latency optimization, and should generally be=
 the common case.  If this value is less than the number of flits transferr=
ed, it implies that there was queueing getting onto the ring, and thus the =
transactions saw higher latency.",
         "Unit": "QPI LL"
     },
     {
         "BriefDescription": "CRC Errors Detected; LinkInit",
-        "Counter": "0,1,2,3",
         "EventCode": "0x3",
         "EventName": "UNC_Q_RxL_CRC_ERRORS.LINK_INIT",
         "PerPkg": "1",
+        "PublicDescription": "Number of CRC errors detected in the QPI Age=
nt.  Each QPI flit incorporates 8 bits of CRC for error detection.  This co=
unts the number of flits where the CRC was able to detect an error.  After =
an error has been detected, the QPI agent will send a request to the transm=
itting socket to resend the flit (as well as any flits that came after it).=
; CRC errors detected during link initialization.",
         "UMask": "0x1",
         "Unit": "QPI LL"
     },
     {
         "BriefDescription": "CRC Errors Detected; Normal Operations",
-        "Counter": "0,1,2,3",
         "EventCode": "0x3",
         "EventName": "UNC_Q_RxL_CRC_ERRORS.NORMAL_OP",
         "PerPkg": "1",
+        "PublicDescription": "Number of CRC errors detected in the QPI Age=
nt.  Each QPI flit incorporates 8 bits of CRC for error detection.  This co=
unts the number of flits where the CRC was able to detect an error.  After =
an error has been detected, the QPI agent will send a request to the transm=
itting socket to resend the flit (as well as any flits that came after it).=
; CRC errors detected during normal operation.",
         "UMask": "0x2",
         "Unit": "QPI LL"
     },
     {
         "BriefDescription": "VN0 Credit Consumed; DRS",
-        "Counter": "0,1,2,3",
         "EventCode": "0x1E",
         "EventName": "UNC_Q_RxL_CREDITS_CONSUMED_VN0.DRS",
-        "ExtSel": "1",
         "PerPkg": "1",
+        "PublicDescription": "Counts the number of times that an RxQ VN0 c=
redit was consumed (i.e. message uses a VN0 credit for the Rx Buffer).  Thi=
s includes packets that went through the RxQ and those that were bypasssed.=
; VN0 credit for the DRS message class.",
         "UMask": "0x1",
         "Unit": "QPI LL"
     },
+    {
+        "BriefDescription": "VN0 Credit Consumed; HOM",
+        "EventCode": "0x1E",
+        "EventName": "UNC_Q_RxL_CREDITS_CONSUMED_VN0.HOM",
+        "PerPkg": "1",
+        "PublicDescription": "Counts the number of times that an RxQ VN0 c=
redit was consumed (i.e. message uses a VN0 credit for the Rx Buffer).  Thi=
s includes packets that went through the RxQ and those that were bypasssed.=
; VN0 credit for the HOM message class.",
+        "UMask": "0x8",
+        "Unit": "QPI LL"
+    },
     {
         "BriefDescription": "VN0 Credit Consumed; NCB",
-        "Counter": "0,1,2,3",
         "EventCode": "0x1E",
         "EventName": "UNC_Q_RxL_CREDITS_CONSUMED_VN0.NCB",
-        "ExtSel": "1",
         "PerPkg": "1",
+        "PublicDescription": "Counts the number of times that an RxQ VN0 c=
redit was consumed (i.e. message uses a VN0 credit for the Rx Buffer).  Thi=
s includes packets that went through the RxQ and those that were bypasssed.=
; VN0 credit for the NCB message class.",
         "UMask": "0x2",
         "Unit": "QPI LL"
     },
     {
         "BriefDescription": "VN0 Credit Consumed; NCS",
-        "Counter": "0,1,2,3",
         "EventCode": "0x1E",
         "EventName": "UNC_Q_RxL_CREDITS_CONSUMED_VN0.NCS",
-        "ExtSel": "1",
         "PerPkg": "1",
+        "PublicDescription": "Counts the number of times that an RxQ VN0 c=
redit was consumed (i.e. message uses a VN0 credit for the Rx Buffer).  Thi=
s includes packets that went through the RxQ and those that were bypasssed.=
; VN0 credit for the NCS message class.",
         "UMask": "0x4",
         "Unit": "QPI LL"
     },
     {
-        "BriefDescription": "VN0 Credit Consumed; HOM",
-        "Counter": "0,1,2,3",
+        "BriefDescription": "VN0 Credit Consumed; NDR",
         "EventCode": "0x1E",
-        "EventName": "UNC_Q_RxL_CREDITS_CONSUMED_VN0.HOM",
-        "ExtSel": "1",
+        "EventName": "UNC_Q_RxL_CREDITS_CONSUMED_VN0.NDR",
         "PerPkg": "1",
-        "UMask": "0x8",
+        "PublicDescription": "Counts the number of times that an RxQ VN0 c=
redit was consumed (i.e. message uses a VN0 credit for the Rx Buffer).  Thi=
s includes packets that went through the RxQ and those that were bypasssed.=
; VN0 credit for the NDR message class.",
+        "UMask": "0x20",
         "Unit": "QPI LL"
     },
     {
         "BriefDescription": "VN0 Credit Consumed; SNP",
-        "Counter": "0,1,2,3",
         "EventCode": "0x1E",
         "EventName": "UNC_Q_RxL_CREDITS_CONSUMED_VN0.SNP",
-        "ExtSel": "1",
         "PerPkg": "1",
+        "PublicDescription": "Counts the number of times that an RxQ VN0 c=
redit was consumed (i.e. message uses a VN0 credit for the Rx Buffer).  Thi=
s includes packets that went through the RxQ and those that were bypasssed.=
; VN0 credit for the SNP message class.",
         "UMask": "0x10",
         "Unit": "QPI LL"
     },
     {
-        "BriefDescription": "VN0 Credit Consumed; NDR",
-        "Counter": "0,1,2,3",
-        "EventCode": "0x1E",
-        "EventName": "UNC_Q_RxL_CREDITS_CONSUMED_VN0.NDR",
-        "ExtSel": "1",
+        "BriefDescription": "VN1 Credit Consumed; DRS",
+        "EventCode": "0x39",
+        "EventName": "UNC_Q_RxL_CREDITS_CONSUMED_VN1.DRS",
         "PerPkg": "1",
-        "UMask": "0x20",
+        "PublicDescription": "Counts the number of times that an RxQ VN1 c=
redit was consumed (i.e. message uses a VN1 credit for the Rx Buffer).  Thi=
s includes packets that went through the RxQ and those that were bypasssed.=
; VN1 credit for the DRS message class.",
+        "UMask": "0x1",
         "Unit": "QPI LL"
     },
     {
-        "BriefDescription": "VN1 Credit Consumed; DRS",
-        "Counter": "0,1,2,3",
+        "BriefDescription": "VN1 Credit Consumed; HOM",
         "EventCode": "0x39",
-        "EventName": "UNC_Q_RxL_CREDITS_CONSUMED_VN1.DRS",
-        "ExtSel": "1",
+        "EventName": "UNC_Q_RxL_CREDITS_CONSUMED_VN1.HOM",
         "PerPkg": "1",
-        "UMask": "0x1",
+        "PublicDescription": "Counts the number of times that an RxQ VN1 c=
redit was consumed (i.e. message uses a VN1 credit for the Rx Buffer).  Thi=
s includes packets that went through the RxQ and those that were bypasssed.=
; VN1 credit for the HOM message class.",
+        "UMask": "0x8",
         "Unit": "QPI LL"
     },
     {
         "BriefDescription": "VN1 Credit Consumed; NCB",
-        "Counter": "0,1,2,3",
         "EventCode": "0x39",
         "EventName": "UNC_Q_RxL_CREDITS_CONSUMED_VN1.NCB",
-        "ExtSel": "1",
         "PerPkg": "1",
+        "PublicDescription": "Counts the number of times that an RxQ VN1 c=
redit was consumed (i.e. message uses a VN1 credit for the Rx Buffer).  Thi=
s includes packets that went through the RxQ and those that were bypasssed.=
; VN1 credit for the NCB message class.",
         "UMask": "0x2",
         "Unit": "QPI LL"
     },
     {
         "BriefDescription": "VN1 Credit Consumed; NCS",
-        "Counter": "0,1,2,3",
         "EventCode": "0x39",
         "EventName": "UNC_Q_RxL_CREDITS_CONSUMED_VN1.NCS",
-        "ExtSel": "1",
         "PerPkg": "1",
+        "PublicDescription": "Counts the number of times that an RxQ VN1 c=
redit was consumed (i.e. message uses a VN1 credit for the Rx Buffer).  Thi=
s includes packets that went through the RxQ and those that were bypasssed.=
; VN1 credit for the NCS message class.",
         "UMask": "0x4",
         "Unit": "QPI LL"
     },
     {
-        "BriefDescription": "VN1 Credit Consumed; HOM",
-        "Counter": "0,1,2,3",
+        "BriefDescription": "VN1 Credit Consumed; NDR",
         "EventCode": "0x39",
-        "EventName": "UNC_Q_RxL_CREDITS_CONSUMED_VN1.HOM",
-        "ExtSel": "1",
+        "EventName": "UNC_Q_RxL_CREDITS_CONSUMED_VN1.NDR",
         "PerPkg": "1",
-        "UMask": "0x8",
+        "PublicDescription": "Counts the number of times that an RxQ VN1 c=
redit was consumed (i.e. message uses a VN1 credit for the Rx Buffer).  Thi=
s includes packets that went through the RxQ and those that were bypasssed.=
; VN1 credit for the NDR message class.",
+        "UMask": "0x20",
         "Unit": "QPI LL"
     },
     {
         "BriefDescription": "VN1 Credit Consumed; SNP",
-        "Counter": "0,1,2,3",
         "EventCode": "0x39",
         "EventName": "UNC_Q_RxL_CREDITS_CONSUMED_VN1.SNP",
-        "ExtSel": "1",
         "PerPkg": "1",
+        "PublicDescription": "Counts the number of times that an RxQ VN1 c=
redit was consumed (i.e. message uses a VN1 credit for the Rx Buffer).  Thi=
s includes packets that went through the RxQ and those that were bypasssed.=
; VN1 credit for the SNP message class.",
         "UMask": "0x10",
         "Unit": "QPI LL"
     },
-    {
-        "BriefDescription": "VN1 Credit Consumed; NDR",
-        "Counter": "0,1,2,3",
-        "EventCode": "0x39",
-        "EventName": "UNC_Q_RxL_CREDITS_CONSUMED_VN1.NDR",
-        "ExtSel": "1",
-        "PerPkg": "1",
-        "UMask": "0x20",
-        "Unit": "QPI LL"
-    },
     {
         "BriefDescription": "VNA Credit Consumed",
-        "Counter": "0,1,2,3",
         "EventCode": "0x1D",
         "EventName": "UNC_Q_RxL_CREDITS_CONSUMED_VNA",
-        "ExtSel": "1",
         "PerPkg": "1",
+        "PublicDescription": "Counts the number of times that an RxQ VNA c=
redit was consumed (i.e. message uses a VNA credit for the Rx Buffer).  Thi=
s includes packets that went through the RxQ and those that were bypasssed.=
",
         "Unit": "QPI LL"
     },
     {
         "BriefDescription": "RxQ Cycles Not Empty",
-        "Counter": "0,1,2,3",
         "EventCode": "0xA",
         "EventName": "UNC_Q_RxL_CYCLES_NE",
         "PerPkg": "1",
+        "PublicDescription": "Counts the number of cycles that the QPI RxQ=
 was not empty.  Generally, when data is transmitted across QPI, it will by=
pass the RxQ and pass directly to the ring interface.  If things back up ge=
tting transmitted onto the ring, however, it may need to allocate into this=
 buffer, thus increasing the latency.  This event can be used in conjunctio=
n with the Flit Buffer Occupancy Accumulator event to calculate the average=
 occupancy.",
         "Unit": "QPI LL"
     },
     {
         "BriefDescription": "RxQ Cycles Not Empty - DRS; for VN0",
-        "Counter": "0,1,2,3",
         "EventCode": "0xF",
         "EventName": "UNC_Q_RxL_CYCLES_NE_DRS.VN0",
-        "ExtSel": "1",
         "PerPkg": "1",
+        "PublicDescription": "Counts the number of cycles that the QPI RxQ=
 was not empty.  Generally, when data is transmitted across QPI, it will by=
pass the RxQ and pass directly to the ring interface.  If things back up ge=
tting transmitted onto the ring, however, it may need to allocate into this=
 buffer, thus increasing the latency.  This event can be used in conjunctio=
n with the Flit Buffer Occupancy Accumulator event to calculate the average=
 occupancy.  This monitors DRS flits only.",
         "UMask": "0x1",
         "Unit": "QPI LL"
     },
     {
         "BriefDescription": "RxQ Cycles Not Empty - DRS; for VN1",
-        "Counter": "0,1,2,3",
         "EventCode": "0xF",
         "EventName": "UNC_Q_RxL_CYCLES_NE_DRS.VN1",
-        "ExtSel": "1",
         "PerPkg": "1",
+        "PublicDescription": "Counts the number of cycles that the QPI RxQ=
 was not empty.  Generally, when data is transmitted across QPI, it will by=
pass the RxQ and pass directly to the ring interface.  If things back up ge=
tting transmitted onto the ring, however, it may need to allocate into this=
 buffer, thus increasing the latency.  This event can be used in conjunctio=
n with the Flit Buffer Occupancy Accumulator event to calculate the average=
 occupancy.  This monitors DRS flits only.",
         "UMask": "0x2",
         "Unit": "QPI LL"
     },
     {
         "BriefDescription": "RxQ Cycles Not Empty - HOM; for VN0",
-        "Counter": "0,1,2,3",
         "EventCode": "0x12",
         "EventName": "UNC_Q_RxL_CYCLES_NE_HOM.VN0",
-        "ExtSel": "1",
         "PerPkg": "1",
+        "PublicDescription": "Counts the number of cycles that the QPI RxQ=
 was not empty.  Generally, when data is transmitted across QPI, it will by=
pass the RxQ and pass directly to the ring interface.  If things back up ge=
tting transmitted onto the ring, however, it may need to allocate into this=
 buffer, thus increasing the latency.  This event can be used in conjunctio=
n with the Flit Buffer Occupancy Accumulator event to calculate the average=
 occupancy.  This monitors HOM flits only.",
         "UMask": "0x1",
         "Unit": "QPI LL"
     },
     {
         "BriefDescription": "RxQ Cycles Not Empty - HOM; for VN1",
-        "Counter": "0,1,2,3",
         "EventCode": "0x12",
         "EventName": "UNC_Q_RxL_CYCLES_NE_HOM.VN1",
-        "ExtSel": "1",
         "PerPkg": "1",
+        "PublicDescription": "Counts the number of cycles that the QPI RxQ=
 was not empty.  Generally, when data is transmitted across QPI, it will by=
pass the RxQ and pass directly to the ring interface.  If things back up ge=
tting transmitted onto the ring, however, it may need to allocate into this=
 buffer, thus increasing the latency.  This event can be used in conjunctio=
n with the Flit Buffer Occupancy Accumulator event to calculate the average=
 occupancy.  This monitors HOM flits only.",
         "UMask": "0x2",
         "Unit": "QPI LL"
     },
     {
         "BriefDescription": "RxQ Cycles Not Empty - NCB; for VN0",
-        "Counter": "0,1,2,3",
         "EventCode": "0x10",
         "EventName": "UNC_Q_RxL_CYCLES_NE_NCB.VN0",
-        "ExtSel": "1",
         "PerPkg": "1",
+        "PublicDescription": "Counts the number of cycles that the QPI RxQ=
 was not empty.  Generally, when data is transmitted across QPI, it will by=
pass the RxQ and pass directly to the ring interface.  If things back up ge=
tting transmitted onto the ring, however, it may need to allocate into this=
 buffer, thus increasing the latency.  This event can be used in conjunctio=
n with the Flit Buffer Occupancy Accumulator event to calculate the average=
 occupancy.  This monitors NCB flits only.",
         "UMask": "0x1",
         "Unit": "QPI LL"
     },
     {
         "BriefDescription": "RxQ Cycles Not Empty - NCB; for VN1",
-        "Counter": "0,1,2,3",
         "EventCode": "0x10",
         "EventName": "UNC_Q_RxL_CYCLES_NE_NCB.VN1",
-        "ExtSel": "1",
         "PerPkg": "1",
+        "PublicDescription": "Counts the number of cycles that the QPI RxQ=
 was not empty.  Generally, when data is transmitted across QPI, it will by=
pass the RxQ and pass directly to the ring interface.  If things back up ge=
tting transmitted onto the ring, however, it may need to allocate into this=
 buffer, thus increasing the latency.  This event can be used in conjunctio=
n with the Flit Buffer Occupancy Accumulator event to calculate the average=
 occupancy.  This monitors NCB flits only.",
         "UMask": "0x2",
         "Unit": "QPI LL"
     },
     {
         "BriefDescription": "RxQ Cycles Not Empty - NCS; for VN0",
-        "Counter": "0,1,2,3",
         "EventCode": "0x11",
         "EventName": "UNC_Q_RxL_CYCLES_NE_NCS.VN0",
-        "ExtSel": "1",
         "PerPkg": "1",
+        "PublicDescription": "Counts the number of cycles that the QPI RxQ=
 was not empty.  Generally, when data is transmitted across QPI, it will by=
pass the RxQ and pass directly to the ring interface.  If things back up ge=
tting transmitted onto the ring, however, it may need to allocate into this=
 buffer, thus increasing the latency.  This event can be used in conjunctio=
n with the Flit Buffer Occupancy Accumulator event to calculate the average=
 occupancy.  This monitors NCS flits only.",
         "UMask": "0x1",
         "Unit": "QPI LL"
     },
     {
         "BriefDescription": "RxQ Cycles Not Empty - NCS; for VN1",
-        "Counter": "0,1,2,3",
         "EventCode": "0x11",
         "EventName": "UNC_Q_RxL_CYCLES_NE_NCS.VN1",
-        "ExtSel": "1",
         "PerPkg": "1",
+        "PublicDescription": "Counts the number of cycles that the QPI RxQ=
 was not empty.  Generally, when data is transmitted across QPI, it will by=
pass the RxQ and pass directly to the ring interface.  If things back up ge=
tting transmitted onto the ring, however, it may need to allocate into this=
 buffer, thus increasing the latency.  This event can be used in conjunctio=
n with the Flit Buffer Occupancy Accumulator event to calculate the average=
 occupancy.  This monitors NCS flits only.",
         "UMask": "0x2",
         "Unit": "QPI LL"
     },
     {
         "BriefDescription": "RxQ Cycles Not Empty - NDR; for VN0",
-        "Counter": "0,1,2,3",
         "EventCode": "0x14",
         "EventName": "UNC_Q_RxL_CYCLES_NE_NDR.VN0",
-        "ExtSel": "1",
         "PerPkg": "1",
+        "PublicDescription": "Counts the number of cycles that the QPI RxQ=
 was not empty.  Generally, when data is transmitted across QPI, it will by=
pass the RxQ and pass directly to the ring interface.  If things back up ge=
tting transmitted onto the ring, however, it may need to allocate into this=
 buffer, thus increasing the latency.  This event can be used in conjunctio=
n with the Flit Buffer Occupancy Accumulator event to calculate the average=
 occupancy.  This monitors NDR flits only.",
         "UMask": "0x1",
         "Unit": "QPI LL"
     },
     {
         "BriefDescription": "RxQ Cycles Not Empty - NDR; for VN1",
-        "Counter": "0,1,2,3",
         "EventCode": "0x14",
         "EventName": "UNC_Q_RxL_CYCLES_NE_NDR.VN1",
-        "ExtSel": "1",
         "PerPkg": "1",
+        "PublicDescription": "Counts the number of cycles that the QPI RxQ=
 was not empty.  Generally, when data is transmitted across QPI, it will by=
pass the RxQ and pass directly to the ring interface.  If things back up ge=
tting transmitted onto the ring, however, it may need to allocate into this=
 buffer, thus increasing the latency.  This event can be used in conjunctio=
n with the Flit Buffer Occupancy Accumulator event to calculate the average=
 occupancy.  This monitors NDR flits only.",
         "UMask": "0x2",
         "Unit": "QPI LL"
     },
     {
         "BriefDescription": "RxQ Cycles Not Empty - SNP; for VN0",
-        "Counter": "0,1,2,3",
         "EventCode": "0x13",
         "EventName": "UNC_Q_RxL_CYCLES_NE_SNP.VN0",
-        "ExtSel": "1",
         "PerPkg": "1",
+        "PublicDescription": "Counts the number of cycles that the QPI RxQ=
 was not empty.  Generally, when data is transmitted across QPI, it will by=
pass the RxQ and pass directly to the ring interface.  If things back up ge=
tting transmitted onto the ring, however, it may need to allocate into this=
 buffer, thus increasing the latency.  This event can be used in conjunctio=
n with the Flit Buffer Occupancy Accumulator event to calculate the average=
 occupancy.  This monitors SNP flits only.",
         "UMask": "0x1",
         "Unit": "QPI LL"
     },
     {
         "BriefDescription": "RxQ Cycles Not Empty - SNP; for VN1",
-        "Counter": "0,1,2,3",
         "EventCode": "0x13",
         "EventName": "UNC_Q_RxL_CYCLES_NE_SNP.VN1",
-        "ExtSel": "1",
         "PerPkg": "1",
+        "PublicDescription": "Counts the number of cycles that the QPI RxQ=
 was not empty.  Generally, when data is transmitted across QPI, it will by=
pass the RxQ and pass directly to the ring interface.  If things back up ge=
tting transmitted onto the ring, however, it may need to allocate into this=
 buffer, thus increasing the latency.  This event can be used in conjunctio=
n with the Flit Buffer Occupancy Accumulator event to calculate the average=
 occupancy.  This monitors SNP flits only.",
         "UMask": "0x2",
         "Unit": "QPI LL"
     },
     {
         "BriefDescription": "Flits Received - Group 0; Idle and Null Flits=
",
-        "Counter": "0,1,2,3",
         "EventCode": "0x1",
         "EventName": "UNC_Q_RxL_FLITS_G0.IDLE",
         "PerPkg": "1",
+        "PublicDescription": "Counts the number of flits received from the=
 QPI Link.  It includes filters for Idle, protocol, and Data Flits.  Each f=
lit is made up of 80 bits of information (in addition to some ECC data).  I=
n full-width (L0) mode, flits are made up of four fits, each of which conta=
ins 20 bits of data (along with some additional ECC data).   In half-width =
(L0p) mode, the fits are only 10 bits, and therefore it takes twice as many=
 fits to transmit a flit.  When one talks about QPI speed (for example, 8.0=
 GT/s), the transfers here refer to fits.  Therefore, in L0, the system wil=
l transfer 1 flit at the rate of 1/4th the QPI speed.  One can calculate th=
e bandwidth of the link by taking: flits*80b/time.  Note that this is not t=
he same as data bandwidth.  For example, when we are transferring a 64B cac=
heline across QPI, we will break it into 9 flits -- 1 with header informati=
on and 8 with 64 bits of actual data and an additional 16 bits of other inf=
ormation.  To calculate data bandwidth, one should therefore do: data flits=
 * 8B / time (for L0) or 4B instead of 8B for L0p.; Number of flits receive=
d over QPI that do not hold protocol payload.  When QPI is not in a power s=
aving state, it continuously transmits flits across the link.  When there a=
re no protocol flits to send, it will send IDLE and NULL flits  across.  Th=
ese flits sometimes do carry a payload, such as credit returns, but are gen=
erally not considered part of the QPI bandwidth.",
         "UMask": "0x1",
         "Unit": "QPI LL"
     },
     {
-        "BriefDescription": "Flits Received - Group 1; SNP Flits",
-        "Counter": "0,1,2,3",
+        "BriefDescription": "Flits Received - Group 1; DRS Flits (both Hea=
der and Data)",
         "EventCode": "0x2",
-        "EventName": "UNC_Q_RxL_FLITS_G1.SNP",
-        "ExtSel": "1",
+        "EventName": "UNC_Q_RxL_FLITS_G1.DRS",
         "PerPkg": "1",
-        "UMask": "0x1",
+        "PublicDescription": "Counts the number of flits received from the=
 QPI Link.  This is one of three groups that allow us to track flits.  It i=
ncludes filters for SNP, HOM, and DRS message classes.  Each flit is made u=
p of 80 bits of information (in addition to some ECC data).  In full-width =
(L0) mode, flits are made up of four fits, each of which contains 20 bits o=
f data (along with some additional ECC data).   In half-width (L0p) mode, t=
he fits are only 10 bits, and therefore it takes twice as many fits to tran=
smit a flit.  When one talks about QPI speed (for example, 8.0 GT/s), the t=
ransfers here refer to fits.  Therefore, in L0, the system will transfer 1 =
flit at the rate of 1/4th the QPI speed.  One can calculate the bandwidth o=
f the link by taking: flits*80b/time.  Note that this is not the same as da=
ta bandwidth.  For example, when we are transferring a 64B cacheline across=
 QPI, we will break it into 9 flits -- 1 with header information and 8 with=
 64 bits of actual data and an additional 16 bits of other information.  To=
 calculate data bandwidth, one should therefore do: data flits * 8B / time.=
; Counts the total number of flits received over QPI on the DRS (Data Respo=
nse) channel.  DRS flits are used to transmit data with coherency.  This do=
es not count data flits received over the NCB channel which transmits non-c=
oherent data.",
+        "UMask": "0x18",
         "Unit": "QPI LL"
     },
     {
-        "BriefDescription": "Flits Received - Group 1; HOM Request Flits",
-        "Counter": "0,1,2,3",
+        "BriefDescription": "Flits Received - Group 1; DRS Data Flits",
         "EventCode": "0x2",
-        "EventName": "UNC_Q_RxL_FLITS_G1.HOM_REQ",
-        "ExtSel": "1",
+        "EventName": "UNC_Q_RxL_FLITS_G1.DRS_DATA",
         "PerPkg": "1",
-        "UMask": "0x2",
+        "PublicDescription": "Counts the number of flits received from the=
 QPI Link.  This is one of three groups that allow us to track flits.  It i=
ncludes filters for SNP, HOM, and DRS message classes.  Each flit is made u=
p of 80 bits of information (in addition to some ECC data).  In full-width =
(L0) mode, flits are made up of four fits, each of which contains 20 bits o=
f data (along with some additional ECC data).   In half-width (L0p) mode, t=
he fits are only 10 bits, and therefore it takes twice as many fits to tran=
smit a flit.  When one talks about QPI speed (for example, 8.0 GT/s), the t=
ransfers here refer to fits.  Therefore, in L0, the system will transfer 1 =
flit at the rate of 1/4th the QPI speed.  One can calculate the bandwidth o=
f the link by taking: flits*80b/time.  Note that this is not the same as da=
ta bandwidth.  For example, when we are transferring a 64B cacheline across=
 QPI, we will break it into 9 flits -- 1 with header information and 8 with=
 64 bits of actual data and an additional 16 bits of other information.  To=
 calculate data bandwidth, one should therefore do: data flits * 8B / time.=
; Counts the total number of data flits received over QPI on the DRS (Data =
Response) channel.  DRS flits are used to transmit data with coherency.  Th=
is does not count data flits received over the NCB channel which transmits =
non-coherent data.  This includes only the data flits (not the header).",
+        "UMask": "0x8",
         "Unit": "QPI LL"
     },
     {
-        "BriefDescription": "Flits Received - Group 1; HOM Non-Request Fli=
ts",
-        "Counter": "0,1,2,3",
+        "BriefDescription": "Flits Received - Group 1; DRS Header Flits",
         "EventCode": "0x2",
-        "EventName": "UNC_Q_RxL_FLITS_G1.HOM_NONREQ",
-        "ExtSel": "1",
+        "EventName": "UNC_Q_RxL_FLITS_G1.DRS_NONDATA",
         "PerPkg": "1",
-        "UMask": "0x4",
+        "PublicDescription": "Counts the number of flits received from the=
 QPI Link.  This is one of three groups that allow us to track flits.  It i=
ncludes filters for SNP, HOM, and DRS message classes.  Each flit is made u=
p of 80 bits of information (in addition to some ECC data).  In full-width =
(L0) mode, flits are made up of four fits, each of which contains 20 bits o=
f data (along with some additional ECC data).   In half-width (L0p) mode, t=
he fits are only 10 bits, and therefore it takes twice as many fits to tran=
smit a flit.  When one talks about QPI speed (for example, 8.0 GT/s), the t=
ransfers here refer to fits.  Therefore, in L0, the system will transfer 1 =
flit at the rate of 1/4th the QPI speed.  One can calculate the bandwidth o=
f the link by taking: flits*80b/time.  Note that this is not the same as da=
ta bandwidth.  For example, when we are transferring a 64B cacheline across=
 QPI, we will break it into 9 flits -- 1 with header information and 8 with=
 64 bits of actual data and an additional 16 bits of other information.  To=
 calculate data bandwidth, one should therefore do: data flits * 8B / time.=
; Counts the total number of protocol flits received over QPI on the DRS (D=
ata Response) channel.  DRS flits are used to transmit data with coherency.=
  This does not count data flits received over the NCB channel which transm=
its non-coherent data.  This includes only the header flits (not the data).=
  This includes extended headers.",
+        "UMask": "0x10",
         "Unit": "QPI LL"
     },
     {
         "BriefDescription": "Flits Received - Group 1; HOM Flits",
-        "Counter": "0,1,2,3",
         "EventCode": "0x2",
         "EventName": "UNC_Q_RxL_FLITS_G1.HOM",
-        "ExtSel": "1",
         "PerPkg": "1",
+        "PublicDescription": "Counts the number of flits received from the=
 QPI Link.  This is one of three groups that allow us to track flits.  It i=
ncludes filters for SNP, HOM, and DRS message classes.  Each flit is made u=
p of 80 bits of information (in addition to some ECC data).  In full-width =
(L0) mode, flits are made up of four fits, each of which contains 20 bits o=
f data (along with some additional ECC data).   In half-width (L0p) mode, t=
he fits are only 10 bits, and therefore it takes twice as many fits to tran=
smit a flit.  When one talks about QPI speed (for example, 8.0 GT/s), the t=
ransfers here refer to fits.  Therefore, in L0, the system will transfer 1 =
flit at the rate of 1/4th the QPI speed.  One can calculate the bandwidth o=
f the link by taking: flits*80b/time.  Note that this is not the same as da=
ta bandwidth.  For example, when we are transferring a 64B cacheline across=
 QPI, we will break it into 9 flits -- 1 with header information and 8 with=
 64 bits of actual data and an additional 16 bits of other information.  To=
 calculate data bandwidth, one should therefore do: data flits * 8B / time.=
; Counts the number of flits received over QPI on the home channel.",
         "UMask": "0x6",
         "Unit": "QPI LL"
     },
     {
-        "BriefDescription": "Flits Received - Group 1; DRS Data Flits",
-        "Counter": "0,1,2,3",
+        "BriefDescription": "Flits Received - Group 1; HOM Non-Request Fli=
ts",
         "EventCode": "0x2",
-        "EventName": "UNC_Q_RxL_FLITS_G1.DRS_DATA",
-        "ExtSel": "1",
+        "EventName": "UNC_Q_RxL_FLITS_G1.HOM_NONREQ",
         "PerPkg": "1",
-        "UMask": "0x8",
+        "PublicDescription": "Counts the number of flits received from the=
 QPI Link.  This is one of three groups that allow us to track flits.  It i=
ncludes filters for SNP, HOM, and DRS message classes.  Each flit is made u=
p of 80 bits of information (in addition to some ECC data).  In full-width =
(L0) mode, flits are made up of four fits, each of which contains 20 bits o=
f data (along with some additional ECC data).   In half-width (L0p) mode, t=
he fits are only 10 bits, and therefore it takes twice as many fits to tran=
smit a flit.  When one talks about QPI speed (for example, 8.0 GT/s), the t=
ransfers here refer to fits.  Therefore, in L0, the system will transfer 1 =
flit at the rate of 1/4th the QPI speed.  One can calculate the bandwidth o=
f the link by taking: flits*80b/time.  Note that this is not the same as da=
ta bandwidth.  For example, when we are transferring a 64B cacheline across=
 QPI, we will break it into 9 flits -- 1 with header information and 8 with=
 64 bits of actual data and an additional 16 bits of other information.  To=
 calculate data bandwidth, one should therefore do: data flits * 8B / time.=
; Counts the number of non-request flits received over QPI on the home chan=
nel.  These are most commonly snoop responses, and this event can be used a=
s a proxy for that.",
+        "UMask": "0x4",
         "Unit": "QPI LL"
     },
     {
-        "BriefDescription": "Flits Received - Group 1; DRS Header Flits",
-        "Counter": "0,1,2,3",
+        "BriefDescription": "Flits Received - Group 1; HOM Request Flits",
         "EventCode": "0x2",
-        "EventName": "UNC_Q_RxL_FLITS_G1.DRS_NONDATA",
-        "ExtSel": "1",
+        "EventName": "UNC_Q_RxL_FLITS_G1.HOM_REQ",
         "PerPkg": "1",
-        "UMask": "0x10",
+        "PublicDescription": "Counts the number of flits received from the=
 QPI Link.  This is one of three groups that allow us to track flits.  It i=
ncludes filters for SNP, HOM, and DRS message classes.  Each flit is made u=
p of 80 bits of information (in addition to some ECC data).  In full-width =
(L0) mode, flits are made up of four fits, each of which contains 20 bits o=
f data (along with some additional ECC data).   In half-width (L0p) mode, t=
he fits are only 10 bits, and therefore it takes twice as many fits to tran=
smit a flit.  When one talks about QPI speed (for example, 8.0 GT/s), the t=
ransfers here refer to fits.  Therefore, in L0, the system will transfer 1 =
flit at the rate of 1/4th the QPI speed.  One can calculate the bandwidth o=
f the link by taking: flits*80b/time.  Note that this is not the same as da=
ta bandwidth.  For example, when we are transferring a 64B cacheline across=
 QPI, we will break it into 9 flits -- 1 with header information and 8 with=
 64 bits of actual data and an additional 16 bits of other information.  To=
 calculate data bandwidth, one should therefore do: data flits * 8B / time.=
; Counts the number of data request received over QPI on the home channel. =
 This basically counts the number of remote memory requests received over Q=
PI.  In conjunction with the local read count in the Home Agent, one can ca=
lculate the number of LLC Misses.",
+        "UMask": "0x2",
         "Unit": "QPI LL"
     },
     {
-        "BriefDescription": "Flits Received - Group 1; DRS Flits (both Hea=
der and Data)",
-        "Counter": "0,1,2,3",
+        "BriefDescription": "Flits Received - Group 1; SNP Flits",
         "EventCode": "0x2",
-        "EventName": "UNC_Q_RxL_FLITS_G1.DRS",
-        "ExtSel": "1",
-        "PerPkg": "1",
-        "UMask": "0x18",
-        "Unit": "QPI LL"
-    },
-    {
-        "BriefDescription": "Flits Received - Group 2; Non-Data Response R=
x Flits - AD",
-        "Counter": "0,1,2,3",
-        "EventCode": "0x3",
-        "EventName": "UNC_Q_RxL_FLITS_G2.NDR_AD",
-        "ExtSel": "1",
+        "EventName": "UNC_Q_RxL_FLITS_G1.SNP",
         "PerPkg": "1",
+        "PublicDescription": "Counts the number of flits received from the=
 QPI Link.  This is one of three groups that allow us to track flits.  It i=
ncludes filters for SNP, HOM, and DRS message classes.  Each flit is made u=
p of 80 bits of information (in addition to some ECC data).  In full-width =
(L0) mode, flits are made up of four fits, each of which contains 20 bits o=
f data (along with some additional ECC data).   In half-width (L0p) mode, t=
he fits are only 10 bits, and therefore it takes twice as many fits to tran=
smit a flit.  When one talks about QPI speed (for example, 8.0 GT/s), the t=
ransfers here refer to fits.  Therefore, in L0, the system will transfer 1 =
flit at the rate of 1/4th the QPI speed.  One can calculate the bandwidth o=
f the link by taking: flits*80b/time.  Note that this is not the same as da=
ta bandwidth.  For example, when we are transferring a 64B cacheline across=
 QPI, we will break it into 9 flits -- 1 with header information and 8 with=
 64 bits of actual data and an additional 16 bits of other information.  To=
 calculate data bandwidth, one should therefore do: data flits * 8B / time.=
; Counts the number of snoop request flits received over QPI.  These reques=
ts are contained in the snoop channel.  This does not include snoop respons=
es, which are received on the home channel.",
         "UMask": "0x1",
         "Unit": "QPI LL"
     },
     {
-        "BriefDescription": "Flits Received - Group 2; Non-Data Response R=
x Flits - AK",
-        "Counter": "0,1,2,3",
+        "BriefDescription": "Flits Received - Group 2; Non-Coherent Rx Fli=
ts",
         "EventCode": "0x3",
-        "EventName": "UNC_Q_RxL_FLITS_G2.NDR_AK",
-        "ExtSel": "1",
+        "EventName": "UNC_Q_RxL_FLITS_G2.NCB",
         "PerPkg": "1",
-        "UMask": "0x2",
+        "PublicDescription": "Counts the number of flits received from the=
 QPI Link.  This is one of three groups that allow us to track flits.  It i=
ncludes filters for NDR, NCB, and NCS message classes.  Each flit is made u=
p of 80 bits of information (in addition to some ECC data).  In full-width =
(L0) mode, flits are made up of four fits, each of which contains 20 bits o=
f data (along with some additional ECC data).   In half-width (L0p) mode, t=
he fits are only 10 bits, and therefore it takes twice as many fits to tran=
smit a flit.  When one talks about QPI speed (for example, 8.0 GT/s), the t=
ransfers here refer to fits.  Therefore, in L0, the system will transfer 1 =
flit at the rate of 1/4th the QPI speed.  One can calculate the bandwidth o=
f the link by taking: flits*80b/time.  Note that this is not the same as da=
ta bandwidth.  For example, when we are transferring a 64B cacheline across=
 QPI, we will break it into 9 flits -- 1 with header information and 8 with=
 64 bits of actual data and an additional 16 bits of other information.  To=
 calculate data bandwidth, one should therefore do: data flits * 8B / time.=
; Number of Non-Coherent Bypass flits.  These packets are generally used to=
 transmit non-coherent data across QPI.",
+        "UMask": "0xc",
         "Unit": "QPI LL"
     },
     {
         "BriefDescription": "Flits Received - Group 2; Non-Coherent data R=
x Flits",
-        "Counter": "0,1,2,3",
         "EventCode": "0x3",
         "EventName": "UNC_Q_RxL_FLITS_G2.NCB_DATA",
-        "ExtSel": "1",
         "PerPkg": "1",
+        "PublicDescription": "Counts the number of flits received from the=
 QPI Link.  This is one of three groups that allow us to track flits.  It i=
ncludes filters for NDR, NCB, and NCS message classes.  Each flit is made u=
p of 80 bits of information (in addition to some ECC data).  In full-width =
(L0) mode, flits are made up of four fits, each of which contains 20 bits o=
f data (along with some additional ECC data).   In half-width (L0p) mode, t=
he fits are only 10 bits, and therefore it takes twice as many fits to tran=
smit a flit.  When one talks about QPI speed (for example, 8.0 GT/s), the t=
ransfers here refer to fits.  Therefore, in L0, the system will transfer 1 =
flit at the rate of 1/4th the QPI speed.  One can calculate the bandwidth o=
f the link by taking: flits*80b/time.  Note that this is not the same as da=
ta bandwidth.  For example, when we are transferring a 64B cacheline across=
 QPI, we will break it into 9 flits -- 1 with header information and 8 with=
 64 bits of actual data and an additional 16 bits of other information.  To=
 calculate data bandwidth, one should therefore do: data flits * 8B / time.=
; Number of Non-Coherent Bypass data flits.  These flits are generally used=
 to transmit non-coherent data across QPI.  This does not include a count o=
f the DRS (coherent) data flits.  This only counts the data flits, not the =
NCB headers.",
         "UMask": "0x4",
         "Unit": "QPI LL"
     },
     {
         "BriefDescription": "Flits Received - Group 2; Non-Coherent non-da=
ta Rx Flits",
-        "Counter": "0,1,2,3",
         "EventCode": "0x3",
         "EventName": "UNC_Q_RxL_FLITS_G2.NCB_NONDATA",
-        "ExtSel": "1",
         "PerPkg": "1",
+        "PublicDescription": "Counts the number of flits received from the=
 QPI Link.  This is one of three groups that allow us to track flits.  It i=
ncludes filters for NDR, NCB, and NCS message classes.  Each flit is made u=
p of 80 bits of information (in addition to some ECC data).  In full-width =
(L0) mode, flits are made up of four fits, each of which contains 20 bits o=
f data (along with some additional ECC data).   In half-width (L0p) mode, t=
he fits are only 10 bits, and therefore it takes twice as many fits to tran=
smit a flit.  When one talks about QPI speed (for example, 8.0 GT/s), the t=
ransfers here refer to fits.  Therefore, in L0, the system will transfer 1 =
flit at the rate of 1/4th the QPI speed.  One can calculate the bandwidth o=
f the link by taking: flits*80b/time.  Note that this is not the same as da=
ta bandwidth.  For example, when we are transferring a 64B cacheline across=
 QPI, we will break it into 9 flits -- 1 with header information and 8 with=
 64 bits of actual data and an additional 16 bits of other information.  To=
 calculate data bandwidth, one should therefore do: data flits * 8B / time.=
; Number of Non-Coherent Bypass non-data flits.  These packets are generall=
y used to transmit non-coherent data across QPI, and the flits counted here=
 are for headers and other non-data flits.  This includes extended headers.=
",
         "UMask": "0x8",
         "Unit": "QPI LL"
     },
     {
-        "BriefDescription": "Flits Received - Group 2; Non-Coherent Rx Fli=
ts",
-        "Counter": "0,1,2,3",
+        "BriefDescription": "Flits Received - Group 2; Non-Coherent standa=
rd Rx Flits",
         "EventCode": "0x3",
-        "EventName": "UNC_Q_RxL_FLITS_G2.NCB",
-        "ExtSel": "1",
+        "EventName": "UNC_Q_RxL_FLITS_G2.NCS",
         "PerPkg": "1",
-        "UMask": "0xC",
+        "PublicDescription": "Counts the number of flits received from the=
 QPI Link.  This is one of three groups that allow us to track flits.  It i=
ncludes filters for NDR, NCB, and NCS message classes.  Each flit is made u=
p of 80 bits of information (in addition to some ECC data).  In full-width =
(L0) mode, flits are made up of four fits, each of which contains 20 bits o=
f data (along with some additional ECC data).   In half-width (L0p) mode, t=
he fits are only 10 bits, and therefore it takes twice as many fits to tran=
smit a flit.  When one talks about QPI speed (for example, 8.0 GT/s), the t=
ransfers here refer to fits.  Therefore, in L0, the system will transfer 1 =
flit at the rate of 1/4th the QPI speed.  One can calculate the bandwidth o=
f the link by taking: flits*80b/time.  Note that this is not the same as da=
ta bandwidth.  For example, when we are transferring a 64B cacheline across=
 QPI, we will break it into 9 flits -- 1 with header information and 8 with=
 64 bits of actual data and an additional 16 bits of other information.  To=
 calculate data bandwidth, one should therefore do: data flits * 8B / time.=
; Number of NCS (non-coherent standard) flits received over QPI.    This in=
cludes extended headers.",
+        "UMask": "0x10",
         "Unit": "QPI LL"
     },
     {
-        "BriefDescription": "Flits Received - Group 2; Non-Coherent standa=
rd Rx Flits",
-        "Counter": "0,1,2,3",
+        "BriefDescription": "Flits Received - Group 2; Non-Data Response R=
x Flits - AD",
         "EventCode": "0x3",
-        "EventName": "UNC_Q_RxL_FLITS_G2.NCS",
-        "ExtSel": "1",
+        "EventName": "UNC_Q_RxL_FLITS_G2.NDR_AD",
         "PerPkg": "1",
-        "UMask": "0x10",
+        "PublicDescription": "Counts the number of flits received from the=
 QPI Link.  This is one of three groups that allow us to track flits.  It i=
ncludes filters for NDR, NCB, and NCS message classes.  Each flit is made u=
p of 80 bits of information (in addition to some ECC data).  In full-width =
(L0) mode, flits are made up of four fits, each of which contains 20 bits o=
f data (along with some additional ECC data).   In half-width (L0p) mode, t=
he fits are only 10 bits, and therefore it takes twice as many fits to tran=
smit a flit.  When one talks about QPI speed (for example, 8.0 GT/s), the t=
ransfers here refer to fits.  Therefore, in L0, the system will transfer 1 =
flit at the rate of 1/4th the QPI speed.  One can calculate the bandwidth o=
f the link by taking: flits*80b/time.  Note that this is not the same as da=
ta bandwidth.  For example, when we are transferring a 64B cacheline across=
 QPI, we will break it into 9 flits -- 1 with header information and 8 with=
 64 bits of actual data and an additional 16 bits of other information.  To=
 calculate data bandwidth, one should therefore do: data flits * 8B / time.=
; Counts the total number of flits received over the NDR (Non-Data Response=
) channel.  This channel is used to send a variety of protocol flits includ=
ing grants and completions.  This is only for NDR packets to the local sock=
et which use the AK ring.",
+        "UMask": "0x1",
+        "Unit": "QPI LL"
+    },
+    {
+        "BriefDescription": "Flits Received - Group 2; Non-Data Response R=
x Flits - AK",
+        "EventCode": "0x3",
+        "EventName": "UNC_Q_RxL_FLITS_G2.NDR_AK",
+        "PerPkg": "1",
+        "PublicDescription": "Counts the number of flits received from the=
 QPI Link.  This is one of three groups that allow us to track flits.  It i=
ncludes filters for NDR, NCB, and NCS message classes.  Each flit is made u=
p of 80 bits of information (in addition to some ECC data).  In full-width =
(L0) mode, flits are made up of four fits, each of which contains 20 bits o=
f data (along with some additional ECC data).   In half-width (L0p) mode, t=
he fits are only 10 bits, and therefore it takes twice as many fits to tran=
smit a flit.  When one talks about QPI speed (for example, 8.0 GT/s), the t=
ransfers here refer to fits.  Therefore, in L0, the system will transfer 1 =
flit at the rate of 1/4th the QPI speed.  One can calculate the bandwidth o=
f the link by taking: flits*80b/time.  Note that this is not the same as da=
ta bandwidth.  For example, when we are transferring a 64B cacheline across=
 QPI, we will break it into 9 flits -- 1 with header information and 8 with=
 64 bits of actual data and an additional 16 bits of other information.  To=
 calculate data bandwidth, one should therefore do: data flits * 8B / time.=
; Counts the total number of flits received over the NDR (Non-Data Response=
) channel.  This channel is used to send a variety of protocol flits includ=
ing grants and completions.  This is only for NDR packets destined for Rout=
e-thru to a remote socket.",
+        "UMask": "0x2",
         "Unit": "QPI LL"
     },
     {
         "BriefDescription": "Rx Flit Buffer Allocations",
-        "Counter": "0,1,2,3",
         "EventCode": "0x8",
         "EventName": "UNC_Q_RxL_INSERTS",
         "PerPkg": "1",
+        "PublicDescription": "Number of allocations into the QPI Rx Flit B=
uffer.  Generally, when data is transmitted across QPI, it will bypass the =
RxQ and pass directly to the ring interface.  If things back up getting tra=
nsmitted onto the ring, however, it may need to allocate into this buffer, =
thus increasing the latency.  This event can be used in conjunction with th=
e Flit Buffer Occupancy event in order to calculate the average flit buffer=
 lifetime.",
         "Unit": "QPI LL"
     },
     {
         "BriefDescription": "Rx Flit Buffer Allocations - DRS; for VN0",
-        "Counter": "0,1,2,3",
         "EventCode": "0x9",
         "EventName": "UNC_Q_RxL_INSERTS_DRS.VN0",
-        "ExtSel": "1",
         "PerPkg": "1",
+        "PublicDescription": "Number of allocations into the QPI Rx Flit B=
uffer.  Generally, when data is transmitted across QPI, it will bypass the =
RxQ and pass directly to the ring interface.  If things back up getting tra=
nsmitted onto the ring, however, it may need to allocate into this buffer, =
thus increasing the latency.  This event can be used in conjunction with th=
e Flit Buffer Occupancy event in order to calculate the average flit buffer=
 lifetime.  This monitors only DRS flits.",
         "UMask": "0x1",
         "Unit": "QPI LL"
     },
     {
         "BriefDescription": "Rx Flit Buffer Allocations - DRS; for VN1",
-        "Counter": "0,1,2,3",
         "EventCode": "0x9",
         "EventName": "UNC_Q_RxL_INSERTS_DRS.VN1",
-        "ExtSel": "1",
         "PerPkg": "1",
+        "PublicDescription": "Number of allocations into the QPI Rx Flit B=
uffer.  Generally, when data is transmitted across QPI, it will bypass the =
RxQ and pass directly to the ring interface.  If things back up getting tra=
nsmitted onto the ring, however, it may need to allocate into this buffer, =
thus increasing the latency.  This event can be used in conjunction with th=
e Flit Buffer Occupancy event in order to calculate the average flit buffer=
 lifetime.  This monitors only DRS flits.",
         "UMask": "0x2",
         "Unit": "QPI LL"
     },
     {
         "BriefDescription": "Rx Flit Buffer Allocations - HOM; for VN0",
-        "Counter": "0,1,2,3",
         "EventCode": "0xC",
         "EventName": "UNC_Q_RxL_INSERTS_HOM.VN0",
-        "ExtSel": "1",
         "PerPkg": "1",
+        "PublicDescription": "Number of allocations into the QPI Rx Flit B=
uffer.  Generally, when data is transmitted across QPI, it will bypass the =
RxQ and pass directly to the ring interface.  If things back up getting tra=
nsmitted onto the ring, however, it may need to allocate into this buffer, =
thus increasing the latency.  This event can be used in conjunction with th=
e Flit Buffer Occupancy event in order to calculate the average flit buffer=
 lifetime.  This monitors only HOM flits.",
         "UMask": "0x1",
         "Unit": "QPI LL"
     },
     {
         "BriefDescription": "Rx Flit Buffer Allocations - HOM; for VN1",
-        "Counter": "0,1,2,3",
         "EventCode": "0xC",
         "EventName": "UNC_Q_RxL_INSERTS_HOM.VN1",
-        "ExtSel": "1",
         "PerPkg": "1",
+        "PublicDescription": "Number of allocations into the QPI Rx Flit B=
uffer.  Generally, when data is transmitted across QPI, it will bypass the =
RxQ and pass directly to the ring interface.  If things back up getting tra=
nsmitted onto the ring, however, it may need to allocate into this buffer, =
thus increasing the latency.  This event can be used in conjunction with th=
e Flit Buffer Occupancy event in order to calculate the average flit buffer=
 lifetime.  This monitors only HOM flits.",
         "UMask": "0x2",
         "Unit": "QPI LL"
     },
     {
         "BriefDescription": "Rx Flit Buffer Allocations - NCB; for VN0",
-        "Counter": "0,1,2,3",
         "EventCode": "0xA",
         "EventName": "UNC_Q_RxL_INSERTS_NCB.VN0",
-        "ExtSel": "1",
         "PerPkg": "1",
+        "PublicDescription": "Number of allocations into the QPI Rx Flit B=
uffer.  Generally, when data is transmitted across QPI, it will bypass the =
RxQ and pass directly to the ring interface.  If things back up getting tra=
nsmitted onto the ring, however, it may need to allocate into this buffer, =
thus increasing the latency.  This event can be used in conjunction with th=
e Flit Buffer Occupancy event in order to calculate the average flit buffer=
 lifetime.  This monitors only NCB flits.",
         "UMask": "0x1",
         "Unit": "QPI LL"
     },
     {
         "BriefDescription": "Rx Flit Buffer Allocations - NCB; for VN1",
-        "Counter": "0,1,2,3",
         "EventCode": "0xA",
         "EventName": "UNC_Q_RxL_INSERTS_NCB.VN1",
-        "ExtSel": "1",
         "PerPkg": "1",
+        "PublicDescription": "Number of allocations into the QPI Rx Flit B=
uffer.  Generally, when data is transmitted across QPI, it will bypass the =
RxQ and pass directly to the ring interface.  If things back up getting tra=
nsmitted onto the ring, however, it may need to allocate into this buffer, =
thus increasing the latency.  This event can be used in conjunction with th=
e Flit Buffer Occupancy event in order to calculate the average flit buffer=
 lifetime.  This monitors only NCB flits.",
         "UMask": "0x2",
         "Unit": "QPI LL"
     },
     {
         "BriefDescription": "Rx Flit Buffer Allocations - NCS; for VN0",
-        "Counter": "0,1,2,3",
         "EventCode": "0xB",
         "EventName": "UNC_Q_RxL_INSERTS_NCS.VN0",
-        "ExtSel": "1",
         "PerPkg": "1",
+        "PublicDescription": "Number of allocations into the QPI Rx Flit B=
uffer.  Generally, when data is transmitted across QPI, it will bypass the =
RxQ and pass directly to the ring interface.  If things back up getting tra=
nsmitted onto the ring, however, it may need to allocate into this buffer, =
thus increasing the latency.  This event can be used in conjunction with th=
e Flit Buffer Occupancy event in order to calculate the average flit buffer=
 lifetime.  This monitors only NCS flits.",
         "UMask": "0x1",
         "Unit": "QPI LL"
     },
     {
         "BriefDescription": "Rx Flit Buffer Allocations - NCS; for VN1",
-        "Counter": "0,1,2,3",
         "EventCode": "0xB",
         "EventName": "UNC_Q_RxL_INSERTS_NCS.VN1",
-        "ExtSel": "1",
         "PerPkg": "1",
+        "PublicDescription": "Number of allocations into the QPI Rx Flit B=
uffer.  Generally, when data is transmitted across QPI, it will bypass the =
RxQ and pass directly to the ring interface.  If things back up getting tra=
nsmitted onto the ring, however, it may need to allocate into this buffer, =
thus increasing the latency.  This event can be used in conjunction with th=
e Flit Buffer Occupancy event in order to calculate the average flit buffer=
 lifetime.  This monitors only NCS flits.",
         "UMask": "0x2",
         "Unit": "QPI LL"
     },
     {
         "BriefDescription": "Rx Flit Buffer Allocations - NDR; for VN0",
-        "Counter": "0,1,2,3",
         "EventCode": "0xE",
         "EventName": "UNC_Q_RxL_INSERTS_NDR.VN0",
-        "ExtSel": "1",
         "PerPkg": "1",
+        "PublicDescription": "Number of allocations into the QPI Rx Flit B=
uffer.  Generally, when data is transmitted across QPI, it will bypass the =
RxQ and pass directly to the ring interface.  If things back up getting tra=
nsmitted onto the ring, however, it may need to allocate into this buffer, =
thus increasing the latency.  This event can be used in conjunction with th=
e Flit Buffer Occupancy event in order to calculate the average flit buffer=
 lifetime.  This monitors only NDR flits.",
         "UMask": "0x1",
         "Unit": "QPI LL"
     },
     {
         "BriefDescription": "Rx Flit Buffer Allocations - NDR; for VN1",
-        "Counter": "0,1,2,3",
         "EventCode": "0xE",
         "EventName": "UNC_Q_RxL_INSERTS_NDR.VN1",
-        "ExtSel": "1",
         "PerPkg": "1",
+        "PublicDescription": "Number of allocations into the QPI Rx Flit B=
uffer.  Generally, when data is transmitted across QPI, it will bypass the =
RxQ and pass directly to the ring interface.  If things back up getting tra=
nsmitted onto the ring, however, it may need to allocate into this buffer, =
thus increasing the latency.  This event can be used in conjunction with th=
e Flit Buffer Occupancy event in order to calculate the average flit buffer=
 lifetime.  This monitors only NDR flits.",
         "UMask": "0x2",
         "Unit": "QPI LL"
     },
     {
         "BriefDescription": "Rx Flit Buffer Allocations - SNP; for VN0",
-        "Counter": "0,1,2,3",
         "EventCode": "0xD",
         "EventName": "UNC_Q_RxL_INSERTS_SNP.VN0",
-        "ExtSel": "1",
         "PerPkg": "1",
+        "PublicDescription": "Number of allocations into the QPI Rx Flit B=
uffer.  Generally, when data is transmitted across QPI, it will bypass the =
RxQ and pass directly to the ring interface.  If things back up getting tra=
nsmitted onto the ring, however, it may need to allocate into this buffer, =
thus increasing the latency.  This event can be used in conjunction with th=
e Flit Buffer Occupancy event in order to calculate the average flit buffer=
 lifetime.  This monitors only SNP flits.",
         "UMask": "0x1",
         "Unit": "QPI LL"
     },
     {
         "BriefDescription": "Rx Flit Buffer Allocations - SNP; for VN1",
-        "Counter": "0,1,2,3",
         "EventCode": "0xD",
         "EventName": "UNC_Q_RxL_INSERTS_SNP.VN1",
-        "ExtSel": "1",
         "PerPkg": "1",
+        "PublicDescription": "Number of allocations into the QPI Rx Flit B=
uffer.  Generally, when data is transmitted across QPI, it will bypass the =
RxQ and pass directly to the ring interface.  If things back up getting tra=
nsmitted onto the ring, however, it may need to allocate into this buffer, =
thus increasing the latency.  This event can be used in conjunction with th=
e Flit Buffer Occupancy event in order to calculate the average flit buffer=
 lifetime.  This monitors only SNP flits.",
         "UMask": "0x2",
         "Unit": "QPI LL"
     },
     {
         "BriefDescription": "RxQ Occupancy - All Packets",
-        "Counter": "0,1,2,3",
         "EventCode": "0xB",
         "EventName": "UNC_Q_RxL_OCCUPANCY",
         "PerPkg": "1",
+        "PublicDescription": "Accumulates the number of elements in the QP=
I RxQ in each cycle.  Generally, when data is transmitted across QPI, it wi=
ll bypass the RxQ and pass directly to the ring interface.  If things back =
up getting transmitted onto the ring, however, it may need to allocate into=
 this buffer, thus increasing the latency.  This event can be used in conju=
nction with the Flit Buffer Not Empty event to calculate average occupancy,=
 or with the Flit Buffer Allocations event to track average lifetime.",
         "Unit": "QPI LL"
     },
     {
         "BriefDescription": "RxQ Occupancy - DRS; for VN0",
-        "Counter": "0,1,2,3",
         "EventCode": "0x15",
         "EventName": "UNC_Q_RxL_OCCUPANCY_DRS.VN0",
-        "ExtSel": "1",
         "PerPkg": "1",
+        "PublicDescription": "Accumulates the number of elements in the QP=
I RxQ in each cycle.  Generally, when data is transmitted across QPI, it wi=
ll bypass the RxQ and pass directly to the ring interface.  If things back =
up getting transmitted onto the ring, however, it may need to allocate into=
 this buffer, thus increasing the latency.  This event can be used in conju=
nction with the Flit Buffer Not Empty event to calculate average occupancy,=
 or with the Flit Buffer Allocations event to track average lifetime.  This=
 monitors DRS flits only.",
         "UMask": "0x1",
         "Unit": "QPI LL"
     },
     {
         "BriefDescription": "RxQ Occupancy - DRS; for VN1",
-        "Counter": "0,1,2,3",
         "EventCode": "0x15",
         "EventName": "UNC_Q_RxL_OCCUPANCY_DRS.VN1",
-        "ExtSel": "1",
         "PerPkg": "1",
+        "PublicDescription": "Accumulates the number of elements in the QP=
I RxQ in each cycle.  Generally, when data is transmitted across QPI, it wi=
ll bypass the RxQ and pass directly to the ring interface.  If things back =
up getting transmitted onto the ring, however, it may need to allocate into=
 this buffer, thus increasing the latency.  This event can be used in conju=
nction with the Flit Buffer Not Empty event to calculate average occupancy,=
 or with the Flit Buffer Allocations event to track average lifetime.  This=
 monitors DRS flits only.",
         "UMask": "0x2",
         "Unit": "QPI LL"
     },
     {
         "BriefDescription": "RxQ Occupancy - HOM; for VN0",
-        "Counter": "0,1,2,3",
         "EventCode": "0x18",
         "EventName": "UNC_Q_RxL_OCCUPANCY_HOM.VN0",
-        "ExtSel": "1",
         "PerPkg": "1",
+        "PublicDescription": "Accumulates the number of elements in the QP=
I RxQ in each cycle.  Generally, when data is transmitted across QPI, it wi=
ll bypass the RxQ and pass directly to the ring interface.  If things back =
up getting transmitted onto the ring, however, it may need to allocate into=
 this buffer, thus increasing the latency.  This event can be used in conju=
nction with the Flit Buffer Not Empty event to calculate average occupancy,=
 or with the Flit Buffer Allocations event to track average lifetime.  This=
 monitors HOM flits only.",
         "UMask": "0x1",
         "Unit": "QPI LL"
     },
     {
         "BriefDescription": "RxQ Occupancy - HOM; for VN1",
-        "Counter": "0,1,2,3",
         "EventCode": "0x18",
         "EventName": "UNC_Q_RxL_OCCUPANCY_HOM.VN1",
-        "ExtSel": "1",
         "PerPkg": "1",
+        "PublicDescription": "Accumulates the number of elements in the QP=
I RxQ in each cycle.  Generally, when data is transmitted across QPI, it wi=
ll bypass the RxQ and pass directly to the ring interface.  If things back =
up getting transmitted onto the ring, however, it may need to allocate into=
 this buffer, thus increasing the latency.  This event can be used in conju=
nction with the Flit Buffer Not Empty event to calculate average occupancy,=
 or with the Flit Buffer Allocations event to track average lifetime.  This=
 monitors HOM flits only.",
         "UMask": "0x2",
         "Unit": "QPI LL"
     },
     {
         "BriefDescription": "RxQ Occupancy - NCB; for VN0",
-        "Counter": "0,1,2,3",
         "EventCode": "0x16",
         "EventName": "UNC_Q_RxL_OCCUPANCY_NCB.VN0",
-        "ExtSel": "1",
         "PerPkg": "1",
+        "PublicDescription": "Accumulates the number of elements in the QP=
I RxQ in each cycle.  Generally, when data is transmitted across QPI, it wi=
ll bypass the RxQ and pass directly to the ring interface.  If things back =
up getting transmitted onto the ring, however, it may need to allocate into=
 this buffer, thus increasing the latency.  This event can be used in conju=
nction with the Flit Buffer Not Empty event to calculate average occupancy,=
 or with the Flit Buffer Allocations event to track average lifetime.  This=
 monitors NCB flits only.",
         "UMask": "0x1",
         "Unit": "QPI LL"
     },
     {
         "BriefDescription": "RxQ Occupancy - NCB; for VN1",
-        "Counter": "0,1,2,3",
         "EventCode": "0x16",
         "EventName": "UNC_Q_RxL_OCCUPANCY_NCB.VN1",
-        "ExtSel": "1",
         "PerPkg": "1",
+        "PublicDescription": "Accumulates the number of elements in the QP=
I RxQ in each cycle.  Generally, when data is transmitted across QPI, it wi=
ll bypass the RxQ and pass directly to the ring interface.  If things back =
up getting transmitted onto the ring, however, it may need to allocate into=
 this buffer, thus increasing the latency.  This event can be used in conju=
nction with the Flit Buffer Not Empty event to calculate average occupancy,=
 or with the Flit Buffer Allocations event to track average lifetime.  This=
 monitors NCB flits only.",
         "UMask": "0x2",
         "Unit": "QPI LL"
     },
     {
         "BriefDescription": "RxQ Occupancy - NCS; for VN0",
-        "Counter": "0,1,2,3",
         "EventCode": "0x17",
         "EventName": "UNC_Q_RxL_OCCUPANCY_NCS.VN0",
-        "ExtSel": "1",
         "PerPkg": "1",
+        "PublicDescription": "Accumulates the number of elements in the QP=
I RxQ in each cycle.  Generally, when data is transmitted across QPI, it wi=
ll bypass the RxQ and pass directly to the ring interface.  If things back =
up getting transmitted onto the ring, however, it may need to allocate into=
 this buffer, thus increasing the latency.  This event can be used in conju=
nction with the Flit Buffer Not Empty event to calculate average occupancy,=
 or with the Flit Buffer Allocations event to track average lifetime.  This=
 monitors NCS flits only.",
         "UMask": "0x1",
         "Unit": "QPI LL"
     },
     {
         "BriefDescription": "RxQ Occupancy - NCS; for VN1",
-        "Counter": "0,1,2,3",
         "EventCode": "0x17",
         "EventName": "UNC_Q_RxL_OCCUPANCY_NCS.VN1",
-        "ExtSel": "1",
         "PerPkg": "1",
+        "PublicDescription": "Accumulates the number of elements in the QP=
I RxQ in each cycle.  Generally, when data is transmitted across QPI, it wi=
ll bypass the RxQ and pass directly to the ring interface.  If things back =
up getting transmitted onto the ring, however, it may need to allocate into=
 this buffer, thus increasing the latency.  This event can be used in conju=
nction with the Flit Buffer Not Empty event to calculate average occupancy,=
 or with the Flit Buffer Allocations event to track average lifetime.  This=
 monitors NCS flits only.",
         "UMask": "0x2",
         "Unit": "QPI LL"
     },
     {
         "BriefDescription": "RxQ Occupancy - NDR; for VN0",
-        "Counter": "0,1,2,3",
         "EventCode": "0x1A",
         "EventName": "UNC_Q_RxL_OCCUPANCY_NDR.VN0",
-        "ExtSel": "1",
         "PerPkg": "1",
+        "PublicDescription": "Accumulates the number of elements in the QP=
I RxQ in each cycle.  Generally, when data is transmitted across QPI, it wi=
ll bypass the RxQ and pass directly to the ring interface.  If things back =
up getting transmitted onto the ring, however, it may need to allocate into=
 this buffer, thus increasing the latency.  This event can be used in conju=
nction with the Flit Buffer Not Empty event to calculate average occupancy,=
 or with the Flit Buffer Allocations event to track average lifetime.  This=
 monitors NDR flits only.",
         "UMask": "0x1",
         "Unit": "QPI LL"
     },
     {
         "BriefDescription": "RxQ Occupancy - NDR; for VN1",
-        "Counter": "0,1,2,3",
         "EventCode": "0x1A",
         "EventName": "UNC_Q_RxL_OCCUPANCY_NDR.VN1",
-        "ExtSel": "1",
         "PerPkg": "1",
+        "PublicDescription": "Accumulates the number of elements in the QP=
I RxQ in each cycle.  Generally, when data is transmitted across QPI, it wi=
ll bypass the RxQ and pass directly to the ring interface.  If things back =
up getting transmitted onto the ring, however, it may need to allocate into=
 this buffer, thus increasing the latency.  This event can be used in conju=
nction with the Flit Buffer Not Empty event to calculate average occupancy,=
 or with the Flit Buffer Allocations event to track average lifetime.  This=
 monitors NDR flits only.",
         "UMask": "0x2",
         "Unit": "QPI LL"
     },
     {
         "BriefDescription": "RxQ Occupancy - SNP; for VN0",
-        "Counter": "0,1,2,3",
         "EventCode": "0x19",
         "EventName": "UNC_Q_RxL_OCCUPANCY_SNP.VN0",
-        "ExtSel": "1",
         "PerPkg": "1",
+        "PublicDescription": "Accumulates the number of elements in the QP=
I RxQ in each cycle.  Generally, when data is transmitted across QPI, it wi=
ll bypass the RxQ and pass directly to the ring interface.  If things back =
up getting transmitted onto the ring, however, it may need to allocate into=
 this buffer, thus increasing the latency.  This event can be used in conju=
nction with the Flit Buffer Not Empty event to calculate average occupancy,=
 or with the Flit Buffer Allocations event to track average lifetime.  This=
 monitors SNP flits only.",
         "UMask": "0x1",
         "Unit": "QPI LL"
     },
     {
         "BriefDescription": "RxQ Occupancy - SNP; for VN1",
-        "Counter": "0,1,2,3",
         "EventCode": "0x19",
         "EventName": "UNC_Q_RxL_OCCUPANCY_SNP.VN1",
-        "ExtSel": "1",
         "PerPkg": "1",
+        "PublicDescription": "Accumulates the number of elements in the QP=
I RxQ in each cycle.  Generally, when data is transmitted across QPI, it wi=
ll bypass the RxQ and pass directly to the ring interface.  If things back =
up getting transmitted onto the ring, however, it may need to allocate into=
 this buffer, thus increasing the latency.  This event can be used in conju=
nction with the Flit Buffer Not Empty event to calculate average occupancy,=
 or with the Flit Buffer Allocations event to track average lifetime.  This=
 monitors SNP flits only.",
         "UMask": "0x2",
         "Unit": "QPI LL"
     },
     {
         "BriefDescription": "Stalls Sending to R3QPI on VN0; BGF Stall - H=
OM",
-        "Counter": "0,1,2,3",
         "EventCode": "0x35",
         "EventName": "UNC_Q_RxL_STALLS_VN0.BGF_DRS",
-        "ExtSel": "1",
         "PerPkg": "1",
+        "PublicDescription": "Number of stalls trying to send to R3QPI on =
Virtual Network 0; Stalled a packet from the HOM message class because ther=
e were not enough BGF credits.  In bypass mode, we will stall on the packet=
 boundary, while in RxQ mode we will stall on the flit boundary.",
         "UMask": "0x1",
         "Unit": "QPI LL"
     },
+    {
+        "BriefDescription": "Stalls Sending to R3QPI on VN0; BGF Stall - D=
RS",
+        "EventCode": "0x35",
+        "EventName": "UNC_Q_RxL_STALLS_VN0.BGF_HOM",
+        "PerPkg": "1",
+        "PublicDescription": "Number of stalls trying to send to R3QPI on =
Virtual Network 0; Stalled a packet from the DRS message class because ther=
e were not enough BGF credits.  In bypass mode, we will stall on the packet=
 boundary, while in RxQ mode we will stall on the flit boundary.",
+        "UMask": "0x8",
+        "Unit": "QPI LL"
+    },
     {
         "BriefDescription": "Stalls Sending to R3QPI on VN0; BGF Stall - S=
NP",
-        "Counter": "0,1,2,3",
         "EventCode": "0x35",
         "EventName": "UNC_Q_RxL_STALLS_VN0.BGF_NCB",
-        "ExtSel": "1",
         "PerPkg": "1",
+        "PublicDescription": "Number of stalls trying to send to R3QPI on =
Virtual Network 0; Stalled a packet from the SNP message class because ther=
e were not enough BGF credits.  In bypass mode, we will stall on the packet=
 boundary, while in RxQ mode we will stall on the flit boundary.",
         "UMask": "0x2",
         "Unit": "QPI LL"
     },
     {
         "BriefDescription": "Stalls Sending to R3QPI on VN0; BGF Stall - N=
DR",
-        "Counter": "0,1,2,3",
         "EventCode": "0x35",
         "EventName": "UNC_Q_RxL_STALLS_VN0.BGF_NCS",
-        "ExtSel": "1",
         "PerPkg": "1",
+        "PublicDescription": "Number of stalls trying to send to R3QPI on =
Virtual Network 0; Stalled a packet from the NDR message class because ther=
e were not enough BGF credits.  In bypass mode, we will stall on the packet=
 boundary, while in RxQ mode we will stall on the flit boundary.",
         "UMask": "0x4",
         "Unit": "QPI LL"
     },
     {
-        "BriefDescription": "Stalls Sending to R3QPI on VN0; BGF Stall - D=
RS",
-        "Counter": "0,1,2,3",
+        "BriefDescription": "Stalls Sending to R3QPI on VN0; BGF Stall - N=
CS",
         "EventCode": "0x35",
-        "EventName": "UNC_Q_RxL_STALLS_VN0.BGF_HOM",
-        "ExtSel": "1",
+        "EventName": "UNC_Q_RxL_STALLS_VN0.BGF_NDR",
         "PerPkg": "1",
-        "UMask": "0x8",
+        "PublicDescription": "Number of stalls trying to send to R3QPI on =
Virtual Network 0; Stalled a packet from the NCS message class because ther=
e were not enough BGF credits.  In bypass mode, we will stall on the packet=
 boundary, while in RxQ mode we will stall on the flit boundary.",
+        "UMask": "0x20",
         "Unit": "QPI LL"
     },
     {
         "BriefDescription": "Stalls Sending to R3QPI on VN0; BGF Stall - N=
CB",
-        "Counter": "0,1,2,3",
         "EventCode": "0x35",
         "EventName": "UNC_Q_RxL_STALLS_VN0.BGF_SNP",
-        "ExtSel": "1",
         "PerPkg": "1",
+        "PublicDescription": "Number of stalls trying to send to R3QPI on =
Virtual Network 0; Stalled a packet from the NCB message class because ther=
e were not enough BGF credits.  In bypass mode, we will stall on the packet=
 boundary, while in RxQ mode we will stall on the flit boundary.",
         "UMask": "0x10",
         "Unit": "QPI LL"
     },
-    {
-        "BriefDescription": "Stalls Sending to R3QPI on VN0; BGF Stall - N=
CS",
-        "Counter": "0,1,2,3",
-        "EventCode": "0x35",
-        "EventName": "UNC_Q_RxL_STALLS_VN0.BGF_NDR",
-        "ExtSel": "1",
-        "PerPkg": "1",
-        "UMask": "0x20",
-        "Unit": "QPI LL"
-    },
     {
         "BriefDescription": "Stalls Sending to R3QPI on VN0; Egress Credit=
s",
-        "Counter": "0,1,2,3",
         "EventCode": "0x35",
         "EventName": "UNC_Q_RxL_STALLS_VN0.EGRESS_CREDITS",
-        "ExtSel": "1",
         "PerPkg": "1",
+        "PublicDescription": "Number of stalls trying to send to R3QPI on =
Virtual Network 0; Stalled a packet because there were insufficient BGF cre=
dits.  For details on a message class granularity, use the Egress Credit Oc=
cupancy events.",
         "UMask": "0x40",
         "Unit": "QPI LL"
     },
     {
         "BriefDescription": "Stalls Sending to R3QPI on VN0; GV",
-        "Counter": "0,1,2,3",
         "EventCode": "0x35",
         "EventName": "UNC_Q_RxL_STALLS_VN0.GV",
-        "ExtSel": "1",
         "PerPkg": "1",
+        "PublicDescription": "Number of stalls trying to send to R3QPI on =
Virtual Network 0; Stalled because a GV transition (frequency transition) w=
as taking place.",
         "UMask": "0x80",
         "Unit": "QPI LL"
     },
     {
         "BriefDescription": "Stalls Sending to R3QPI on VN1; BGF Stall - H=
OM",
-        "Counter": "0,1,2,3",
         "EventCode": "0x3A",
         "EventName": "UNC_Q_RxL_STALLS_VN1.BGF_DRS",
-        "ExtSel": "1",
         "PerPkg": "1",
+        "PublicDescription": "Number of stalls trying to send to R3QPI on =
Virtual Network 1.; Stalled a packet from the HOM message class because the=
re were not enough BGF credits.  In bypass mode, we will stall on the packe=
t boundary, while in RxQ mode we will stall on the flit boundary.",
         "UMask": "0x1",
         "Unit": "QPI LL"
     },
+    {
+        "BriefDescription": "Stalls Sending to R3QPI on VN1; BGF Stall - D=
RS",
+        "EventCode": "0x3A",
+        "EventName": "UNC_Q_RxL_STALLS_VN1.BGF_HOM",
+        "PerPkg": "1",
+        "PublicDescription": "Number of stalls trying to send to R3QPI on =
Virtual Network 1.; Stalled a packet from the DRS message class because the=
re were not enough BGF credits.  In bypass mode, we will stall on the packe=
t boundary, while in RxQ mode we will stall on the flit boundary.",
+        "UMask": "0x8",
+        "Unit": "QPI LL"
+    },
     {
         "BriefDescription": "Stalls Sending to R3QPI on VN1; BGF Stall - S=
NP",
-        "Counter": "0,1,2,3",
         "EventCode": "0x3A",
         "EventName": "UNC_Q_RxL_STALLS_VN1.BGF_NCB",
-        "ExtSel": "1",
         "PerPkg": "1",
+        "PublicDescription": "Number of stalls trying to send to R3QPI on =
Virtual Network 1.; Stalled a packet from the SNP message class because the=
re were not enough BGF credits.  In bypass mode, we will stall on the packe=
t boundary, while in RxQ mode we will stall on the flit boundary.",
         "UMask": "0x2",
         "Unit": "QPI LL"
     },
     {
         "BriefDescription": "Stalls Sending to R3QPI on VN1; BGF Stall - N=
DR",
-        "Counter": "0,1,2,3",
         "EventCode": "0x3A",
         "EventName": "UNC_Q_RxL_STALLS_VN1.BGF_NCS",
-        "ExtSel": "1",
         "PerPkg": "1",
+        "PublicDescription": "Number of stalls trying to send to R3QPI on =
Virtual Network 1.; Stalled a packet from the NDR message class because the=
re were not enough BGF credits.  In bypass mode, we will stall on the packe=
t boundary, while in RxQ mode we will stall on the flit boundary.",
         "UMask": "0x4",
         "Unit": "QPI LL"
     },
     {
-        "BriefDescription": "Stalls Sending to R3QPI on VN1; BGF Stall - D=
RS",
-        "Counter": "0,1,2,3",
+        "BriefDescription": "Stalls Sending to R3QPI on VN1; BGF Stall - N=
CS",
         "EventCode": "0x3A",
-        "EventName": "UNC_Q_RxL_STALLS_VN1.BGF_HOM",
-        "ExtSel": "1",
+        "EventName": "UNC_Q_RxL_STALLS_VN1.BGF_NDR",
         "PerPkg": "1",
-        "UMask": "0x8",
+        "PublicDescription": "Number of stalls trying to send to R3QPI on =
Virtual Network 1.; Stalled a packet from the NCS message class because the=
re were not enough BGF credits.  In bypass mode, we will stall on the packe=
t boundary, while in RxQ mode we will stall on the flit boundary.",
+        "UMask": "0x20",
         "Unit": "QPI LL"
     },
     {
         "BriefDescription": "Stalls Sending to R3QPI on VN1; BGF Stall - N=
CB",
-        "Counter": "0,1,2,3",
         "EventCode": "0x3A",
         "EventName": "UNC_Q_RxL_STALLS_VN1.BGF_SNP",
-        "ExtSel": "1",
         "PerPkg": "1",
+        "PublicDescription": "Number of stalls trying to send to R3QPI on =
Virtual Network 1.; Stalled a packet from the NCB message class because the=
re were not enough BGF credits.  In bypass mode, we will stall on the packe=
t boundary, while in RxQ mode we will stall on the flit boundary.",
         "UMask": "0x10",
         "Unit": "QPI LL"
     },
-    {
-        "BriefDescription": "Stalls Sending to R3QPI on VN1; BGF Stall - N=
CS",
-        "Counter": "0,1,2,3",
-        "EventCode": "0x3A",
-        "EventName": "UNC_Q_RxL_STALLS_VN1.BGF_NDR",
-        "ExtSel": "1",
-        "PerPkg": "1",
-        "UMask": "0x20",
-        "Unit": "QPI LL"
-    },
     {
         "BriefDescription": "Cycles in L0p",
-        "Counter": "0,1,2,3",
         "EventCode": "0xD",
         "EventName": "UNC_Q_TxL0P_POWER_CYCLES",
         "PerPkg": "1",
+        "PublicDescription": "Number of QPI qfclk cycles spent in L0p powe=
r mode.  L0p is a mode where we disable 1/2 of the QPI lanes, decreasing ou=
r bandwidth in order to save power.  It increases snoop and data transfer l=
atencies and decreases overall bandwidth.  This mode can be very useful in =
NUMA optimized workloads that largely only utilize QPI for snoops and their=
 responses.  Use edge detect to count the number of instances when the QPI =
link entered L0p.  Link power states are per link and per direction, so for=
 example the Tx direction could be in one state while Rx was in another.",
         "Unit": "QPI LL"
     },
     {
         "BriefDescription": "Cycles in L0",
-        "Counter": "0,1,2,3",
         "EventCode": "0xC",
         "EventName": "UNC_Q_TxL0_POWER_CYCLES",
         "PerPkg": "1",
+        "PublicDescription": "Number of QPI qfclk cycles spent in L0 power=
 mode in the Link Layer.  L0 is the default mode which provides the highest=
 performance with the most power.  Use edge detect to count the number of i=
nstances that the link entered L0.  Link power states are per link and per =
direction, so for example the Tx direction could be in one state while Rx w=
as in another.  The phy layer  sometimes leaves L0 for training, which will=
 not be captured by this event.",
         "Unit": "QPI LL"
     },
     {
         "BriefDescription": "Tx Flit Buffer Bypassed",
-        "Counter": "0,1,2,3",
         "EventCode": "0x5",
         "EventName": "UNC_Q_TxL_BYPASSED",
         "PerPkg": "1",
+        "PublicDescription": "Counts the number of times that an incoming =
flit was able to bypass the Tx flit buffer and pass directly out the QPI Li=
nk. Generally, when data is transmitted across QPI, it will bypass the TxQ =
and pass directly to the link.  However, the TxQ will be used with L0p and =
when LLR occurs, increasing latency to transfer out to the link.",
         "Unit": "QPI LL"
     },
     {
-        "BriefDescription": "Cycles Stalled with no LLR Credits; LLR is fu=
ll",
-        "Counter": "0,1,2,3",
+        "BriefDescription": "Cycles Stalled with no LLR Credits; LLR is al=
most full",
         "EventCode": "0x2",
-        "EventName": "UNC_Q_TxL_CRC_NO_CREDITS.FULL",
+        "EventName": "UNC_Q_TxL_CRC_NO_CREDITS.ALMOST_FULL",
         "PerPkg": "1",
-        "UMask": "0x1",
+        "PublicDescription": "Number of cycles when the Tx side ran out of=
 Link Layer Retry credits, causing the Tx to stall.; When LLR is almost ful=
l, we block some but not all packets.",
+        "UMask": "0x2",
         "Unit": "QPI LL"
     },
     {
-        "BriefDescription": "Cycles Stalled with no LLR Credits; LLR is al=
most full",
-        "Counter": "0,1,2,3",
+        "BriefDescription": "Cycles Stalled with no LLR Credits; LLR is fu=
ll",
         "EventCode": "0x2",
-        "EventName": "UNC_Q_TxL_CRC_NO_CREDITS.ALMOST_FULL",
+        "EventName": "UNC_Q_TxL_CRC_NO_CREDITS.FULL",
         "PerPkg": "1",
-        "UMask": "0x2",
+        "PublicDescription": "Number of cycles when the Tx side ran out of=
 Link Layer Retry credits, causing the Tx to stall.; When LLR is totally fu=
ll, we are not allowed to send any packets.",
+        "UMask": "0x1",
         "Unit": "QPI LL"
     },
     {
         "BriefDescription": "Tx Flit Buffer Cycles not Empty",
-        "Counter": "0,1,2,3",
         "EventCode": "0x6",
         "EventName": "UNC_Q_TxL_CYCLES_NE",
         "PerPkg": "1",
+        "PublicDescription": "Counts the number of cycles when the TxQ is =
not empty. Generally, when data is transmitted across QPI, it will bypass t=
he TxQ and pass directly to the link.  However, the TxQ will be used with L=
0p and when LLR occurs, increasing latency to transfer out to the link.",
         "Unit": "QPI LL"
     },
     {
         "BriefDescription": "Flits Transferred - Group 0; Data Tx Flits",
-        "Counter": "0,1,2,3",
         "EventName": "UNC_Q_TxL_FLITS_G0.DATA",
         "PerPkg": "1",
-        "UMask": "0x2",
-        "Unit": "QPI LL"
-    },
-    {
-        "BriefDescription": "Number of data flits transmitted . Derived fr=
om unc_q_txl_flits_g0.data",
-        "Counter": "0,1,2,3",
-        "EventName": "QPI_DATA_BANDWIDTH_TX",
-        "PerPkg": "1",
-        "ScaleUnit": "8Bytes",
+        "PublicDescription": "Counts the number of flits transmitted acros=
s the QPI Link.  It includes filters for Idle, protocol, and Data Flits.  E=
ach flit is made up of 80 bits of information (in addition to some ECC data=
).  In full-width (L0) mode, flits are made up of four fits, each of which =
contains 20 bits of data (along with some additional ECC data).   In half-w=
idth (L0p) mode, the fits are only 10 bits, and therefore it takes twice as=
 many fits to transmit a flit.  When one talks about QPI speed (for example=
, 8.0 GT/s), the transfers here refer to fits.  Therefore, in L0, the syste=
m will transfer 1 flit at the rate of 1/4th the QPI speed.  One can calcula=
te the bandwidth of the link by taking: flits*80b/time.  Note that this is =
not the same as data bandwidth.  For example, when we are transferring a 64=
B cacheline across QPI, we will break it into 9 flits -- 1 with header info=
rmation and 8 with 64 bits of actual data and an additional 16 bits of othe=
r information.  To calculate data bandwidth, one should therefore do: data =
flits * 8B / time (for L0) or 4B instead of 8B for L0p.; Number of data fli=
ts transmitted over QPI.  Each flit contains 64b of data.  This includes bo=
th DRS and NCB data flits (coherent and non-coherent).  This can be used to=
 calculate the data bandwidth of the QPI link.  One can get a good picture =
of the QPI-link characteristics by evaluating the protocol flits, data flit=
s, and idle/null flits.  This does not include the header flits that go in =
data packets.",
         "UMask": "0x2",
         "Unit": "QPI LL"
     },
     {
         "BriefDescription": "Flits Transferred - Group 0; Non-Data protoco=
l Tx Flits",
-        "Counter": "0,1,2,3",
         "EventName": "UNC_Q_TxL_FLITS_G0.NON_DATA",
         "PerPkg": "1",
+        "PublicDescription": "Counts the number of flits transmitted acros=
s the QPI Link.  It includes filters for Idle, protocol, and Data Flits.  E=
ach flit is made up of 80 bits of information (in addition to some ECC data=
).  In full-width (L0) mode, flits are made up of four fits, each of which =
contains 20 bits of data (along with some additional ECC data).   In half-w=
idth (L0p) mode, the fits are only 10 bits, and therefore it takes twice as=
 many fits to transmit a flit.  When one talks about QPI speed (for example=
, 8.0 GT/s), the transfers here refer to fits.  Therefore, in L0, the syste=
m will transfer 1 flit at the rate of 1/4th the QPI speed.  One can calcula=
te the bandwidth of the link by taking: flits*80b/time.  Note that this is =
not the same as data bandwidth.  For example, when we are transferring a 64=
B cacheline across QPI, we will break it into 9 flits -- 1 with header info=
rmation and 8 with 64 bits of actual data and an additional 16 bits of othe=
r information.  To calculate data bandwidth, one should therefore do: data =
flits * 8B / time (for L0) or 4B instead of 8B for L0p.; Number of non-NULL=
 non-data flits transmitted across QPI.  This basically tracks the protocol=
 overhead on the QPI link.  One can get a good picture of the QPI-link char=
acteristics by evaluating the protocol flits, data flits, and idle/null fli=
ts.  This includes the header flits for data packets.",
         "UMask": "0x4",
         "Unit": "QPI LL"
     },
     {
-        "BriefDescription": "Number of non data (control) flits transmitte=
d . Derived from unc_q_txl_flits_g0.non_data",
-        "Counter": "0,1,2,3",
-        "EventName": "QPI_CTL_BANDWIDTH_TX",
-        "PerPkg": "1",
-        "ScaleUnit": "8Bytes",
-        "UMask": "0x4",
-        "Unit": "QPI LL"
-    },
-    {
-        "BriefDescription": "Flits Transferred - Group 1; SNP Flits",
-        "Counter": "0,1,2,3",
-        "EventName": "UNC_Q_TxL_FLITS_G1.SNP",
-        "ExtSel": "1",
+        "BriefDescription": "Flits Transferred - Group 1; DRS Flits (both =
Header and Data)",
+        "EventName": "UNC_Q_TxL_FLITS_G1.DRS",
         "PerPkg": "1",
-        "UMask": "0x1",
+        "PublicDescription": "Counts the number of flits transmitted acros=
s the QPI Link.  This is one of three groups that allow us to track flits. =
 It includes filters for SNP, HOM, and DRS message classes.  Each flit is m=
ade up of 80 bits of information (in addition to some ECC data).  In full-w=
idth (L0) mode, flits are made up of four fits, each of which contains 20 b=
its of data (along with some additional ECC data).   In half-width (L0p) mo=
de, the fits are only 10 bits, and therefore it takes twice as many fits to=
 transmit a flit.  When one talks about QPI speed (for example, 8.0 GT/s), =
the transfers here refer to fits.  Therefore, in L0, the system will transf=
er 1 flit at the rate of 1/4th the QPI speed.  One can calculate the bandwi=
dth of the link by taking: flits*80b/time.  Note that this is not the same =
as data bandwidth.  For example, when we are transferring a 64B cacheline a=
cross QPI, we will break it into 9 flits -- 1 with header information and 8=
 with 64 bits of actual data and an additional 16 bits of other information=
.  To calculate data bandwidth, one should therefore do: data flits * 8B / =
time.; Counts the total number of flits transmitted over QPI on the DRS (Da=
ta Response) channel.  DRS flits are used to transmit data with coherency."=
,
+        "UMask": "0x18",
         "Unit": "QPI LL"
     },
     {
-        "BriefDescription": "Flits Transferred - Group 1; HOM Request Flit=
s",
-        "Counter": "0,1,2,3",
-        "EventName": "UNC_Q_TxL_FLITS_G1.HOM_REQ",
-        "ExtSel": "1",
+        "BriefDescription": "Flits Transferred - Group 1; DRS Data Flits",
+        "EventName": "UNC_Q_TxL_FLITS_G1.DRS_DATA",
         "PerPkg": "1",
-        "UMask": "0x2",
+        "PublicDescription": "Counts the number of flits transmitted acros=
s the QPI Link.  This is one of three groups that allow us to track flits. =
 It includes filters for SNP, HOM, and DRS message classes.  Each flit is m=
ade up of 80 bits of information (in addition to some ECC data).  In full-w=
idth (L0) mode, flits are made up of four fits, each of which contains 20 b=
its of data (along with some additional ECC data).   In half-width (L0p) mo=
de, the fits are only 10 bits, and therefore it takes twice as many fits to=
 transmit a flit.  When one talks about QPI speed (for example, 8.0 GT/s), =
the transfers here refer to fits.  Therefore, in L0, the system will transf=
er 1 flit at the rate of 1/4th the QPI speed.  One can calculate the bandwi=
dth of the link by taking: flits*80b/time.  Note that this is not the same =
as data bandwidth.  For example, when we are transferring a 64B cacheline a=
cross QPI, we will break it into 9 flits -- 1 with header information and 8=
 with 64 bits of actual data and an additional 16 bits of other information=
.  To calculate data bandwidth, one should therefore do: data flits * 8B / =
time.; Counts the total number of data flits transmitted over QPI on the DR=
S (Data Response) channel.  DRS flits are used to transmit data with cohere=
ncy.  This does not count data flits transmitted over the NCB channel which=
 transmits non-coherent data.  This includes only the data flits (not the h=
eader).",
+        "UMask": "0x8",
         "Unit": "QPI LL"
     },
     {
-        "BriefDescription": "Flits Transferred - Group 1; HOM Non-Request =
Flits",
-        "Counter": "0,1,2,3",
-        "EventName": "UNC_Q_TxL_FLITS_G1.HOM_NONREQ",
-        "ExtSel": "1",
+        "BriefDescription": "Flits Transferred - Group 1; DRS Header Flits=
",
+        "EventName": "UNC_Q_TxL_FLITS_G1.DRS_NONDATA",
         "PerPkg": "1",
-        "UMask": "0x4",
+        "PublicDescription": "Counts the number of flits transmitted acros=
s the QPI Link.  This is one of three groups that allow us to track flits. =
 It includes filters for SNP, HOM, and DRS message classes.  Each flit is m=
ade up of 80 bits of information (in addition to some ECC data).  In full-w=
idth (L0) mode, flits are made up of four fits, each of which contains 20 b=
its of data (along with some additional ECC data).   In half-width (L0p) mo=
de, the fits are only 10 bits, and therefore it takes twice as many fits to=
 transmit a flit.  When one talks about QPI speed (for example, 8.0 GT/s), =
the transfers here refer to fits.  Therefore, in L0, the system will transf=
er 1 flit at the rate of 1/4th the QPI speed.  One can calculate the bandwi=
dth of the link by taking: flits*80b/time.  Note that this is not the same =
as data bandwidth.  For example, when we are transferring a 64B cacheline a=
cross QPI, we will break it into 9 flits -- 1 with header information and 8=
 with 64 bits of actual data and an additional 16 bits of other information=
.  To calculate data bandwidth, one should therefore do: data flits * 8B / =
time.; Counts the total number of protocol flits transmitted over QPI on th=
e DRS (Data Response) channel.  DRS flits are used to transmit data with co=
herency.  This does not count data flits transmitted over the NCB channel w=
hich transmits non-coherent data.  This includes only the header flits (not=
 the data).  This includes extended headers.",
+        "UMask": "0x10",
         "Unit": "QPI LL"
     },
     {
         "BriefDescription": "Flits Transferred - Group 1; HOM Flits",
-        "Counter": "0,1,2,3",
         "EventName": "UNC_Q_TxL_FLITS_G1.HOM",
-        "ExtSel": "1",
         "PerPkg": "1",
+        "PublicDescription": "Counts the number of flits transmitted acros=
s the QPI Link.  This is one of three groups that allow us to track flits. =
 It includes filters for SNP, HOM, and DRS message classes.  Each flit is m=
ade up of 80 bits of information (in addition to some ECC data).  In full-w=
idth (L0) mode, flits are made up of four fits, each of which contains 20 b=
its of data (along with some additional ECC data).   In half-width (L0p) mo=
de, the fits are only 10 bits, and therefore it takes twice as many fits to=
 transmit a flit.  When one talks about QPI speed (for example, 8.0 GT/s), =
the transfers here refer to fits.  Therefore, in L0, the system will transf=
er 1 flit at the rate of 1/4th the QPI speed.  One can calculate the bandwi=
dth of the link by taking: flits*80b/time.  Note that this is not the same =
as data bandwidth.  For example, when we are transferring a 64B cacheline a=
cross QPI, we will break it into 9 flits -- 1 with header information and 8=
 with 64 bits of actual data and an additional 16 bits of other information=
.  To calculate data bandwidth, one should therefore do: data flits * 8B / =
time.; Counts the number of flits transmitted over QPI on the home channel.=
",
         "UMask": "0x6",
         "Unit": "QPI LL"
     },
     {
-        "BriefDescription": "Flits Transferred - Group 1; DRS Data Flits",
-        "Counter": "0,1,2,3",
-        "EventName": "UNC_Q_TxL_FLITS_G1.DRS_DATA",
-        "ExtSel": "1",
-        "PerPkg": "1",
-        "UMask": "0x8",
-        "Unit": "QPI LL"
-    },
-    {
-        "BriefDescription": "Flits Transferred - Group 1; DRS Header Flits=
",
-        "Counter": "0,1,2,3",
-        "EventName": "UNC_Q_TxL_FLITS_G1.DRS_NONDATA",
-        "ExtSel": "1",
+        "BriefDescription": "Flits Transferred - Group 1; HOM Non-Request =
Flits",
+        "EventName": "UNC_Q_TxL_FLITS_G1.HOM_NONREQ",
         "PerPkg": "1",
-        "UMask": "0x10",
+        "PublicDescription": "Counts the number of flits transmitted acros=
s the QPI Link.  This is one of three groups that allow us to track flits. =
 It includes filters for SNP, HOM, and DRS message classes.  Each flit is m=
ade up of 80 bits of information (in addition to some ECC data).  In full-w=
idth (L0) mode, flits are made up of four fits, each of which contains 20 b=
its of data (along with some additional ECC data).   In half-width (L0p) mo=
de, the fits are only 10 bits, and therefore it takes twice as many fits to=
 transmit a flit.  When one talks about QPI speed (for example, 8.0 GT/s), =
the transfers here refer to fits.  Therefore, in L0, the system will transf=
er 1 flit at the rate of 1/4th the QPI speed.  One can calculate the bandwi=
dth of the link by taking: flits*80b/time.  Note that this is not the same =
as data bandwidth.  For example, when we are transferring a 64B cacheline a=
cross QPI, we will break it into 9 flits -- 1 with header information and 8=
 with 64 bits of actual data and an additional 16 bits of other information=
.  To calculate data bandwidth, one should therefore do: data flits * 8B / =
time.; Counts the number of non-request flits transmitted over QPI on the h=
ome channel.  These are most commonly snoop responses, and this event can b=
e used as a proxy for that.",
+        "UMask": "0x4",
         "Unit": "QPI LL"
     },
     {
-        "BriefDescription": "Flits Transferred - Group 1; DRS Flits (both =
Header and Data)",
-        "Counter": "0,1,2,3",
-        "EventName": "UNC_Q_TxL_FLITS_G1.DRS",
-        "ExtSel": "1",
+        "BriefDescription": "Flits Transferred - Group 1; HOM Request Flit=
s",
+        "EventName": "UNC_Q_TxL_FLITS_G1.HOM_REQ",
         "PerPkg": "1",
-        "UMask": "0x18",
+        "PublicDescription": "Counts the number of flits transmitted acros=
s the QPI Link.  This is one of three groups that allow us to track flits. =
 It includes filters for SNP, HOM, and DRS message classes.  Each flit is m=
ade up of 80 bits of information (in addition to some ECC data).  In full-w=
idth (L0) mode, flits are made up of four fits, each of which contains 20 b=
its of data (along with some additional ECC data).   In half-width (L0p) mo=
de, the fits are only 10 bits, and therefore it takes twice as many fits to=
 transmit a flit.  When one talks about QPI speed (for example, 8.0 GT/s), =
the transfers here refer to fits.  Therefore, in L0, the system will transf=
er 1 flit at the rate of 1/4th the QPI speed.  One can calculate the bandwi=
dth of the link by taking: flits*80b/time.  Note that this is not the same =
as data bandwidth.  For example, when we are transferring a 64B cacheline a=
cross QPI, we will break it into 9 flits -- 1 with header information and 8=
 with 64 bits of actual data and an additional 16 bits of other information=
.  To calculate data bandwidth, one should therefore do: data flits * 8B / =
time.; Counts the number of data request transmitted over QPI on the home c=
hannel.  This basically counts the number of remote memory requests transmi=
tted over QPI.  In conjunction with the local read count in the Home Agent,=
 one can calculate the number of LLC Misses.",
+        "UMask": "0x2",
         "Unit": "QPI LL"
     },
     {
-        "BriefDescription": "Flits Transferred - Group 2; Non-Data Respons=
e Tx Flits - AD",
-        "Counter": "0,1,2,3",
-        "EventCode": "0x1",
-        "EventName": "UNC_Q_TxL_FLITS_G2.NDR_AD",
-        "ExtSel": "1",
+        "BriefDescription": "Flits Transferred - Group 1; SNP Flits",
+        "EventName": "UNC_Q_TxL_FLITS_G1.SNP",
         "PerPkg": "1",
+        "PublicDescription": "Counts the number of flits transmitted acros=
s the QPI Link.  This is one of three groups that allow us to track flits. =
 It includes filters for SNP, HOM, and DRS message classes.  Each flit is m=
ade up of 80 bits of information (in addition to some ECC data).  In full-w=
idth (L0) mode, flits are made up of four fits, each of which contains 20 b=
its of data (along with some additional ECC data).   In half-width (L0p) mo=
de, the fits are only 10 bits, and therefore it takes twice as many fits to=
 transmit a flit.  When one talks about QPI speed (for example, 8.0 GT/s), =
the transfers here refer to fits.  Therefore, in L0, the system will transf=
er 1 flit at the rate of 1/4th the QPI speed.  One can calculate the bandwi=
dth of the link by taking: flits*80b/time.  Note that this is not the same =
as data bandwidth.  For example, when we are transferring a 64B cacheline a=
cross QPI, we will break it into 9 flits -- 1 with header information and 8=
 with 64 bits of actual data and an additional 16 bits of other information=
.  To calculate data bandwidth, one should therefore do: data flits * 8B / =
time.; Counts the number of snoop request flits transmitted over QPI.  Thes=
e requests are contained in the snoop channel.  This does not include snoop=
 responses, which are transmitted on the home channel.",
         "UMask": "0x1",
         "Unit": "QPI LL"
     },
     {
-        "BriefDescription": "Flits Transferred - Group 2; Non-Data Respons=
e Tx Flits - AK",
-        "Counter": "0,1,2,3",
+        "BriefDescription": "Flits Transferred - Group 2; Non-Coherent Byp=
ass Tx Flits",
         "EventCode": "0x1",
-        "EventName": "UNC_Q_TxL_FLITS_G2.NDR_AK",
-        "ExtSel": "1",
+        "EventName": "UNC_Q_TxL_FLITS_G2.NCB",
         "PerPkg": "1",
-        "UMask": "0x2",
+        "PublicDescription": "Counts the number of flits transmitted acros=
s the QPI Link.  This is one of three groups that allow us to track flits. =
 It includes filters for NDR, NCB, and NCS message classes.  Each flit is m=
ade up of 80 bits of information (in addition to some ECC data).  In full-w=
idth (L0) mode, flits are made up of four fits, each of which contains 20 b=
its of data (along with some additional ECC data).   In half-width (L0p) mo=
de, the fits are only 10 bits, and therefore it takes twice as many fits to=
 transmit a flit.  When one talks about QPI speed (for example, 8.0 GT/s), =
the transfers here refer to fits.  Therefore, in L0, the system will transf=
er 1 flit at the rate of 1/4th the QPI speed.  One can calculate the bandwi=
dth of the link by taking: flits*80b/time.  Note that this is not the same =
as data bandwidth.  For example, when we are transferring a 64B cacheline a=
cross QPI, we will break it into 9 flits -- 1 with header information and 8=
 with 64 bits of actual data and an additional 16 bits of other information=
.  To calculate data bandwidth, one should therefore do: data flits * 8B / =
time.; Number of Non-Coherent Bypass flits.  These packets are generally us=
ed to transmit non-coherent data across QPI.",
+        "UMask": "0xc",
         "Unit": "QPI LL"
     },
     {
         "BriefDescription": "Flits Transferred - Group 2; Non-Coherent dat=
a Tx Flits",
-        "Counter": "0,1,2,3",
         "EventCode": "0x1",
         "EventName": "UNC_Q_TxL_FLITS_G2.NCB_DATA",
-        "ExtSel": "1",
         "PerPkg": "1",
+        "PublicDescription": "Counts the number of flits transmitted acros=
s the QPI Link.  This is one of three groups that allow us to track flits. =
 It includes filters for NDR, NCB, and NCS message classes.  Each flit is m=
ade up of 80 bits of information (in addition to some ECC data).  In full-w=
idth (L0) mode, flits are made up of four fits, each of which contains 20 b=
its of data (along with some additional ECC data).   In half-width (L0p) mo=
de, the fits are only 10 bits, and therefore it takes twice as many fits to=
 transmit a flit.  When one talks about QPI speed (for example, 8.0 GT/s), =
the transfers here refer to fits.  Therefore, in L0, the system will transf=
er 1 flit at the rate of 1/4th the QPI speed.  One can calculate the bandwi=
dth of the link by taking: flits*80b/time.  Note that this is not the same =
as data bandwidth.  For example, when we are transferring a 64B cacheline a=
cross QPI, we will break it into 9 flits -- 1 with header information and 8=
 with 64 bits of actual data and an additional 16 bits of other information=
.  To calculate data bandwidth, one should therefore do: data flits * 8B / =
time.; Number of Non-Coherent Bypass data flits.  These flits are generally=
 used to transmit non-coherent data across QPI.  This does not include a co=
unt of the DRS (coherent) data flits.  This only counts the data flits, not=
 the NCB headers.",
         "UMask": "0x4",
         "Unit": "QPI LL"
     },
     {
         "BriefDescription": "Flits Transferred - Group 2; Non-Coherent non=
-data Tx Flits",
-        "Counter": "0,1,2,3",
         "EventCode": "0x1",
         "EventName": "UNC_Q_TxL_FLITS_G2.NCB_NONDATA",
-        "ExtSel": "1",
         "PerPkg": "1",
+        "PublicDescription": "Counts the number of flits transmitted acros=
s the QPI Link.  This is one of three groups that allow us to track flits. =
 It includes filters for NDR, NCB, and NCS message classes.  Each flit is m=
ade up of 80 bits of information (in addition to some ECC data).  In full-w=
idth (L0) mode, flits are made up of four fits, each of which contains 20 b=
its of data (along with some additional ECC data).   In half-width (L0p) mo=
de, the fits are only 10 bits, and therefore it takes twice as many fits to=
 transmit a flit.  When one talks about QPI speed (for example, 8.0 GT/s), =
the transfers here refer to fits.  Therefore, in L0, the system will transf=
er 1 flit at the rate of 1/4th the QPI speed.  One can calculate the bandwi=
dth of the link by taking: flits*80b/time.  Note that this is not the same =
as data bandwidth.  For example, when we are transferring a 64B cacheline a=
cross QPI, we will break it into 9 flits -- 1 with header information and 8=
 with 64 bits of actual data and an additional 16 bits of other information=
.  To calculate data bandwidth, one should therefore do: data flits * 8B / =
time.; Number of Non-Coherent Bypass non-data flits.  These packets are gen=
erally used to transmit non-coherent data across QPI, and the flits counted=
 here are for headers and other non-data flits.  This includes extended hea=
ders.",
         "UMask": "0x8",
         "Unit": "QPI LL"
     },
     {
-        "BriefDescription": "Flits Transferred - Group 2; Non-Coherent Byp=
ass Tx Flits",
-        "Counter": "0,1,2,3",
+        "BriefDescription": "Flits Transferred - Group 2; Non-Coherent sta=
ndard Tx Flits",
         "EventCode": "0x1",
-        "EventName": "UNC_Q_TxL_FLITS_G2.NCB",
-        "ExtSel": "1",
+        "EventName": "UNC_Q_TxL_FLITS_G2.NCS",
         "PerPkg": "1",
-        "UMask": "0xC",
+        "PublicDescription": "Counts the number of flits transmitted acros=
s the QPI Link.  This is one of three groups that allow us to track flits. =
 It includes filters for NDR, NCB, and NCS message classes.  Each flit is m=
ade up of 80 bits of information (in addition to some ECC data).  In full-w=
idth (L0) mode, flits are made up of four fits, each of which contains 20 b=
its of data (along with some additional ECC data).   In half-width (L0p) mo=
de, the fits are only 10 bits, and therefore it takes twice as many fits to=
 transmit a flit.  When one talks about QPI speed (for example, 8.0 GT/s), =
the transfers here refer to fits.  Therefore, in L0, the system will transf=
er 1 flit at the rate of 1/4th the QPI speed.  One can calculate the bandwi=
dth of the link by taking: flits*80b/time.  Note that this is not the same =
as data bandwidth.  For example, when we are transferring a 64B cacheline a=
cross QPI, we will break it into 9 flits -- 1 with header information and 8=
 with 64 bits of actual data and an additional 16 bits of other information=
.  To calculate data bandwidth, one should therefore do: data flits * 8B / =
time.; Number of NCS (non-coherent standard) flits transmitted over QPI.   =
 This includes extended headers.",
+        "UMask": "0x10",
         "Unit": "QPI LL"
     },
     {
-        "BriefDescription": "Flits Transferred - Group 2; Non-Coherent sta=
ndard Tx Flits",
-        "Counter": "0,1,2,3",
+        "BriefDescription": "Flits Transferred - Group 2; Non-Data Respons=
e Tx Flits - AD",
         "EventCode": "0x1",
-        "EventName": "UNC_Q_TxL_FLITS_G2.NCS",
-        "ExtSel": "1",
+        "EventName": "UNC_Q_TxL_FLITS_G2.NDR_AD",
         "PerPkg": "1",
-        "UMask": "0x10",
+        "PublicDescription": "Counts the number of flits transmitted acros=
s the QPI Link.  This is one of three groups that allow us to track flits. =
 It includes filters for NDR, NCB, and NCS message classes.  Each flit is m=
ade up of 80 bits of information (in addition to some ECC data).  In full-w=
idth (L0) mode, flits are made up of four fits, each of which contains 20 b=
its of data (along with some additional ECC data).   In half-width (L0p) mo=
de, the fits are only 10 bits, and therefore it takes twice as many fits to=
 transmit a flit.  When one talks about QPI speed (for example, 8.0 GT/s), =
the transfers here refer to fits.  Therefore, in L0, the system will transf=
er 1 flit at the rate of 1/4th the QPI speed.  One can calculate the bandwi=
dth of the link by taking: flits*80b/time.  Note that this is not the same =
as data bandwidth.  For example, when we are transferring a 64B cacheline a=
cross QPI, we will break it into 9 flits -- 1 with header information and 8=
 with 64 bits of actual data and an additional 16 bits of other information=
.  To calculate data bandwidth, one should therefore do: data flits * 8B / =
time.; Counts the total number of flits transmitted over the NDR (Non-Data =
Response) channel.  This channel is used to send a variety of protocol flit=
s including grants and completions.  This is only for NDR packets to the lo=
cal socket which use the AK ring.",
+        "UMask": "0x1",
+        "Unit": "QPI LL"
+    },
+    {
+        "BriefDescription": "Flits Transferred - Group 2; Non-Data Respons=
e Tx Flits - AK",
+        "EventCode": "0x1",
+        "EventName": "UNC_Q_TxL_FLITS_G2.NDR_AK",
+        "PerPkg": "1",
+        "PublicDescription": "Counts the number of flits transmitted acros=
s the QPI Link.  This is one of three groups that allow us to track flits. =
 It includes filters for NDR, NCB, and NCS message classes.  Each flit is m=
ade up of 80 bits of information (in addition to some ECC data).  In full-w=
idth (L0) mode, flits are made up of four fits, each of which contains 20 b=
its of data (along with some additional ECC data).   In half-width (L0p) mo=
de, the fits are only 10 bits, and therefore it takes twice as many fits to=
 transmit a flit.  When one talks about QPI speed (for example, 8.0 GT/s), =
the transfers here refer to fits.  Therefore, in L0, the system will transf=
er 1 flit at the rate of 1/4th the QPI speed.  One can calculate the bandwi=
dth of the link by taking: flits*80b/time.  Note that this is not the same =
as data bandwidth.  For example, when we are transferring a 64B cacheline a=
cross QPI, we will break it into 9 flits -- 1 with header information and 8=
 with 64 bits of actual data and an additional 16 bits of other information=
.  To calculate data bandwidth, one should therefore do: data flits * 8B / =
time.; Counts the total number of flits transmitted over the NDR (Non-Data =
Response) channel.  This channel is used to send a variety of protocol flit=
s including grants and completions.  This is only for NDR packets destined =
for Route-thru to a remote socket.",
+        "UMask": "0x2",
         "Unit": "QPI LL"
     },
     {
         "BriefDescription": "Tx Flit Buffer Allocations",
-        "Counter": "0,1,2,3",
         "EventCode": "0x4",
         "EventName": "UNC_Q_TxL_INSERTS",
         "PerPkg": "1",
+        "PublicDescription": "Number of allocations into the QPI Tx Flit B=
uffer.  Generally, when data is transmitted across QPI, it will bypass the =
TxQ and pass directly to the link.  However, the TxQ will be used with L0p =
and when LLR occurs, increasing latency to transfer out to the link.  This =
event can be used in conjunction with the Flit Buffer Occupancy event in or=
der to calculate the average flit buffer lifetime.",
         "Unit": "QPI LL"
     },
     {
         "BriefDescription": "Tx Flit Buffer Occupancy",
-        "Counter": "0,1,2,3",
         "EventCode": "0x7",
         "EventName": "UNC_Q_TxL_OCCUPANCY",
         "PerPkg": "1",
+        "PublicDescription": "Accumulates the number of flits in the TxQ. =
 Generally, when data is transmitted across QPI, it will bypass the TxQ and=
 pass directly to the link.  However, the TxQ will be used with L0p and whe=
n LLR occurs, increasing latency to transfer out to the link. This can be u=
sed with the cycles not empty event to track average occupancy, or the allo=
cations event to track average lifetime in the TxQ.",
         "Unit": "QPI LL"
     },
     {
         "BriefDescription": "R3QPI Egress Credit Occupancy - HOM; for VN0"=
,
-        "Counter": "0,1,2,3",
         "EventCode": "0x26",
         "EventName": "UNC_Q_TxR_AD_HOM_CREDIT_ACQUIRED.VN0",
-        "ExtSel": "1",
         "PerPkg": "1",
+        "PublicDescription": "Number of link layer credits into the R3 (fo=
r transactions across the BGF) acquired each cycle. Flow Control FIFO for H=
ome messages on AD.",
         "UMask": "0x1",
         "Unit": "QPI LL"
     },
     {
         "BriefDescription": "R3QPI Egress Credit Occupancy - HOM; for VN1"=
,
-        "Counter": "0,1,2,3",
         "EventCode": "0x26",
         "EventName": "UNC_Q_TxR_AD_HOM_CREDIT_ACQUIRED.VN1",
-        "ExtSel": "1",
         "PerPkg": "1",
+        "PublicDescription": "Number of link layer credits into the R3 (fo=
r transactions across the BGF) acquired each cycle. Flow Control FIFO for H=
ome messages on AD.",
         "UMask": "0x2",
         "Unit": "QPI LL"
     },
     {
         "BriefDescription": "R3QPI Egress Credit Occupancy - AD HOM; for V=
N0",
-        "Counter": "0,1,2,3",
         "EventCode": "0x22",
         "EventName": "UNC_Q_TxR_AD_HOM_CREDIT_OCCUPANCY.VN0",
-        "ExtSel": "1",
         "PerPkg": "1",
+        "PublicDescription": "Occupancy event that tracks the number of li=
nk layer credits into the R3 (for transactions across the BGF) available in=
 each cycle.  Flow Control FIFO for HOM messages on AD.",
         "UMask": "0x1",
         "Unit": "QPI LL"
     },
     {
         "BriefDescription": "R3QPI Egress Credit Occupancy - AD HOM; for V=
N1",
-        "Counter": "0,1,2,3",
         "EventCode": "0x22",
         "EventName": "UNC_Q_TxR_AD_HOM_CREDIT_OCCUPANCY.VN1",
-        "ExtSel": "1",
         "PerPkg": "1",
+        "PublicDescription": "Occupancy event that tracks the number of li=
nk layer credits into the R3 (for transactions across the BGF) available in=
 each cycle.  Flow Control FIFO for HOM messages on AD.",
         "UMask": "0x2",
         "Unit": "QPI LL"
     },
     {
         "BriefDescription": "R3QPI Egress Credit Occupancy - AD NDR; for V=
N0",
-        "Counter": "0,1,2,3",
         "EventCode": "0x28",
         "EventName": "UNC_Q_TxR_AD_NDR_CREDIT_ACQUIRED.VN0",
-        "ExtSel": "1",
         "PerPkg": "1",
+        "PublicDescription": "Number of link layer credits into the R3 (fo=
r transactions across the BGF) acquired each cycle.  Flow Control FIFO for =
NDR messages on AD.",
         "UMask": "0x1",
         "Unit": "QPI LL"
     },
     {
         "BriefDescription": "R3QPI Egress Credit Occupancy - AD NDR; for V=
N1",
-        "Counter": "0,1,2,3",
         "EventCode": "0x28",
         "EventName": "UNC_Q_TxR_AD_NDR_CREDIT_ACQUIRED.VN1",
-        "ExtSel": "1",
         "PerPkg": "1",
+        "PublicDescription": "Number of link layer credits into the R3 (fo=
r transactions across the BGF) acquired each cycle.  Flow Control FIFO for =
NDR messages on AD.",
         "UMask": "0x2",
         "Unit": "QPI LL"
     },
     {
         "BriefDescription": "R3QPI Egress Credit Occupancy - AD NDR; for V=
N0",
-        "Counter": "0,1,2,3",
         "EventCode": "0x24",
         "EventName": "UNC_Q_TxR_AD_NDR_CREDIT_OCCUPANCY.VN0",
-        "ExtSel": "1",
         "PerPkg": "1",
+        "PublicDescription": "Occupancy event that tracks the number of li=
nk layer credits into the R3 (for transactions across the BGF) available in=
 each cycle. Flow Control FIFO  for NDR messages on AD.",
         "UMask": "0x1",
         "Unit": "QPI LL"
     },
     {
         "BriefDescription": "R3QPI Egress Credit Occupancy - AD NDR; for V=
N1",
-        "Counter": "0,1,2,3",
         "EventCode": "0x24",
         "EventName": "UNC_Q_TxR_AD_NDR_CREDIT_OCCUPANCY.VN1",
-        "ExtSel": "1",
         "PerPkg": "1",
+        "PublicDescription": "Occupancy event that tracks the number of li=
nk layer credits into the R3 (for transactions across the BGF) available in=
 each cycle. Flow Control FIFO  for NDR messages on AD.",
         "UMask": "0x2",
         "Unit": "QPI LL"
     },
     {
         "BriefDescription": "R3QPI Egress Credit Occupancy - SNP; for VN0"=
,
-        "Counter": "0,1,2,3",
         "EventCode": "0x27",
         "EventName": "UNC_Q_TxR_AD_SNP_CREDIT_ACQUIRED.VN0",
-        "ExtSel": "1",
         "PerPkg": "1",
+        "PublicDescription": "Number of link layer credits into the R3 (fo=
r transactions across the BGF) acquired each cycle.  Flow Control FIFO for =
Snoop messages on AD.",
         "UMask": "0x1",
         "Unit": "QPI LL"
     },
     {
         "BriefDescription": "R3QPI Egress Credit Occupancy - SNP; for VN1"=
,
-        "Counter": "0,1,2,3",
         "EventCode": "0x27",
         "EventName": "UNC_Q_TxR_AD_SNP_CREDIT_ACQUIRED.VN1",
-        "ExtSel": "1",
         "PerPkg": "1",
+        "PublicDescription": "Number of link layer credits into the R3 (fo=
r transactions across the BGF) acquired each cycle.  Flow Control FIFO for =
Snoop messages on AD.",
         "UMask": "0x2",
         "Unit": "QPI LL"
     },
     {
         "BriefDescription": "R3QPI Egress Credit Occupancy - AD SNP; for V=
N0",
-        "Counter": "0,1,2,3",
         "EventCode": "0x23",
         "EventName": "UNC_Q_TxR_AD_SNP_CREDIT_OCCUPANCY.VN0",
-        "ExtSel": "1",
         "PerPkg": "1",
+        "PublicDescription": "Occupancy event that tracks the number of li=
nk layer credits into the R3 (for transactions across the BGF) available in=
 each cycle.  Flow Control FIFO for Snoop messages on AD.",
         "UMask": "0x1",
         "Unit": "QPI LL"
     },
     {
         "BriefDescription": "R3QPI Egress Credit Occupancy - AD SNP; for V=
N1",
-        "Counter": "0,1,2,3",
         "EventCode": "0x23",
         "EventName": "UNC_Q_TxR_AD_SNP_CREDIT_OCCUPANCY.VN1",
-        "ExtSel": "1",
         "PerPkg": "1",
+        "PublicDescription": "Occupancy event that tracks the number of li=
nk layer credits into the R3 (for transactions across the BGF) available in=
 each cycle.  Flow Control FIFO for Snoop messages on AD.",
         "UMask": "0x2",
         "Unit": "QPI LL"
     },
     {
         "BriefDescription": "R3QPI Egress Credit Occupancy - AK NDR",
-        "Counter": "0,1,2,3",
         "EventCode": "0x29",
         "EventName": "UNC_Q_TxR_AK_NDR_CREDIT_ACQUIRED",
-        "ExtSel": "1",
         "PerPkg": "1",
+        "PublicDescription": "Number of credits into the R3 (for transacti=
ons across the BGF) acquired each cycle. Local NDR message class to AK Egre=
ss.",
         "Unit": "QPI LL"
     },
     {
         "BriefDescription": "R3QPI Egress Credit Occupancy - AK NDR",
-        "Counter": "0,1,2,3",
         "EventCode": "0x25",
         "EventName": "UNC_Q_TxR_AK_NDR_CREDIT_OCCUPANCY",
-        "ExtSel": "1",
         "PerPkg": "1",
+        "PublicDescription": "Occupancy event that tracks the number of cr=
edits into the R3 (for transactions across the BGF) available in each cycle=
.  Local NDR message class to AK Egress.",
         "Unit": "QPI LL"
     },
     {
         "BriefDescription": "R3QPI Egress Credit Occupancy - DRS; for VN0"=
,
-        "Counter": "0,1,2,3",
         "EventCode": "0x2A",
         "EventName": "UNC_Q_TxR_BL_DRS_CREDIT_ACQUIRED.VN0",
-        "ExtSel": "1",
         "PerPkg": "1",
+        "PublicDescription": "Number of credits into the R3 (for transacti=
ons across the BGF) acquired each cycle. DRS message class to BL Egress.",
         "UMask": "0x1",
         "Unit": "QPI LL"
     },
     {
         "BriefDescription": "R3QPI Egress Credit Occupancy - DRS; for VN1"=
,
-        "Counter": "0,1,2,3",
         "EventCode": "0x2A",
         "EventName": "UNC_Q_TxR_BL_DRS_CREDIT_ACQUIRED.VN1",
-        "ExtSel": "1",
         "PerPkg": "1",
+        "PublicDescription": "Number of credits into the R3 (for transacti=
ons across the BGF) acquired each cycle. DRS message class to BL Egress.",
         "UMask": "0x2",
         "Unit": "QPI LL"
     },
     {
         "BriefDescription": "R3QPI Egress Credit Occupancy - DRS; for Shar=
ed VN",
-        "Counter": "0,1,2,3",
         "EventCode": "0x2A",
         "EventName": "UNC_Q_TxR_BL_DRS_CREDIT_ACQUIRED.VN_SHR",
-        "ExtSel": "1",
         "PerPkg": "1",
+        "PublicDescription": "Number of credits into the R3 (for transacti=
ons across the BGF) acquired each cycle. DRS message class to BL Egress.",
         "UMask": "0x4",
         "Unit": "QPI LL"
     },
     {
         "BriefDescription": "R3QPI Egress Credit Occupancy - BL DRS; for V=
N0",
-        "Counter": "0,1,2,3",
         "EventCode": "0x1F",
         "EventName": "UNC_Q_TxR_BL_DRS_CREDIT_OCCUPANCY.VN0",
-        "ExtSel": "1",
         "PerPkg": "1",
+        "PublicDescription": "Occupancy event that tracks the number of cr=
edits into the R3 (for transactions across the BGF) available in each cycle=
.  DRS message class to BL Egress.",
         "UMask": "0x1",
         "Unit": "QPI LL"
     },
     {
         "BriefDescription": "R3QPI Egress Credit Occupancy - BL DRS; for V=
N1",
-        "Counter": "0,1,2,3",
         "EventCode": "0x1F",
         "EventName": "UNC_Q_TxR_BL_DRS_CREDIT_OCCUPANCY.VN1",
-        "ExtSel": "1",
         "PerPkg": "1",
+        "PublicDescription": "Occupancy event that tracks the number of cr=
edits into the R3 (for transactions across the BGF) available in each cycle=
.  DRS message class to BL Egress.",
         "UMask": "0x2",
         "Unit": "QPI LL"
     },
     {
         "BriefDescription": "R3QPI Egress Credit Occupancy - BL DRS; for S=
hared VN",
-        "Counter": "0,1,2,3",
         "EventCode": "0x1F",
         "EventName": "UNC_Q_TxR_BL_DRS_CREDIT_OCCUPANCY.VN_SHR",
-        "ExtSel": "1",
         "PerPkg": "1",
+        "PublicDescription": "Occupancy event that tracks the number of cr=
edits into the R3 (for transactions across the BGF) available in each cycle=
.  DRS message class to BL Egress.",
         "UMask": "0x4",
         "Unit": "QPI LL"
     },
     {
         "BriefDescription": "R3QPI Egress Credit Occupancy - NCB; for VN0"=
,
-        "Counter": "0,1,2,3",
         "EventCode": "0x2B",
         "EventName": "UNC_Q_TxR_BL_NCB_CREDIT_ACQUIRED.VN0",
-        "ExtSel": "1",
         "PerPkg": "1",
+        "PublicDescription": "Number of credits into the R3 (for transacti=
ons across the BGF) acquired each cycle. NCB message class to BL Egress.",
         "UMask": "0x1",
         "Unit": "QPI LL"
     },
     {
         "BriefDescription": "R3QPI Egress Credit Occupancy - NCB; for VN1"=
,
-        "Counter": "0,1,2,3",
         "EventCode": "0x2B",
         "EventName": "UNC_Q_TxR_BL_NCB_CREDIT_ACQUIRED.VN1",
-        "ExtSel": "1",
         "PerPkg": "1",
+        "PublicDescription": "Number of credits into the R3 (for transacti=
ons across the BGF) acquired each cycle. NCB message class to BL Egress.",
         "UMask": "0x2",
         "Unit": "QPI LL"
     },
     {
         "BriefDescription": "R3QPI Egress Credit Occupancy - BL NCB; for V=
N0",
-        "Counter": "0,1,2,3",
         "EventCode": "0x20",
         "EventName": "UNC_Q_TxR_BL_NCB_CREDIT_OCCUPANCY.VN0",
-        "ExtSel": "1",
         "PerPkg": "1",
+        "PublicDescription": "Occupancy event that tracks the number of cr=
edits into the R3 (for transactions across the BGF) available in each cycle=
.  NCB message class to BL Egress.",
         "UMask": "0x1",
         "Unit": "QPI LL"
     },
     {
         "BriefDescription": "R3QPI Egress Credit Occupancy - BL NCB; for V=
N1",
-        "Counter": "0,1,2,3",
         "EventCode": "0x20",
         "EventName": "UNC_Q_TxR_BL_NCB_CREDIT_OCCUPANCY.VN1",
-        "ExtSel": "1",
         "PerPkg": "1",
+        "PublicDescription": "Occupancy event that tracks the number of cr=
edits into the R3 (for transactions across the BGF) available in each cycle=
.  NCB message class to BL Egress.",
         "UMask": "0x2",
         "Unit": "QPI LL"
     },
     {
         "BriefDescription": "R3QPI Egress Credit Occupancy - NCS; for VN0"=
,
-        "Counter": "0,1,2,3",
         "EventCode": "0x2C",
         "EventName": "UNC_Q_TxR_BL_NCS_CREDIT_ACQUIRED.VN0",
-        "ExtSel": "1",
         "PerPkg": "1",
+        "PublicDescription": "Number of credits into the R3 (for transacti=
ons across the BGF) acquired each cycle. NCS message class to BL Egress.",
         "UMask": "0x1",
         "Unit": "QPI LL"
     },
     {
         "BriefDescription": "R3QPI Egress Credit Occupancy - NCS; for VN1"=
,
-        "Counter": "0,1,2,3",
         "EventCode": "0x2C",
         "EventName": "UNC_Q_TxR_BL_NCS_CREDIT_ACQUIRED.VN1",
-        "ExtSel": "1",
         "PerPkg": "1",
+        "PublicDescription": "Number of credits into the R3 (for transacti=
ons across the BGF) acquired each cycle. NCS message class to BL Egress.",
         "UMask": "0x2",
         "Unit": "QPI LL"
     },
     {
         "BriefDescription": "R3QPI Egress Credit Occupancy - BL NCS; for V=
N0",
-        "Counter": "0,1,2,3",
         "EventCode": "0x21",
         "EventName": "UNC_Q_TxR_BL_NCS_CREDIT_OCCUPANCY.VN0",
-        "ExtSel": "1",
         "PerPkg": "1",
+        "PublicDescription": "Occupancy event that tracks the number of cr=
edits into the R3 (for transactions across the BGF) available in each cycle=
.  NCS message class to BL Egress.",
         "UMask": "0x1",
         "Unit": "QPI LL"
     },
     {
         "BriefDescription": "R3QPI Egress Credit Occupancy - BL NCS; for V=
N1",
-        "Counter": "0,1,2,3",
         "EventCode": "0x21",
         "EventName": "UNC_Q_TxR_BL_NCS_CREDIT_OCCUPANCY.VN1",
-        "ExtSel": "1",
         "PerPkg": "1",
+        "PublicDescription": "Occupancy event that tracks the number of cr=
edits into the R3 (for transactions across the BGF) available in each cycle=
.  NCS message class to BL Egress.",
         "UMask": "0x2",
         "Unit": "QPI LL"
     },
     {
         "BriefDescription": "VNA Credits Returned",
-        "Counter": "0,1,2,3",
         "EventCode": "0x1C",
         "EventName": "UNC_Q_VNA_CREDIT_RETURNS",
-        "ExtSel": "1",
         "PerPkg": "1",
+        "PublicDescription": "Number of VNA credits returned.",
         "Unit": "QPI LL"
     },
     {
         "BriefDescription": "VNA Credits Pending Return - Occupancy",
-        "Counter": "0,1,2,3",
         "EventCode": "0x1B",
         "EventName": "UNC_Q_VNA_CREDIT_RETURN_OCCUPANCY",
-        "ExtSel": "1",
         "PerPkg": "1",
+        "PublicDescription": "Number of VNA credits in the Rx side that ar=
e waitng to be returned back across the link.",
         "Unit": "QPI LL"
     }
 ]
diff --git a/tools/perf/pmu-events/arch/x86/haswellx/uncore-memory.json b/t=
ools/perf/pmu-events/arch/x86/haswellx/uncore-memory.json
index c003daa9ed8c..c005f5115722 100644
--- a/tools/perf/pmu-events/arch/x86/haswellx/uncore-memory.json
+++ b/tools/perf/pmu-events/arch/x86/haswellx/uncore-memory.json
@@ -1,34 +1,53 @@
 [
     {
-        "BriefDescription": "DRAM Activate Count; Activate due to Read",
-        "Counter": "0,1,2,3",
-        "EventCode": "0x1",
-        "EventName": "UNC_M_ACT_COUNT.RD",
+        "BriefDescription": "read requests to memory controller. Derived f=
rom unc_m_cas_count.rd",
+        "EventCode": "0x4",
+        "EventName": "LLC_MISSES.MEM_READ",
         "PerPkg": "1",
-        "UMask": "0x1",
+        "PublicDescription": "DRAM RD_CAS and WR_CAS Commands; Counts the =
total number of DRAM Read CAS commands issued on this channel (including un=
derfills).",
+        "ScaleUnit": "64Bytes",
+        "UMask": "0x3",
         "Unit": "iMC"
     },
     {
-        "BriefDescription": "DRAM Activate Count; Activate due to Write",
-        "Counter": "0,1,2,3",
-        "EventCode": "0x1",
-        "EventName": "UNC_M_ACT_COUNT.WR",
+        "BriefDescription": "write requests to memory controller. Derived =
from unc_m_cas_count.wr",
+        "EventCode": "0x4",
+        "EventName": "LLC_MISSES.MEM_WRITE",
         "PerPkg": "1",
-        "UMask": "0x2",
+        "PublicDescription": "DRAM RD_CAS and WR_CAS Commands; Counts the =
total number of DRAM Write CAS commands issued on this channel.",
+        "ScaleUnit": "64Bytes",
+        "UMask": "0xc",
         "Unit": "iMC"
     },
     {
         "BriefDescription": "DRAM Activate Count; Activate due to Write",
-        "Counter": "0,1,2,3",
         "EventCode": "0x1",
         "EventName": "UNC_M_ACT_COUNT.BYP",
         "PerPkg": "1",
+        "PublicDescription": "Counts the number of DRAM Activate commands =
sent on this channel.  Activate commands are issued to open up a page on th=
e DRAM devices so that it can be read or written to with a CAS.  One can ca=
lculate the number of Page Misses by subtracting the number of Page Miss pr=
echarges from the number of Activates.",
         "UMask": "0x8",
         "Unit": "iMC"
     },
+    {
+        "BriefDescription": "DRAM Activate Count; Activate due to Read",
+        "EventCode": "0x1",
+        "EventName": "UNC_M_ACT_COUNT.RD",
+        "PerPkg": "1",
+        "PublicDescription": "Counts the number of DRAM Activate commands =
sent on this channel.  Activate commands are issued to open up a page on th=
e DRAM devices so that it can be read or written to with a CAS.  One can ca=
lculate the number of Page Misses by subtracting the number of Page Miss pr=
echarges from the number of Activates.",
+        "UMask": "0x1",
+        "Unit": "iMC"
+    },
+    {
+        "BriefDescription": "DRAM Activate Count; Activate due to Write",
+        "EventCode": "0x1",
+        "EventName": "UNC_M_ACT_COUNT.WR",
+        "PerPkg": "1",
+        "PublicDescription": "Counts the number of DRAM Activate commands =
sent on this channel.  Activate commands are issued to open up a page on th=
e DRAM devices so that it can be read or written to with a CAS.  One can ca=
lculate the number of Page Misses by subtracting the number of Page Miss pr=
echarges from the number of Activates.",
+        "UMask": "0x2",
+        "Unit": "iMC"
+    },
     {
         "BriefDescription": "ACT command issued by 2 cycle bypass",
-        "Counter": "0,1,2,3",
         "EventCode": "0xA1",
         "EventName": "UNC_M_BYP_CMDS.ACT",
         "PerPkg": "1",
@@ -37,7 +56,6 @@
     },
     {
         "BriefDescription": "CAS command issued by 2 cycle bypass",
-        "Counter": "0,1,2,3",
         "EventCode": "0xA1",
         "EventName": "UNC_M_BYP_CMDS.CAS",
         "PerPkg": "1",
@@ -46,7 +64,6 @@
     },
     {
         "BriefDescription": "PRE command issued by 2 cycle bypass",
-        "Counter": "0,1,2,3",
         "EventCode": "0xA1",
         "EventName": "UNC_M_BYP_CMDS.PRE",
         "PerPkg": "1",
@@ -54,282 +71,264 @@
         "Unit": "iMC"
     },
     {
-        "BriefDescription": "DRAM RD_CAS and WR_CAS Commands.; All DRAM RD=
_CAS (w/ and w/out auto-pre)",
-        "Counter": "0,1,2,3",
-        "EventCode": "0x4",
-        "EventName": "UNC_M_CAS_COUNT.RD_REG",
-        "PerPkg": "1",
-        "UMask": "0x1",
-        "Unit": "iMC"
-    },
-    {
-        "BriefDescription": "DRAM RD_CAS and WR_CAS Commands.; Underfill R=
ead Issued",
-        "Counter": "0,1,2,3",
+        "BriefDescription": "DRAM RD_CAS and WR_CAS Commands.; All DRAM WR=
_CAS (w/ and w/out auto-pre)",
         "EventCode": "0x4",
-        "EventName": "UNC_M_CAS_COUNT.RD_UNDERFILL",
+        "EventName": "UNC_M_CAS_COUNT.ALL",
         "PerPkg": "1",
-        "UMask": "0x2",
+        "PublicDescription": "DRAM RD_CAS and WR_CAS Commands; Counts the =
total number of DRAM CAS commands issued on this channel.",
+        "UMask": "0xf",
         "Unit": "iMC"
     },
     {
         "BriefDescription": "DRAM RD_CAS and WR_CAS Commands.; All DRAM Re=
ads (RD_CAS + Underfills)",
-        "Counter": "0,1,2,3",
         "EventCode": "0x4",
         "EventName": "UNC_M_CAS_COUNT.RD",
         "PerPkg": "1",
+        "PublicDescription": "DRAM RD_CAS and WR_CAS Commands; Counts the =
total number of DRAM Read CAS commands issued on this channel (including un=
derfills).",
         "UMask": "0x3",
         "Unit": "iMC"
     },
     {
-        "BriefDescription": "read requests to memory controller. Derived f=
rom unc_m_cas_count.rd",
-        "Counter": "0,1,2,3",
+        "BriefDescription": "DRAM RD_CAS and WR_CAS Commands.; All DRAM RD=
_CAS (w/ and w/out auto-pre)",
         "EventCode": "0x4",
-        "EventName": "LLC_MISSES.MEM_READ",
+        "EventName": "UNC_M_CAS_COUNT.RD_REG",
         "PerPkg": "1",
-        "ScaleUnit": "64Bytes",
-        "UMask": "0x3",
+        "PublicDescription": "DRAM RD_CAS and WR_CAS Commands; Counts the =
total number or DRAM Read CAS commands issued on this channel.  This includ=
es both regular RD CAS commands as well as those with implicit Precharge.  =
AutoPre is only used in systems that are using closed page policy.  We do n=
ot filter based on major mode, as RD_CAS is not issued during WMM (with the=
 exception of underfills).",
+        "UMask": "0x1",
         "Unit": "iMC"
     },
     {
-        "BriefDescription": "DRAM RD_CAS and WR_CAS Commands.; DRAM WR_CAS=
 (w/ and w/out auto-pre) in Write Major Mode",
-        "Counter": "0,1,2,3",
+        "BriefDescription": "DRAM RD_CAS and WR_CAS Commands.; Read CAS is=
sued in RMM",
         "EventCode": "0x4",
-        "EventName": "UNC_M_CAS_COUNT.WR_WMM",
+        "EventName": "UNC_M_CAS_COUNT.RD_RMM",
         "PerPkg": "1",
-        "UMask": "0x4",
+        "UMask": "0x20",
         "Unit": "iMC"
     },
     {
-        "BriefDescription": "DRAM RD_CAS and WR_CAS Commands.; DRAM WR_CAS=
 (w/ and w/out auto-pre) in Read Major Mode",
-        "Counter": "0,1,2,3",
+        "BriefDescription": "DRAM RD_CAS and WR_CAS Commands.; Underfill R=
ead Issued",
         "EventCode": "0x4",
-        "EventName": "UNC_M_CAS_COUNT.WR_RMM",
+        "EventName": "UNC_M_CAS_COUNT.RD_UNDERFILL",
         "PerPkg": "1",
-        "UMask": "0x8",
+        "PublicDescription": "DRAM RD_CAS and WR_CAS Commands; Counts the =
number of underfill reads that are issued by the memory controller.  This w=
ill generally be about the same as the number of partial writes, but may be=
 slightly less because of partials hitting in the WPQ.  While it is possibl=
e for underfills to be issed in both WMM and RMM, this event counts both.",
+        "UMask": "0x2",
         "Unit": "iMC"
     },
     {
-        "BriefDescription": "DRAM RD_CAS and WR_CAS Commands.; All DRAM WR=
_CAS (both Modes)",
-        "Counter": "0,1,2,3",
+        "BriefDescription": "DRAM RD_CAS and WR_CAS Commands.; Read CAS is=
sued in WMM",
         "EventCode": "0x4",
-        "EventName": "UNC_M_CAS_COUNT.WR",
+        "EventName": "UNC_M_CAS_COUNT.RD_WMM",
         "PerPkg": "1",
-        "UMask": "0xC",
+        "UMask": "0x10",
         "Unit": "iMC"
     },
     {
-        "BriefDescription": "write requests to memory controller. Derived =
from unc_m_cas_count.wr",
-        "Counter": "0,1,2,3",
+        "BriefDescription": "DRAM RD_CAS and WR_CAS Commands.; All DRAM WR=
_CAS (both Modes)",
         "EventCode": "0x4",
-        "EventName": "LLC_MISSES.MEM_WRITE",
+        "EventName": "UNC_M_CAS_COUNT.WR",
         "PerPkg": "1",
-        "ScaleUnit": "64Bytes",
-        "UMask": "0xC",
+        "PublicDescription": "DRAM RD_CAS and WR_CAS Commands; Counts the =
total number of DRAM Write CAS commands issued on this channel.",
+        "UMask": "0xc",
         "Unit": "iMC"
     },
     {
-        "BriefDescription": "DRAM RD_CAS and WR_CAS Commands.; All DRAM WR=
_CAS (w/ and w/out auto-pre)",
-        "Counter": "0,1,2,3",
+        "BriefDescription": "DRAM RD_CAS and WR_CAS Commands.; DRAM WR_CAS=
 (w/ and w/out auto-pre) in Read Major Mode",
         "EventCode": "0x4",
-        "EventName": "UNC_M_CAS_COUNT.ALL",
+        "EventName": "UNC_M_CAS_COUNT.WR_RMM",
         "PerPkg": "1",
-        "UMask": "0xF",
+        "PublicDescription": "DRAM RD_CAS and WR_CAS Commands; Counts the =
total number of Opportunistic DRAM Write CAS commands issued on this channe=
l while in Read-Major-Mode.",
+        "UMask": "0x8",
         "Unit": "iMC"
     },
     {
-        "BriefDescription": "DRAM RD_CAS and WR_CAS Commands.; Read CAS is=
sued in WMM",
-        "Counter": "0,1,2,3",
+        "BriefDescription": "DRAM RD_CAS and WR_CAS Commands.; DRAM WR_CAS=
 (w/ and w/out auto-pre) in Write Major Mode",
         "EventCode": "0x4",
-        "EventName": "UNC_M_CAS_COUNT.RD_WMM",
+        "EventName": "UNC_M_CAS_COUNT.WR_WMM",
         "PerPkg": "1",
-        "UMask": "0x10",
+        "PublicDescription": "DRAM RD_CAS and WR_CAS Commands; Counts the =
total number or DRAM Write CAS commands issued on this channel while in Wri=
te-Major-Mode.",
+        "UMask": "0x4",
         "Unit": "iMC"
     },
     {
-        "BriefDescription": "DRAM RD_CAS and WR_CAS Commands.; Read CAS is=
sued in RMM",
-        "Counter": "0,1,2,3",
-        "EventCode": "0x4",
-        "EventName": "UNC_M_CAS_COUNT.RD_RMM",
+        "BriefDescription": "DRAM Clockticks",
+        "EventName": "UNC_M_CLOCKTICKS",
         "PerPkg": "1",
-        "UMask": "0x20",
         "Unit": "iMC"
     },
     {
         "BriefDescription": "DRAM Clockticks",
-        "Counter": "0,1,2,3",
-        "EventName": "UNC_M_CLOCKTICKS",
+        "EventName": "UNC_M_DCLOCKTICKS",
         "PerPkg": "1",
         "Unit": "iMC"
     },
     {
         "BriefDescription": "DRAM Precharge All Commands",
-        "Counter": "0,1,2,3",
         "EventCode": "0x6",
         "EventName": "UNC_M_DRAM_PRE_ALL",
         "PerPkg": "1",
+        "PublicDescription": "Counts the number of times that the precharg=
e all command was sent.",
         "Unit": "iMC"
     },
     {
         "BriefDescription": "Number of DRAM Refreshes Issued",
-        "Counter": "0,1,2,3",
         "EventCode": "0x5",
-        "EventName": "UNC_M_DRAM_REFRESH.PANIC",
+        "EventName": "UNC_M_DRAM_REFRESH.HIGH",
         "PerPkg": "1",
-        "UMask": "0x2",
+        "PublicDescription": "Counts the number of refreshes issued.",
+        "UMask": "0x4",
         "Unit": "iMC"
     },
     {
         "BriefDescription": "Number of DRAM Refreshes Issued",
-        "Counter": "0,1,2,3",
         "EventCode": "0x5",
-        "EventName": "UNC_M_DRAM_REFRESH.HIGH",
+        "EventName": "UNC_M_DRAM_REFRESH.PANIC",
         "PerPkg": "1",
-        "UMask": "0x4",
+        "PublicDescription": "Counts the number of refreshes issued.",
+        "UMask": "0x2",
         "Unit": "iMC"
     },
     {
         "BriefDescription": "ECC Correctable Errors",
-        "Counter": "0,1,2,3",
         "EventCode": "0x9",
         "EventName": "UNC_M_ECC_CORRECTABLE_ERRORS",
         "PerPkg": "1",
+        "PublicDescription": "Counts the number of ECC errors detected and=
 corrected by the iMC on this channel.  This counter is only useful with EC=
C DRAM devices.  This count will increment one time for each correction reg=
ardless of the number of bits corrected.  The iMC can correct up to 4 bit e=
rrors in independent channel mode and 8 bit errors in lockstep mode.",
         "Unit": "iMC"
     },
     {
-        "BriefDescription": "Cycles in a Major Mode; Read Major Mode",
-        "Counter": "0,1,2,3",
+        "BriefDescription": "Cycles in a Major Mode; Isoch Major Mode",
         "EventCode": "0x7",
-        "EventName": "UNC_M_MAJOR_MODES.READ",
+        "EventName": "UNC_M_MAJOR_MODES.ISOCH",
         "PerPkg": "1",
-        "UMask": "0x1",
+        "PublicDescription": "Counts the total number of cycles spent in a=
 major mode (selected by a filter) on the given channel.   Major modea are =
channel-wide, and not a per-rank (or dimm or bank) mode.; We group these tw=
o modes together so that we can use four counters to track each of the majo=
r modes at one time.  These major modes are used whenever there is an ISOCH=
 txn in the memory controller.  In these mode, only ISOCH transactions are =
processed.",
+        "UMask": "0x8",
         "Unit": "iMC"
     },
     {
-        "BriefDescription": "Cycles in a Major Mode; Write Major Mode",
-        "Counter": "0,1,2,3",
+        "BriefDescription": "Cycles in a Major Mode; Partial Major Mode",
         "EventCode": "0x7",
-        "EventName": "UNC_M_MAJOR_MODES.WRITE",
+        "EventName": "UNC_M_MAJOR_MODES.PARTIAL",
         "PerPkg": "1",
-        "UMask": "0x2",
+        "PublicDescription": "Counts the total number of cycles spent in a=
 major mode (selected by a filter) on the given channel.   Major modea are =
channel-wide, and not a per-rank (or dimm or bank) mode.; This major mode i=
s used to drain starved underfill reads.  Regular reads and writes are bloc=
ked and only underfill reads will be processed.",
+        "UMask": "0x4",
         "Unit": "iMC"
     },
     {
-        "BriefDescription": "Cycles in a Major Mode; Partial Major Mode",
-        "Counter": "0,1,2,3",
+        "BriefDescription": "Cycles in a Major Mode; Read Major Mode",
         "EventCode": "0x7",
-        "EventName": "UNC_M_MAJOR_MODES.PARTIAL",
+        "EventName": "UNC_M_MAJOR_MODES.READ",
         "PerPkg": "1",
-        "UMask": "0x4",
+        "PublicDescription": "Counts the total number of cycles spent in a=
 major mode (selected by a filter) on the given channel.   Major modea are =
channel-wide, and not a per-rank (or dimm or bank) mode.; Read Major Mode i=
s the default mode for the iMC, as reads are generally more critical to for=
ward progress than writes.",
+        "UMask": "0x1",
         "Unit": "iMC"
     },
     {
-        "BriefDescription": "Cycles in a Major Mode; Isoch Major Mode",
-        "Counter": "0,1,2,3",
+        "BriefDescription": "Cycles in a Major Mode; Write Major Mode",
         "EventCode": "0x7",
-        "EventName": "UNC_M_MAJOR_MODES.ISOCH",
+        "EventName": "UNC_M_MAJOR_MODES.WRITE",
         "PerPkg": "1",
-        "UMask": "0x8",
+        "PublicDescription": "Counts the total number of cycles spent in a=
 major mode (selected by a filter) on the given channel.   Major modea are =
channel-wide, and not a per-rank (or dimm or bank) mode.; This mode is trig=
gered when the WPQ hits high occupancy and causes writes to be higher prior=
ity than reads.  This can cause blips in the available read bandwidth in th=
e system and temporarily increase read latencies in order to achieve better=
 bus utilizations and higher bandwidth.",
+        "UMask": "0x2",
         "Unit": "iMC"
     },
     {
         "BriefDescription": "Channel DLLOFF Cycles",
-        "Counter": "0,1,2,3",
         "EventCode": "0x84",
         "EventName": "UNC_M_POWER_CHANNEL_DLLOFF",
         "PerPkg": "1",
+        "PublicDescription": "Number of cycles when all the ranks in the c=
hannel are in CKE Slow (DLLOFF) mode.",
         "Unit": "iMC"
     },
     {
         "BriefDescription": "Channel PPD Cycles",
-        "Counter": "0,1,2,3",
         "EventCode": "0x85",
         "EventName": "UNC_M_POWER_CHANNEL_PPD",
         "PerPkg": "1",
+        "PublicDescription": "Number of cycles when all the ranks in the c=
hannel are in PPD mode.  If IBT=3Doff is enabled, then this can be used to =
count those cycles.  If it is not enabled, then this can count the number o=
f cycles when that could have been taken advantage of.",
         "Unit": "iMC"
     },
     {
         "BriefDescription": "CKE_ON_CYCLES by Rank; DIMM ID",
-        "Counter": "0,1,2,3",
         "EventCode": "0x83",
         "EventName": "UNC_M_POWER_CKE_CYCLES.RANK0",
         "PerPkg": "1",
+        "PublicDescription": "Number of cycles spent in CKE ON mode.  The =
filter allows you to select a rank to monitor.  If multiple ranks are in CK=
E ON mode at one time, the counter will ONLY increment by one rather than d=
oing accumulation.  Multiple counters will need to be used to track multipl=
e ranks simultaneously.  There is no distinction between the different CKE =
modes (APD, PPDS, PPDF).  This can be determined based on the system progra=
mming.  These events should commonly be used with Invert to get the number =
of cycles in power saving mode.  Edge Detect is also useful here.  Make sur=
e that you do NOT use Invert with Edge Detect (this just confuses the syste=
m and is not necessary).",
         "UMask": "0x1",
         "Unit": "iMC"
     },
     {
         "BriefDescription": "CKE_ON_CYCLES by Rank; DIMM ID",
-        "Counter": "0,1,2,3",
         "EventCode": "0x83",
         "EventName": "UNC_M_POWER_CKE_CYCLES.RANK1",
         "PerPkg": "1",
+        "PublicDescription": "Number of cycles spent in CKE ON mode.  The =
filter allows you to select a rank to monitor.  If multiple ranks are in CK=
E ON mode at one time, the counter will ONLY increment by one rather than d=
oing accumulation.  Multiple counters will need to be used to track multipl=
e ranks simultaneously.  There is no distinction between the different CKE =
modes (APD, PPDS, PPDF).  This can be determined based on the system progra=
mming.  These events should commonly be used with Invert to get the number =
of cycles in power saving mode.  Edge Detect is also useful here.  Make sur=
e that you do NOT use Invert with Edge Detect (this just confuses the syste=
m and is not necessary).",
         "UMask": "0x2",
         "Unit": "iMC"
     },
     {
         "BriefDescription": "CKE_ON_CYCLES by Rank; DIMM ID",
-        "Counter": "0,1,2,3",
         "EventCode": "0x83",
         "EventName": "UNC_M_POWER_CKE_CYCLES.RANK2",
         "PerPkg": "1",
+        "PublicDescription": "Number of cycles spent in CKE ON mode.  The =
filter allows you to select a rank to monitor.  If multiple ranks are in CK=
E ON mode at one time, the counter will ONLY increment by one rather than d=
oing accumulation.  Multiple counters will need to be used to track multipl=
e ranks simultaneously.  There is no distinction between the different CKE =
modes (APD, PPDS, PPDF).  This can be determined based on the system progra=
mming.  These events should commonly be used with Invert to get the number =
of cycles in power saving mode.  Edge Detect is also useful here.  Make sur=
e that you do NOT use Invert with Edge Detect (this just confuses the syste=
m and is not necessary).",
         "UMask": "0x4",
         "Unit": "iMC"
     },
     {
         "BriefDescription": "CKE_ON_CYCLES by Rank; DIMM ID",
-        "Counter": "0,1,2,3",
         "EventCode": "0x83",
         "EventName": "UNC_M_POWER_CKE_CYCLES.RANK3",
         "PerPkg": "1",
+        "PublicDescription": "Number of cycles spent in CKE ON mode.  The =
filter allows you to select a rank to monitor.  If multiple ranks are in CK=
E ON mode at one time, the counter will ONLY increment by one rather than d=
oing accumulation.  Multiple counters will need to be used to track multipl=
e ranks simultaneously.  There is no distinction between the different CKE =
modes (APD, PPDS, PPDF).  This can be determined based on the system progra=
mming.  These events should commonly be used with Invert to get the number =
of cycles in power saving mode.  Edge Detect is also useful here.  Make sur=
e that you do NOT use Invert with Edge Detect (this just confuses the syste=
m and is not necessary).",
         "UMask": "0x8",
         "Unit": "iMC"
     },
     {
         "BriefDescription": "CKE_ON_CYCLES by Rank; DIMM ID",
-        "Counter": "0,1,2,3",
         "EventCode": "0x83",
         "EventName": "UNC_M_POWER_CKE_CYCLES.RANK4",
         "PerPkg": "1",
+        "PublicDescription": "Number of cycles spent in CKE ON mode.  The =
filter allows you to select a rank to monitor.  If multiple ranks are in CK=
E ON mode at one time, the counter will ONLY increment by one rather than d=
oing accumulation.  Multiple counters will need to be used to track multipl=
e ranks simultaneously.  There is no distinction between the different CKE =
modes (APD, PPDS, PPDF).  This can be determined based on the system progra=
mming.  These events should commonly be used with Invert to get the number =
of cycles in power saving mode.  Edge Detect is also useful here.  Make sur=
e that you do NOT use Invert with Edge Detect (this just confuses the syste=
m and is not necessary).",
         "UMask": "0x10",
         "Unit": "iMC"
     },
     {
         "BriefDescription": "CKE_ON_CYCLES by Rank; DIMM ID",
-        "Counter": "0,1,2,3",
         "EventCode": "0x83",
         "EventName": "UNC_M_POWER_CKE_CYCLES.RANK5",
         "PerPkg": "1",
+        "PublicDescription": "Number of cycles spent in CKE ON mode.  The =
filter allows you to select a rank to monitor.  If multiple ranks are in CK=
E ON mode at one time, the counter will ONLY increment by one rather than d=
oing accumulation.  Multiple counters will need to be used to track multipl=
e ranks simultaneously.  There is no distinction between the different CKE =
modes (APD, PPDS, PPDF).  This can be determined based on the system progra=
mming.  These events should commonly be used with Invert to get the number =
of cycles in power saving mode.  Edge Detect is also useful here.  Make sur=
e that you do NOT use Invert with Edge Detect (this just confuses the syste=
m and is not necessary).",
         "UMask": "0x20",
         "Unit": "iMC"
     },
     {
         "BriefDescription": "CKE_ON_CYCLES by Rank; DIMM ID",
-        "Counter": "0,1,2,3",
         "EventCode": "0x83",
         "EventName": "UNC_M_POWER_CKE_CYCLES.RANK6",
         "PerPkg": "1",
+        "PublicDescription": "Number of cycles spent in CKE ON mode.  The =
filter allows you to select a rank to monitor.  If multiple ranks are in CK=
E ON mode at one time, the counter will ONLY increment by one rather than d=
oing accumulation.  Multiple counters will need to be used to track multipl=
e ranks simultaneously.  There is no distinction between the different CKE =
modes (APD, PPDS, PPDF).  This can be determined based on the system progra=
mming.  These events should commonly be used with Invert to get the number =
of cycles in power saving mode.  Edge Detect is also useful here.  Make sur=
e that you do NOT use Invert with Edge Detect (this just confuses the syste=
m and is not necessary).",
         "UMask": "0x40",
         "Unit": "iMC"
     },
     {
         "BriefDescription": "CKE_ON_CYCLES by Rank; DIMM ID",
-        "Counter": "0,1,2,3",
         "EventCode": "0x83",
         "EventName": "UNC_M_POWER_CKE_CYCLES.RANK7",
         "PerPkg": "1",
+        "PublicDescription": "Number of cycles spent in CKE ON mode.  The =
filter allows you to select a rank to monitor.  If multiple ranks are in CK=
E ON mode at one time, the counter will ONLY increment by one rather than d=
oing accumulation.  Multiple counters will need to be used to track multipl=
e ranks simultaneously.  There is no distinction between the different CKE =
modes (APD, PPDS, PPDF).  This can be determined based on the system progra=
mming.  These events should commonly be used with Invert to get the number =
of cycles in power saving mode.  Edge Detect is also useful here.  Make sur=
e that you do NOT use Invert with Edge Detect (this just confuses the syste=
m and is not necessary).",
         "UMask": "0x80",
         "Unit": "iMC"
     },
     {
         "BriefDescription": "Critical Throttle Cycles",
-        "Counter": "0,1,2,3",
         "EventCode": "0x86",
         "EventName": "UNC_M_POWER_CRITICAL_THROTTLE_CYCLES",
         "PerPkg": "1",
+        "PublicDescription": "Counts the number of cycles when the iMC is =
in critical thermal throttling.  When this happens, all traffic is blocked.=
  This should be rare unless something bad is going on in the platform.  Th=
ere is no filtering by rank for this event.",
         "Unit": "iMC"
     },
     {
         "BriefDescription": "UNC_M_POWER_PCU_THROTTLING",
-        "Counter": "0,1,2,3",
         "EventCode": "0x42",
         "EventName": "UNC_M_POWER_PCU_THROTTLING",
         "PerPkg": "1",
@@ -337,150 +336,157 @@
     },
     {
         "BriefDescription": "Clock-Enabled Self-Refresh",
-        "Counter": "0,1,2,3",
         "EventCode": "0x43",
         "EventName": "UNC_M_POWER_SELF_REFRESH",
         "PerPkg": "1",
+        "PublicDescription": "Counts the number of cycles when the iMC is =
in self-refresh and the iMC still has a clock.  This happens in some packag=
e C-states.  For example, the PCU may ask the iMC to enter self-refresh eve=
n though some of the cores are still processing.  One use of this is for Mo=
nroe technology.  Self-refresh is required during package C3 and C6, but th=
ere is no clock in the iMC at this time, so it is not possible to count the=
se cases.",
         "Unit": "iMC"
     },
     {
         "BriefDescription": "Throttle Cycles for Rank 0; DIMM ID",
-        "Counter": "0,1,2,3",
         "EventCode": "0x41",
         "EventName": "UNC_M_POWER_THROTTLE_CYCLES.RANK0",
         "PerPkg": "1",
+        "PublicDescription": "Counts the number of cycles while the iMC is=
 being throttled by either thermal constraints or by the PCU throttling.  I=
t is not possible to distinguish between the two.  This can be filtered by =
rank.  If multiple ranks are selected and are being throttled at the same t=
ime, the counter will only increment by 1.; Thermal throttling is performed=
 per DIMM.  We support 3 DIMMs per channel.  This ID allows us to filter by=
 ID.",
         "UMask": "0x1",
         "Unit": "iMC"
     },
     {
         "BriefDescription": "Throttle Cycles for Rank 0; DIMM ID",
-        "Counter": "0,1,2,3",
         "EventCode": "0x41",
         "EventName": "UNC_M_POWER_THROTTLE_CYCLES.RANK1",
         "PerPkg": "1",
+        "PublicDescription": "Counts the number of cycles while the iMC is=
 being throttled by either thermal constraints or by the PCU throttling.  I=
t is not possible to distinguish between the two.  This can be filtered by =
rank.  If multiple ranks are selected and are being throttled at the same t=
ime, the counter will only increment by 1.",
         "UMask": "0x2",
         "Unit": "iMC"
     },
     {
         "BriefDescription": "Throttle Cycles for Rank 0; DIMM ID",
-        "Counter": "0,1,2,3",
         "EventCode": "0x41",
         "EventName": "UNC_M_POWER_THROTTLE_CYCLES.RANK2",
         "PerPkg": "1",
+        "PublicDescription": "Counts the number of cycles while the iMC is=
 being throttled by either thermal constraints or by the PCU throttling.  I=
t is not possible to distinguish between the two.  This can be filtered by =
rank.  If multiple ranks are selected and are being throttled at the same t=
ime, the counter will only increment by 1.",
         "UMask": "0x4",
         "Unit": "iMC"
     },
     {
         "BriefDescription": "Throttle Cycles for Rank 0; DIMM ID",
-        "Counter": "0,1,2,3",
         "EventCode": "0x41",
         "EventName": "UNC_M_POWER_THROTTLE_CYCLES.RANK3",
         "PerPkg": "1",
+        "PublicDescription": "Counts the number of cycles while the iMC is=
 being throttled by either thermal constraints or by the PCU throttling.  I=
t is not possible to distinguish between the two.  This can be filtered by =
rank.  If multiple ranks are selected and are being throttled at the same t=
ime, the counter will only increment by 1.",
         "UMask": "0x8",
         "Unit": "iMC"
     },
     {
         "BriefDescription": "Throttle Cycles for Rank 0; DIMM ID",
-        "Counter": "0,1,2,3",
         "EventCode": "0x41",
         "EventName": "UNC_M_POWER_THROTTLE_CYCLES.RANK4",
         "PerPkg": "1",
+        "PublicDescription": "Counts the number of cycles while the iMC is=
 being throttled by either thermal constraints or by the PCU throttling.  I=
t is not possible to distinguish between the two.  This can be filtered by =
rank.  If multiple ranks are selected and are being throttled at the same t=
ime, the counter will only increment by 1.",
         "UMask": "0x10",
         "Unit": "iMC"
     },
     {
         "BriefDescription": "Throttle Cycles for Rank 0; DIMM ID",
-        "Counter": "0,1,2,3",
         "EventCode": "0x41",
         "EventName": "UNC_M_POWER_THROTTLE_CYCLES.RANK5",
         "PerPkg": "1",
+        "PublicDescription": "Counts the number of cycles while the iMC is=
 being throttled by either thermal constraints or by the PCU throttling.  I=
t is not possible to distinguish between the two.  This can be filtered by =
rank.  If multiple ranks are selected and are being throttled at the same t=
ime, the counter will only increment by 1.",
         "UMask": "0x20",
         "Unit": "iMC"
     },
     {
         "BriefDescription": "Throttle Cycles for Rank 0; DIMM ID",
-        "Counter": "0,1,2,3",
         "EventCode": "0x41",
         "EventName": "UNC_M_POWER_THROTTLE_CYCLES.RANK6",
         "PerPkg": "1",
+        "PublicDescription": "Counts the number of cycles while the iMC is=
 being throttled by either thermal constraints or by the PCU throttling.  I=
t is not possible to distinguish between the two.  This can be filtered by =
rank.  If multiple ranks are selected and are being throttled at the same t=
ime, the counter will only increment by 1.",
         "UMask": "0x40",
         "Unit": "iMC"
     },
     {
         "BriefDescription": "Throttle Cycles for Rank 0; DIMM ID",
-        "Counter": "0,1,2,3",
         "EventCode": "0x41",
         "EventName": "UNC_M_POWER_THROTTLE_CYCLES.RANK7",
         "PerPkg": "1",
+        "PublicDescription": "Counts the number of cycles while the iMC is=
 being throttled by either thermal constraints or by the PCU throttling.  I=
t is not possible to distinguish between the two.  This can be filtered by =
rank.  If multiple ranks are selected and are being throttled at the same t=
ime, the counter will only increment by 1.",
         "UMask": "0x80",
         "Unit": "iMC"
     },
     {
         "BriefDescription": "Read Preemption Count; Read over Read Preempt=
ion",
-        "Counter": "0,1,2,3",
         "EventCode": "0x8",
         "EventName": "UNC_M_PREEMPTION.RD_PREEMPT_RD",
         "PerPkg": "1",
+        "PublicDescription": "Counts the number of times a read in the iMC=
 preempts another read or write.  Generally reads to an open page are issue=
d ahead of requests to closed pages.  This improves the page hit rate of th=
e system.  However, high priority requests can cause pages of active reques=
ts to be closed in order to get them out.  This will reduce the latency of =
the high-priority request at the expense of lower bandwidth and increased o=
verall average latency.; Filter for when a read preempts another read.",
         "UMask": "0x1",
         "Unit": "iMC"
     },
     {
         "BriefDescription": "Read Preemption Count; Read over Write Preemp=
tion",
-        "Counter": "0,1,2,3",
         "EventCode": "0x8",
         "EventName": "UNC_M_PREEMPTION.RD_PREEMPT_WR",
         "PerPkg": "1",
+        "PublicDescription": "Counts the number of times a read in the iMC=
 preempts another read or write.  Generally reads to an open page are issue=
d ahead of requests to closed pages.  This improves the page hit rate of th=
e system.  However, high priority requests can cause pages of active reques=
ts to be closed in order to get them out.  This will reduce the latency of =
the high-priority request at the expense of lower bandwidth and increased o=
verall average latency.; Filter for when a read preempts a write.",
         "UMask": "0x2",
         "Unit": "iMC"
     },
     {
-        "BriefDescription": "DRAM Precharge commands.; Precharges due to p=
age miss",
-        "Counter": "0,1,2,3",
+        "BriefDescription": "DRAM Precharge commands.; Precharge due to by=
pass",
         "EventCode": "0x2",
-        "EventName": "UNC_M_PRE_COUNT.PAGE_MISS",
+        "EventName": "UNC_M_PRE_COUNT.BYP",
         "PerPkg": "1",
-        "UMask": "0x1",
+        "PublicDescription": "Counts the number of DRAM Precharge commands=
 sent on this channel.",
+        "UMask": "0x10",
         "Unit": "iMC"
     },
     {
         "BriefDescription": "DRAM Precharge commands.; Precharge due to ti=
mer expiration",
-        "Counter": "0,1,2,3",
         "EventCode": "0x2",
         "EventName": "UNC_M_PRE_COUNT.PAGE_CLOSE",
         "PerPkg": "1",
+        "PublicDescription": "Counts the number of DRAM Precharge commands=
 sent on this channel.; Counts the number of DRAM Precharge commands sent o=
n this channel as a result of the page close counter expiring.  This does n=
ot include implicit precharge commands sent in auto-precharge mode.",
         "UMask": "0x2",
         "Unit": "iMC"
     },
+    {
+        "BriefDescription": "DRAM Precharge commands.; Precharges due to p=
age miss",
+        "EventCode": "0x2",
+        "EventName": "UNC_M_PRE_COUNT.PAGE_MISS",
+        "PerPkg": "1",
+        "PublicDescription": "Counts the number of DRAM Precharge commands=
 sent on this channel.; Counts the number of DRAM Precharge commands sent o=
n this channel as a result of page misses.  This does not include explicit =
precharge commands sent with CAS commands in Auto-Precharge mode.  This doe=
s not include PRE commands sent as a result of the page close counter expir=
ation.",
+        "UMask": "0x1",
+        "Unit": "iMC"
+    },
     {
         "BriefDescription": "DRAM Precharge commands.; Precharge due to re=
ad",
-        "Counter": "0,1,2,3",
         "EventCode": "0x2",
         "EventName": "UNC_M_PRE_COUNT.RD",
         "PerPkg": "1",
+        "PublicDescription": "Counts the number of DRAM Precharge commands=
 sent on this channel.",
         "UMask": "0x4",
         "Unit": "iMC"
     },
     {
         "BriefDescription": "DRAM Precharge commands.; Precharge due to wr=
ite",
-        "Counter": "0,1,2,3",
         "EventCode": "0x2",
         "EventName": "UNC_M_PRE_COUNT.WR",
         "PerPkg": "1",
+        "PublicDescription": "Counts the number of DRAM Precharge commands=
 sent on this channel.",
         "UMask": "0x8",
         "Unit": "iMC"
     },
     {
-        "BriefDescription": "DRAM Precharge commands.; Precharge due to by=
pass",
-        "Counter": "0,1,2,3",
-        "EventCode": "0x2",
-        "EventName": "UNC_M_PRE_COUNT.BYP",
+        "BriefDescription": "Read CAS issued with HIGH priority",
+        "EventCode": "0xA0",
+        "EventName": "UNC_M_RD_CAS_PRIO.HIGH",
         "PerPkg": "1",
-        "UMask": "0x10",
+        "UMask": "0x4",
         "Unit": "iMC"
     },
     {
         "BriefDescription": "Read CAS issued with LOW priority",
-        "Counter": "0,1,2,3",
         "EventCode": "0xA0",
         "EventName": "UNC_M_RD_CAS_PRIO.LOW",
         "PerPkg": "1",
@@ -489,25 +495,14 @@
     },
     {
         "BriefDescription": "Read CAS issued with MEDIUM priority",
-        "Counter": "0,1,2,3",
         "EventCode": "0xA0",
         "EventName": "UNC_M_RD_CAS_PRIO.MED",
         "PerPkg": "1",
         "UMask": "0x2",
         "Unit": "iMC"
     },
-    {
-        "BriefDescription": "Read CAS issued with HIGH priority",
-        "Counter": "0,1,2,3",
-        "EventCode": "0xA0",
-        "EventName": "UNC_M_RD_CAS_PRIO.HIGH",
-        "PerPkg": "1",
-        "UMask": "0x4",
-        "Unit": "iMC"
-    },
     {
         "BriefDescription": "Read CAS issued with PANIC NON ISOCH priority=
 (starved)",
-        "Counter": "0,1,2,3",
         "EventCode": "0xA0",
         "EventName": "UNC_M_RD_CAS_PRIO.PANIC",
         "PerPkg": "1",
@@ -515,1186 +510,1182 @@
         "Unit": "iMC"
     },
     {
-        "BriefDescription": "RD_CAS Access to Rank 0; Bank 1",
-        "Counter": "0,1,2,3",
+        "BriefDescription": "RD_CAS Access to Rank 0; All Banks",
         "EventCode": "0xB0",
-        "EventName": "UNC_M_RD_CAS_RANK0.BANK1",
+        "EventName": "UNC_M_RD_CAS_RANK0.ALLBANKS",
         "PerPkg": "1",
-        "UMask": "0x1",
+        "PublicDescription": "RD_CAS Access to Rank 0 : All Banks",
+        "UMask": "0x10",
         "Unit": "iMC"
     },
     {
-        "BriefDescription": "RD_CAS Access to Rank 0; Bank 2",
-        "Counter": "0,1,2,3",
+        "BriefDescription": "RD_CAS Access to Rank 0; Bank 0",
         "EventCode": "0xB0",
-        "EventName": "UNC_M_RD_CAS_RANK0.BANK2",
+        "EventName": "UNC_M_RD_CAS_RANK0.BANK0",
         "PerPkg": "1",
-        "UMask": "0x2",
+        "PublicDescription": "RD_CAS Access to Rank 0 : Bank 0",
         "Unit": "iMC"
     },
     {
-        "BriefDescription": "RD_CAS Access to Rank 0; Bank 4",
-        "Counter": "0,1,2,3",
+        "BriefDescription": "RD_CAS Access to Rank 0; Bank 1",
         "EventCode": "0xB0",
-        "EventName": "UNC_M_RD_CAS_RANK0.BANK4",
+        "EventName": "UNC_M_RD_CAS_RANK0.BANK1",
         "PerPkg": "1",
-        "UMask": "0x4",
+        "PublicDescription": "RD_CAS Access to Rank 0 : Bank 1",
+        "UMask": "0x1",
         "Unit": "iMC"
     },
     {
-        "BriefDescription": "RD_CAS Access to Rank 0; Bank 8",
-        "Counter": "0,1,2,3",
+        "BriefDescription": "RD_CAS Access to Rank 0; Bank 10",
         "EventCode": "0xB0",
-        "EventName": "UNC_M_RD_CAS_RANK0.BANK8",
+        "EventName": "UNC_M_RD_CAS_RANK0.BANK10",
         "PerPkg": "1",
-        "UMask": "0x8",
+        "PublicDescription": "RD_CAS Access to Rank 0 : Bank 10",
+        "UMask": "0xa",
         "Unit": "iMC"
     },
     {
-        "BriefDescription": "RD_CAS Access to Rank 0; All Banks",
-        "Counter": "0,1,2,3",
+        "BriefDescription": "RD_CAS Access to Rank 0; Bank 11",
         "EventCode": "0xB0",
-        "EventName": "UNC_M_RD_CAS_RANK0.ALLBANKS",
+        "EventName": "UNC_M_RD_CAS_RANK0.BANK11",
         "PerPkg": "1",
-        "UMask": "0x10",
+        "PublicDescription": "RD_CAS Access to Rank 0 : Bank 11",
+        "UMask": "0xb",
         "Unit": "iMC"
     },
     {
-        "BriefDescription": "RD_CAS Access to Rank 0; Bank 0",
-        "Counter": "0,1,2,3",
+        "BriefDescription": "RD_CAS Access to Rank 0; Bank 12",
         "EventCode": "0xB0",
-        "EventName": "UNC_M_RD_CAS_RANK0.BANK0",
+        "EventName": "UNC_M_RD_CAS_RANK0.BANK12",
         "PerPkg": "1",
+        "PublicDescription": "RD_CAS Access to Rank 0 : Bank 12",
+        "UMask": "0xc",
         "Unit": "iMC"
     },
     {
-        "BriefDescription": "RD_CAS Access to Rank 0; Bank 3",
-        "Counter": "0,1,2,3",
+        "BriefDescription": "RD_CAS Access to Rank 0; Bank 13",
         "EventCode": "0xB0",
-        "EventName": "UNC_M_RD_CAS_RANK0.BANK3",
+        "EventName": "UNC_M_RD_CAS_RANK0.BANK13",
         "PerPkg": "1",
-        "UMask": "0x3",
+        "PublicDescription": "RD_CAS Access to Rank 0 : Bank 13",
+        "UMask": "0xd",
         "Unit": "iMC"
     },
     {
-        "BriefDescription": "RD_CAS Access to Rank 0; Bank 5",
-        "Counter": "0,1,2,3",
+        "BriefDescription": "RD_CAS Access to Rank 0; Bank 14",
         "EventCode": "0xB0",
-        "EventName": "UNC_M_RD_CAS_RANK0.BANK5",
+        "EventName": "UNC_M_RD_CAS_RANK0.BANK14",
         "PerPkg": "1",
-        "UMask": "0x5",
+        "PublicDescription": "RD_CAS Access to Rank 0 : Bank 14",
+        "UMask": "0xe",
         "Unit": "iMC"
     },
     {
-        "BriefDescription": "RD_CAS Access to Rank 0; Bank 6",
-        "Counter": "0,1,2,3",
+        "BriefDescription": "RD_CAS Access to Rank 0; Bank 15",
         "EventCode": "0xB0",
-        "EventName": "UNC_M_RD_CAS_RANK0.BANK6",
+        "EventName": "UNC_M_RD_CAS_RANK0.BANK15",
         "PerPkg": "1",
-        "UMask": "0x6",
+        "PublicDescription": "RD_CAS Access to Rank 0 : Bank 15",
+        "UMask": "0xf",
         "Unit": "iMC"
     },
     {
-        "BriefDescription": "RD_CAS Access to Rank 0; Bank 7",
-        "Counter": "0,1,2,3",
+        "BriefDescription": "RD_CAS Access to Rank 0; Bank 2",
         "EventCode": "0xB0",
-        "EventName": "UNC_M_RD_CAS_RANK0.BANK7",
+        "EventName": "UNC_M_RD_CAS_RANK0.BANK2",
         "PerPkg": "1",
-        "UMask": "0x7",
+        "PublicDescription": "RD_CAS Access to Rank 0 : Bank 2",
+        "UMask": "0x2",
         "Unit": "iMC"
     },
     {
-        "BriefDescription": "RD_CAS Access to Rank 0; Bank 9",
-        "Counter": "0,1,2,3",
+        "BriefDescription": "RD_CAS Access to Rank 0; Bank 3",
         "EventCode": "0xB0",
-        "EventName": "UNC_M_RD_CAS_RANK0.BANK9",
+        "EventName": "UNC_M_RD_CAS_RANK0.BANK3",
         "PerPkg": "1",
-        "UMask": "0x9",
+        "PublicDescription": "RD_CAS Access to Rank 0 : Bank 3",
+        "UMask": "0x3",
         "Unit": "iMC"
     },
     {
-        "BriefDescription": "RD_CAS Access to Rank 0; Bank 10",
-        "Counter": "0,1,2,3",
+        "BriefDescription": "RD_CAS Access to Rank 0; Bank 4",
         "EventCode": "0xB0",
-        "EventName": "UNC_M_RD_CAS_RANK0.BANK10",
+        "EventName": "UNC_M_RD_CAS_RANK0.BANK4",
         "PerPkg": "1",
-        "UMask": "0xA",
+        "PublicDescription": "RD_CAS Access to Rank 0 : Bank 4",
+        "UMask": "0x4",
         "Unit": "iMC"
     },
     {
-        "BriefDescription": "RD_CAS Access to Rank 0; Bank 11",
-        "Counter": "0,1,2,3",
+        "BriefDescription": "RD_CAS Access to Rank 0; Bank 5",
         "EventCode": "0xB0",
-        "EventName": "UNC_M_RD_CAS_RANK0.BANK11",
+        "EventName": "UNC_M_RD_CAS_RANK0.BANK5",
         "PerPkg": "1",
-        "UMask": "0xB",
+        "PublicDescription": "RD_CAS Access to Rank 0 : Bank 5",
+        "UMask": "0x5",
         "Unit": "iMC"
     },
     {
-        "BriefDescription": "RD_CAS Access to Rank 0; Bank 12",
-        "Counter": "0,1,2,3",
+        "BriefDescription": "RD_CAS Access to Rank 0; Bank 6",
         "EventCode": "0xB0",
-        "EventName": "UNC_M_RD_CAS_RANK0.BANK12",
+        "EventName": "UNC_M_RD_CAS_RANK0.BANK6",
         "PerPkg": "1",
-        "UMask": "0xC",
+        "PublicDescription": "RD_CAS Access to Rank 0 : Bank 6",
+        "UMask": "0x6",
         "Unit": "iMC"
     },
     {
-        "BriefDescription": "RD_CAS Access to Rank 0; Bank 13",
-        "Counter": "0,1,2,3",
+        "BriefDescription": "RD_CAS Access to Rank 0; Bank 7",
         "EventCode": "0xB0",
-        "EventName": "UNC_M_RD_CAS_RANK0.BANK13",
+        "EventName": "UNC_M_RD_CAS_RANK0.BANK7",
         "PerPkg": "1",
-        "UMask": "0xD",
+        "PublicDescription": "RD_CAS Access to Rank 0 : Bank 7",
+        "UMask": "0x7",
         "Unit": "iMC"
     },
     {
-        "BriefDescription": "RD_CAS Access to Rank 0; Bank 14",
-        "Counter": "0,1,2,3",
+        "BriefDescription": "RD_CAS Access to Rank 0; Bank 8",
         "EventCode": "0xB0",
-        "EventName": "UNC_M_RD_CAS_RANK0.BANK14",
+        "EventName": "UNC_M_RD_CAS_RANK0.BANK8",
         "PerPkg": "1",
-        "UMask": "0xE",
+        "PublicDescription": "RD_CAS Access to Rank 0 : Bank 8",
+        "UMask": "0x8",
         "Unit": "iMC"
     },
     {
-        "BriefDescription": "RD_CAS Access to Rank 0; Bank 15",
-        "Counter": "0,1,2,3",
+        "BriefDescription": "RD_CAS Access to Rank 0; Bank 9",
         "EventCode": "0xB0",
-        "EventName": "UNC_M_RD_CAS_RANK0.BANK15",
+        "EventName": "UNC_M_RD_CAS_RANK0.BANK9",
         "PerPkg": "1",
-        "UMask": "0xF",
+        "PublicDescription": "RD_CAS Access to Rank 0 : Bank 9",
+        "UMask": "0x9",
         "Unit": "iMC"
     },
     {
         "BriefDescription": "RD_CAS Access to Rank 0; Bank Group 0 (Banks =
0-3)",
-        "Counter": "0,1,2,3",
         "EventCode": "0xB0",
         "EventName": "UNC_M_RD_CAS_RANK0.BANKG0",
         "PerPkg": "1",
+        "PublicDescription": "RD_CAS Access to Rank 0 : Bank Group 0 (Bank=
s 0-3)",
         "UMask": "0x11",
         "Unit": "iMC"
     },
     {
         "BriefDescription": "RD_CAS Access to Rank 0; Bank Group 1 (Banks =
4-7)",
-        "Counter": "0,1,2,3",
         "EventCode": "0xB0",
         "EventName": "UNC_M_RD_CAS_RANK0.BANKG1",
         "PerPkg": "1",
+        "PublicDescription": "RD_CAS Access to Rank 0 : Bank Group 1 (Bank=
s 4-7)",
         "UMask": "0x12",
         "Unit": "iMC"
     },
     {
         "BriefDescription": "RD_CAS Access to Rank 0; Bank Group 2 (Banks =
8-11)",
-        "Counter": "0,1,2,3",
         "EventCode": "0xB0",
         "EventName": "UNC_M_RD_CAS_RANK0.BANKG2",
         "PerPkg": "1",
+        "PublicDescription": "RD_CAS Access to Rank 0 : Bank Group 2 (Bank=
s 8-11)",
         "UMask": "0x13",
         "Unit": "iMC"
     },
     {
         "BriefDescription": "RD_CAS Access to Rank 0; Bank Group 3 (Banks =
12-15)",
-        "Counter": "0,1,2,3",
         "EventCode": "0xB0",
         "EventName": "UNC_M_RD_CAS_RANK0.BANKG3",
         "PerPkg": "1",
+        "PublicDescription": "RD_CAS Access to Rank 0 : Bank Group 3 (Bank=
s 12-15)",
         "UMask": "0x14",
         "Unit": "iMC"
     },
     {
-        "BriefDescription": "RD_CAS Access to Rank 1; Bank 1",
-        "Counter": "0,1,2,3",
+        "BriefDescription": "RD_CAS Access to Rank 1; All Banks",
         "EventCode": "0xB1",
-        "EventName": "UNC_M_RD_CAS_RANK1.BANK1",
+        "EventName": "UNC_M_RD_CAS_RANK1.ALLBANKS",
         "PerPkg": "1",
-        "UMask": "0x1",
+        "PublicDescription": "RD_CAS Access to Rank 0 : All Banks",
+        "UMask": "0x10",
         "Unit": "iMC"
     },
     {
-        "BriefDescription": "RD_CAS Access to Rank 1; Bank 2",
-        "Counter": "0,1,2,3",
+        "BriefDescription": "RD_CAS Access to Rank 1; Bank 0",
         "EventCode": "0xB1",
-        "EventName": "UNC_M_RD_CAS_RANK1.BANK2",
+        "EventName": "UNC_M_RD_CAS_RANK1.BANK0",
         "PerPkg": "1",
-        "UMask": "0x2",
+        "PublicDescription": "RD_CAS Access to Rank 0 : Bank 0",
         "Unit": "iMC"
     },
     {
-        "BriefDescription": "RD_CAS Access to Rank 1; Bank 4",
-        "Counter": "0,1,2,3",
+        "BriefDescription": "RD_CAS Access to Rank 1; Bank 1",
         "EventCode": "0xB1",
-        "EventName": "UNC_M_RD_CAS_RANK1.BANK4",
+        "EventName": "UNC_M_RD_CAS_RANK1.BANK1",
         "PerPkg": "1",
-        "UMask": "0x4",
+        "PublicDescription": "RD_CAS Access to Rank 0 : Bank 1",
+        "UMask": "0x1",
         "Unit": "iMC"
     },
     {
-        "BriefDescription": "RD_CAS Access to Rank 1; Bank 8",
-        "Counter": "0,1,2,3",
+        "BriefDescription": "RD_CAS Access to Rank 1; Bank 10",
         "EventCode": "0xB1",
-        "EventName": "UNC_M_RD_CAS_RANK1.BANK8",
+        "EventName": "UNC_M_RD_CAS_RANK1.BANK10",
         "PerPkg": "1",
-        "UMask": "0x8",
+        "PublicDescription": "RD_CAS Access to Rank 0 : Bank 10",
+        "UMask": "0xa",
         "Unit": "iMC"
     },
     {
-        "BriefDescription": "RD_CAS Access to Rank 1; All Banks",
-        "Counter": "0,1,2,3",
+        "BriefDescription": "RD_CAS Access to Rank 1; Bank 11",
         "EventCode": "0xB1",
-        "EventName": "UNC_M_RD_CAS_RANK1.ALLBANKS",
+        "EventName": "UNC_M_RD_CAS_RANK1.BANK11",
         "PerPkg": "1",
-        "UMask": "0x10",
+        "PublicDescription": "RD_CAS Access to Rank 0 : Bank 11",
+        "UMask": "0xb",
         "Unit": "iMC"
     },
     {
-        "BriefDescription": "RD_CAS Access to Rank 1; Bank 0",
-        "Counter": "0,1,2,3",
+        "BriefDescription": "RD_CAS Access to Rank 1; Bank 12",
         "EventCode": "0xB1",
-        "EventName": "UNC_M_RD_CAS_RANK1.BANK0",
+        "EventName": "UNC_M_RD_CAS_RANK1.BANK12",
         "PerPkg": "1",
+        "PublicDescription": "RD_CAS Access to Rank 0 : Bank 12",
+        "UMask": "0xc",
         "Unit": "iMC"
     },
     {
-        "BriefDescription": "RD_CAS Access to Rank 1; Bank 3",
-        "Counter": "0,1,2,3",
+        "BriefDescription": "RD_CAS Access to Rank 1; Bank 13",
         "EventCode": "0xB1",
-        "EventName": "UNC_M_RD_CAS_RANK1.BANK3",
+        "EventName": "UNC_M_RD_CAS_RANK1.BANK13",
         "PerPkg": "1",
-        "UMask": "0x3",
+        "PublicDescription": "RD_CAS Access to Rank 0 : Bank 13",
+        "UMask": "0xd",
         "Unit": "iMC"
     },
     {
-        "BriefDescription": "RD_CAS Access to Rank 1; Bank 5",
-        "Counter": "0,1,2,3",
+        "BriefDescription": "RD_CAS Access to Rank 1; Bank 14",
         "EventCode": "0xB1",
-        "EventName": "UNC_M_RD_CAS_RANK1.BANK5",
+        "EventName": "UNC_M_RD_CAS_RANK1.BANK14",
         "PerPkg": "1",
-        "UMask": "0x5",
+        "PublicDescription": "RD_CAS Access to Rank 0 : Bank 14",
+        "UMask": "0xe",
         "Unit": "iMC"
     },
     {
-        "BriefDescription": "RD_CAS Access to Rank 1; Bank 6",
-        "Counter": "0,1,2,3",
+        "BriefDescription": "RD_CAS Access to Rank 1; Bank 15",
         "EventCode": "0xB1",
-        "EventName": "UNC_M_RD_CAS_RANK1.BANK6",
+        "EventName": "UNC_M_RD_CAS_RANK1.BANK15",
         "PerPkg": "1",
-        "UMask": "0x6",
+        "PublicDescription": "RD_CAS Access to Rank 0 : Bank 15",
+        "UMask": "0xf",
         "Unit": "iMC"
     },
     {
-        "BriefDescription": "RD_CAS Access to Rank 1; Bank 7",
-        "Counter": "0,1,2,3",
+        "BriefDescription": "RD_CAS Access to Rank 1; Bank 2",
         "EventCode": "0xB1",
-        "EventName": "UNC_M_RD_CAS_RANK1.BANK7",
+        "EventName": "UNC_M_RD_CAS_RANK1.BANK2",
         "PerPkg": "1",
-        "UMask": "0x7",
+        "PublicDescription": "RD_CAS Access to Rank 0 : Bank 2",
+        "UMask": "0x2",
         "Unit": "iMC"
     },
     {
-        "BriefDescription": "RD_CAS Access to Rank 1; Bank 9",
-        "Counter": "0,1,2,3",
+        "BriefDescription": "RD_CAS Access to Rank 1; Bank 3",
         "EventCode": "0xB1",
-        "EventName": "UNC_M_RD_CAS_RANK1.BANK9",
+        "EventName": "UNC_M_RD_CAS_RANK1.BANK3",
         "PerPkg": "1",
-        "UMask": "0x9",
+        "PublicDescription": "RD_CAS Access to Rank 0 : Bank 3",
+        "UMask": "0x3",
         "Unit": "iMC"
     },
     {
-        "BriefDescription": "RD_CAS Access to Rank 1; Bank 10",
-        "Counter": "0,1,2,3",
+        "BriefDescription": "RD_CAS Access to Rank 1; Bank 4",
         "EventCode": "0xB1",
-        "EventName": "UNC_M_RD_CAS_RANK1.BANK10",
+        "EventName": "UNC_M_RD_CAS_RANK1.BANK4",
         "PerPkg": "1",
-        "UMask": "0xA",
+        "PublicDescription": "RD_CAS Access to Rank 0 : Bank 4",
+        "UMask": "0x4",
         "Unit": "iMC"
     },
     {
-        "BriefDescription": "RD_CAS Access to Rank 1; Bank 11",
-        "Counter": "0,1,2,3",
+        "BriefDescription": "RD_CAS Access to Rank 1; Bank 5",
         "EventCode": "0xB1",
-        "EventName": "UNC_M_RD_CAS_RANK1.BANK11",
+        "EventName": "UNC_M_RD_CAS_RANK1.BANK5",
         "PerPkg": "1",
-        "UMask": "0xB",
+        "PublicDescription": "RD_CAS Access to Rank 0 : Bank 5",
+        "UMask": "0x5",
         "Unit": "iMC"
     },
     {
-        "BriefDescription": "RD_CAS Access to Rank 1; Bank 12",
-        "Counter": "0,1,2,3",
+        "BriefDescription": "RD_CAS Access to Rank 1; Bank 6",
         "EventCode": "0xB1",
-        "EventName": "UNC_M_RD_CAS_RANK1.BANK12",
+        "EventName": "UNC_M_RD_CAS_RANK1.BANK6",
         "PerPkg": "1",
-        "UMask": "0xC",
+        "PublicDescription": "RD_CAS Access to Rank 0 : Bank 6",
+        "UMask": "0x6",
         "Unit": "iMC"
     },
     {
-        "BriefDescription": "RD_CAS Access to Rank 1; Bank 13",
-        "Counter": "0,1,2,3",
+        "BriefDescription": "RD_CAS Access to Rank 1; Bank 7",
         "EventCode": "0xB1",
-        "EventName": "UNC_M_RD_CAS_RANK1.BANK13",
+        "EventName": "UNC_M_RD_CAS_RANK1.BANK7",
         "PerPkg": "1",
-        "UMask": "0xD",
+        "PublicDescription": "RD_CAS Access to Rank 0 : Bank 7",
+        "UMask": "0x7",
         "Unit": "iMC"
     },
     {
-        "BriefDescription": "RD_CAS Access to Rank 1; Bank 14",
-        "Counter": "0,1,2,3",
+        "BriefDescription": "RD_CAS Access to Rank 1; Bank 8",
         "EventCode": "0xB1",
-        "EventName": "UNC_M_RD_CAS_RANK1.BANK14",
+        "EventName": "UNC_M_RD_CAS_RANK1.BANK8",
         "PerPkg": "1",
-        "UMask": "0xE",
+        "PublicDescription": "RD_CAS Access to Rank 0 : Bank 8",
+        "UMask": "0x8",
         "Unit": "iMC"
     },
     {
-        "BriefDescription": "RD_CAS Access to Rank 1; Bank 15",
-        "Counter": "0,1,2,3",
+        "BriefDescription": "RD_CAS Access to Rank 1; Bank 9",
         "EventCode": "0xB1",
-        "EventName": "UNC_M_RD_CAS_RANK1.BANK15",
+        "EventName": "UNC_M_RD_CAS_RANK1.BANK9",
         "PerPkg": "1",
-        "UMask": "0xF",
+        "PublicDescription": "RD_CAS Access to Rank 0 : Bank 9",
+        "UMask": "0x9",
         "Unit": "iMC"
     },
     {
         "BriefDescription": "RD_CAS Access to Rank 1; Bank Group 0 (Banks =
0-3)",
-        "Counter": "0,1,2,3",
         "EventCode": "0xB1",
         "EventName": "UNC_M_RD_CAS_RANK1.BANKG0",
         "PerPkg": "1",
+        "PublicDescription": "RD_CAS Access to Rank 0 : Bank Group 0 (Bank=
s 0-3)",
         "UMask": "0x11",
         "Unit": "iMC"
     },
     {
         "BriefDescription": "RD_CAS Access to Rank 1; Bank Group 1 (Banks =
4-7)",
-        "Counter": "0,1,2,3",
         "EventCode": "0xB1",
         "EventName": "UNC_M_RD_CAS_RANK1.BANKG1",
         "PerPkg": "1",
+        "PublicDescription": "RD_CAS Access to Rank 0 : Bank Group 1 (Bank=
s 4-7)",
         "UMask": "0x12",
         "Unit": "iMC"
     },
     {
         "BriefDescription": "RD_CAS Access to Rank 1; Bank Group 2 (Banks =
8-11)",
-        "Counter": "0,1,2,3",
         "EventCode": "0xB1",
         "EventName": "UNC_M_RD_CAS_RANK1.BANKG2",
         "PerPkg": "1",
+        "PublicDescription": "RD_CAS Access to Rank 0 : Bank Group 2 (Bank=
s 8-11)",
         "UMask": "0x13",
         "Unit": "iMC"
     },
     {
         "BriefDescription": "RD_CAS Access to Rank 1; Bank Group 3 (Banks =
12-15)",
-        "Counter": "0,1,2,3",
         "EventCode": "0xB1",
         "EventName": "UNC_M_RD_CAS_RANK1.BANKG3",
         "PerPkg": "1",
+        "PublicDescription": "RD_CAS Access to Rank 0 : Bank Group 3 (Bank=
s 12-15)",
         "UMask": "0x14",
         "Unit": "iMC"
     },
     {
         "BriefDescription": "RD_CAS Access to Rank 2; Bank 0",
-        "Counter": "0,1,2,3",
         "EventCode": "0xB2",
         "EventName": "UNC_M_RD_CAS_RANK2.BANK0",
         "PerPkg": "1",
+        "PublicDescription": "RD_CAS Access to Rank 0 : Bank 0",
         "Unit": "iMC"
     },
     {
-        "BriefDescription": "RD_CAS Access to Rank 4; Bank 1",
-        "Counter": "0,1,2,3",
+        "BriefDescription": "RD_CAS Access to Rank 4; All Banks",
         "EventCode": "0xB4",
-        "EventName": "UNC_M_RD_CAS_RANK4.BANK1",
+        "EventName": "UNC_M_RD_CAS_RANK4.ALLBANKS",
         "PerPkg": "1",
-        "UMask": "0x1",
+        "PublicDescription": "RD_CAS Access to Rank 0 : All Banks",
+        "UMask": "0x10",
         "Unit": "iMC"
     },
     {
-        "BriefDescription": "RD_CAS Access to Rank 4; Bank 2",
-        "Counter": "0,1,2,3",
+        "BriefDescription": "RD_CAS Access to Rank 4; Bank 0",
         "EventCode": "0xB4",
-        "EventName": "UNC_M_RD_CAS_RANK4.BANK2",
+        "EventName": "UNC_M_RD_CAS_RANK4.BANK0",
         "PerPkg": "1",
-        "UMask": "0x2",
+        "PublicDescription": "RD_CAS Access to Rank 0 : Bank 0",
         "Unit": "iMC"
     },
     {
-        "BriefDescription": "RD_CAS Access to Rank 4; Bank 4",
-        "Counter": "0,1,2,3",
+        "BriefDescription": "RD_CAS Access to Rank 4; Bank 1",
         "EventCode": "0xB4",
-        "EventName": "UNC_M_RD_CAS_RANK4.BANK4",
+        "EventName": "UNC_M_RD_CAS_RANK4.BANK1",
         "PerPkg": "1",
-        "UMask": "0x4",
+        "PublicDescription": "RD_CAS Access to Rank 0 : Bank 1",
+        "UMask": "0x1",
         "Unit": "iMC"
     },
     {
-        "BriefDescription": "RD_CAS Access to Rank 4; Bank 8",
-        "Counter": "0,1,2,3",
+        "BriefDescription": "RD_CAS Access to Rank 4; Bank 10",
         "EventCode": "0xB4",
-        "EventName": "UNC_M_RD_CAS_RANK4.BANK8",
+        "EventName": "UNC_M_RD_CAS_RANK4.BANK10",
         "PerPkg": "1",
-        "UMask": "0x8",
+        "PublicDescription": "RD_CAS Access to Rank 0 : Bank 10",
+        "UMask": "0xa",
         "Unit": "iMC"
     },
     {
-        "BriefDescription": "RD_CAS Access to Rank 4; All Banks",
-        "Counter": "0,1,2,3",
+        "BriefDescription": "RD_CAS Access to Rank 4; Bank 11",
         "EventCode": "0xB4",
-        "EventName": "UNC_M_RD_CAS_RANK4.ALLBANKS",
+        "EventName": "UNC_M_RD_CAS_RANK4.BANK11",
         "PerPkg": "1",
-        "UMask": "0x10",
+        "PublicDescription": "RD_CAS Access to Rank 0 : Bank 11",
+        "UMask": "0xb",
         "Unit": "iMC"
     },
     {
-        "BriefDescription": "RD_CAS Access to Rank 4; Bank 0",
-        "Counter": "0,1,2,3",
+        "BriefDescription": "RD_CAS Access to Rank 4; Bank 12",
         "EventCode": "0xB4",
-        "EventName": "UNC_M_RD_CAS_RANK4.BANK0",
+        "EventName": "UNC_M_RD_CAS_RANK4.BANK12",
         "PerPkg": "1",
+        "PublicDescription": "RD_CAS Access to Rank 0 : Bank 12",
+        "UMask": "0xc",
         "Unit": "iMC"
     },
     {
-        "BriefDescription": "RD_CAS Access to Rank 4; Bank 3",
-        "Counter": "0,1,2,3",
+        "BriefDescription": "RD_CAS Access to Rank 4; Bank 13",
         "EventCode": "0xB4",
-        "EventName": "UNC_M_RD_CAS_RANK4.BANK3",
+        "EventName": "UNC_M_RD_CAS_RANK4.BANK13",
         "PerPkg": "1",
-        "UMask": "0x3",
+        "PublicDescription": "RD_CAS Access to Rank 0 : Bank 13",
+        "UMask": "0xd",
         "Unit": "iMC"
     },
     {
-        "BriefDescription": "RD_CAS Access to Rank 4; Bank 5",
-        "Counter": "0,1,2,3",
+        "BriefDescription": "RD_CAS Access to Rank 4; Bank 14",
         "EventCode": "0xB4",
-        "EventName": "UNC_M_RD_CAS_RANK4.BANK5",
+        "EventName": "UNC_M_RD_CAS_RANK4.BANK14",
         "PerPkg": "1",
-        "UMask": "0x5",
+        "PublicDescription": "RD_CAS Access to Rank 0 : Bank 14",
+        "UMask": "0xe",
         "Unit": "iMC"
     },
     {
-        "BriefDescription": "RD_CAS Access to Rank 4; Bank 6",
-        "Counter": "0,1,2,3",
+        "BriefDescription": "RD_CAS Access to Rank 4; Bank 15",
         "EventCode": "0xB4",
-        "EventName": "UNC_M_RD_CAS_RANK4.BANK6",
+        "EventName": "UNC_M_RD_CAS_RANK4.BANK15",
         "PerPkg": "1",
-        "UMask": "0x6",
+        "PublicDescription": "RD_CAS Access to Rank 0 : Bank 15",
+        "UMask": "0xf",
         "Unit": "iMC"
     },
     {
-        "BriefDescription": "RD_CAS Access to Rank 4; Bank 7",
-        "Counter": "0,1,2,3",
+        "BriefDescription": "RD_CAS Access to Rank 4; Bank 2",
         "EventCode": "0xB4",
-        "EventName": "UNC_M_RD_CAS_RANK4.BANK7",
+        "EventName": "UNC_M_RD_CAS_RANK4.BANK2",
         "PerPkg": "1",
-        "UMask": "0x7",
+        "PublicDescription": "RD_CAS Access to Rank 0 : Bank 2",
+        "UMask": "0x2",
         "Unit": "iMC"
     },
     {
-        "BriefDescription": "RD_CAS Access to Rank 4; Bank 9",
-        "Counter": "0,1,2,3",
+        "BriefDescription": "RD_CAS Access to Rank 4; Bank 3",
         "EventCode": "0xB4",
-        "EventName": "UNC_M_RD_CAS_RANK4.BANK9",
+        "EventName": "UNC_M_RD_CAS_RANK4.BANK3",
         "PerPkg": "1",
-        "UMask": "0x9",
+        "PublicDescription": "RD_CAS Access to Rank 0 : Bank 3",
+        "UMask": "0x3",
         "Unit": "iMC"
     },
     {
-        "BriefDescription": "RD_CAS Access to Rank 4; Bank 10",
-        "Counter": "0,1,2,3",
+        "BriefDescription": "RD_CAS Access to Rank 4; Bank 4",
         "EventCode": "0xB4",
-        "EventName": "UNC_M_RD_CAS_RANK4.BANK10",
+        "EventName": "UNC_M_RD_CAS_RANK4.BANK4",
         "PerPkg": "1",
-        "UMask": "0xA",
+        "PublicDescription": "RD_CAS Access to Rank 0 : Bank 4",
+        "UMask": "0x4",
         "Unit": "iMC"
     },
     {
-        "BriefDescription": "RD_CAS Access to Rank 4; Bank 11",
-        "Counter": "0,1,2,3",
+        "BriefDescription": "RD_CAS Access to Rank 4; Bank 5",
         "EventCode": "0xB4",
-        "EventName": "UNC_M_RD_CAS_RANK4.BANK11",
+        "EventName": "UNC_M_RD_CAS_RANK4.BANK5",
         "PerPkg": "1",
-        "UMask": "0xB",
+        "PublicDescription": "RD_CAS Access to Rank 0 : Bank 5",
+        "UMask": "0x5",
         "Unit": "iMC"
     },
     {
-        "BriefDescription": "RD_CAS Access to Rank 4; Bank 12",
-        "Counter": "0,1,2,3",
+        "BriefDescription": "RD_CAS Access to Rank 4; Bank 6",
         "EventCode": "0xB4",
-        "EventName": "UNC_M_RD_CAS_RANK4.BANK12",
+        "EventName": "UNC_M_RD_CAS_RANK4.BANK6",
         "PerPkg": "1",
-        "UMask": "0xC",
+        "PublicDescription": "RD_CAS Access to Rank 0 : Bank 6",
+        "UMask": "0x6",
         "Unit": "iMC"
     },
     {
-        "BriefDescription": "RD_CAS Access to Rank 4; Bank 13",
-        "Counter": "0,1,2,3",
+        "BriefDescription": "RD_CAS Access to Rank 4; Bank 7",
         "EventCode": "0xB4",
-        "EventName": "UNC_M_RD_CAS_RANK4.BANK13",
+        "EventName": "UNC_M_RD_CAS_RANK4.BANK7",
         "PerPkg": "1",
-        "UMask": "0xD",
+        "PublicDescription": "RD_CAS Access to Rank 0 : Bank 7",
+        "UMask": "0x7",
         "Unit": "iMC"
     },
     {
-        "BriefDescription": "RD_CAS Access to Rank 4; Bank 14",
-        "Counter": "0,1,2,3",
+        "BriefDescription": "RD_CAS Access to Rank 4; Bank 8",
         "EventCode": "0xB4",
-        "EventName": "UNC_M_RD_CAS_RANK4.BANK14",
+        "EventName": "UNC_M_RD_CAS_RANK4.BANK8",
         "PerPkg": "1",
-        "UMask": "0xE",
+        "PublicDescription": "RD_CAS Access to Rank 0 : Bank 8",
+        "UMask": "0x8",
         "Unit": "iMC"
     },
     {
-        "BriefDescription": "RD_CAS Access to Rank 4; Bank 15",
-        "Counter": "0,1,2,3",
+        "BriefDescription": "RD_CAS Access to Rank 4; Bank 9",
         "EventCode": "0xB4",
-        "EventName": "UNC_M_RD_CAS_RANK4.BANK15",
+        "EventName": "UNC_M_RD_CAS_RANK4.BANK9",
         "PerPkg": "1",
-        "UMask": "0xF",
+        "PublicDescription": "RD_CAS Access to Rank 0 : Bank 9",
+        "UMask": "0x9",
         "Unit": "iMC"
     },
     {
         "BriefDescription": "RD_CAS Access to Rank 4; Bank Group 0 (Banks =
0-3)",
-        "Counter": "0,1,2,3",
         "EventCode": "0xB4",
         "EventName": "UNC_M_RD_CAS_RANK4.BANKG0",
         "PerPkg": "1",
+        "PublicDescription": "RD_CAS Access to Rank 0 : Bank Group 0 (Bank=
s 0-3)",
         "UMask": "0x11",
         "Unit": "iMC"
     },
     {
         "BriefDescription": "RD_CAS Access to Rank 4; Bank Group 1 (Banks =
4-7)",
-        "Counter": "0,1,2,3",
         "EventCode": "0xB4",
         "EventName": "UNC_M_RD_CAS_RANK4.BANKG1",
         "PerPkg": "1",
+        "PublicDescription": "RD_CAS Access to Rank 0 : Bank Group 1 (Bank=
s 4-7)",
         "UMask": "0x12",
         "Unit": "iMC"
     },
     {
         "BriefDescription": "RD_CAS Access to Rank 4; Bank Group 2 (Banks =
8-11)",
-        "Counter": "0,1,2,3",
         "EventCode": "0xB4",
         "EventName": "UNC_M_RD_CAS_RANK4.BANKG2",
         "PerPkg": "1",
+        "PublicDescription": "RD_CAS Access to Rank 0 : Bank Group 2 (Bank=
s 8-11)",
         "UMask": "0x13",
         "Unit": "iMC"
     },
     {
         "BriefDescription": "RD_CAS Access to Rank 4; Bank Group 3 (Banks =
12-15)",
-        "Counter": "0,1,2,3",
         "EventCode": "0xB4",
         "EventName": "UNC_M_RD_CAS_RANK4.BANKG3",
         "PerPkg": "1",
+        "PublicDescription": "RD_CAS Access to Rank 0 : Bank Group 3 (Bank=
s 12-15)",
         "UMask": "0x14",
         "Unit": "iMC"
     },
     {
-        "BriefDescription": "RD_CAS Access to Rank 5; Bank 1",
-        "Counter": "0,1,2,3",
+        "BriefDescription": "RD_CAS Access to Rank 5; All Banks",
         "EventCode": "0xB5",
-        "EventName": "UNC_M_RD_CAS_RANK5.BANK1",
+        "EventName": "UNC_M_RD_CAS_RANK5.ALLBANKS",
         "PerPkg": "1",
-        "UMask": "0x1",
+        "PublicDescription": "RD_CAS Access to Rank 0 : All Banks",
+        "UMask": "0x10",
         "Unit": "iMC"
     },
     {
-        "BriefDescription": "RD_CAS Access to Rank 5; Bank 2",
-        "Counter": "0,1,2,3",
+        "BriefDescription": "RD_CAS Access to Rank 5; Bank 0",
         "EventCode": "0xB5",
-        "EventName": "UNC_M_RD_CAS_RANK5.BANK2",
+        "EventName": "UNC_M_RD_CAS_RANK5.BANK0",
         "PerPkg": "1",
-        "UMask": "0x2",
+        "PublicDescription": "RD_CAS Access to Rank 0 : Bank 0",
         "Unit": "iMC"
     },
     {
-        "BriefDescription": "RD_CAS Access to Rank 5; Bank 4",
-        "Counter": "0,1,2,3",
+        "BriefDescription": "RD_CAS Access to Rank 5; Bank 1",
         "EventCode": "0xB5",
-        "EventName": "UNC_M_RD_CAS_RANK5.BANK4",
+        "EventName": "UNC_M_RD_CAS_RANK5.BANK1",
         "PerPkg": "1",
-        "UMask": "0x4",
+        "PublicDescription": "RD_CAS Access to Rank 0 : Bank 1",
+        "UMask": "0x1",
         "Unit": "iMC"
     },
     {
-        "BriefDescription": "RD_CAS Access to Rank 5; Bank 8",
-        "Counter": "0,1,2,3",
+        "BriefDescription": "RD_CAS Access to Rank 5; Bank 10",
         "EventCode": "0xB5",
-        "EventName": "UNC_M_RD_CAS_RANK5.BANK8",
+        "EventName": "UNC_M_RD_CAS_RANK5.BANK10",
         "PerPkg": "1",
-        "UMask": "0x8",
+        "PublicDescription": "RD_CAS Access to Rank 0 : Bank 10",
+        "UMask": "0xa",
         "Unit": "iMC"
     },
     {
-        "BriefDescription": "RD_CAS Access to Rank 5; All Banks",
-        "Counter": "0,1,2,3",
+        "BriefDescription": "RD_CAS Access to Rank 5; Bank 11",
         "EventCode": "0xB5",
-        "EventName": "UNC_M_RD_CAS_RANK5.ALLBANKS",
+        "EventName": "UNC_M_RD_CAS_RANK5.BANK11",
         "PerPkg": "1",
-        "UMask": "0x10",
+        "PublicDescription": "RD_CAS Access to Rank 0 : Bank 11",
+        "UMask": "0xb",
         "Unit": "iMC"
     },
     {
-        "BriefDescription": "RD_CAS Access to Rank 5; Bank 0",
-        "Counter": "0,1,2,3",
+        "BriefDescription": "RD_CAS Access to Rank 5; Bank 12",
         "EventCode": "0xB5",
-        "EventName": "UNC_M_RD_CAS_RANK5.BANK0",
+        "EventName": "UNC_M_RD_CAS_RANK5.BANK12",
         "PerPkg": "1",
+        "PublicDescription": "RD_CAS Access to Rank 0 : Bank 12",
+        "UMask": "0xc",
         "Unit": "iMC"
     },
     {
-        "BriefDescription": "RD_CAS Access to Rank 5; Bank 3",
-        "Counter": "0,1,2,3",
+        "BriefDescription": "RD_CAS Access to Rank 5; Bank 13",
         "EventCode": "0xB5",
-        "EventName": "UNC_M_RD_CAS_RANK5.BANK3",
+        "EventName": "UNC_M_RD_CAS_RANK5.BANK13",
         "PerPkg": "1",
-        "UMask": "0x3",
+        "PublicDescription": "RD_CAS Access to Rank 0 : Bank 13",
+        "UMask": "0xd",
         "Unit": "iMC"
     },
     {
-        "BriefDescription": "RD_CAS Access to Rank 5; Bank 5",
-        "Counter": "0,1,2,3",
+        "BriefDescription": "RD_CAS Access to Rank 5; Bank 14",
         "EventCode": "0xB5",
-        "EventName": "UNC_M_RD_CAS_RANK5.BANK5",
+        "EventName": "UNC_M_RD_CAS_RANK5.BANK14",
         "PerPkg": "1",
-        "UMask": "0x5",
+        "PublicDescription": "RD_CAS Access to Rank 0 : Bank 14",
+        "UMask": "0xe",
         "Unit": "iMC"
     },
     {
-        "BriefDescription": "RD_CAS Access to Rank 5; Bank 6",
-        "Counter": "0,1,2,3",
+        "BriefDescription": "RD_CAS Access to Rank 5; Bank 15",
         "EventCode": "0xB5",
-        "EventName": "UNC_M_RD_CAS_RANK5.BANK6",
+        "EventName": "UNC_M_RD_CAS_RANK5.BANK15",
         "PerPkg": "1",
-        "UMask": "0x6",
+        "PublicDescription": "RD_CAS Access to Rank 0 : Bank 15",
+        "UMask": "0xf",
         "Unit": "iMC"
     },
     {
-        "BriefDescription": "RD_CAS Access to Rank 5; Bank 7",
-        "Counter": "0,1,2,3",
+        "BriefDescription": "RD_CAS Access to Rank 5; Bank 2",
         "EventCode": "0xB5",
-        "EventName": "UNC_M_RD_CAS_RANK5.BANK7",
+        "EventName": "UNC_M_RD_CAS_RANK5.BANK2",
         "PerPkg": "1",
-        "UMask": "0x7",
+        "PublicDescription": "RD_CAS Access to Rank 0 : Bank 2",
+        "UMask": "0x2",
         "Unit": "iMC"
     },
     {
-        "BriefDescription": "RD_CAS Access to Rank 5; Bank 9",
-        "Counter": "0,1,2,3",
+        "BriefDescription": "RD_CAS Access to Rank 5; Bank 3",
         "EventCode": "0xB5",
-        "EventName": "UNC_M_RD_CAS_RANK5.BANK9",
+        "EventName": "UNC_M_RD_CAS_RANK5.BANK3",
         "PerPkg": "1",
-        "UMask": "0x9",
+        "PublicDescription": "RD_CAS Access to Rank 0 : Bank 3",
+        "UMask": "0x3",
         "Unit": "iMC"
     },
     {
-        "BriefDescription": "RD_CAS Access to Rank 5; Bank 10",
-        "Counter": "0,1,2,3",
+        "BriefDescription": "RD_CAS Access to Rank 5; Bank 4",
         "EventCode": "0xB5",
-        "EventName": "UNC_M_RD_CAS_RANK5.BANK10",
+        "EventName": "UNC_M_RD_CAS_RANK5.BANK4",
         "PerPkg": "1",
-        "UMask": "0xA",
+        "PublicDescription": "RD_CAS Access to Rank 0 : Bank 4",
+        "UMask": "0x4",
         "Unit": "iMC"
     },
     {
-        "BriefDescription": "RD_CAS Access to Rank 5; Bank 11",
-        "Counter": "0,1,2,3",
+        "BriefDescription": "RD_CAS Access to Rank 5; Bank 5",
         "EventCode": "0xB5",
-        "EventName": "UNC_M_RD_CAS_RANK5.BANK11",
+        "EventName": "UNC_M_RD_CAS_RANK5.BANK5",
         "PerPkg": "1",
-        "UMask": "0xB",
+        "PublicDescription": "RD_CAS Access to Rank 0 : Bank 5",
+        "UMask": "0x5",
         "Unit": "iMC"
     },
     {
-        "BriefDescription": "RD_CAS Access to Rank 5; Bank 12",
-        "Counter": "0,1,2,3",
+        "BriefDescription": "RD_CAS Access to Rank 5; Bank 6",
         "EventCode": "0xB5",
-        "EventName": "UNC_M_RD_CAS_RANK5.BANK12",
+        "EventName": "UNC_M_RD_CAS_RANK5.BANK6",
         "PerPkg": "1",
-        "UMask": "0xC",
+        "PublicDescription": "RD_CAS Access to Rank 0 : Bank 6",
+        "UMask": "0x6",
         "Unit": "iMC"
     },
     {
-        "BriefDescription": "RD_CAS Access to Rank 5; Bank 13",
-        "Counter": "0,1,2,3",
+        "BriefDescription": "RD_CAS Access to Rank 5; Bank 7",
         "EventCode": "0xB5",
-        "EventName": "UNC_M_RD_CAS_RANK5.BANK13",
+        "EventName": "UNC_M_RD_CAS_RANK5.BANK7",
         "PerPkg": "1",
-        "UMask": "0xD",
+        "PublicDescription": "RD_CAS Access to Rank 0 : Bank 7",
+        "UMask": "0x7",
         "Unit": "iMC"
     },
     {
-        "BriefDescription": "RD_CAS Access to Rank 5; Bank 14",
-        "Counter": "0,1,2,3",
+        "BriefDescription": "RD_CAS Access to Rank 5; Bank 8",
         "EventCode": "0xB5",
-        "EventName": "UNC_M_RD_CAS_RANK5.BANK14",
+        "EventName": "UNC_M_RD_CAS_RANK5.BANK8",
         "PerPkg": "1",
-        "UMask": "0xE",
+        "PublicDescription": "RD_CAS Access to Rank 0 : Bank 8",
+        "UMask": "0x8",
         "Unit": "iMC"
     },
     {
-        "BriefDescription": "RD_CAS Access to Rank 5; Bank 15",
-        "Counter": "0,1,2,3",
+        "BriefDescription": "RD_CAS Access to Rank 5; Bank 9",
         "EventCode": "0xB5",
-        "EventName": "UNC_M_RD_CAS_RANK5.BANK15",
+        "EventName": "UNC_M_RD_CAS_RANK5.BANK9",
         "PerPkg": "1",
-        "UMask": "0xF",
+        "PublicDescription": "RD_CAS Access to Rank 0 : Bank 9",
+        "UMask": "0x9",
         "Unit": "iMC"
     },
     {
         "BriefDescription": "RD_CAS Access to Rank 5; Bank Group 0 (Banks =
0-3)",
-        "Counter": "0,1,2,3",
         "EventCode": "0xB5",
         "EventName": "UNC_M_RD_CAS_RANK5.BANKG0",
         "PerPkg": "1",
+        "PublicDescription": "RD_CAS Access to Rank 0 : Bank Group 0 (Bank=
s 0-3)",
         "UMask": "0x11",
         "Unit": "iMC"
     },
     {
         "BriefDescription": "RD_CAS Access to Rank 5; Bank Group 1 (Banks =
4-7)",
-        "Counter": "0,1,2,3",
         "EventCode": "0xB5",
         "EventName": "UNC_M_RD_CAS_RANK5.BANKG1",
         "PerPkg": "1",
+        "PublicDescription": "RD_CAS Access to Rank 0 : Bank Group 1 (Bank=
s 4-7)",
         "UMask": "0x12",
         "Unit": "iMC"
     },
     {
         "BriefDescription": "RD_CAS Access to Rank 5; Bank Group 2 (Banks =
8-11)",
-        "Counter": "0,1,2,3",
         "EventCode": "0xB5",
         "EventName": "UNC_M_RD_CAS_RANK5.BANKG2",
         "PerPkg": "1",
+        "PublicDescription": "RD_CAS Access to Rank 0 : Bank Group 2 (Bank=
s 8-11)",
         "UMask": "0x13",
         "Unit": "iMC"
     },
     {
         "BriefDescription": "RD_CAS Access to Rank 5; Bank Group 3 (Banks =
12-15)",
-        "Counter": "0,1,2,3",
         "EventCode": "0xB5",
         "EventName": "UNC_M_RD_CAS_RANK5.BANKG3",
         "PerPkg": "1",
+        "PublicDescription": "RD_CAS Access to Rank 0 : Bank Group 3 (Bank=
s 12-15)",
         "UMask": "0x14",
         "Unit": "iMC"
     },
     {
-        "BriefDescription": "RD_CAS Access to Rank 6; Bank 1",
-        "Counter": "0,1,2,3",
+        "BriefDescription": "RD_CAS Access to Rank 6; All Banks",
         "EventCode": "0xB6",
-        "EventName": "UNC_M_RD_CAS_RANK6.BANK1",
+        "EventName": "UNC_M_RD_CAS_RANK6.ALLBANKS",
         "PerPkg": "1",
-        "UMask": "0x1",
+        "PublicDescription": "RD_CAS Access to Rank 0 : All Banks",
+        "UMask": "0x10",
         "Unit": "iMC"
     },
     {
-        "BriefDescription": "RD_CAS Access to Rank 6; Bank 2",
-        "Counter": "0,1,2,3",
+        "BriefDescription": "RD_CAS Access to Rank 6; Bank 0",
         "EventCode": "0xB6",
-        "EventName": "UNC_M_RD_CAS_RANK6.BANK2",
+        "EventName": "UNC_M_RD_CAS_RANK6.BANK0",
         "PerPkg": "1",
-        "UMask": "0x2",
+        "PublicDescription": "RD_CAS Access to Rank 0 : Bank 0",
         "Unit": "iMC"
     },
     {
-        "BriefDescription": "RD_CAS Access to Rank 6; Bank 4",
-        "Counter": "0,1,2,3",
+        "BriefDescription": "RD_CAS Access to Rank 6; Bank 1",
         "EventCode": "0xB6",
-        "EventName": "UNC_M_RD_CAS_RANK6.BANK4",
+        "EventName": "UNC_M_RD_CAS_RANK6.BANK1",
         "PerPkg": "1",
-        "UMask": "0x4",
+        "PublicDescription": "RD_CAS Access to Rank 0 : Bank 1",
+        "UMask": "0x1",
         "Unit": "iMC"
     },
     {
-        "BriefDescription": "RD_CAS Access to Rank 6; Bank 8",
-        "Counter": "0,1,2,3",
+        "BriefDescription": "RD_CAS Access to Rank 6; Bank 10",
         "EventCode": "0xB6",
-        "EventName": "UNC_M_RD_CAS_RANK6.BANK8",
+        "EventName": "UNC_M_RD_CAS_RANK6.BANK10",
         "PerPkg": "1",
-        "UMask": "0x8",
+        "PublicDescription": "RD_CAS Access to Rank 0 : Bank 10",
+        "UMask": "0xa",
         "Unit": "iMC"
     },
     {
-        "BriefDescription": "RD_CAS Access to Rank 6; All Banks",
-        "Counter": "0,1,2,3",
+        "BriefDescription": "RD_CAS Access to Rank 6; Bank 11",
         "EventCode": "0xB6",
-        "EventName": "UNC_M_RD_CAS_RANK6.ALLBANKS",
+        "EventName": "UNC_M_RD_CAS_RANK6.BANK11",
         "PerPkg": "1",
-        "UMask": "0x10",
+        "PublicDescription": "RD_CAS Access to Rank 0 : Bank 11",
+        "UMask": "0xb",
         "Unit": "iMC"
     },
     {
-        "BriefDescription": "RD_CAS Access to Rank 6; Bank 0",
-        "Counter": "0,1,2,3",
+        "BriefDescription": "RD_CAS Access to Rank 6; Bank 12",
         "EventCode": "0xB6",
-        "EventName": "UNC_M_RD_CAS_RANK6.BANK0",
+        "EventName": "UNC_M_RD_CAS_RANK6.BANK12",
         "PerPkg": "1",
+        "PublicDescription": "RD_CAS Access to Rank 0 : Bank 12",
+        "UMask": "0xc",
         "Unit": "iMC"
     },
     {
-        "BriefDescription": "RD_CAS Access to Rank 6; Bank 3",
-        "Counter": "0,1,2,3",
+        "BriefDescription": "RD_CAS Access to Rank 6; Bank 13",
         "EventCode": "0xB6",
-        "EventName": "UNC_M_RD_CAS_RANK6.BANK3",
+        "EventName": "UNC_M_RD_CAS_RANK6.BANK13",
         "PerPkg": "1",
-        "UMask": "0x3",
+        "PublicDescription": "RD_CAS Access to Rank 0 : Bank 13",
+        "UMask": "0xd",
         "Unit": "iMC"
     },
     {
-        "BriefDescription": "RD_CAS Access to Rank 6; Bank 5",
-        "Counter": "0,1,2,3",
+        "BriefDescription": "RD_CAS Access to Rank 6; Bank 14",
         "EventCode": "0xB6",
-        "EventName": "UNC_M_RD_CAS_RANK6.BANK5",
+        "EventName": "UNC_M_RD_CAS_RANK6.BANK14",
         "PerPkg": "1",
-        "UMask": "0x5",
+        "PublicDescription": "RD_CAS Access to Rank 0 : Bank 14",
+        "UMask": "0xe",
         "Unit": "iMC"
     },
     {
-        "BriefDescription": "RD_CAS Access to Rank 6; Bank 6",
-        "Counter": "0,1,2,3",
+        "BriefDescription": "RD_CAS Access to Rank 6; Bank 15",
         "EventCode": "0xB6",
-        "EventName": "UNC_M_RD_CAS_RANK6.BANK6",
+        "EventName": "UNC_M_RD_CAS_RANK6.BANK15",
         "PerPkg": "1",
-        "UMask": "0x6",
+        "PublicDescription": "RD_CAS Access to Rank 0 : Bank 15",
+        "UMask": "0xf",
         "Unit": "iMC"
     },
     {
-        "BriefDescription": "RD_CAS Access to Rank 6; Bank 7",
-        "Counter": "0,1,2,3",
+        "BriefDescription": "RD_CAS Access to Rank 6; Bank 2",
         "EventCode": "0xB6",
-        "EventName": "UNC_M_RD_CAS_RANK6.BANK7",
+        "EventName": "UNC_M_RD_CAS_RANK6.BANK2",
         "PerPkg": "1",
-        "UMask": "0x7",
+        "PublicDescription": "RD_CAS Access to Rank 0 : Bank 2",
+        "UMask": "0x2",
         "Unit": "iMC"
     },
     {
-        "BriefDescription": "RD_CAS Access to Rank 6; Bank 9",
-        "Counter": "0,1,2,3",
+        "BriefDescription": "RD_CAS Access to Rank 6; Bank 3",
         "EventCode": "0xB6",
-        "EventName": "UNC_M_RD_CAS_RANK6.BANK9",
+        "EventName": "UNC_M_RD_CAS_RANK6.BANK3",
         "PerPkg": "1",
-        "UMask": "0x9",
+        "PublicDescription": "RD_CAS Access to Rank 0 : Bank 3",
+        "UMask": "0x3",
         "Unit": "iMC"
     },
     {
-        "BriefDescription": "RD_CAS Access to Rank 6; Bank 10",
-        "Counter": "0,1,2,3",
+        "BriefDescription": "RD_CAS Access to Rank 6; Bank 4",
         "EventCode": "0xB6",
-        "EventName": "UNC_M_RD_CAS_RANK6.BANK10",
+        "EventName": "UNC_M_RD_CAS_RANK6.BANK4",
         "PerPkg": "1",
-        "UMask": "0xA",
+        "PublicDescription": "RD_CAS Access to Rank 0 : Bank 4",
+        "UMask": "0x4",
         "Unit": "iMC"
     },
     {
-        "BriefDescription": "RD_CAS Access to Rank 6; Bank 11",
-        "Counter": "0,1,2,3",
+        "BriefDescription": "RD_CAS Access to Rank 6; Bank 5",
         "EventCode": "0xB6",
-        "EventName": "UNC_M_RD_CAS_RANK6.BANK11",
+        "EventName": "UNC_M_RD_CAS_RANK6.BANK5",
         "PerPkg": "1",
-        "UMask": "0xB",
+        "PublicDescription": "RD_CAS Access to Rank 0 : Bank 5",
+        "UMask": "0x5",
         "Unit": "iMC"
     },
     {
-        "BriefDescription": "RD_CAS Access to Rank 6; Bank 12",
-        "Counter": "0,1,2,3",
+        "BriefDescription": "RD_CAS Access to Rank 6; Bank 6",
         "EventCode": "0xB6",
-        "EventName": "UNC_M_RD_CAS_RANK6.BANK12",
+        "EventName": "UNC_M_RD_CAS_RANK6.BANK6",
         "PerPkg": "1",
-        "UMask": "0xC",
+        "PublicDescription": "RD_CAS Access to Rank 0 : Bank 6",
+        "UMask": "0x6",
         "Unit": "iMC"
     },
     {
-        "BriefDescription": "RD_CAS Access to Rank 6; Bank 13",
-        "Counter": "0,1,2,3",
+        "BriefDescription": "RD_CAS Access to Rank 6; Bank 7",
         "EventCode": "0xB6",
-        "EventName": "UNC_M_RD_CAS_RANK6.BANK13",
+        "EventName": "UNC_M_RD_CAS_RANK6.BANK7",
         "PerPkg": "1",
-        "UMask": "0xD",
+        "PublicDescription": "RD_CAS Access to Rank 0 : Bank 7",
+        "UMask": "0x7",
         "Unit": "iMC"
     },
     {
-        "BriefDescription": "RD_CAS Access to Rank 6; Bank 14",
-        "Counter": "0,1,2,3",
+        "BriefDescription": "RD_CAS Access to Rank 6; Bank 8",
         "EventCode": "0xB6",
-        "EventName": "UNC_M_RD_CAS_RANK6.BANK14",
+        "EventName": "UNC_M_RD_CAS_RANK6.BANK8",
         "PerPkg": "1",
-        "UMask": "0xE",
+        "PublicDescription": "RD_CAS Access to Rank 0 : Bank 8",
+        "UMask": "0x8",
         "Unit": "iMC"
     },
     {
-        "BriefDescription": "RD_CAS Access to Rank 6; Bank 15",
-        "Counter": "0,1,2,3",
+        "BriefDescription": "RD_CAS Access to Rank 6; Bank 9",
         "EventCode": "0xB6",
-        "EventName": "UNC_M_RD_CAS_RANK6.BANK15",
+        "EventName": "UNC_M_RD_CAS_RANK6.BANK9",
         "PerPkg": "1",
-        "UMask": "0xF",
+        "PublicDescription": "RD_CAS Access to Rank 0 : Bank 9",
+        "UMask": "0x9",
         "Unit": "iMC"
     },
     {
         "BriefDescription": "RD_CAS Access to Rank 6; Bank Group 0 (Banks =
0-3)",
-        "Counter": "0,1,2,3",
         "EventCode": "0xB6",
         "EventName": "UNC_M_RD_CAS_RANK6.BANKG0",
         "PerPkg": "1",
+        "PublicDescription": "RD_CAS Access to Rank 0 : Bank Group 0 (Bank=
s 0-3)",
         "UMask": "0x11",
         "Unit": "iMC"
     },
     {
         "BriefDescription": "RD_CAS Access to Rank 6; Bank Group 1 (Banks =
4-7)",
-        "Counter": "0,1,2,3",
         "EventCode": "0xB6",
         "EventName": "UNC_M_RD_CAS_RANK6.BANKG1",
         "PerPkg": "1",
+        "PublicDescription": "RD_CAS Access to Rank 0 : Bank Group 1 (Bank=
s 4-7)",
         "UMask": "0x12",
         "Unit": "iMC"
     },
     {
         "BriefDescription": "RD_CAS Access to Rank 6; Bank Group 2 (Banks =
8-11)",
-        "Counter": "0,1,2,3",
         "EventCode": "0xB6",
         "EventName": "UNC_M_RD_CAS_RANK6.BANKG2",
         "PerPkg": "1",
+        "PublicDescription": "RD_CAS Access to Rank 0 : Bank Group 2 (Bank=
s 8-11)",
         "UMask": "0x13",
         "Unit": "iMC"
     },
     {
         "BriefDescription": "RD_CAS Access to Rank 6; Bank Group 3 (Banks =
12-15)",
-        "Counter": "0,1,2,3",
         "EventCode": "0xB6",
         "EventName": "UNC_M_RD_CAS_RANK6.BANKG3",
         "PerPkg": "1",
+        "PublicDescription": "RD_CAS Access to Rank 0 : Bank Group 3 (Bank=
s 12-15)",
         "UMask": "0x14",
         "Unit": "iMC"
     },
     {
-        "BriefDescription": "RD_CAS Access to Rank 7; Bank 1",
-        "Counter": "0,1,2,3",
+        "BriefDescription": "RD_CAS Access to Rank 7; All Banks",
         "EventCode": "0xB7",
-        "EventName": "UNC_M_RD_CAS_RANK7.BANK1",
+        "EventName": "UNC_M_RD_CAS_RANK7.ALLBANKS",
         "PerPkg": "1",
-        "UMask": "0x1",
+        "PublicDescription": "RD_CAS Access to Rank 0 : All Banks",
+        "UMask": "0x10",
         "Unit": "iMC"
     },
     {
-        "BriefDescription": "RD_CAS Access to Rank 7; Bank 2",
-        "Counter": "0,1,2,3",
+        "BriefDescription": "RD_CAS Access to Rank 7; Bank 0",
         "EventCode": "0xB7",
-        "EventName": "UNC_M_RD_CAS_RANK7.BANK2",
+        "EventName": "UNC_M_RD_CAS_RANK7.BANK0",
         "PerPkg": "1",
-        "UMask": "0x2",
+        "PublicDescription": "RD_CAS Access to Rank 0 : Bank 0",
         "Unit": "iMC"
     },
     {
-        "BriefDescription": "RD_CAS Access to Rank 7; Bank 4",
-        "Counter": "0,1,2,3",
+        "BriefDescription": "RD_CAS Access to Rank 7; Bank 1",
         "EventCode": "0xB7",
-        "EventName": "UNC_M_RD_CAS_RANK7.BANK4",
+        "EventName": "UNC_M_RD_CAS_RANK7.BANK1",
         "PerPkg": "1",
-        "UMask": "0x4",
+        "PublicDescription": "RD_CAS Access to Rank 0 : Bank 1",
+        "UMask": "0x1",
         "Unit": "iMC"
     },
     {
-        "BriefDescription": "RD_CAS Access to Rank 7; Bank 8",
-        "Counter": "0,1,2,3",
+        "BriefDescription": "RD_CAS Access to Rank 7; Bank 10",
         "EventCode": "0xB7",
-        "EventName": "UNC_M_RD_CAS_RANK7.BANK8",
+        "EventName": "UNC_M_RD_CAS_RANK7.BANK10",
         "PerPkg": "1",
-        "UMask": "0x8",
+        "PublicDescription": "RD_CAS Access to Rank 0 : Bank 10",
+        "UMask": "0xa",
         "Unit": "iMC"
     },
     {
-        "BriefDescription": "RD_CAS Access to Rank 7; All Banks",
-        "Counter": "0,1,2,3",
+        "BriefDescription": "RD_CAS Access to Rank 7; Bank 11",
         "EventCode": "0xB7",
-        "EventName": "UNC_M_RD_CAS_RANK7.ALLBANKS",
+        "EventName": "UNC_M_RD_CAS_RANK7.BANK11",
         "PerPkg": "1",
-        "UMask": "0x10",
+        "PublicDescription": "RD_CAS Access to Rank 0 : Bank 11",
+        "UMask": "0xb",
         "Unit": "iMC"
     },
     {
-        "BriefDescription": "RD_CAS Access to Rank 7; Bank 0",
-        "Counter": "0,1,2,3",
+        "BriefDescription": "RD_CAS Access to Rank 7; Bank 12",
         "EventCode": "0xB7",
-        "EventName": "UNC_M_RD_CAS_RANK7.BANK0",
+        "EventName": "UNC_M_RD_CAS_RANK7.BANK12",
         "PerPkg": "1",
+        "PublicDescription": "RD_CAS Access to Rank 0 : Bank 12",
+        "UMask": "0xc",
         "Unit": "iMC"
     },
     {
-        "BriefDescription": "RD_CAS Access to Rank 7; Bank 3",
-        "Counter": "0,1,2,3",
+        "BriefDescription": "RD_CAS Access to Rank 7; Bank 13",
         "EventCode": "0xB7",
-        "EventName": "UNC_M_RD_CAS_RANK7.BANK3",
+        "EventName": "UNC_M_RD_CAS_RANK7.BANK13",
         "PerPkg": "1",
-        "UMask": "0x3",
+        "PublicDescription": "RD_CAS Access to Rank 0 : Bank 13",
+        "UMask": "0xd",
         "Unit": "iMC"
     },
     {
-        "BriefDescription": "RD_CAS Access to Rank 7; Bank 5",
-        "Counter": "0,1,2,3",
+        "BriefDescription": "RD_CAS Access to Rank 7; Bank 14",
         "EventCode": "0xB7",
-        "EventName": "UNC_M_RD_CAS_RANK7.BANK5",
+        "EventName": "UNC_M_RD_CAS_RANK7.BANK14",
         "PerPkg": "1",
-        "UMask": "0x5",
+        "PublicDescription": "RD_CAS Access to Rank 0 : Bank 14",
+        "UMask": "0xe",
         "Unit": "iMC"
     },
     {
-        "BriefDescription": "RD_CAS Access to Rank 7; Bank 6",
-        "Counter": "0,1,2,3",
+        "BriefDescription": "RD_CAS Access to Rank 7; Bank 15",
         "EventCode": "0xB7",
-        "EventName": "UNC_M_RD_CAS_RANK7.BANK6",
+        "EventName": "UNC_M_RD_CAS_RANK7.BANK15",
         "PerPkg": "1",
-        "UMask": "0x6",
+        "PublicDescription": "RD_CAS Access to Rank 0 : Bank 15",
+        "UMask": "0xf",
         "Unit": "iMC"
     },
     {
-        "BriefDescription": "RD_CAS Access to Rank 7; Bank 7",
-        "Counter": "0,1,2,3",
+        "BriefDescription": "RD_CAS Access to Rank 7; Bank 2",
         "EventCode": "0xB7",
-        "EventName": "UNC_M_RD_CAS_RANK7.BANK7",
+        "EventName": "UNC_M_RD_CAS_RANK7.BANK2",
         "PerPkg": "1",
-        "UMask": "0x7",
+        "PublicDescription": "RD_CAS Access to Rank 0 : Bank 2",
+        "UMask": "0x2",
         "Unit": "iMC"
     },
     {
-        "BriefDescription": "RD_CAS Access to Rank 7; Bank 9",
-        "Counter": "0,1,2,3",
+        "BriefDescription": "RD_CAS Access to Rank 7; Bank 3",
         "EventCode": "0xB7",
-        "EventName": "UNC_M_RD_CAS_RANK7.BANK9",
+        "EventName": "UNC_M_RD_CAS_RANK7.BANK3",
         "PerPkg": "1",
-        "UMask": "0x9",
+        "PublicDescription": "RD_CAS Access to Rank 0 : Bank 3",
+        "UMask": "0x3",
         "Unit": "iMC"
     },
     {
-        "BriefDescription": "RD_CAS Access to Rank 7; Bank 10",
-        "Counter": "0,1,2,3",
+        "BriefDescription": "RD_CAS Access to Rank 7; Bank 4",
         "EventCode": "0xB7",
-        "EventName": "UNC_M_RD_CAS_RANK7.BANK10",
+        "EventName": "UNC_M_RD_CAS_RANK7.BANK4",
         "PerPkg": "1",
-        "UMask": "0xA",
+        "PublicDescription": "RD_CAS Access to Rank 0 : Bank 4",
+        "UMask": "0x4",
         "Unit": "iMC"
     },
     {
-        "BriefDescription": "RD_CAS Access to Rank 7; Bank 11",
-        "Counter": "0,1,2,3",
+        "BriefDescription": "RD_CAS Access to Rank 7; Bank 5",
         "EventCode": "0xB7",
-        "EventName": "UNC_M_RD_CAS_RANK7.BANK11",
+        "EventName": "UNC_M_RD_CAS_RANK7.BANK5",
         "PerPkg": "1",
-        "UMask": "0xB",
+        "PublicDescription": "RD_CAS Access to Rank 0 : Bank 5",
+        "UMask": "0x5",
         "Unit": "iMC"
     },
     {
-        "BriefDescription": "RD_CAS Access to Rank 7; Bank 12",
-        "Counter": "0,1,2,3",
+        "BriefDescription": "RD_CAS Access to Rank 7; Bank 6",
         "EventCode": "0xB7",
-        "EventName": "UNC_M_RD_CAS_RANK7.BANK12",
+        "EventName": "UNC_M_RD_CAS_RANK7.BANK6",
         "PerPkg": "1",
-        "UMask": "0xC",
+        "PublicDescription": "RD_CAS Access to Rank 0 : Bank 6",
+        "UMask": "0x6",
         "Unit": "iMC"
     },
     {
-        "BriefDescription": "RD_CAS Access to Rank 7; Bank 13",
-        "Counter": "0,1,2,3",
+        "BriefDescription": "RD_CAS Access to Rank 7; Bank 7",
         "EventCode": "0xB7",
-        "EventName": "UNC_M_RD_CAS_RANK7.BANK13",
+        "EventName": "UNC_M_RD_CAS_RANK7.BANK7",
         "PerPkg": "1",
-        "UMask": "0xD",
+        "PublicDescription": "RD_CAS Access to Rank 0 : Bank 7",
+        "UMask": "0x7",
         "Unit": "iMC"
     },
     {
-        "BriefDescription": "RD_CAS Access to Rank 7; Bank 14",
-        "Counter": "0,1,2,3",
+        "BriefDescription": "RD_CAS Access to Rank 7; Bank 8",
         "EventCode": "0xB7",
-        "EventName": "UNC_M_RD_CAS_RANK7.BANK14",
+        "EventName": "UNC_M_RD_CAS_RANK7.BANK8",
         "PerPkg": "1",
-        "UMask": "0xE",
+        "PublicDescription": "RD_CAS Access to Rank 0 : Bank 8",
+        "UMask": "0x8",
         "Unit": "iMC"
     },
     {
-        "BriefDescription": "RD_CAS Access to Rank 7; Bank 15",
-        "Counter": "0,1,2,3",
+        "BriefDescription": "RD_CAS Access to Rank 7; Bank 9",
         "EventCode": "0xB7",
-        "EventName": "UNC_M_RD_CAS_RANK7.BANK15",
+        "EventName": "UNC_M_RD_CAS_RANK7.BANK9",
         "PerPkg": "1",
-        "UMask": "0xF",
+        "PublicDescription": "RD_CAS Access to Rank 0 : Bank 9",
+        "UMask": "0x9",
         "Unit": "iMC"
     },
     {
         "BriefDescription": "RD_CAS Access to Rank 7; Bank Group 0 (Banks =
0-3)",
-        "Counter": "0,1,2,3",
         "EventCode": "0xB7",
         "EventName": "UNC_M_RD_CAS_RANK7.BANKG0",
         "PerPkg": "1",
+        "PublicDescription": "RD_CAS Access to Rank 0 : Bank Group 0 (Bank=
s 0-3)",
         "UMask": "0x11",
         "Unit": "iMC"
     },
     {
         "BriefDescription": "RD_CAS Access to Rank 7; Bank Group 1 (Banks =
4-7)",
-        "Counter": "0,1,2,3",
         "EventCode": "0xB7",
         "EventName": "UNC_M_RD_CAS_RANK7.BANKG1",
         "PerPkg": "1",
+        "PublicDescription": "RD_CAS Access to Rank 0 : Bank Group 1 (Bank=
s 4-7)",
         "UMask": "0x12",
         "Unit": "iMC"
     },
     {
         "BriefDescription": "RD_CAS Access to Rank 7; Bank Group 2 (Banks =
8-11)",
-        "Counter": "0,1,2,3",
         "EventCode": "0xB7",
         "EventName": "UNC_M_RD_CAS_RANK7.BANKG2",
         "PerPkg": "1",
+        "PublicDescription": "RD_CAS Access to Rank 0 : Bank Group 2 (Bank=
s 8-11)",
         "UMask": "0x13",
         "Unit": "iMC"
     },
     {
         "BriefDescription": "RD_CAS Access to Rank 7; Bank Group 3 (Banks =
12-15)",
-        "Counter": "0,1,2,3",
         "EventCode": "0xB7",
         "EventName": "UNC_M_RD_CAS_RANK7.BANKG3",
         "PerPkg": "1",
+        "PublicDescription": "RD_CAS Access to Rank 0 : Bank Group 3 (Bank=
s 12-15)",
         "UMask": "0x14",
         "Unit": "iMC"
     },
     {
         "BriefDescription": "Read Pending Queue Not Empty",
-        "Counter": "0,1,2,3",
         "EventCode": "0x11",
         "EventName": "UNC_M_RPQ_CYCLES_NE",
         "PerPkg": "1",
+        "PublicDescription": "Counts the number of cycles that the Read Pe=
nding Queue is not empty.  This can then be used to calculate the average o=
ccupancy (in conjunction with the Read Pending Queue Occupancy count).  The=
 RPQ is used to schedule reads out to the memory controller and to track th=
e requests.  Requests allocate into the RPQ soon after they enter the memor=
y controller, and need credits for an entry in this buffer before being sen=
t from the HA to the iMC.  They deallocate after the CAS command has been i=
ssued to memory.  This filter is to be used in conjunction with the occupan=
cy filter so that one can correctly track the average occupancies for sched=
ulable entries and scheduled requests.",
         "Unit": "iMC"
     },
     {
         "BriefDescription": "Read Pending Queue Allocations",
-        "Counter": "0,1,2,3",
         "EventCode": "0x10",
         "EventName": "UNC_M_RPQ_INSERTS",
         "PerPkg": "1",
+        "PublicDescription": "Counts the number of allocations into the Re=
ad Pending Queue.  This queue is used to schedule reads out to the memory c=
ontroller and to track the requests.  Requests allocate into the RPQ soon a=
fter they enter the memory controller, and need credits for an entry in thi=
s buffer before being sent from the HA to the iMC.  They deallocate after t=
he CAS command has been issued to memory.  This includes both ISOCH and non=
-ISOCH requests.",
         "Unit": "iMC"
     },
     {
         "BriefDescription": "VMSE MXB write buffer occupancy",
-        "Counter": "0,1,2,3",
         "EventCode": "0x91",
         "EventName": "UNC_M_VMSE_MXB_WR_OCCUPANCY",
         "PerPkg": "1",
         "Unit": "iMC"
     },
     {
-        "BriefDescription": "VMSE WR PUSH issued; VMSE write PUSH issued i=
n WMM",
-        "Counter": "0,1,2,3",
+        "BriefDescription": "VMSE WR PUSH issued; VMSE write PUSH issued i=
n RMM",
         "EventCode": "0x90",
-        "EventName": "UNC_M_VMSE_WR_PUSH.WMM",
+        "EventName": "UNC_M_VMSE_WR_PUSH.RMM",
         "PerPkg": "1",
-        "UMask": "0x1",
+        "UMask": "0x2",
         "Unit": "iMC"
     },
     {
-        "BriefDescription": "VMSE WR PUSH issued; VMSE write PUSH issued i=
n RMM",
-        "Counter": "0,1,2,3",
+        "BriefDescription": "VMSE WR PUSH issued; VMSE write PUSH issued i=
n WMM",
         "EventCode": "0x90",
-        "EventName": "UNC_M_VMSE_WR_PUSH.RMM",
+        "EventName": "UNC_M_VMSE_WR_PUSH.WMM",
         "PerPkg": "1",
-        "UMask": "0x2",
+        "UMask": "0x1",
         "Unit": "iMC"
     },
     {
         "BriefDescription": "Transition from WMM to RMM because of low thr=
eshold; Transition from WMM to RMM because of starve counter",
-        "Counter": "0,1,2,3",
         "EventCode": "0xC0",
         "EventName": "UNC_M_WMM_TO_RMM.LOW_THRESH",
         "PerPkg": "1",
@@ -1703,7 +1694,6 @@
     },
     {
         "BriefDescription": "Transition from WMM to RMM because of low thr=
eshold",
-        "Counter": "0,1,2,3",
         "EventCode": "0xC0",
         "EventName": "UNC_M_WMM_TO_RMM.STARVE",
         "PerPkg": "1",
@@ -1712,7 +1702,6 @@
     },
     {
         "BriefDescription": "Transition from WMM to RMM because of low thr=
eshold",
-        "Counter": "0,1,2,3",
         "EventCode": "0xC0",
         "EventName": "UNC_M_WMM_TO_RMM.VMSE_RETRY",
         "PerPkg": "1",
@@ -1721,1177 +1710,1169 @@
     },
     {
         "BriefDescription": "Write Pending Queue Full Cycles",
-        "Counter": "0,1,2,3",
         "EventCode": "0x22",
         "EventName": "UNC_M_WPQ_CYCLES_FULL",
         "PerPkg": "1",
+        "PublicDescription": "Counts the number of cycles when the Write P=
ending Queue is full.  When the WPQ is full, the HA will not be able to iss=
ue any additional read requests into the iMC.  This count should be similar=
 count in the HA which tracks the number of cycles that the HA has no WPQ c=
redits, just somewhat smaller to account for the credit return overhead.",
         "Unit": "iMC"
     },
     {
         "BriefDescription": "Write Pending Queue Not Empty",
-        "Counter": "0,1,2,3",
         "EventCode": "0x21",
         "EventName": "UNC_M_WPQ_CYCLES_NE",
         "PerPkg": "1",
+        "PublicDescription": "Counts the number of cycles that the Write P=
ending Queue is not empty.  This can then be used to calculate the average =
queue occupancy (in conjunction with the WPQ Occupancy Accumulation count).=
  The WPQ is used to schedule write out to the memory controller and to tra=
ck the writes.  Requests allocate into the WPQ soon after they enter the me=
mory controller, and need credits for an entry in this buffer before being =
sent from the HA to the iMC.  They deallocate after being issued to DRAM.  =
Write requests themselves are able to complete (from the perspective of the=
 rest of the system) as soon they have posted to the iMC.  This is not to b=
e confused with actually performing the write to DRAM.  Therefore, the aver=
age latency for this queue is actually not useful for deconstruction interm=
ediate write latencies.",
         "Unit": "iMC"
     },
     {
         "BriefDescription": "Write Pending Queue CAM Match",
-        "Counter": "0,1,2,3",
         "EventCode": "0x23",
         "EventName": "UNC_M_WPQ_READ_HIT",
         "PerPkg": "1",
+        "PublicDescription": "Counts the number of times a request hits in=
 the WPQ (write-pending queue).  The iMC allows writes and reads to pass up=
 other writes to different addresses.  Before a read or a write is issued, =
it will first CAM the WPQ to see if there is a write pending to that addres=
s.  When reads hit, they are able to directly pull their data from the WPQ =
instead of going to memory.  Writes that hit will overwrite the existing da=
ta.  Partial writes that hit will not need to do underfill reads and will s=
imply update their relevant sections.",
         "Unit": "iMC"
     },
     {
         "BriefDescription": "Write Pending Queue CAM Match",
-        "Counter": "0,1,2,3",
         "EventCode": "0x24",
         "EventName": "UNC_M_WPQ_WRITE_HIT",
         "PerPkg": "1",
+        "PublicDescription": "Counts the number of times a request hits in=
 the WPQ (write-pending queue).  The iMC allows writes and reads to pass up=
 other writes to different addresses.  Before a read or a write is issued, =
it will first CAM the WPQ to see if there is a write pending to that addres=
s.  When reads hit, they are able to directly pull their data from the WPQ =
instead of going to memory.  Writes that hit will overwrite the existing da=
ta.  Partial writes that hit will not need to do underfill reads and will s=
imply update their relevant sections.",
         "Unit": "iMC"
     },
     {
         "BriefDescription": "Not getting the requested Major Mode",
-        "Counter": "0,1,2,3",
         "EventCode": "0xC1",
         "EventName": "UNC_M_WRONG_MM",
         "PerPkg": "1",
         "Unit": "iMC"
     },
+    {
+        "BriefDescription": "WR_CAS Access to Rank 0; All Banks",
+        "EventCode": "0xB8",
+        "EventName": "UNC_M_WR_CAS_RANK0.ALLBANKS",
+        "PerPkg": "1",
+        "PublicDescription": "WR_CAS Access to Rank 0 : All Banks",
+        "UMask": "0x10",
+        "Unit": "iMC"
+    },
+    {
+        "BriefDescription": "WR_CAS Access to Rank 0; Bank 0",
+        "EventCode": "0xB8",
+        "EventName": "UNC_M_WR_CAS_RANK0.BANK0",
+        "PerPkg": "1",
+        "PublicDescription": "WR_CAS Access to Rank 0 : Bank 0",
+        "Unit": "iMC"
+    },
     {
         "BriefDescription": "WR_CAS Access to Rank 0; Bank 1",
-        "Counter": "0,1,2,3",
         "EventCode": "0xB8",
         "EventName": "UNC_M_WR_CAS_RANK0.BANK1",
         "PerPkg": "1",
+        "PublicDescription": "WR_CAS Access to Rank 0 : Bank 1",
         "UMask": "0x1",
         "Unit": "iMC"
     },
     {
-        "BriefDescription": "WR_CAS Access to Rank 0; Bank 2",
-        "Counter": "0,1,2,3",
+        "BriefDescription": "WR_CAS Access to Rank 0; Bank 10",
         "EventCode": "0xB8",
-        "EventName": "UNC_M_WR_CAS_RANK0.BANK2",
+        "EventName": "UNC_M_WR_CAS_RANK0.BANK10",
         "PerPkg": "1",
-        "UMask": "0x2",
+        "PublicDescription": "WR_CAS Access to Rank 0 : Bank 10",
+        "UMask": "0xa",
         "Unit": "iMC"
     },
     {
-        "BriefDescription": "WR_CAS Access to Rank 0; Bank 4",
-        "Counter": "0,1,2,3",
+        "BriefDescription": "WR_CAS Access to Rank 0; Bank 11",
         "EventCode": "0xB8",
-        "EventName": "UNC_M_WR_CAS_RANK0.BANK4",
+        "EventName": "UNC_M_WR_CAS_RANK0.BANK11",
         "PerPkg": "1",
-        "UMask": "0x4",
+        "PublicDescription": "WR_CAS Access to Rank 0 : Bank 11",
+        "UMask": "0xb",
         "Unit": "iMC"
     },
     {
-        "BriefDescription": "WR_CAS Access to Rank 0; Bank 8",
-        "Counter": "0,1,2,3",
+        "BriefDescription": "WR_CAS Access to Rank 0; Bank 12",
         "EventCode": "0xB8",
-        "EventName": "UNC_M_WR_CAS_RANK0.BANK8",
+        "EventName": "UNC_M_WR_CAS_RANK0.BANK12",
         "PerPkg": "1",
-        "UMask": "0x8",
+        "PublicDescription": "WR_CAS Access to Rank 0 : Bank 12",
+        "UMask": "0xc",
         "Unit": "iMC"
     },
     {
-        "BriefDescription": "WR_CAS Access to Rank 0; All Banks",
-        "Counter": "0,1,2,3",
+        "BriefDescription": "WR_CAS Access to Rank 0; Bank 13",
         "EventCode": "0xB8",
-        "EventName": "UNC_M_WR_CAS_RANK0.ALLBANKS",
+        "EventName": "UNC_M_WR_CAS_RANK0.BANK13",
         "PerPkg": "1",
-        "UMask": "0x10",
+        "PublicDescription": "WR_CAS Access to Rank 0 : Bank 13",
+        "UMask": "0xd",
         "Unit": "iMC"
     },
     {
-        "BriefDescription": "WR_CAS Access to Rank 0; Bank 0",
-        "Counter": "0,1,2,3",
+        "BriefDescription": "WR_CAS Access to Rank 0; Bank 14",
         "EventCode": "0xB8",
-        "EventName": "UNC_M_WR_CAS_RANK0.BANK0",
+        "EventName": "UNC_M_WR_CAS_RANK0.BANK14",
+        "PerPkg": "1",
+        "PublicDescription": "WR_CAS Access to Rank 0 : Bank 14",
+        "UMask": "0xe",
+        "Unit": "iMC"
+    },
+    {
+        "BriefDescription": "WR_CAS Access to Rank 0; Bank 15",
+        "EventCode": "0xB8",
+        "EventName": "UNC_M_WR_CAS_RANK0.BANK15",
+        "PerPkg": "1",
+        "PublicDescription": "WR_CAS Access to Rank 0 : Bank 15",
+        "UMask": "0xf",
+        "Unit": "iMC"
+    },
+    {
+        "BriefDescription": "WR_CAS Access to Rank 0; Bank 2",
+        "EventCode": "0xB8",
+        "EventName": "UNC_M_WR_CAS_RANK0.BANK2",
         "PerPkg": "1",
+        "PublicDescription": "WR_CAS Access to Rank 0 : Bank 2",
+        "UMask": "0x2",
         "Unit": "iMC"
     },
     {
         "BriefDescription": "WR_CAS Access to Rank 0; Bank 3",
-        "Counter": "0,1,2,3",
         "EventCode": "0xB8",
         "EventName": "UNC_M_WR_CAS_RANK0.BANK3",
         "PerPkg": "1",
+        "PublicDescription": "WR_CAS Access to Rank 0 : Bank 3",
         "UMask": "0x3",
         "Unit": "iMC"
     },
+    {
+        "BriefDescription": "WR_CAS Access to Rank 0; Bank 4",
+        "EventCode": "0xB8",
+        "EventName": "UNC_M_WR_CAS_RANK0.BANK4",
+        "PerPkg": "1",
+        "PublicDescription": "WR_CAS Access to Rank 0 : Bank 4",
+        "UMask": "0x4",
+        "Unit": "iMC"
+    },
     {
         "BriefDescription": "WR_CAS Access to Rank 0; Bank 5",
-        "Counter": "0,1,2,3",
         "EventCode": "0xB8",
         "EventName": "UNC_M_WR_CAS_RANK0.BANK5",
         "PerPkg": "1",
+        "PublicDescription": "WR_CAS Access to Rank 0 : Bank 5",
         "UMask": "0x5",
         "Unit": "iMC"
     },
     {
         "BriefDescription": "WR_CAS Access to Rank 0; Bank 6",
-        "Counter": "0,1,2,3",
         "EventCode": "0xB8",
         "EventName": "UNC_M_WR_CAS_RANK0.BANK6",
         "PerPkg": "1",
+        "PublicDescription": "WR_CAS Access to Rank 0 : Bank 6",
         "UMask": "0x6",
         "Unit": "iMC"
     },
     {
         "BriefDescription": "WR_CAS Access to Rank 0; Bank 7",
-        "Counter": "0,1,2,3",
         "EventCode": "0xB8",
         "EventName": "UNC_M_WR_CAS_RANK0.BANK7",
         "PerPkg": "1",
+        "PublicDescription": "WR_CAS Access to Rank 0 : Bank 7",
         "UMask": "0x7",
         "Unit": "iMC"
     },
+    {
+        "BriefDescription": "WR_CAS Access to Rank 0; Bank 8",
+        "EventCode": "0xB8",
+        "EventName": "UNC_M_WR_CAS_RANK0.BANK8",
+        "PerPkg": "1",
+        "PublicDescription": "WR_CAS Access to Rank 0 : Bank 8",
+        "UMask": "0x8",
+        "Unit": "iMC"
+    },
     {
         "BriefDescription": "WR_CAS Access to Rank 0; Bank 9",
-        "Counter": "0,1,2,3",
         "EventCode": "0xB8",
         "EventName": "UNC_M_WR_CAS_RANK0.BANK9",
         "PerPkg": "1",
+        "PublicDescription": "WR_CAS Access to Rank 0 : Bank 9",
         "UMask": "0x9",
         "Unit": "iMC"
     },
     {
-        "BriefDescription": "WR_CAS Access to Rank 0; Bank 10",
-        "Counter": "0,1,2,3",
-        "EventCode": "0xB8",
-        "EventName": "UNC_M_WR_CAS_RANK0.BANK10",
-        "PerPkg": "1",
-        "UMask": "0xA",
-        "Unit": "iMC"
-    },
-    {
-        "BriefDescription": "WR_CAS Access to Rank 0; Bank 11",
-        "Counter": "0,1,2,3",
-        "EventCode": "0xB8",
-        "EventName": "UNC_M_WR_CAS_RANK0.BANK11",
-        "PerPkg": "1",
-        "UMask": "0xB",
-        "Unit": "iMC"
-    },
-    {
-        "BriefDescription": "WR_CAS Access to Rank 0; Bank 12",
-        "Counter": "0,1,2,3",
-        "EventCode": "0xB8",
-        "EventName": "UNC_M_WR_CAS_RANK0.BANK12",
-        "PerPkg": "1",
-        "UMask": "0xC",
-        "Unit": "iMC"
-    },
-    {
-        "BriefDescription": "WR_CAS Access to Rank 0; Bank 13",
-        "Counter": "0,1,2,3",
-        "EventCode": "0xB8",
-        "EventName": "UNC_M_WR_CAS_RANK0.BANK13",
-        "PerPkg": "1",
-        "UMask": "0xD",
-        "Unit": "iMC"
-    },
-    {
-        "BriefDescription": "WR_CAS Access to Rank 0; Bank 14",
-        "Counter": "0,1,2,3",
-        "EventCode": "0xB8",
-        "EventName": "UNC_M_WR_CAS_RANK0.BANK14",
-        "PerPkg": "1",
-        "UMask": "0xE",
-        "Unit": "iMC"
-    },
-    {
-        "BriefDescription": "WR_CAS Access to Rank 0; Bank 15",
-        "Counter": "0,1,2,3",
-        "EventCode": "0xB8",
-        "EventName": "UNC_M_WR_CAS_RANK0.BANK15",
-        "PerPkg": "1",
-        "UMask": "0xF",
-        "Unit": "iMC"
-    },
-    {
-        "BriefDescription": "WR_CAS Access to Rank 0; Bank Group 0 (Banks =
0-3)",
-        "Counter": "0,1,2,3",
+        "BriefDescription": "WR_CAS Access to Rank 0; Bank Group 0 (Banks =
0-3)",
         "EventCode": "0xB8",
         "EventName": "UNC_M_WR_CAS_RANK0.BANKG0",
         "PerPkg": "1",
+        "PublicDescription": "WR_CAS Access to Rank 0 : Bank Group 0 (Bank=
s 0-3)",
         "UMask": "0x11",
         "Unit": "iMC"
     },
     {
         "BriefDescription": "WR_CAS Access to Rank 0; Bank Group 1 (Banks =
4-7)",
-        "Counter": "0,1,2,3",
         "EventCode": "0xB8",
         "EventName": "UNC_M_WR_CAS_RANK0.BANKG1",
         "PerPkg": "1",
+        "PublicDescription": "WR_CAS Access to Rank 0 : Bank Group 1 (Bank=
s 4-7)",
         "UMask": "0x12",
         "Unit": "iMC"
     },
     {
         "BriefDescription": "WR_CAS Access to Rank 0; Bank Group 2 (Banks =
8-11)",
-        "Counter": "0,1,2,3",
         "EventCode": "0xB8",
         "EventName": "UNC_M_WR_CAS_RANK0.BANKG2",
         "PerPkg": "1",
+        "PublicDescription": "WR_CAS Access to Rank 0 : Bank Group 2 (Bank=
s 8-11)",
         "UMask": "0x13",
         "Unit": "iMC"
     },
     {
         "BriefDescription": "WR_CAS Access to Rank 0; Bank Group 3 (Banks =
12-15)",
-        "Counter": "0,1,2,3",
         "EventCode": "0xB8",
         "EventName": "UNC_M_WR_CAS_RANK0.BANKG3",
         "PerPkg": "1",
+        "PublicDescription": "WR_CAS Access to Rank 0 : Bank Group 3 (Bank=
s 12-15)",
         "UMask": "0x14",
         "Unit": "iMC"
     },
     {
-        "BriefDescription": "WR_CAS Access to Rank 1; Bank 1",
-        "Counter": "0,1,2,3",
+        "BriefDescription": "WR_CAS Access to Rank 1; All Banks",
         "EventCode": "0xB9",
-        "EventName": "UNC_M_WR_CAS_RANK1.BANK1",
+        "EventName": "UNC_M_WR_CAS_RANK1.ALLBANKS",
         "PerPkg": "1",
-        "UMask": "0x1",
+        "PublicDescription": "WR_CAS Access to Rank 0 : All Banks",
+        "UMask": "0x10",
         "Unit": "iMC"
     },
     {
-        "BriefDescription": "WR_CAS Access to Rank 1; Bank 2",
-        "Counter": "0,1,2,3",
+        "BriefDescription": "WR_CAS Access to Rank 1; Bank 0",
         "EventCode": "0xB9",
-        "EventName": "UNC_M_WR_CAS_RANK1.BANK2",
+        "EventName": "UNC_M_WR_CAS_RANK1.BANK0",
         "PerPkg": "1",
-        "UMask": "0x2",
+        "PublicDescription": "WR_CAS Access to Rank 0 : Bank 0",
         "Unit": "iMC"
     },
     {
-        "BriefDescription": "WR_CAS Access to Rank 1; Bank 4",
-        "Counter": "0,1,2,3",
+        "BriefDescription": "WR_CAS Access to Rank 1; Bank 1",
         "EventCode": "0xB9",
-        "EventName": "UNC_M_WR_CAS_RANK1.BANK4",
+        "EventName": "UNC_M_WR_CAS_RANK1.BANK1",
         "PerPkg": "1",
-        "UMask": "0x4",
+        "PublicDescription": "WR_CAS Access to Rank 0 : Bank 1",
+        "UMask": "0x1",
         "Unit": "iMC"
     },
     {
-        "BriefDescription": "WR_CAS Access to Rank 1; Bank 8",
-        "Counter": "0,1,2,3",
+        "BriefDescription": "WR_CAS Access to Rank 1; Bank 10",
         "EventCode": "0xB9",
-        "EventName": "UNC_M_WR_CAS_RANK1.BANK8",
+        "EventName": "UNC_M_WR_CAS_RANK1.BANK10",
         "PerPkg": "1",
-        "UMask": "0x8",
+        "PublicDescription": "WR_CAS Access to Rank 0 : Bank 10",
+        "UMask": "0xa",
         "Unit": "iMC"
     },
     {
-        "BriefDescription": "WR_CAS Access to Rank 1; All Banks",
-        "Counter": "0,1,2,3",
+        "BriefDescription": "WR_CAS Access to Rank 1; Bank 11",
         "EventCode": "0xB9",
-        "EventName": "UNC_M_WR_CAS_RANK1.ALLBANKS",
+        "EventName": "UNC_M_WR_CAS_RANK1.BANK11",
         "PerPkg": "1",
-        "UMask": "0x10",
+        "PublicDescription": "WR_CAS Access to Rank 0 : Bank 11",
+        "UMask": "0xb",
         "Unit": "iMC"
     },
     {
-        "BriefDescription": "WR_CAS Access to Rank 1; Bank 0",
-        "Counter": "0,1,2,3",
+        "BriefDescription": "WR_CAS Access to Rank 1; Bank 12",
         "EventCode": "0xB9",
-        "EventName": "UNC_M_WR_CAS_RANK1.BANK0",
+        "EventName": "UNC_M_WR_CAS_RANK1.BANK12",
         "PerPkg": "1",
+        "PublicDescription": "WR_CAS Access to Rank 0 : Bank 12",
+        "UMask": "0xc",
         "Unit": "iMC"
     },
     {
-        "BriefDescription": "WR_CAS Access to Rank 1; Bank 3",
-        "Counter": "0,1,2,3",
+        "BriefDescription": "WR_CAS Access to Rank 1; Bank 13",
         "EventCode": "0xB9",
-        "EventName": "UNC_M_WR_CAS_RANK1.BANK3",
+        "EventName": "UNC_M_WR_CAS_RANK1.BANK13",
         "PerPkg": "1",
-        "UMask": "0x3",
+        "PublicDescription": "WR_CAS Access to Rank 0 : Bank 13",
+        "UMask": "0xd",
         "Unit": "iMC"
     },
     {
-        "BriefDescription": "WR_CAS Access to Rank 1; Bank 5",
-        "Counter": "0,1,2,3",
+        "BriefDescription": "WR_CAS Access to Rank 1; Bank 14",
         "EventCode": "0xB9",
-        "EventName": "UNC_M_WR_CAS_RANK1.BANK5",
+        "EventName": "UNC_M_WR_CAS_RANK1.BANK14",
         "PerPkg": "1",
-        "UMask": "0x5",
+        "PublicDescription": "WR_CAS Access to Rank 0 : Bank 14",
+        "UMask": "0xe",
         "Unit": "iMC"
     },
     {
-        "BriefDescription": "WR_CAS Access to Rank 1; Bank 6",
-        "Counter": "0,1,2,3",
+        "BriefDescription": "WR_CAS Access to Rank 1; Bank 15",
         "EventCode": "0xB9",
-        "EventName": "UNC_M_WR_CAS_RANK1.BANK6",
+        "EventName": "UNC_M_WR_CAS_RANK1.BANK15",
         "PerPkg": "1",
-        "UMask": "0x6",
+        "PublicDescription": "WR_CAS Access to Rank 0 : Bank 15",
+        "UMask": "0xf",
         "Unit": "iMC"
     },
     {
-        "BriefDescription": "WR_CAS Access to Rank 1; Bank 7",
-        "Counter": "0,1,2,3",
+        "BriefDescription": "WR_CAS Access to Rank 1; Bank 2",
         "EventCode": "0xB9",
-        "EventName": "UNC_M_WR_CAS_RANK1.BANK7",
+        "EventName": "UNC_M_WR_CAS_RANK1.BANK2",
         "PerPkg": "1",
-        "UMask": "0x7",
+        "PublicDescription": "WR_CAS Access to Rank 0 : Bank 2",
+        "UMask": "0x2",
         "Unit": "iMC"
     },
     {
-        "BriefDescription": "WR_CAS Access to Rank 1; Bank 9",
-        "Counter": "0,1,2,3",
+        "BriefDescription": "WR_CAS Access to Rank 1; Bank 3",
         "EventCode": "0xB9",
-        "EventName": "UNC_M_WR_CAS_RANK1.BANK9",
+        "EventName": "UNC_M_WR_CAS_RANK1.BANK3",
         "PerPkg": "1",
-        "UMask": "0x9",
+        "PublicDescription": "WR_CAS Access to Rank 0 : Bank 3",
+        "UMask": "0x3",
         "Unit": "iMC"
     },
     {
-        "BriefDescription": "WR_CAS Access to Rank 1; Bank 10",
-        "Counter": "0,1,2,3",
+        "BriefDescription": "WR_CAS Access to Rank 1; Bank 4",
         "EventCode": "0xB9",
-        "EventName": "UNC_M_WR_CAS_RANK1.BANK10",
+        "EventName": "UNC_M_WR_CAS_RANK1.BANK4",
         "PerPkg": "1",
-        "UMask": "0xA",
+        "PublicDescription": "WR_CAS Access to Rank 0 : Bank 4",
+        "UMask": "0x4",
         "Unit": "iMC"
     },
     {
-        "BriefDescription": "WR_CAS Access to Rank 1; Bank 11",
-        "Counter": "0,1,2,3",
+        "BriefDescription": "WR_CAS Access to Rank 1; Bank 5",
         "EventCode": "0xB9",
-        "EventName": "UNC_M_WR_CAS_RANK1.BANK11",
+        "EventName": "UNC_M_WR_CAS_RANK1.BANK5",
         "PerPkg": "1",
-        "UMask": "0xB",
+        "PublicDescription": "WR_CAS Access to Rank 0 : Bank 5",
+        "UMask": "0x5",
         "Unit": "iMC"
     },
     {
-        "BriefDescription": "WR_CAS Access to Rank 1; Bank 12",
-        "Counter": "0,1,2,3",
+        "BriefDescription": "WR_CAS Access to Rank 1; Bank 6",
         "EventCode": "0xB9",
-        "EventName": "UNC_M_WR_CAS_RANK1.BANK12",
+        "EventName": "UNC_M_WR_CAS_RANK1.BANK6",
         "PerPkg": "1",
-        "UMask": "0xC",
+        "PublicDescription": "WR_CAS Access to Rank 0 : Bank 6",
+        "UMask": "0x6",
         "Unit": "iMC"
     },
     {
-        "BriefDescription": "WR_CAS Access to Rank 1; Bank 13",
-        "Counter": "0,1,2,3",
+        "BriefDescription": "WR_CAS Access to Rank 1; Bank 7",
         "EventCode": "0xB9",
-        "EventName": "UNC_M_WR_CAS_RANK1.BANK13",
+        "EventName": "UNC_M_WR_CAS_RANK1.BANK7",
         "PerPkg": "1",
-        "UMask": "0xD",
+        "PublicDescription": "WR_CAS Access to Rank 0 : Bank 7",
+        "UMask": "0x7",
         "Unit": "iMC"
     },
     {
-        "BriefDescription": "WR_CAS Access to Rank 1; Bank 14",
-        "Counter": "0,1,2,3",
+        "BriefDescription": "WR_CAS Access to Rank 1; Bank 8",
         "EventCode": "0xB9",
-        "EventName": "UNC_M_WR_CAS_RANK1.BANK14",
+        "EventName": "UNC_M_WR_CAS_RANK1.BANK8",
         "PerPkg": "1",
-        "UMask": "0xE",
+        "PublicDescription": "WR_CAS Access to Rank 0 : Bank 8",
+        "UMask": "0x8",
         "Unit": "iMC"
     },
     {
-        "BriefDescription": "WR_CAS Access to Rank 1; Bank 15",
-        "Counter": "0,1,2,3",
+        "BriefDescription": "WR_CAS Access to Rank 1; Bank 9",
         "EventCode": "0xB9",
-        "EventName": "UNC_M_WR_CAS_RANK1.BANK15",
+        "EventName": "UNC_M_WR_CAS_RANK1.BANK9",
         "PerPkg": "1",
-        "UMask": "0xF",
+        "PublicDescription": "WR_CAS Access to Rank 0 : Bank 9",
+        "UMask": "0x9",
         "Unit": "iMC"
     },
     {
         "BriefDescription": "WR_CAS Access to Rank 1; Bank Group 0 (Banks =
0-3)",
-        "Counter": "0,1,2,3",
         "EventCode": "0xB9",
         "EventName": "UNC_M_WR_CAS_RANK1.BANKG0",
         "PerPkg": "1",
+        "PublicDescription": "WR_CAS Access to Rank 0 : Bank Group 0 (Bank=
s 0-3)",
         "UMask": "0x11",
         "Unit": "iMC"
     },
     {
         "BriefDescription": "WR_CAS Access to Rank 1; Bank Group 1 (Banks =
4-7)",
-        "Counter": "0,1,2,3",
         "EventCode": "0xB9",
         "EventName": "UNC_M_WR_CAS_RANK1.BANKG1",
         "PerPkg": "1",
+        "PublicDescription": "WR_CAS Access to Rank 0 : Bank Group 1 (Bank=
s 4-7)",
         "UMask": "0x12",
         "Unit": "iMC"
     },
     {
         "BriefDescription": "WR_CAS Access to Rank 1; Bank Group 2 (Banks =
8-11)",
-        "Counter": "0,1,2,3",
         "EventCode": "0xB9",
         "EventName": "UNC_M_WR_CAS_RANK1.BANKG2",
         "PerPkg": "1",
+        "PublicDescription": "WR_CAS Access to Rank 0 : Bank Group 2 (Bank=
s 8-11)",
         "UMask": "0x13",
         "Unit": "iMC"
     },
     {
         "BriefDescription": "WR_CAS Access to Rank 1; Bank Group 3 (Banks =
12-15)",
-        "Counter": "0,1,2,3",
         "EventCode": "0xB9",
         "EventName": "UNC_M_WR_CAS_RANK1.BANKG3",
         "PerPkg": "1",
+        "PublicDescription": "WR_CAS Access to Rank 0 : Bank Group 3 (Bank=
s 12-15)",
         "UMask": "0x14",
         "Unit": "iMC"
     },
     {
-        "BriefDescription": "WR_CAS Access to Rank 4; Bank 1",
-        "Counter": "0,1,2,3",
+        "BriefDescription": "WR_CAS Access to Rank 4; All Banks",
         "EventCode": "0xBC",
-        "EventName": "UNC_M_WR_CAS_RANK4.BANK1",
+        "EventName": "UNC_M_WR_CAS_RANK4.ALLBANKS",
         "PerPkg": "1",
-        "UMask": "0x1",
+        "PublicDescription": "WR_CAS Access to Rank 0 : All Banks",
+        "UMask": "0x10",
         "Unit": "iMC"
     },
     {
-        "BriefDescription": "WR_CAS Access to Rank 4; Bank 2",
-        "Counter": "0,1,2,3",
+        "BriefDescription": "WR_CAS Access to Rank 4; Bank 0",
         "EventCode": "0xBC",
-        "EventName": "UNC_M_WR_CAS_RANK4.BANK2",
+        "EventName": "UNC_M_WR_CAS_RANK4.BANK0",
         "PerPkg": "1",
-        "UMask": "0x2",
+        "PublicDescription": "WR_CAS Access to Rank 0 : Bank 0",
         "Unit": "iMC"
     },
     {
-        "BriefDescription": "WR_CAS Access to Rank 4; Bank 4",
-        "Counter": "0,1,2,3",
+        "BriefDescription": "WR_CAS Access to Rank 4; Bank 1",
         "EventCode": "0xBC",
-        "EventName": "UNC_M_WR_CAS_RANK4.BANK4",
+        "EventName": "UNC_M_WR_CAS_RANK4.BANK1",
         "PerPkg": "1",
-        "UMask": "0x4",
+        "PublicDescription": "WR_CAS Access to Rank 0 : Bank 1",
+        "UMask": "0x1",
         "Unit": "iMC"
     },
     {
-        "BriefDescription": "WR_CAS Access to Rank 4; Bank 8",
-        "Counter": "0,1,2,3",
+        "BriefDescription": "WR_CAS Access to Rank 4; Bank 10",
         "EventCode": "0xBC",
-        "EventName": "UNC_M_WR_CAS_RANK4.BANK8",
+        "EventName": "UNC_M_WR_CAS_RANK4.BANK10",
         "PerPkg": "1",
-        "UMask": "0x8",
+        "PublicDescription": "WR_CAS Access to Rank 0 : Bank 10",
+        "UMask": "0xa",
         "Unit": "iMC"
     },
     {
-        "BriefDescription": "WR_CAS Access to Rank 4; All Banks",
-        "Counter": "0,1,2,3",
+        "BriefDescription": "WR_CAS Access to Rank 4; Bank 11",
         "EventCode": "0xBC",
-        "EventName": "UNC_M_WR_CAS_RANK4.ALLBANKS",
+        "EventName": "UNC_M_WR_CAS_RANK4.BANK11",
         "PerPkg": "1",
-        "UMask": "0x10",
+        "PublicDescription": "WR_CAS Access to Rank 0 : Bank 11",
+        "UMask": "0xb",
         "Unit": "iMC"
     },
     {
-        "BriefDescription": "WR_CAS Access to Rank 4; Bank 0",
-        "Counter": "0,1,2,3",
+        "BriefDescription": "WR_CAS Access to Rank 4; Bank 12",
         "EventCode": "0xBC",
-        "EventName": "UNC_M_WR_CAS_RANK4.BANK0",
+        "EventName": "UNC_M_WR_CAS_RANK4.BANK12",
         "PerPkg": "1",
+        "PublicDescription": "WR_CAS Access to Rank 0 : Bank 12",
+        "UMask": "0xc",
         "Unit": "iMC"
     },
     {
-        "BriefDescription": "WR_CAS Access to Rank 4; Bank 3",
-        "Counter": "0,1,2,3",
+        "BriefDescription": "WR_CAS Access to Rank 4; Bank 13",
         "EventCode": "0xBC",
-        "EventName": "UNC_M_WR_CAS_RANK4.BANK3",
+        "EventName": "UNC_M_WR_CAS_RANK4.BANK13",
         "PerPkg": "1",
-        "UMask": "0x3",
+        "PublicDescription": "WR_CAS Access to Rank 0 : Bank 13",
+        "UMask": "0xd",
         "Unit": "iMC"
     },
     {
-        "BriefDescription": "WR_CAS Access to Rank 4; Bank 5",
-        "Counter": "0,1,2,3",
+        "BriefDescription": "WR_CAS Access to Rank 4; Bank 14",
         "EventCode": "0xBC",
-        "EventName": "UNC_M_WR_CAS_RANK4.BANK5",
+        "EventName": "UNC_M_WR_CAS_RANK4.BANK14",
         "PerPkg": "1",
-        "UMask": "0x5",
+        "PublicDescription": "WR_CAS Access to Rank 0 : Bank 14",
+        "UMask": "0xe",
         "Unit": "iMC"
     },
     {
-        "BriefDescription": "WR_CAS Access to Rank 4; Bank 6",
-        "Counter": "0,1,2,3",
+        "BriefDescription": "WR_CAS Access to Rank 4; Bank 15",
         "EventCode": "0xBC",
-        "EventName": "UNC_M_WR_CAS_RANK4.BANK6",
+        "EventName": "UNC_M_WR_CAS_RANK4.BANK15",
         "PerPkg": "1",
-        "UMask": "0x6",
+        "PublicDescription": "WR_CAS Access to Rank 0 : Bank 15",
+        "UMask": "0xf",
         "Unit": "iMC"
     },
     {
-        "BriefDescription": "WR_CAS Access to Rank 4; Bank 7",
-        "Counter": "0,1,2,3",
+        "BriefDescription": "WR_CAS Access to Rank 4; Bank 2",
         "EventCode": "0xBC",
-        "EventName": "UNC_M_WR_CAS_RANK4.BANK7",
+        "EventName": "UNC_M_WR_CAS_RANK4.BANK2",
         "PerPkg": "1",
-        "UMask": "0x7",
+        "PublicDescription": "WR_CAS Access to Rank 0 : Bank 2",
+        "UMask": "0x2",
         "Unit": "iMC"
     },
     {
-        "BriefDescription": "WR_CAS Access to Rank 4; Bank 9",
-        "Counter": "0,1,2,3",
+        "BriefDescription": "WR_CAS Access to Rank 4; Bank 3",
         "EventCode": "0xBC",
-        "EventName": "UNC_M_WR_CAS_RANK4.BANK9",
+        "EventName": "UNC_M_WR_CAS_RANK4.BANK3",
         "PerPkg": "1",
-        "UMask": "0x9",
+        "PublicDescription": "WR_CAS Access to Rank 0 : Bank 3",
+        "UMask": "0x3",
         "Unit": "iMC"
     },
     {
-        "BriefDescription": "WR_CAS Access to Rank 4; Bank 10",
-        "Counter": "0,1,2,3",
+        "BriefDescription": "WR_CAS Access to Rank 4; Bank 4",
         "EventCode": "0xBC",
-        "EventName": "UNC_M_WR_CAS_RANK4.BANK10",
+        "EventName": "UNC_M_WR_CAS_RANK4.BANK4",
         "PerPkg": "1",
-        "UMask": "0xA",
+        "PublicDescription": "WR_CAS Access to Rank 0 : Bank 4",
+        "UMask": "0x4",
         "Unit": "iMC"
     },
     {
-        "BriefDescription": "WR_CAS Access to Rank 4; Bank 11",
-        "Counter": "0,1,2,3",
+        "BriefDescription": "WR_CAS Access to Rank 4; Bank 5",
         "EventCode": "0xBC",
-        "EventName": "UNC_M_WR_CAS_RANK4.BANK11",
+        "EventName": "UNC_M_WR_CAS_RANK4.BANK5",
         "PerPkg": "1",
-        "UMask": "0xB",
+        "PublicDescription": "WR_CAS Access to Rank 0 : Bank 5",
+        "UMask": "0x5",
         "Unit": "iMC"
     },
     {
-        "BriefDescription": "WR_CAS Access to Rank 4; Bank 12",
-        "Counter": "0,1,2,3",
+        "BriefDescription": "WR_CAS Access to Rank 4; Bank 6",
         "EventCode": "0xBC",
-        "EventName": "UNC_M_WR_CAS_RANK4.BANK12",
+        "EventName": "UNC_M_WR_CAS_RANK4.BANK6",
         "PerPkg": "1",
-        "UMask": "0xC",
+        "PublicDescription": "WR_CAS Access to Rank 0 : Bank 6",
+        "UMask": "0x6",
         "Unit": "iMC"
     },
     {
-        "BriefDescription": "WR_CAS Access to Rank 4; Bank 13",
-        "Counter": "0,1,2,3",
+        "BriefDescription": "WR_CAS Access to Rank 4; Bank 7",
         "EventCode": "0xBC",
-        "EventName": "UNC_M_WR_CAS_RANK4.BANK13",
+        "EventName": "UNC_M_WR_CAS_RANK4.BANK7",
         "PerPkg": "1",
-        "UMask": "0xD",
+        "PublicDescription": "WR_CAS Access to Rank 0 : Bank 7",
+        "UMask": "0x7",
         "Unit": "iMC"
     },
     {
-        "BriefDescription": "WR_CAS Access to Rank 4; Bank 14",
-        "Counter": "0,1,2,3",
+        "BriefDescription": "WR_CAS Access to Rank 4; Bank 8",
         "EventCode": "0xBC",
-        "EventName": "UNC_M_WR_CAS_RANK4.BANK14",
+        "EventName": "UNC_M_WR_CAS_RANK4.BANK8",
         "PerPkg": "1",
-        "UMask": "0xE",
+        "PublicDescription": "WR_CAS Access to Rank 0 : Bank 8",
+        "UMask": "0x8",
         "Unit": "iMC"
     },
     {
-        "BriefDescription": "WR_CAS Access to Rank 4; Bank 15",
-        "Counter": "0,1,2,3",
+        "BriefDescription": "WR_CAS Access to Rank 4; Bank 9",
         "EventCode": "0xBC",
-        "EventName": "UNC_M_WR_CAS_RANK4.BANK15",
+        "EventName": "UNC_M_WR_CAS_RANK4.BANK9",
         "PerPkg": "1",
-        "UMask": "0xF",
+        "PublicDescription": "WR_CAS Access to Rank 0 : Bank 9",
+        "UMask": "0x9",
         "Unit": "iMC"
     },
     {
         "BriefDescription": "WR_CAS Access to Rank 4; Bank Group 0 (Banks =
0-3)",
-        "Counter": "0,1,2,3",
         "EventCode": "0xBC",
         "EventName": "UNC_M_WR_CAS_RANK4.BANKG0",
         "PerPkg": "1",
+        "PublicDescription": "WR_CAS Access to Rank 0 : Bank Group 0 (Bank=
s 0-3)",
         "UMask": "0x11",
         "Unit": "iMC"
     },
     {
         "BriefDescription": "WR_CAS Access to Rank 4; Bank Group 1 (Banks =
4-7)",
-        "Counter": "0,1,2,3",
         "EventCode": "0xBC",
         "EventName": "UNC_M_WR_CAS_RANK4.BANKG1",
         "PerPkg": "1",
+        "PublicDescription": "WR_CAS Access to Rank 0 : Bank Group 1 (Bank=
s 4-7)",
         "UMask": "0x12",
         "Unit": "iMC"
     },
     {
         "BriefDescription": "WR_CAS Access to Rank 4; Bank Group 2 (Banks =
8-11)",
-        "Counter": "0,1,2,3",
         "EventCode": "0xBC",
         "EventName": "UNC_M_WR_CAS_RANK4.BANKG2",
         "PerPkg": "1",
+        "PublicDescription": "WR_CAS Access to Rank 0 : Bank Group 2 (Bank=
s 8-11)",
         "UMask": "0x13",
         "Unit": "iMC"
     },
     {
         "BriefDescription": "WR_CAS Access to Rank 4; Bank Group 3 (Banks =
12-15)",
-        "Counter": "0,1,2,3",
         "EventCode": "0xBC",
         "EventName": "UNC_M_WR_CAS_RANK4.BANKG3",
         "PerPkg": "1",
+        "PublicDescription": "WR_CAS Access to Rank 0 : Bank Group 3 (Bank=
s 12-15)",
         "UMask": "0x14",
         "Unit": "iMC"
     },
     {
-        "BriefDescription": "WR_CAS Access to Rank 5; Bank 1",
-        "Counter": "0,1,2,3",
+        "BriefDescription": "WR_CAS Access to Rank 5; All Banks",
         "EventCode": "0xBD",
-        "EventName": "UNC_M_WR_CAS_RANK5.BANK1",
+        "EventName": "UNC_M_WR_CAS_RANK5.ALLBANKS",
         "PerPkg": "1",
-        "UMask": "0x1",
+        "PublicDescription": "WR_CAS Access to Rank 0 : All Banks",
+        "UMask": "0x10",
         "Unit": "iMC"
     },
     {
-        "BriefDescription": "WR_CAS Access to Rank 5; Bank 2",
-        "Counter": "0,1,2,3",
+        "BriefDescription": "WR_CAS Access to Rank 5; Bank 0",
         "EventCode": "0xBD",
-        "EventName": "UNC_M_WR_CAS_RANK5.BANK2",
+        "EventName": "UNC_M_WR_CAS_RANK5.BANK0",
         "PerPkg": "1",
-        "UMask": "0x2",
+        "PublicDescription": "WR_CAS Access to Rank 0 : Bank 0",
         "Unit": "iMC"
     },
     {
-        "BriefDescription": "WR_CAS Access to Rank 5; Bank 4",
-        "Counter": "0,1,2,3",
+        "BriefDescription": "WR_CAS Access to Rank 5; Bank 1",
         "EventCode": "0xBD",
-        "EventName": "UNC_M_WR_CAS_RANK5.BANK4",
+        "EventName": "UNC_M_WR_CAS_RANK5.BANK1",
         "PerPkg": "1",
-        "UMask": "0x4",
+        "PublicDescription": "WR_CAS Access to Rank 0 : Bank 1",
+        "UMask": "0x1",
         "Unit": "iMC"
     },
     {
-        "BriefDescription": "WR_CAS Access to Rank 5; Bank 8",
-        "Counter": "0,1,2,3",
+        "BriefDescription": "WR_CAS Access to Rank 5; Bank 10",
         "EventCode": "0xBD",
-        "EventName": "UNC_M_WR_CAS_RANK5.BANK8",
+        "EventName": "UNC_M_WR_CAS_RANK5.BANK10",
         "PerPkg": "1",
-        "UMask": "0x8",
+        "PublicDescription": "WR_CAS Access to Rank 0 : Bank 10",
+        "UMask": "0xa",
         "Unit": "iMC"
     },
     {
-        "BriefDescription": "WR_CAS Access to Rank 5; All Banks",
-        "Counter": "0,1,2,3",
+        "BriefDescription": "WR_CAS Access to Rank 5; Bank 11",
         "EventCode": "0xBD",
-        "EventName": "UNC_M_WR_CAS_RANK5.ALLBANKS",
+        "EventName": "UNC_M_WR_CAS_RANK5.BANK11",
         "PerPkg": "1",
-        "UMask": "0x10",
+        "PublicDescription": "WR_CAS Access to Rank 0 : Bank 11",
+        "UMask": "0xb",
         "Unit": "iMC"
     },
     {
-        "BriefDescription": "WR_CAS Access to Rank 5; Bank 0",
-        "Counter": "0,1,2,3",
+        "BriefDescription": "WR_CAS Access to Rank 5; Bank 12",
         "EventCode": "0xBD",
-        "EventName": "UNC_M_WR_CAS_RANK5.BANK0",
+        "EventName": "UNC_M_WR_CAS_RANK5.BANK12",
         "PerPkg": "1",
+        "PublicDescription": "WR_CAS Access to Rank 0 : Bank 12",
+        "UMask": "0xc",
         "Unit": "iMC"
     },
     {
-        "BriefDescription": "WR_CAS Access to Rank 5; Bank 3",
-        "Counter": "0,1,2,3",
+        "BriefDescription": "WR_CAS Access to Rank 5; Bank 13",
         "EventCode": "0xBD",
-        "EventName": "UNC_M_WR_CAS_RANK5.BANK3",
+        "EventName": "UNC_M_WR_CAS_RANK5.BANK13",
         "PerPkg": "1",
-        "UMask": "0x3",
+        "PublicDescription": "WR_CAS Access to Rank 0 : Bank 13",
+        "UMask": "0xd",
         "Unit": "iMC"
     },
     {
-        "BriefDescription": "WR_CAS Access to Rank 5; Bank 5",
-        "Counter": "0,1,2,3",
+        "BriefDescription": "WR_CAS Access to Rank 5; Bank 14",
         "EventCode": "0xBD",
-        "EventName": "UNC_M_WR_CAS_RANK5.BANK5",
+        "EventName": "UNC_M_WR_CAS_RANK5.BANK14",
         "PerPkg": "1",
-        "UMask": "0x5",
+        "PublicDescription": "WR_CAS Access to Rank 0 : Bank 14",
+        "UMask": "0xe",
         "Unit": "iMC"
     },
     {
-        "BriefDescription": "WR_CAS Access to Rank 5; Bank 6",
-        "Counter": "0,1,2,3",
+        "BriefDescription": "WR_CAS Access to Rank 5; Bank 15",
         "EventCode": "0xBD",
-        "EventName": "UNC_M_WR_CAS_RANK5.BANK6",
+        "EventName": "UNC_M_WR_CAS_RANK5.BANK15",
         "PerPkg": "1",
-        "UMask": "0x6",
+        "PublicDescription": "WR_CAS Access to Rank 0 : Bank 15",
+        "UMask": "0xf",
         "Unit": "iMC"
     },
     {
-        "BriefDescription": "WR_CAS Access to Rank 5; Bank 7",
-        "Counter": "0,1,2,3",
+        "BriefDescription": "WR_CAS Access to Rank 5; Bank 2",
         "EventCode": "0xBD",
-        "EventName": "UNC_M_WR_CAS_RANK5.BANK7",
+        "EventName": "UNC_M_WR_CAS_RANK5.BANK2",
         "PerPkg": "1",
-        "UMask": "0x7",
+        "PublicDescription": "WR_CAS Access to Rank 0 : Bank 2",
+        "UMask": "0x2",
         "Unit": "iMC"
     },
     {
-        "BriefDescription": "WR_CAS Access to Rank 5; Bank 9",
-        "Counter": "0,1,2,3",
+        "BriefDescription": "WR_CAS Access to Rank 5; Bank 3",
         "EventCode": "0xBD",
-        "EventName": "UNC_M_WR_CAS_RANK5.BANK9",
+        "EventName": "UNC_M_WR_CAS_RANK5.BANK3",
         "PerPkg": "1",
-        "UMask": "0x9",
+        "PublicDescription": "WR_CAS Access to Rank 0 : Bank 3",
+        "UMask": "0x3",
         "Unit": "iMC"
     },
     {
-        "BriefDescription": "WR_CAS Access to Rank 5; Bank 10",
-        "Counter": "0,1,2,3",
+        "BriefDescription": "WR_CAS Access to Rank 5; Bank 4",
         "EventCode": "0xBD",
-        "EventName": "UNC_M_WR_CAS_RANK5.BANK10",
+        "EventName": "UNC_M_WR_CAS_RANK5.BANK4",
         "PerPkg": "1",
-        "UMask": "0xA",
+        "PublicDescription": "WR_CAS Access to Rank 0 : Bank 4",
+        "UMask": "0x4",
         "Unit": "iMC"
     },
     {
-        "BriefDescription": "WR_CAS Access to Rank 5; Bank 11",
-        "Counter": "0,1,2,3",
+        "BriefDescription": "WR_CAS Access to Rank 5; Bank 5",
         "EventCode": "0xBD",
-        "EventName": "UNC_M_WR_CAS_RANK5.BANK11",
+        "EventName": "UNC_M_WR_CAS_RANK5.BANK5",
         "PerPkg": "1",
-        "UMask": "0xB",
+        "PublicDescription": "WR_CAS Access to Rank 0 : Bank 5",
+        "UMask": "0x5",
         "Unit": "iMC"
     },
     {
-        "BriefDescription": "WR_CAS Access to Rank 5; Bank 12",
-        "Counter": "0,1,2,3",
+        "BriefDescription": "WR_CAS Access to Rank 5; Bank 6",
         "EventCode": "0xBD",
-        "EventName": "UNC_M_WR_CAS_RANK5.BANK12",
+        "EventName": "UNC_M_WR_CAS_RANK5.BANK6",
         "PerPkg": "1",
-        "UMask": "0xC",
+        "PublicDescription": "WR_CAS Access to Rank 0 : Bank 6",
+        "UMask": "0x6",
         "Unit": "iMC"
     },
     {
-        "BriefDescription": "WR_CAS Access to Rank 5; Bank 13",
-        "Counter": "0,1,2,3",
+        "BriefDescription": "WR_CAS Access to Rank 5; Bank 7",
         "EventCode": "0xBD",
-        "EventName": "UNC_M_WR_CAS_RANK5.BANK13",
+        "EventName": "UNC_M_WR_CAS_RANK5.BANK7",
         "PerPkg": "1",
-        "UMask": "0xD",
+        "PublicDescription": "WR_CAS Access to Rank 0 : Bank 7",
+        "UMask": "0x7",
         "Unit": "iMC"
     },
     {
-        "BriefDescription": "WR_CAS Access to Rank 5; Bank 14",
-        "Counter": "0,1,2,3",
+        "BriefDescription": "WR_CAS Access to Rank 5; Bank 8",
         "EventCode": "0xBD",
-        "EventName": "UNC_M_WR_CAS_RANK5.BANK14",
+        "EventName": "UNC_M_WR_CAS_RANK5.BANK8",
         "PerPkg": "1",
-        "UMask": "0xE",
+        "PublicDescription": "WR_CAS Access to Rank 0 : Bank 8",
+        "UMask": "0x8",
         "Unit": "iMC"
     },
     {
-        "BriefDescription": "WR_CAS Access to Rank 5; Bank 15",
-        "Counter": "0,1,2,3",
+        "BriefDescription": "WR_CAS Access to Rank 5; Bank 9",
         "EventCode": "0xBD",
-        "EventName": "UNC_M_WR_CAS_RANK5.BANK15",
+        "EventName": "UNC_M_WR_CAS_RANK5.BANK9",
         "PerPkg": "1",
-        "UMask": "0xF",
+        "PublicDescription": "WR_CAS Access to Rank 0 : Bank 9",
+        "UMask": "0x9",
         "Unit": "iMC"
     },
     {
         "BriefDescription": "WR_CAS Access to Rank 5; Bank Group 0 (Banks =
0-3)",
-        "Counter": "0,1,2,3",
         "EventCode": "0xBD",
         "EventName": "UNC_M_WR_CAS_RANK5.BANKG0",
         "PerPkg": "1",
+        "PublicDescription": "WR_CAS Access to Rank 0 : Bank Group 0 (Bank=
s 0-3)",
         "UMask": "0x11",
         "Unit": "iMC"
     },
     {
         "BriefDescription": "WR_CAS Access to Rank 5; Bank Group 1 (Banks =
4-7)",
-        "Counter": "0,1,2,3",
         "EventCode": "0xBD",
         "EventName": "UNC_M_WR_CAS_RANK5.BANKG1",
         "PerPkg": "1",
+        "PublicDescription": "WR_CAS Access to Rank 0 : Bank Group 1 (Bank=
s 4-7)",
         "UMask": "0x12",
         "Unit": "iMC"
     },
     {
         "BriefDescription": "WR_CAS Access to Rank 5; Bank Group 2 (Banks =
8-11)",
-        "Counter": "0,1,2,3",
         "EventCode": "0xBD",
         "EventName": "UNC_M_WR_CAS_RANK5.BANKG2",
         "PerPkg": "1",
+        "PublicDescription": "WR_CAS Access to Rank 0 : Bank Group 2 (Bank=
s 8-11)",
         "UMask": "0x13",
         "Unit": "iMC"
     },
     {
         "BriefDescription": "WR_CAS Access to Rank 5; Bank Group 3 (Banks =
12-15)",
-        "Counter": "0,1,2,3",
         "EventCode": "0xBD",
         "EventName": "UNC_M_WR_CAS_RANK5.BANKG3",
         "PerPkg": "1",
+        "PublicDescription": "WR_CAS Access to Rank 0 : Bank Group 3 (Bank=
s 12-15)",
         "UMask": "0x14",
         "Unit": "iMC"
     },
     {
-        "BriefDescription": "WR_CAS Access to Rank 6; Bank 1",
-        "Counter": "0,1,2,3",
+        "BriefDescription": "WR_CAS Access to Rank 6; All Banks",
         "EventCode": "0xBE",
-        "EventName": "UNC_M_WR_CAS_RANK6.BANK1",
+        "EventName": "UNC_M_WR_CAS_RANK6.ALLBANKS",
         "PerPkg": "1",
-        "UMask": "0x1",
+        "PublicDescription": "WR_CAS Access to Rank 0 : All Banks",
+        "UMask": "0x10",
         "Unit": "iMC"
     },
     {
-        "BriefDescription": "WR_CAS Access to Rank 6; Bank 2",
-        "Counter": "0,1,2,3",
+        "BriefDescription": "WR_CAS Access to Rank 6; Bank 0",
         "EventCode": "0xBE",
-        "EventName": "UNC_M_WR_CAS_RANK6.BANK2",
+        "EventName": "UNC_M_WR_CAS_RANK6.BANK0",
         "PerPkg": "1",
-        "UMask": "0x2",
+        "PublicDescription": "WR_CAS Access to Rank 0 : Bank 0",
         "Unit": "iMC"
     },
     {
-        "BriefDescription": "WR_CAS Access to Rank 6; Bank 4",
-        "Counter": "0,1,2,3",
+        "BriefDescription": "WR_CAS Access to Rank 6; Bank 1",
         "EventCode": "0xBE",
-        "EventName": "UNC_M_WR_CAS_RANK6.BANK4",
+        "EventName": "UNC_M_WR_CAS_RANK6.BANK1",
         "PerPkg": "1",
-        "UMask": "0x4",
+        "PublicDescription": "WR_CAS Access to Rank 0 : Bank 1",
+        "UMask": "0x1",
         "Unit": "iMC"
     },
     {
-        "BriefDescription": "WR_CAS Access to Rank 6; Bank 8",
-        "Counter": "0,1,2,3",
+        "BriefDescription": "WR_CAS Access to Rank 6; Bank 10",
         "EventCode": "0xBE",
-        "EventName": "UNC_M_WR_CAS_RANK6.BANK8",
+        "EventName": "UNC_M_WR_CAS_RANK6.BANK10",
         "PerPkg": "1",
-        "UMask": "0x8",
+        "PublicDescription": "WR_CAS Access to Rank 0 : Bank 10",
+        "UMask": "0xa",
         "Unit": "iMC"
     },
     {
-        "BriefDescription": "WR_CAS Access to Rank 6; All Banks",
-        "Counter": "0,1,2,3",
+        "BriefDescription": "WR_CAS Access to Rank 6; Bank 11",
         "EventCode": "0xBE",
-        "EventName": "UNC_M_WR_CAS_RANK6.ALLBANKS",
+        "EventName": "UNC_M_WR_CAS_RANK6.BANK11",
         "PerPkg": "1",
-        "UMask": "0x10",
+        "PublicDescription": "WR_CAS Access to Rank 0 : Bank 11",
+        "UMask": "0xb",
         "Unit": "iMC"
     },
     {
-        "BriefDescription": "WR_CAS Access to Rank 6; Bank 0",
-        "Counter": "0,1,2,3",
+        "BriefDescription": "WR_CAS Access to Rank 6; Bank 12",
         "EventCode": "0xBE",
-        "EventName": "UNC_M_WR_CAS_RANK6.BANK0",
+        "EventName": "UNC_M_WR_CAS_RANK6.BANK12",
         "PerPkg": "1",
+        "PublicDescription": "WR_CAS Access to Rank 0 : Bank 12",
+        "UMask": "0xc",
         "Unit": "iMC"
     },
     {
-        "BriefDescription": "WR_CAS Access to Rank 6; Bank 3",
-        "Counter": "0,1,2,3",
+        "BriefDescription": "WR_CAS Access to Rank 6; Bank 13",
         "EventCode": "0xBE",
-        "EventName": "UNC_M_WR_CAS_RANK6.BANK3",
+        "EventName": "UNC_M_WR_CAS_RANK6.BANK13",
         "PerPkg": "1",
-        "UMask": "0x3",
+        "PublicDescription": "WR_CAS Access to Rank 0 : Bank 13",
+        "UMask": "0xd",
         "Unit": "iMC"
     },
     {
-        "BriefDescription": "WR_CAS Access to Rank 6; Bank 5",
-        "Counter": "0,1,2,3",
+        "BriefDescription": "WR_CAS Access to Rank 6; Bank 14",
         "EventCode": "0xBE",
-        "EventName": "UNC_M_WR_CAS_RANK6.BANK5",
+        "EventName": "UNC_M_WR_CAS_RANK6.BANK14",
         "PerPkg": "1",
-        "UMask": "0x5",
+        "PublicDescription": "WR_CAS Access to Rank 0 : Bank 14",
+        "UMask": "0xe",
         "Unit": "iMC"
     },
     {
-        "BriefDescription": "WR_CAS Access to Rank 6; Bank 6",
-        "Counter": "0,1,2,3",
+        "BriefDescription": "WR_CAS Access to Rank 6; Bank 15",
         "EventCode": "0xBE",
-        "EventName": "UNC_M_WR_CAS_RANK6.BANK6",
+        "EventName": "UNC_M_WR_CAS_RANK6.BANK15",
         "PerPkg": "1",
-        "UMask": "0x6",
+        "PublicDescription": "WR_CAS Access to Rank 0 : Bank 15",
+        "UMask": "0xf",
         "Unit": "iMC"
     },
     {
-        "BriefDescription": "WR_CAS Access to Rank 6; Bank 7",
-        "Counter": "0,1,2,3",
+        "BriefDescription": "WR_CAS Access to Rank 6; Bank 2",
         "EventCode": "0xBE",
-        "EventName": "UNC_M_WR_CAS_RANK6.BANK7",
+        "EventName": "UNC_M_WR_CAS_RANK6.BANK2",
         "PerPkg": "1",
-        "UMask": "0x7",
+        "PublicDescription": "WR_CAS Access to Rank 0 : Bank 2",
+        "UMask": "0x2",
         "Unit": "iMC"
     },
     {
-        "BriefDescription": "WR_CAS Access to Rank 6; Bank 9",
-        "Counter": "0,1,2,3",
+        "BriefDescription": "WR_CAS Access to Rank 6; Bank 3",
         "EventCode": "0xBE",
-        "EventName": "UNC_M_WR_CAS_RANK6.BANK9",
+        "EventName": "UNC_M_WR_CAS_RANK6.BANK3",
         "PerPkg": "1",
-        "UMask": "0x9",
+        "PublicDescription": "WR_CAS Access to Rank 0 : Bank 3",
+        "UMask": "0x3",
         "Unit": "iMC"
     },
     {
-        "BriefDescription": "WR_CAS Access to Rank 6; Bank 10",
-        "Counter": "0,1,2,3",
+        "BriefDescription": "WR_CAS Access to Rank 6; Bank 4",
         "EventCode": "0xBE",
-        "EventName": "UNC_M_WR_CAS_RANK6.BANK10",
+        "EventName": "UNC_M_WR_CAS_RANK6.BANK4",
         "PerPkg": "1",
-        "UMask": "0xA",
+        "PublicDescription": "WR_CAS Access to Rank 0 : Bank 4",
+        "UMask": "0x4",
         "Unit": "iMC"
     },
     {
-        "BriefDescription": "WR_CAS Access to Rank 6; Bank 11",
-        "Counter": "0,1,2,3",
+        "BriefDescription": "WR_CAS Access to Rank 6; Bank 5",
         "EventCode": "0xBE",
-        "EventName": "UNC_M_WR_CAS_RANK6.BANK11",
+        "EventName": "UNC_M_WR_CAS_RANK6.BANK5",
         "PerPkg": "1",
-        "UMask": "0xB",
+        "PublicDescription": "WR_CAS Access to Rank 0 : Bank 5",
+        "UMask": "0x5",
         "Unit": "iMC"
     },
     {
-        "BriefDescription": "WR_CAS Access to Rank 6; Bank 12",
-        "Counter": "0,1,2,3",
+        "BriefDescription": "WR_CAS Access to Rank 6; Bank 6",
         "EventCode": "0xBE",
-        "EventName": "UNC_M_WR_CAS_RANK6.BANK12",
+        "EventName": "UNC_M_WR_CAS_RANK6.BANK6",
         "PerPkg": "1",
-        "UMask": "0xC",
+        "PublicDescription": "WR_CAS Access to Rank 0 : Bank 6",
+        "UMask": "0x6",
         "Unit": "iMC"
     },
     {
-        "BriefDescription": "WR_CAS Access to Rank 6; Bank 13",
-        "Counter": "0,1,2,3",
+        "BriefDescription": "WR_CAS Access to Rank 6; Bank 7",
         "EventCode": "0xBE",
-        "EventName": "UNC_M_WR_CAS_RANK6.BANK13",
+        "EventName": "UNC_M_WR_CAS_RANK6.BANK7",
         "PerPkg": "1",
-        "UMask": "0xD",
+        "PublicDescription": "WR_CAS Access to Rank 0 : Bank 7",
+        "UMask": "0x7",
         "Unit": "iMC"
     },
     {
-        "BriefDescription": "WR_CAS Access to Rank 6; Bank 14",
-        "Counter": "0,1,2,3",
+        "BriefDescription": "WR_CAS Access to Rank 6; Bank 8",
         "EventCode": "0xBE",
-        "EventName": "UNC_M_WR_CAS_RANK6.BANK14",
+        "EventName": "UNC_M_WR_CAS_RANK6.BANK8",
         "PerPkg": "1",
-        "UMask": "0xE",
+        "PublicDescription": "WR_CAS Access to Rank 0 : Bank 8",
+        "UMask": "0x8",
         "Unit": "iMC"
     },
     {
-        "BriefDescription": "WR_CAS Access to Rank 6; Bank 15",
-        "Counter": "0,1,2,3",
+        "BriefDescription": "WR_CAS Access to Rank 6; Bank 9",
         "EventCode": "0xBE",
-        "EventName": "UNC_M_WR_CAS_RANK6.BANK15",
+        "EventName": "UNC_M_WR_CAS_RANK6.BANK9",
         "PerPkg": "1",
-        "UMask": "0xF",
+        "PublicDescription": "WR_CAS Access to Rank 0 : Bank 9",
+        "UMask": "0x9",
         "Unit": "iMC"
     },
     {
         "BriefDescription": "WR_CAS Access to Rank 6; Bank Group 0 (Banks =
0-3)",
-        "Counter": "0,1,2,3",
         "EventCode": "0xBE",
         "EventName": "UNC_M_WR_CAS_RANK6.BANKG0",
         "PerPkg": "1",
+        "PublicDescription": "WR_CAS Access to Rank 0 : Bank Group 0 (Bank=
s 0-3)",
         "UMask": "0x11",
         "Unit": "iMC"
     },
     {
         "BriefDescription": "WR_CAS Access to Rank 6; Bank Group 1 (Banks =
4-7)",
-        "Counter": "0,1,2,3",
         "EventCode": "0xBE",
         "EventName": "UNC_M_WR_CAS_RANK6.BANKG1",
         "PerPkg": "1",
+        "PublicDescription": "WR_CAS Access to Rank 0 : Bank Group 1 (Bank=
s 4-7)",
         "UMask": "0x12",
         "Unit": "iMC"
     },
     {
         "BriefDescription": "WR_CAS Access to Rank 6; Bank Group 2 (Banks =
8-11)",
-        "Counter": "0,1,2,3",
         "EventCode": "0xBE",
         "EventName": "UNC_M_WR_CAS_RANK6.BANKG2",
         "PerPkg": "1",
+        "PublicDescription": "WR_CAS Access to Rank 0 : Bank Group 2 (Bank=
s 8-11)",
         "UMask": "0x13",
         "Unit": "iMC"
     },
     {
         "BriefDescription": "WR_CAS Access to Rank 6; Bank Group 3 (Banks =
12-15)",
-        "Counter": "0,1,2,3",
         "EventCode": "0xBE",
         "EventName": "UNC_M_WR_CAS_RANK6.BANKG3",
         "PerPkg": "1",
+        "PublicDescription": "WR_CAS Access to Rank 0 : Bank Group 3 (Bank=
s 12-15)",
         "UMask": "0x14",
         "Unit": "iMC"
     },
     {
-        "BriefDescription": "WR_CAS Access to Rank 7; Bank 1",
-        "Counter": "0,1,2,3",
+        "BriefDescription": "WR_CAS Access to Rank 7; All Banks",
         "EventCode": "0xBF",
-        "EventName": "UNC_M_WR_CAS_RANK7.BANK1",
+        "EventName": "UNC_M_WR_CAS_RANK7.ALLBANKS",
         "PerPkg": "1",
-        "UMask": "0x1",
+        "PublicDescription": "WR_CAS Access to Rank 0 : All Banks",
+        "UMask": "0x10",
         "Unit": "iMC"
     },
     {
-        "BriefDescription": "WR_CAS Access to Rank 7; Bank 2",
-        "Counter": "0,1,2,3",
+        "BriefDescription": "WR_CAS Access to Rank 7; Bank 0",
         "EventCode": "0xBF",
-        "EventName": "UNC_M_WR_CAS_RANK7.BANK2",
+        "EventName": "UNC_M_WR_CAS_RANK7.BANK0",
         "PerPkg": "1",
-        "UMask": "0x2",
+        "PublicDescription": "WR_CAS Access to Rank 0 : Bank 0",
         "Unit": "iMC"
     },
     {
-        "BriefDescription": "WR_CAS Access to Rank 7; Bank 4",
-        "Counter": "0,1,2,3",
+        "BriefDescription": "WR_CAS Access to Rank 7; Bank 1",
         "EventCode": "0xBF",
-        "EventName": "UNC_M_WR_CAS_RANK7.BANK4",
+        "EventName": "UNC_M_WR_CAS_RANK7.BANK1",
         "PerPkg": "1",
-        "UMask": "0x4",
+        "PublicDescription": "WR_CAS Access to Rank 0 : Bank 1",
+        "UMask": "0x1",
         "Unit": "iMC"
     },
     {
-        "BriefDescription": "WR_CAS Access to Rank 7; Bank 8",
-        "Counter": "0,1,2,3",
+        "BriefDescription": "WR_CAS Access to Rank 7; Bank 10",
         "EventCode": "0xBF",
-        "EventName": "UNC_M_WR_CAS_RANK7.BANK8",
+        "EventName": "UNC_M_WR_CAS_RANK7.BANK10",
         "PerPkg": "1",
-        "UMask": "0x8",
+        "PublicDescription": "WR_CAS Access to Rank 0 : Bank 10",
+        "UMask": "0xa",
         "Unit": "iMC"
     },
     {
-        "BriefDescription": "WR_CAS Access to Rank 7; All Banks",
-        "Counter": "0,1,2,3",
+        "BriefDescription": "WR_CAS Access to Rank 7; Bank 11",
         "EventCode": "0xBF",
-        "EventName": "UNC_M_WR_CAS_RANK7.ALLBANKS",
+        "EventName": "UNC_M_WR_CAS_RANK7.BANK11",
         "PerPkg": "1",
-        "UMask": "0x10",
+        "PublicDescription": "WR_CAS Access to Rank 0 : Bank 11",
+        "UMask": "0xb",
         "Unit": "iMC"
     },
     {
-        "BriefDescription": "WR_CAS Access to Rank 7; Bank 0",
-        "Counter": "0,1,2,3",
+        "BriefDescription": "WR_CAS Access to Rank 7; Bank 12",
         "EventCode": "0xBF",
-        "EventName": "UNC_M_WR_CAS_RANK7.BANK0",
+        "EventName": "UNC_M_WR_CAS_RANK7.BANK12",
         "PerPkg": "1",
+        "PublicDescription": "WR_CAS Access to Rank 0 : Bank 12",
+        "UMask": "0xc",
         "Unit": "iMC"
     },
     {
-        "BriefDescription": "WR_CAS Access to Rank 7; Bank 3",
-        "Counter": "0,1,2,3",
+        "BriefDescription": "WR_CAS Access to Rank 7; Bank 13",
         "EventCode": "0xBF",
-        "EventName": "UNC_M_WR_CAS_RANK7.BANK3",
+        "EventName": "UNC_M_WR_CAS_RANK7.BANK13",
         "PerPkg": "1",
-        "UMask": "0x3",
+        "PublicDescription": "WR_CAS Access to Rank 0 : Bank 13",
+        "UMask": "0xd",
         "Unit": "iMC"
     },
     {
-        "BriefDescription": "WR_CAS Access to Rank 7; Bank 5",
-        "Counter": "0,1,2,3",
+        "BriefDescription": "WR_CAS Access to Rank 7; Bank 14",
         "EventCode": "0xBF",
-        "EventName": "UNC_M_WR_CAS_RANK7.BANK5",
+        "EventName": "UNC_M_WR_CAS_RANK7.BANK14",
         "PerPkg": "1",
-        "UMask": "0x5",
+        "PublicDescription": "WR_CAS Access to Rank 0 : Bank 14",
+        "UMask": "0xe",
         "Unit": "iMC"
     },
     {
-        "BriefDescription": "WR_CAS Access to Rank 7; Bank 6",
-        "Counter": "0,1,2,3",
+        "BriefDescription": "WR_CAS Access to Rank 7; Bank 15",
         "EventCode": "0xBF",
-        "EventName": "UNC_M_WR_CAS_RANK7.BANK6",
+        "EventName": "UNC_M_WR_CAS_RANK7.BANK15",
         "PerPkg": "1",
-        "UMask": "0x6",
+        "PublicDescription": "WR_CAS Access to Rank 0 : Bank 15",
+        "UMask": "0xf",
         "Unit": "iMC"
     },
     {
-        "BriefDescription": "WR_CAS Access to Rank 7; Bank 7",
-        "Counter": "0,1,2,3",
+        "BriefDescription": "WR_CAS Access to Rank 7; Bank 2",
         "EventCode": "0xBF",
-        "EventName": "UNC_M_WR_CAS_RANK7.BANK7",
+        "EventName": "UNC_M_WR_CAS_RANK7.BANK2",
         "PerPkg": "1",
-        "UMask": "0x7",
+        "PublicDescription": "WR_CAS Access to Rank 0 : Bank 2",
+        "UMask": "0x2",
         "Unit": "iMC"
     },
     {
-        "BriefDescription": "WR_CAS Access to Rank 7; Bank 9",
-        "Counter": "0,1,2,3",
+        "BriefDescription": "WR_CAS Access to Rank 7; Bank 3",
         "EventCode": "0xBF",
-        "EventName": "UNC_M_WR_CAS_RANK7.BANK9",
+        "EventName": "UNC_M_WR_CAS_RANK7.BANK3",
         "PerPkg": "1",
-        "UMask": "0x9",
+        "PublicDescription": "WR_CAS Access to Rank 0 : Bank 3",
+        "UMask": "0x3",
         "Unit": "iMC"
     },
     {
-        "BriefDescription": "WR_CAS Access to Rank 7; Bank 10",
-        "Counter": "0,1,2,3",
+        "BriefDescription": "WR_CAS Access to Rank 7; Bank 4",
         "EventCode": "0xBF",
-        "EventName": "UNC_M_WR_CAS_RANK7.BANK10",
+        "EventName": "UNC_M_WR_CAS_RANK7.BANK4",
         "PerPkg": "1",
-        "UMask": "0xA",
+        "PublicDescription": "WR_CAS Access to Rank 0 : Bank 4",
+        "UMask": "0x4",
         "Unit": "iMC"
     },
     {
-        "BriefDescription": "WR_CAS Access to Rank 7; Bank 11",
-        "Counter": "0,1,2,3",
+        "BriefDescription": "WR_CAS Access to Rank 7; Bank 5",
         "EventCode": "0xBF",
-        "EventName": "UNC_M_WR_CAS_RANK7.BANK11",
+        "EventName": "UNC_M_WR_CAS_RANK7.BANK5",
         "PerPkg": "1",
-        "UMask": "0xB",
+        "PublicDescription": "WR_CAS Access to Rank 0 : Bank 5",
+        "UMask": "0x5",
         "Unit": "iMC"
     },
     {
-        "BriefDescription": "WR_CAS Access to Rank 7; Bank 12",
-        "Counter": "0,1,2,3",
+        "BriefDescription": "WR_CAS Access to Rank 7; Bank 6",
         "EventCode": "0xBF",
-        "EventName": "UNC_M_WR_CAS_RANK7.BANK12",
+        "EventName": "UNC_M_WR_CAS_RANK7.BANK6",
         "PerPkg": "1",
-        "UMask": "0xC",
+        "PublicDescription": "WR_CAS Access to Rank 0 : Bank 6",
+        "UMask": "0x6",
         "Unit": "iMC"
     },
     {
-        "BriefDescription": "WR_CAS Access to Rank 7; Bank 13",
-        "Counter": "0,1,2,3",
+        "BriefDescription": "WR_CAS Access to Rank 7; Bank 7",
         "EventCode": "0xBF",
-        "EventName": "UNC_M_WR_CAS_RANK7.BANK13",
+        "EventName": "UNC_M_WR_CAS_RANK7.BANK7",
         "PerPkg": "1",
-        "UMask": "0xD",
+        "PublicDescription": "WR_CAS Access to Rank 0 : Bank 7",
+        "UMask": "0x7",
         "Unit": "iMC"
     },
     {
-        "BriefDescription": "WR_CAS Access to Rank 7; Bank 14",
-        "Counter": "0,1,2,3",
+        "BriefDescription": "WR_CAS Access to Rank 7; Bank 8",
         "EventCode": "0xBF",
-        "EventName": "UNC_M_WR_CAS_RANK7.BANK14",
+        "EventName": "UNC_M_WR_CAS_RANK7.BANK8",
         "PerPkg": "1",
-        "UMask": "0xE",
+        "PublicDescription": "WR_CAS Access to Rank 0 : Bank 8",
+        "UMask": "0x8",
         "Unit": "iMC"
     },
     {
-        "BriefDescription": "WR_CAS Access to Rank 7; Bank 15",
-        "Counter": "0,1,2,3",
+        "BriefDescription": "WR_CAS Access to Rank 7; Bank 9",
         "EventCode": "0xBF",
-        "EventName": "UNC_M_WR_CAS_RANK7.BANK15",
+        "EventName": "UNC_M_WR_CAS_RANK7.BANK9",
         "PerPkg": "1",
-        "UMask": "0xF",
+        "PublicDescription": "WR_CAS Access to Rank 0 : Bank 9",
+        "UMask": "0x9",
         "Unit": "iMC"
     },
     {
         "BriefDescription": "WR_CAS Access to Rank 7; Bank Group 0 (Banks =
0-3)",
-        "Counter": "0,1,2,3",
         "EventCode": "0xBF",
         "EventName": "UNC_M_WR_CAS_RANK7.BANKG0",
         "PerPkg": "1",
+        "PublicDescription": "WR_CAS Access to Rank 0 : Bank Group 0 (Bank=
s 0-3)",
         "UMask": "0x11",
         "Unit": "iMC"
     },
     {
         "BriefDescription": "WR_CAS Access to Rank 7; Bank Group 1 (Banks =
4-7)",
-        "Counter": "0,1,2,3",
         "EventCode": "0xBF",
         "EventName": "UNC_M_WR_CAS_RANK7.BANKG1",
         "PerPkg": "1",
+        "PublicDescription": "WR_CAS Access to Rank 0 : Bank Group 1 (Bank=
s 4-7)",
         "UMask": "0x12",
         "Unit": "iMC"
     },
     {
         "BriefDescription": "WR_CAS Access to Rank 7; Bank Group 2 (Banks =
8-11)",
-        "Counter": "0,1,2,3",
         "EventCode": "0xBF",
         "EventName": "UNC_M_WR_CAS_RANK7.BANKG2",
         "PerPkg": "1",
+        "PublicDescription": "WR_CAS Access to Rank 0 : Bank Group 2 (Bank=
s 8-11)",
         "UMask": "0x13",
         "Unit": "iMC"
     },
     {
         "BriefDescription": "WR_CAS Access to Rank 7; Bank Group 3 (Banks =
12-15)",
-        "Counter": "0,1,2,3",
         "EventCode": "0xBF",
         "EventName": "UNC_M_WR_CAS_RANK7.BANKG3",
         "PerPkg": "1",
+        "PublicDescription": "WR_CAS Access to Rank 0 : Bank Group 3 (Bank=
s 12-15)",
         "UMask": "0x14",
         "Unit": "iMC"
-    },
-    {
-        "BriefDescription": "DRAM Clockticks",
-        "Counter": "0,1,2,3",
-        "EventName": "UNC_M_DCLOCKTICKS",
-        "PerPkg": "1",
-        "Unit": "iMC"
     }
 ]
diff --git a/tools/perf/pmu-events/arch/x86/haswellx/uncore-other.json b/to=
ols/perf/pmu-events/arch/x86/haswellx/uncore-other.json
index 135b59f34f37..4c3e2a794117 100644
--- a/tools/perf/pmu-events/arch/x86/haswellx/uncore-other.json
+++ b/tools/perf/pmu-events/arch/x86/haswellx/uncore-other.json
@@ -1,829 +1,816 @@
 [
     {
         "BriefDescription": "Total Write Cache Occupancy; Any Source",
-        "Counter": "0,1",
         "EventCode": "0x12",
         "EventName": "UNC_I_CACHE_TOTAL_OCCUPANCY.ANY",
         "PerPkg": "1",
+        "PublicDescription": "Accumulates the number of reads and writes t=
hat are outstanding in the uncore in each cycle.  This is effectively the s=
um of the READ_OCCUPANCY and WRITE_OCCUPANCY events.; Tracks all requests f=
rom any source port.",
         "UMask": "0x1",
         "Unit": "IRP"
     },
     {
         "BriefDescription": "Total Write Cache Occupancy; Select Source",
-        "Counter": "0,1",
         "EventCode": "0x12",
         "EventName": "UNC_I_CACHE_TOTAL_OCCUPANCY.SOURCE",
         "PerPkg": "1",
+        "PublicDescription": "Accumulates the number of reads and writes t=
hat are outstanding in the uncore in each cycle.  This is effectively the s=
um of the READ_OCCUPANCY and WRITE_OCCUPANCY events.; Tracks only those req=
uests that come from the port specified in the IRP_PmonFilter.OrderingQ reg=
ister.  This register allows one to select one specific queue.  It is not p=
ossible to monitor multiple queues at a time.",
         "UMask": "0x2",
         "Unit": "IRP"
     },
     {
         "BriefDescription": "Clocks in the IRP",
-        "Counter": "0,1",
         "EventName": "UNC_I_CLOCKTICKS",
         "PerPkg": "1",
+        "PublicDescription": "Number of clocks in the IRP.",
         "Unit": "IRP"
     },
     {
-        "BriefDescription": "Coherent Ops; PCIRdCur",
-        "Counter": "0,1",
+        "BriefDescription": "Coherent Ops; CLFlush",
         "EventCode": "0x13",
-        "EventName": "UNC_I_COHERENT_OPS.PCIRDCUR",
+        "EventName": "UNC_I_COHERENT_OPS.CLFLUSH",
         "PerPkg": "1",
-        "UMask": "0x1",
+        "PublicDescription": "Counts the number of coherency related opera=
tions servied by the IRP",
+        "UMask": "0x80",
         "Unit": "IRP"
     },
     {
         "BriefDescription": "Coherent Ops; CRd",
-        "Counter": "0,1",
         "EventCode": "0x13",
         "EventName": "UNC_I_COHERENT_OPS.CRD",
         "PerPkg": "1",
+        "PublicDescription": "Counts the number of coherency related opera=
tions servied by the IRP",
         "UMask": "0x2",
         "Unit": "IRP"
     },
     {
         "BriefDescription": "Coherent Ops; DRd",
-        "Counter": "0,1",
         "EventCode": "0x13",
         "EventName": "UNC_I_COHERENT_OPS.DRD",
         "PerPkg": "1",
+        "PublicDescription": "Counts the number of coherency related opera=
tions servied by the IRP",
         "UMask": "0x4",
         "Unit": "IRP"
     },
     {
-        "BriefDescription": "Coherent Ops; RFO",
-        "Counter": "0,1",
+        "BriefDescription": "Coherent Ops; PCIDCAHin5t",
         "EventCode": "0x13",
-        "EventName": "UNC_I_COHERENT_OPS.RFO",
+        "EventName": "UNC_I_COHERENT_OPS.PCIDCAHINT",
         "PerPkg": "1",
-        "UMask": "0x8",
+        "PublicDescription": "Counts the number of coherency related opera=
tions servied by the IRP",
+        "UMask": "0x20",
+        "Unit": "IRP"
+    },
+    {
+        "BriefDescription": "Coherent Ops; PCIRdCur",
+        "EventCode": "0x13",
+        "EventName": "UNC_I_COHERENT_OPS.PCIRDCUR",
+        "PerPkg": "1",
+        "PublicDescription": "Counts the number of coherency related opera=
tions servied by the IRP",
+        "UMask": "0x1",
         "Unit": "IRP"
     },
     {
         "BriefDescription": "Coherent Ops; PCIItoM",
-        "Counter": "0,1",
         "EventCode": "0x13",
         "EventName": "UNC_I_COHERENT_OPS.PCITOM",
         "PerPkg": "1",
+        "PublicDescription": "Counts the number of coherency related opera=
tions servied by the IRP",
         "UMask": "0x10",
         "Unit": "IRP"
     },
     {
-        "BriefDescription": "Coherent Ops; PCIDCAHin5t",
-        "Counter": "0,1",
+        "BriefDescription": "Coherent Ops; RFO",
         "EventCode": "0x13",
-        "EventName": "UNC_I_COHERENT_OPS.PCIDCAHINT",
+        "EventName": "UNC_I_COHERENT_OPS.RFO",
         "PerPkg": "1",
-        "UMask": "0x20",
+        "PublicDescription": "Counts the number of coherency related opera=
tions servied by the IRP",
+        "UMask": "0x8",
         "Unit": "IRP"
     },
     {
         "BriefDescription": "Coherent Ops; WbMtoI",
-        "Counter": "0,1",
         "EventCode": "0x13",
         "EventName": "UNC_I_COHERENT_OPS.WBMTOI",
         "PerPkg": "1",
+        "PublicDescription": "Counts the number of coherency related opera=
tions servied by the IRP",
         "UMask": "0x40",
         "Unit": "IRP"
     },
     {
-        "BriefDescription": "Coherent Ops; CLFlush",
-        "Counter": "0,1",
-        "EventCode": "0x13",
-        "EventName": "UNC_I_COHERENT_OPS.CLFLUSH",
-        "PerPkg": "1",
-        "UMask": "0x80",
-        "Unit": "IRP"
-    },
-    {
-        "BriefDescription": "Misc Events - Set 0; Fastpath Requests",
-        "Counter": "0,1",
-        "EventCode": "0x14",
-        "EventName": "UNC_I_MISC0.FAST_REQ",
-        "PerPkg": "1",
-        "UMask": "0x1",
-        "Unit": "IRP"
-    },
-    {
-        "BriefDescription": "Misc Events - Set 0; Fastpath Rejects",
-        "Counter": "0,1",
+        "BriefDescription": "Misc Events - Set 0; Cache Inserts of Atomic =
Transactions as Secondary",
         "EventCode": "0x14",
-        "EventName": "UNC_I_MISC0.FAST_REJ",
+        "EventName": "UNC_I_MISC0.2ND_ATOMIC_INSERT",
         "PerPkg": "1",
-        "UMask": "0x2",
+        "PublicDescription": "Counts Timeouts - Set 0 : Cache Inserts of A=
tomic Transactions as Secondary",
+        "UMask": "0x10",
         "Unit": "IRP"
     },
     {
         "BriefDescription": "Misc Events - Set 0; Cache Inserts of Read Tr=
ansactions as Secondary",
-        "Counter": "0,1",
         "EventCode": "0x14",
         "EventName": "UNC_I_MISC0.2ND_RD_INSERT",
         "PerPkg": "1",
+        "PublicDescription": "Counts Timeouts - Set 0 : Cache Inserts of R=
ead Transactions as Secondary",
         "UMask": "0x4",
         "Unit": "IRP"
     },
     {
         "BriefDescription": "Misc Events - Set 0; Cache Inserts of Write T=
ransactions as Secondary",
-        "Counter": "0,1",
         "EventCode": "0x14",
         "EventName": "UNC_I_MISC0.2ND_WR_INSERT",
         "PerPkg": "1",
+        "PublicDescription": "Counts Timeouts - Set 0 : Cache Inserts of W=
rite Transactions as Secondary",
         "UMask": "0x8",
         "Unit": "IRP"
     },
     {
-        "BriefDescription": "Misc Events - Set 0; Cache Inserts of Atomic =
Transactions as Secondary",
-        "Counter": "0,1",
+        "BriefDescription": "Misc Events - Set 0; Fastpath Rejects",
         "EventCode": "0x14",
-        "EventName": "UNC_I_MISC0.2ND_ATOMIC_INSERT",
+        "EventName": "UNC_I_MISC0.FAST_REJ",
         "PerPkg": "1",
-        "UMask": "0x10",
+        "PublicDescription": "Counts Timeouts - Set 0 : Fastpath Rejects",
+        "UMask": "0x2",
+        "Unit": "IRP"
+    },
+    {
+        "BriefDescription": "Misc Events - Set 0; Fastpath Requests",
+        "EventCode": "0x14",
+        "EventName": "UNC_I_MISC0.FAST_REQ",
+        "PerPkg": "1",
+        "PublicDescription": "Counts Timeouts - Set 0 : Fastpath Requests"=
,
+        "UMask": "0x1",
         "Unit": "IRP"
     },
     {
         "BriefDescription": "Misc Events - Set 0; Fastpath Transfers From =
Primary to Secondary",
-        "Counter": "0,1",
         "EventCode": "0x14",
         "EventName": "UNC_I_MISC0.FAST_XFER",
         "PerPkg": "1",
+        "PublicDescription": "Counts Timeouts - Set 0 : Fastpath Transfers=
 From Primary to Secondary",
         "UMask": "0x20",
         "Unit": "IRP"
     },
     {
         "BriefDescription": "Misc Events - Set 0; Prefetch Ack Hints From =
Primary to Secondary",
-        "Counter": "0,1",
         "EventCode": "0x14",
         "EventName": "UNC_I_MISC0.PF_ACK_HINT",
         "PerPkg": "1",
+        "PublicDescription": "Counts Timeouts - Set 0 : Prefetch Ack Hints=
 From Primary to Secondary",
         "UMask": "0x40",
         "Unit": "IRP"
     },
     {
-        "BriefDescription": "Misc Events - Set 1; Slow Transfer of I Line"=
,
-        "Counter": "0,1",
+        "BriefDescription": "Misc Events - Set 0; Prefetch TimeOut",
+        "EventCode": "0x14",
+        "EventName": "UNC_I_MISC0.PF_TIMEOUT",
+        "PerPkg": "1",
+        "PublicDescription": "Indicates the fetch for a previous prefetch =
wasn't accepted by the prefetch.   This happens in the case of a prefetch T=
imeOut",
+        "UMask": "0x80",
+        "Unit": "IRP"
+    },
+    {
+        "BriefDescription": "Misc Events - Set 1; Data Throttled",
         "EventCode": "0x15",
-        "EventName": "UNC_I_MISC1.SLOW_I",
+        "EventName": "UNC_I_MISC1.DATA_THROTTLE",
         "PerPkg": "1",
-        "UMask": "0x1",
+        "PublicDescription": "IRP throttled switch data",
+        "UMask": "0x80",
         "Unit": "IRP"
     },
     {
-        "BriefDescription": "Misc Events - Set 1; Slow Transfer of S Line"=
,
-        "Counter": "0,1",
+        "BriefDescription": "Misc Events - Set 1",
         "EventCode": "0x15",
-        "EventName": "UNC_I_MISC1.SLOW_S",
+        "EventName": "UNC_I_MISC1.LOST_FWD",
         "PerPkg": "1",
-        "UMask": "0x2",
+        "PublicDescription": "Misc Events - Set 1 : Lost Forward : Snoop p=
ulled away ownership before a write was committed",
+        "UMask": "0x10",
         "Unit": "IRP"
     },
     {
-        "BriefDescription": "Misc Events - Set 1; Slow Transfer of E Line"=
,
-        "Counter": "0,1",
+        "BriefDescription": "Misc Events - Set 1; Received Invalid",
         "EventCode": "0x15",
-        "EventName": "UNC_I_MISC1.SLOW_E",
+        "EventName": "UNC_I_MISC1.SEC_RCVD_INVLD",
         "PerPkg": "1",
-        "UMask": "0x4",
+        "PublicDescription": "Secondary received a transfer that did not h=
ave sufficient MESI state",
+        "UMask": "0x20",
         "Unit": "IRP"
     },
     {
-        "BriefDescription": "Misc Events - Set 1; Slow Transfer of M Line"=
,
-        "Counter": "0,1",
+        "BriefDescription": "Misc Events - Set 1; Received Valid",
         "EventCode": "0x15",
-        "EventName": "UNC_I_MISC1.SLOW_M",
+        "EventName": "UNC_I_MISC1.SEC_RCVD_VLD",
         "PerPkg": "1",
-        "UMask": "0x8",
+        "PublicDescription": "Secondary received a transfer that did have =
sufficient MESI state",
+        "UMask": "0x40",
         "Unit": "IRP"
     },
     {
-        "BriefDescription": "Misc Events - Set 1",
-        "Counter": "0,1",
+        "BriefDescription": "Misc Events - Set 1; Slow Transfer of E Line"=
,
         "EventCode": "0x15",
-        "EventName": "UNC_I_MISC1.LOST_FWD",
+        "EventName": "UNC_I_MISC1.SLOW_E",
         "PerPkg": "1",
-        "UMask": "0x10",
+        "PublicDescription": "Secondary received a transfer that did have =
sufficient MESI state",
+        "UMask": "0x4",
         "Unit": "IRP"
     },
     {
-        "BriefDescription": "Misc Events - Set 1; Received Invalid",
-        "Counter": "0,1",
+        "BriefDescription": "Misc Events - Set 1; Slow Transfer of I Line"=
,
         "EventCode": "0x15",
-        "EventName": "UNC_I_MISC1.SEC_RCVD_INVLD",
+        "EventName": "UNC_I_MISC1.SLOW_I",
         "PerPkg": "1",
-        "UMask": "0x20",
+        "PublicDescription": "Snoop took cacheline ownership before write =
from data was committed.",
+        "UMask": "0x1",
         "Unit": "IRP"
     },
     {
-        "BriefDescription": "Misc Events - Set 1; Received Valid",
-        "Counter": "0,1",
+        "BriefDescription": "Misc Events - Set 1; Slow Transfer of M Line"=
,
         "EventCode": "0x15",
-        "EventName": "UNC_I_MISC1.SEC_RCVD_VLD",
+        "EventName": "UNC_I_MISC1.SLOW_M",
         "PerPkg": "1",
-        "UMask": "0x40",
+        "PublicDescription": "Snoop took cacheline ownership before write =
from data was committed.",
+        "UMask": "0x8",
         "Unit": "IRP"
     },
     {
-        "BriefDescription": "Misc Events - Set 1; Data Throttled",
-        "Counter": "0,1",
+        "BriefDescription": "Misc Events - Set 1; Slow Transfer of S Line"=
,
         "EventCode": "0x15",
-        "EventName": "UNC_I_MISC1.DATA_THROTTLE",
+        "EventName": "UNC_I_MISC1.SLOW_S",
         "PerPkg": "1",
-        "UMask": "0x80",
+        "PublicDescription": "Secondary received a transfer that did not h=
ave sufficient MESI state",
+        "UMask": "0x2",
         "Unit": "IRP"
     },
     {
         "BriefDescription": "AK Ingress Occupancy",
-        "Counter": "0,1",
         "EventCode": "0xA",
         "EventName": "UNC_I_RxR_AK_INSERTS",
         "PerPkg": "1",
+        "PublicDescription": "Counts the number of allocations into the AK=
 Ingress.  This queue is where the IRP receives responses from R2PCIe (the =
ring).",
         "Unit": "IRP"
     },
     {
         "BriefDescription": "UNC_I_RxR_BL_DRS_CYCLES_FULL",
-        "Counter": "0,1",
         "EventCode": "0x4",
         "EventName": "UNC_I_RxR_BL_DRS_CYCLES_FULL",
         "PerPkg": "1",
+        "PublicDescription": "Counts the number of cycles when the BL Ingr=
ess is full.  This queue is where the IRP receives data from R2PCIe (the ri=
ng).  It is used for data returns from read requets as well as outbound MMI=
O writes.",
         "Unit": "IRP"
     },
     {
         "BriefDescription": "BL Ingress Occupancy - DRS",
-        "Counter": "0,1",
         "EventCode": "0x1",
         "EventName": "UNC_I_RxR_BL_DRS_INSERTS",
         "PerPkg": "1",
+        "PublicDescription": "Counts the number of allocations into the BL=
 Ingress.  This queue is where the IRP receives data from R2PCIe (the ring)=
.  It is used for data returns from read requets as well as outbound MMIO w=
rites.",
         "Unit": "IRP"
     },
     {
         "BriefDescription": "UNC_I_RxR_BL_DRS_OCCUPANCY",
-        "Counter": "0,1",
         "EventCode": "0x7",
         "EventName": "UNC_I_RxR_BL_DRS_OCCUPANCY",
         "PerPkg": "1",
+        "PublicDescription": "Accumulates the occupancy of the BL Ingress =
in each cycles.  This queue is where the IRP receives data from R2PCIe (the=
 ring).  It is used for data returns from read requets as well as outbound =
MMIO writes.",
         "Unit": "IRP"
     },
     {
         "BriefDescription": "UNC_I_RxR_BL_NCB_CYCLES_FULL",
-        "Counter": "0,1",
         "EventCode": "0x5",
         "EventName": "UNC_I_RxR_BL_NCB_CYCLES_FULL",
         "PerPkg": "1",
+        "PublicDescription": "Counts the number of cycles when the BL Ingr=
ess is full.  This queue is where the IRP receives data from R2PCIe (the ri=
ng).  It is used for data returns from read requets as well as outbound MMI=
O writes.",
         "Unit": "IRP"
     },
     {
         "BriefDescription": "BL Ingress Occupancy - NCB",
-        "Counter": "0,1",
         "EventCode": "0x2",
         "EventName": "UNC_I_RxR_BL_NCB_INSERTS",
         "PerPkg": "1",
+        "PublicDescription": "Counts the number of allocations into the BL=
 Ingress.  This queue is where the IRP receives data from R2PCIe (the ring)=
.  It is used for data returns from read requets as well as outbound MMIO w=
rites.",
         "Unit": "IRP"
     },
     {
         "BriefDescription": "UNC_I_RxR_BL_NCB_OCCUPANCY",
-        "Counter": "0,1",
         "EventCode": "0x8",
         "EventName": "UNC_I_RxR_BL_NCB_OCCUPANCY",
         "PerPkg": "1",
+        "PublicDescription": "Accumulates the occupancy of the BL Ingress =
in each cycles.  This queue is where the IRP receives data from R2PCIe (the=
 ring).  It is used for data returns from read requets as well as outbound =
MMIO writes.",
         "Unit": "IRP"
     },
     {
         "BriefDescription": "UNC_I_RxR_BL_NCS_CYCLES_FULL",
-        "Counter": "0,1",
         "EventCode": "0x6",
         "EventName": "UNC_I_RxR_BL_NCS_CYCLES_FULL",
         "PerPkg": "1",
+        "PublicDescription": "Counts the number of cycles when the BL Ingr=
ess is full.  This queue is where the IRP receives data from R2PCIe (the ri=
ng).  It is used for data returns from read requets as well as outbound MMI=
O writes.",
         "Unit": "IRP"
     },
     {
         "BriefDescription": "BL Ingress Occupancy - NCS",
-        "Counter": "0,1",
         "EventCode": "0x3",
         "EventName": "UNC_I_RxR_BL_NCS_INSERTS",
         "PerPkg": "1",
+        "PublicDescription": "Counts the number of allocations into the BL=
 Ingress.  This queue is where the IRP receives data from R2PCIe (the ring)=
.  It is used for data returns from read requets as well as outbound MMIO w=
rites.",
         "Unit": "IRP"
     },
     {
         "BriefDescription": "UNC_I_RxR_BL_NCS_OCCUPANCY",
-        "Counter": "0,1",
         "EventCode": "0x9",
         "EventName": "UNC_I_RxR_BL_NCS_OCCUPANCY",
         "PerPkg": "1",
+        "PublicDescription": "Accumulates the occupancy of the BL Ingress =
in each cycles.  This queue is where the IRP receives data from R2PCIe (the=
 ring).  It is used for data returns from read requets as well as outbound =
MMIO writes.",
         "Unit": "IRP"
     },
     {
-        "BriefDescription": "Snoop Responses; Miss",
-        "Counter": "0,1",
+        "BriefDescription": "Snoop Responses; Hit E or S",
         "EventCode": "0x17",
-        "EventName": "UNC_I_SNOOP_RESP.MISS",
+        "EventName": "UNC_I_SNOOP_RESP.HIT_ES",
         "PerPkg": "1",
-        "UMask": "0x1",
+        "PublicDescription": "Snoop Responses : Hit E or S",
+        "UMask": "0x4",
         "Unit": "IRP"
     },
     {
         "BriefDescription": "Snoop Responses; Hit I",
-        "Counter": "0,1",
         "EventCode": "0x17",
         "EventName": "UNC_I_SNOOP_RESP.HIT_I",
         "PerPkg": "1",
+        "PublicDescription": "Snoop Responses : Hit I",
         "UMask": "0x2",
         "Unit": "IRP"
     },
     {
-        "BriefDescription": "Snoop Responses; Hit E or S",
-        "Counter": "0,1",
+        "BriefDescription": "Snoop Responses; Hit M",
         "EventCode": "0x17",
-        "EventName": "UNC_I_SNOOP_RESP.HIT_ES",
+        "EventName": "UNC_I_SNOOP_RESP.HIT_M",
         "PerPkg": "1",
-        "UMask": "0x4",
+        "PublicDescription": "Snoop Responses : Hit M",
+        "UMask": "0x8",
         "Unit": "IRP"
     },
     {
-        "BriefDescription": "Snoop Responses; Hit M",
-        "Counter": "0,1",
+        "BriefDescription": "Snoop Responses; Miss",
         "EventCode": "0x17",
-        "EventName": "UNC_I_SNOOP_RESP.HIT_M",
+        "EventName": "UNC_I_SNOOP_RESP.MISS",
         "PerPkg": "1",
-        "UMask": "0x8",
+        "PublicDescription": "Snoop Responses : Miss",
+        "UMask": "0x1",
         "Unit": "IRP"
     },
     {
         "BriefDescription": "Snoop Responses; SnpCode",
-        "Counter": "0,1",
         "EventCode": "0x17",
         "EventName": "UNC_I_SNOOP_RESP.SNPCODE",
         "PerPkg": "1",
+        "PublicDescription": "Snoop Responses : SnpCode",
         "UMask": "0x10",
         "Unit": "IRP"
     },
     {
         "BriefDescription": "Snoop Responses; SnpData",
-        "Counter": "0,1",
         "EventCode": "0x17",
         "EventName": "UNC_I_SNOOP_RESP.SNPDATA",
         "PerPkg": "1",
+        "PublicDescription": "Snoop Responses : SnpData",
         "UMask": "0x20",
         "Unit": "IRP"
     },
     {
         "BriefDescription": "Snoop Responses; SnpInv",
-        "Counter": "0,1",
         "EventCode": "0x17",
         "EventName": "UNC_I_SNOOP_RESP.SNPINV",
         "PerPkg": "1",
+        "PublicDescription": "Snoop Responses : SnpInv",
         "UMask": "0x40",
         "Unit": "IRP"
     },
     {
-        "BriefDescription": "Inbound Transaction Count; Reads",
-        "Counter": "0,1",
+        "BriefDescription": "Inbound Transaction Count; Atomic",
         "EventCode": "0x16",
-        "EventName": "UNC_I_TRANSACTIONS.READS",
+        "EventName": "UNC_I_TRANSACTIONS.ATOMIC",
         "PerPkg": "1",
-        "UMask": "0x1",
+        "PublicDescription": "Counts the number of Inbound transactions fr=
om the IRP to the Uncore.  This can be filtered based on request type in ad=
dition to the source queue.  Note the special filtering equation.  We do OR=
-reduction on the request type.  If the SOURCE bit is set, then we also do =
AND qualification based on the source portID.; Tracks the number of atomic =
transactions",
+        "UMask": "0x10",
         "Unit": "IRP"
     },
     {
-        "BriefDescription": "Inbound Transaction Count; Writes",
-        "Counter": "0,1",
+        "BriefDescription": "Inbound Transaction Count; Other",
         "EventCode": "0x16",
-        "EventName": "UNC_I_TRANSACTIONS.WRITES",
+        "EventName": "UNC_I_TRANSACTIONS.OTHER",
         "PerPkg": "1",
-        "UMask": "0x2",
+        "PublicDescription": "Counts the number of Inbound transactions fr=
om the IRP to the Uncore.  This can be filtered based on request type in ad=
dition to the source queue.  Note the special filtering equation.  We do OR=
-reduction on the request type.  If the SOURCE bit is set, then we also do =
AND qualification based on the source portID.; Tracks the number of 'other'=
 kinds of transactions.",
+        "UMask": "0x20",
         "Unit": "IRP"
     },
     {
         "BriefDescription": "Inbound Transaction Count; Read Prefetches",
-        "Counter": "0,1",
         "EventCode": "0x16",
         "EventName": "UNC_I_TRANSACTIONS.RD_PREF",
         "PerPkg": "1",
+        "PublicDescription": "Counts the number of Inbound transactions fr=
om the IRP to the Uncore.  This can be filtered based on request type in ad=
dition to the source queue.  Note the special filtering equation.  We do OR=
-reduction on the request type.  If the SOURCE bit is set, then we also do =
AND qualification based on the source portID.; Tracks the number of read pr=
efetches.",
         "UMask": "0x4",
         "Unit": "IRP"
     },
     {
-        "BriefDescription": "Inbound Transaction Count; Write Prefetches",
-        "Counter": "0,1",
-        "EventCode": "0x16",
-        "EventName": "UNC_I_TRANSACTIONS.WR_PREF",
-        "PerPkg": "1",
-        "UMask": "0x8",
-        "Unit": "IRP"
-    },
-    {
-        "BriefDescription": "Inbound Transaction Count; Atomic",
-        "Counter": "0,1",
+        "BriefDescription": "Inbound Transaction Count; Reads",
         "EventCode": "0x16",
-        "EventName": "UNC_I_TRANSACTIONS.ATOMIC",
+        "EventName": "UNC_I_TRANSACTIONS.READS",
         "PerPkg": "1",
-        "UMask": "0x10",
+        "PublicDescription": "Counts the number of Inbound transactions fr=
om the IRP to the Uncore.  This can be filtered based on request type in ad=
dition to the source queue.  Note the special filtering equation.  We do OR=
-reduction on the request type.  If the SOURCE bit is set, then we also do =
AND qualification based on the source portID.; Tracks only read requests (n=
ot including read prefetches).",
+        "UMask": "0x1",
         "Unit": "IRP"
     },
     {
-        "BriefDescription": "Inbound Transaction Count; Other",
-        "Counter": "0,1",
+        "BriefDescription": "Inbound Transaction Count; Writes",
         "EventCode": "0x16",
-        "EventName": "UNC_I_TRANSACTIONS.OTHER",
+        "EventName": "UNC_I_TRANSACTIONS.WRITES",
         "PerPkg": "1",
-        "UMask": "0x20",
+        "PublicDescription": "Counts the number of Inbound transactions fr=
om the IRP to the Uncore.  This can be filtered based on request type in ad=
dition to the source queue.  Note the special filtering equation.  We do OR=
-reduction on the request type.  If the SOURCE bit is set, then we also do =
AND qualification based on the source portID.; Trackes only write requests.=
  Each write request should have a prefetch, so there is no need to explici=
tly track these requests.  For writes that are tickled and have to retry, t=
he counter will be incremented for each retry.",
+        "UMask": "0x2",
         "Unit": "IRP"
     },
     {
-        "BriefDescription": "Inbound Transaction Count; Select Source",
-        "Counter": "0,1",
+        "BriefDescription": "Inbound Transaction Count; Write Prefetches",
         "EventCode": "0x16",
-        "EventName": "UNC_I_TRANSACTIONS.ORDERINGQ",
+        "EventName": "UNC_I_TRANSACTIONS.WR_PREF",
         "PerPkg": "1",
-        "UMask": "0x40",
+        "PublicDescription": "Counts the number of Inbound transactions fr=
om the IRP to the Uncore.  This can be filtered based on request type in ad=
dition to the source queue.  Note the special filtering equation.  We do OR=
-reduction on the request type.  If the SOURCE bit is set, then we also do =
AND qualification based on the source portID.; Tracks the number of write p=
refetches.",
+        "UMask": "0x8",
         "Unit": "IRP"
     },
     {
         "BriefDescription": "No AD Egress Credit Stalls",
-        "Counter": "0,1",
         "EventCode": "0x18",
         "EventName": "UNC_I_TxR_AD_STALL_CREDIT_CYCLES",
         "PerPkg": "1",
+        "PublicDescription": "Counts the number times when it is not possi=
ble to issue a request to the R2PCIe because there are no AD Egress Credits=
 available.",
         "Unit": "IRP"
     },
     {
         "BriefDescription": "No BL Egress Credit Stalls",
-        "Counter": "0,1",
         "EventCode": "0x19",
         "EventName": "UNC_I_TxR_BL_STALL_CREDIT_CYCLES",
         "PerPkg": "1",
+        "PublicDescription": "Counts the number times when it is not possi=
ble to issue data to the R2PCIe because there are no BL Egress Credits avai=
lable.",
         "Unit": "IRP"
     },
     {
         "BriefDescription": "Outbound Read Requests",
-        "Counter": "0,1",
         "EventCode": "0xE",
         "EventName": "UNC_I_TxR_DATA_INSERTS_NCB",
         "PerPkg": "1",
+        "PublicDescription": "Counts the number of requests issued to the =
switch (towards the devices).",
         "Unit": "IRP"
     },
     {
         "BriefDescription": "Outbound Read Requests",
-        "Counter": "0,1",
         "EventCode": "0xF",
         "EventName": "UNC_I_TxR_DATA_INSERTS_NCS",
         "PerPkg": "1",
+        "PublicDescription": "Counts the number of requests issued to the =
switch (towards the devices).",
         "Unit": "IRP"
     },
     {
         "BriefDescription": "Outbound Request Queue Occupancy",
-        "Counter": "0,1",
         "EventCode": "0xD",
         "EventName": "UNC_I_TxR_REQUEST_OCCUPANCY",
         "PerPkg": "1",
-        "Unit": "IRP"
-    },
-    {
-        "BriefDescription": "Misc Events - Set 0; Prefetch TimeOut",
-        "Counter": "0,1",
-        "EventCode": "0x14",
-        "EventName": "UNC_I_MISC0.PF_TIMEOUT",
-        "PerPkg": "1",
-        "UMask": "0x80",
+        "PublicDescription": "Accumultes the number of outstanding outboun=
d requests from the IRP to the switch (towards the devices).  This can be u=
sed in conjuection with the allocations event in order to calculate average=
 latency of outbound requests.",
         "Unit": "IRP"
     },
     {
         "BriefDescription": "Number of uclks in domain",
-        "Counter": "0,1,2,3",
         "EventCode": "0x1",
         "EventName": "UNC_R2_CLOCKTICKS",
         "PerPkg": "1",
+        "PublicDescription": "Counts the number of uclks in the R2PCIe ucl=
k domain.  This could be slightly different than the count in the Ubox beca=
use of enable/freeze delays.  However, because the R2PCIe is close to the U=
box, they generally should not diverge by more than a handful of cycles.",
         "Unit": "R2PCIe"
     },
     {
-        "BriefDescription": "UNC_R2_IIO_CREDIT.PRQ_QPI0",
-        "Counter": "0,1",
+        "BriefDescription": "UNC_R2_IIO_CREDIT.ISOCH_QPI0",
         "EventCode": "0x2D",
-        "EventName": "UNC_R2_IIO_CREDIT.PRQ_QPI0",
+        "EventName": "UNC_R2_IIO_CREDIT.ISOCH_QPI0",
         "PerPkg": "1",
-        "UMask": "0x1",
+        "UMask": "0x4",
         "Unit": "R2PCIe"
     },
     {
-        "BriefDescription": "UNC_R2_IIO_CREDIT.PRQ_QPI1",
-        "Counter": "0,1",
+        "BriefDescription": "UNC_R2_IIO_CREDIT.ISOCH_QPI1",
         "EventCode": "0x2D",
-        "EventName": "UNC_R2_IIO_CREDIT.PRQ_QPI1",
+        "EventName": "UNC_R2_IIO_CREDIT.ISOCH_QPI1",
         "PerPkg": "1",
-        "UMask": "0x2",
+        "UMask": "0x8",
         "Unit": "R2PCIe"
     },
     {
-        "BriefDescription": "UNC_R2_IIO_CREDIT.ISOCH_QPI0",
-        "Counter": "0,1",
+        "BriefDescription": "UNC_R2_IIO_CREDIT.PRQ_QPI0",
         "EventCode": "0x2D",
-        "EventName": "UNC_R2_IIO_CREDIT.ISOCH_QPI0",
+        "EventName": "UNC_R2_IIO_CREDIT.PRQ_QPI0",
         "PerPkg": "1",
-        "UMask": "0x4",
+        "UMask": "0x1",
         "Unit": "R2PCIe"
     },
     {
-        "BriefDescription": "UNC_R2_IIO_CREDIT.ISOCH_QPI1",
-        "Counter": "0,1",
+        "BriefDescription": "UNC_R2_IIO_CREDIT.PRQ_QPI1",
         "EventCode": "0x2D",
-        "EventName": "UNC_R2_IIO_CREDIT.ISOCH_QPI1",
+        "EventName": "UNC_R2_IIO_CREDIT.PRQ_QPI1",
         "PerPkg": "1",
-        "UMask": "0x8",
+        "UMask": "0x2",
         "Unit": "R2PCIe"
     },
     {
         "BriefDescription": "R2PCIe IIO Credit Acquired; DRS",
-        "Counter": "0,1",
         "EventCode": "0x33",
         "EventName": "UNC_R2_IIO_CREDITS_ACQUIRED.DRS",
         "PerPkg": "1",
+        "PublicDescription": "Counts the number of credits that are acquir=
ed in the R2PCIe agent for sending transactions into the IIO on either NCB =
or NCS are in use.  Transactions from the BL ring going into the IIO Agent =
must first acquire a credit.  These credits are for either the NCB or NCS m=
essage classes.  NCB, or non-coherent bypass messages are used to transmit =
data without coherency (and are common).  NCS is used for reads to PCIe (an=
d should be used sparingly).; Credits to the IIO for the DRS message class.=
",
         "UMask": "0x8",
         "Unit": "R2PCIe"
     },
     {
         "BriefDescription": "R2PCIe IIO Credit Acquired; NCB",
-        "Counter": "0,1",
         "EventCode": "0x33",
         "EventName": "UNC_R2_IIO_CREDITS_ACQUIRED.NCB",
         "PerPkg": "1",
+        "PublicDescription": "Counts the number of credits that are acquir=
ed in the R2PCIe agent for sending transactions into the IIO on either NCB =
or NCS are in use.  Transactions from the BL ring going into the IIO Agent =
must first acquire a credit.  These credits are for either the NCB or NCS m=
essage classes.  NCB, or non-coherent bypass messages are used to transmit =
data without coherency (and are common).  NCS is used for reads to PCIe (an=
d should be used sparingly).; Credits to the IIO for the NCB message class.=
",
         "UMask": "0x10",
         "Unit": "R2PCIe"
     },
     {
         "BriefDescription": "R2PCIe IIO Credit Acquired; NCS",
-        "Counter": "0,1",
         "EventCode": "0x33",
         "EventName": "UNC_R2_IIO_CREDITS_ACQUIRED.NCS",
         "PerPkg": "1",
+        "PublicDescription": "Counts the number of credits that are acquir=
ed in the R2PCIe agent for sending transactions into the IIO on either NCB =
or NCS are in use.  Transactions from the BL ring going into the IIO Agent =
must first acquire a credit.  These credits are for either the NCB or NCS m=
essage classes.  NCB, or non-coherent bypass messages are used to transmit =
data without coherency (and are common).  NCS is used for reads to PCIe (an=
d should be used sparingly).; Credits to the IIO for the NCS message class.=
",
         "UMask": "0x20",
         "Unit": "R2PCIe"
     },
     {
         "BriefDescription": "R2PCIe IIO Credits in Use; DRS",
-        "Counter": "0,1",
         "EventCode": "0x32",
         "EventName": "UNC_R2_IIO_CREDITS_USED.DRS",
         "PerPkg": "1",
+        "PublicDescription": "Counts the number of cycles when one or more=
 credits in the R2PCIe agent for sending transactions into the IIO on eithe=
r NCB or NCS are in use.  Transactions from the BL ring going into the IIO =
Agent must first acquire a credit.  These credits are for either the NCB or=
 NCS message classes.  NCB, or non-coherent bypass messages are used to tra=
nsmit data without coherency (and are common).  NCS is used for reads to PC=
Ie (and should be used sparingly).; Credits to the IIO for the DRS message =
class.",
         "UMask": "0x8",
         "Unit": "R2PCIe"
     },
     {
         "BriefDescription": "R2PCIe IIO Credits in Use; NCB",
-        "Counter": "0,1",
         "EventCode": "0x32",
         "EventName": "UNC_R2_IIO_CREDITS_USED.NCB",
         "PerPkg": "1",
+        "PublicDescription": "Counts the number of cycles when one or more=
 credits in the R2PCIe agent for sending transactions into the IIO on eithe=
r NCB or NCS are in use.  Transactions from the BL ring going into the IIO =
Agent must first acquire a credit.  These credits are for either the NCB or=
 NCS message classes.  NCB, or non-coherent bypass messages are used to tra=
nsmit data without coherency (and are common).  NCS is used for reads to PC=
Ie (and should be used sparingly).; Credits to the IIO for the NCB message =
class.",
         "UMask": "0x10",
         "Unit": "R2PCIe"
     },
     {
         "BriefDescription": "R2PCIe IIO Credits in Use; NCS",
-        "Counter": "0,1",
         "EventCode": "0x32",
         "EventName": "UNC_R2_IIO_CREDITS_USED.NCS",
         "PerPkg": "1",
+        "PublicDescription": "Counts the number of cycles when one or more=
 credits in the R2PCIe agent for sending transactions into the IIO on eithe=
r NCB or NCS are in use.  Transactions from the BL ring going into the IIO =
Agent must first acquire a credit.  These credits are for either the NCB or=
 NCS message classes.  NCB, or non-coherent bypass messages are used to tra=
nsmit data without coherency (and are common).  NCS is used for reads to PC=
Ie (and should be used sparingly).; Credits to the IIO for the NCS message =
class.",
         "UMask": "0x20",
         "Unit": "R2PCIe"
     },
     {
-        "BriefDescription": "R2 AD Ring in Use; Clockwise and Even",
-        "Counter": "0,1,2,3",
-        "EventCode": "0x7",
-        "EventName": "UNC_R2_RING_AD_USED.CW_EVEN",
-        "PerPkg": "1",
-        "UMask": "0x1",
-        "Unit": "R2PCIe"
-    },
-    {
-        "BriefDescription": "R2 AD Ring in Use; Clockwise and Odd",
-        "Counter": "0,1,2,3",
+        "BriefDescription": "R2 AD Ring in Use; Counterclockwise",
         "EventCode": "0x7",
-        "EventName": "UNC_R2_RING_AD_USED.CW_ODD",
+        "EventName": "UNC_R2_RING_AD_USED.CCW",
         "PerPkg": "1",
-        "UMask": "0x2",
+        "PublicDescription": "Counts the number of cycles that the AD ring=
 is being used at this ring stop.  This includes when packets are passing b=
y and when packets are being sunk, but does not include when packets are be=
ing sent from the ring stop.",
+        "UMask": "0xc",
         "Unit": "R2PCIe"
     },
     {
         "BriefDescription": "R2 AD Ring in Use; Counterclockwise and Even"=
,
-        "Counter": "0,1,2,3",
         "EventCode": "0x7",
         "EventName": "UNC_R2_RING_AD_USED.CCW_EVEN",
         "PerPkg": "1",
+        "PublicDescription": "Counts the number of cycles that the AD ring=
 is being used at this ring stop.  This includes when packets are passing b=
y and when packets are being sunk, but does not include when packets are be=
ing sent from the ring stop.; Filters for the Counterclockwise and Even rin=
g polarity.",
         "UMask": "0x4",
         "Unit": "R2PCIe"
     },
     {
         "BriefDescription": "R2 AD Ring in Use; Counterclockwise and Odd",
-        "Counter": "0,1,2,3",
         "EventCode": "0x7",
         "EventName": "UNC_R2_RING_AD_USED.CCW_ODD",
         "PerPkg": "1",
+        "PublicDescription": "Counts the number of cycles that the AD ring=
 is being used at this ring stop.  This includes when packets are passing b=
y and when packets are being sunk, but does not include when packets are be=
ing sent from the ring stop.; Filters for the Counterclockwise and Odd ring=
 polarity.",
         "UMask": "0x8",
         "Unit": "R2PCIe"
     },
     {
         "BriefDescription": "R2 AD Ring in Use; Clockwise",
-        "Counter": "0,1,2,3",
         "EventCode": "0x7",
         "EventName": "UNC_R2_RING_AD_USED.CW",
         "PerPkg": "1",
+        "PublicDescription": "Counts the number of cycles that the AD ring=
 is being used at this ring stop.  This includes when packets are passing b=
y and when packets are being sunk, but does not include when packets are be=
ing sent from the ring stop.",
         "UMask": "0x3",
         "Unit": "R2PCIe"
     },
     {
-        "BriefDescription": "R2 AD Ring in Use; Counterclockwise",
-        "Counter": "0,1,2,3",
+        "BriefDescription": "R2 AD Ring in Use; Clockwise and Even",
         "EventCode": "0x7",
-        "EventName": "UNC_R2_RING_AD_USED.CCW",
+        "EventName": "UNC_R2_RING_AD_USED.CW_EVEN",
         "PerPkg": "1",
-        "UMask": "0xC",
+        "PublicDescription": "Counts the number of cycles that the AD ring=
 is being used at this ring stop.  This includes when packets are passing b=
y and when packets are being sunk, but does not include when packets are be=
ing sent from the ring stop.; Filters for the Clockwise and Even ring polar=
ity.",
+        "UMask": "0x1",
         "Unit": "R2PCIe"
     },
     {
-        "BriefDescription": "AK Ingress Bounced; Up",
-        "Counter": "0,1,2,3",
-        "EventCode": "0x12",
-        "EventName": "UNC_R2_RING_AK_BOUNCES.UP",
+        "BriefDescription": "R2 AD Ring in Use; Clockwise and Odd",
+        "EventCode": "0x7",
+        "EventName": "UNC_R2_RING_AD_USED.CW_ODD",
         "PerPkg": "1",
-        "UMask": "0x1",
+        "PublicDescription": "Counts the number of cycles that the AD ring=
 is being used at this ring stop.  This includes when packets are passing b=
y and when packets are being sunk, but does not include when packets are be=
ing sent from the ring stop.; Filters for the Clockwise and Odd ring polari=
ty.",
+        "UMask": "0x2",
         "Unit": "R2PCIe"
     },
     {
         "BriefDescription": "AK Ingress Bounced; Dn",
-        "Counter": "0,1,2,3",
         "EventCode": "0x12",
         "EventName": "UNC_R2_RING_AK_BOUNCES.DN",
         "PerPkg": "1",
+        "PublicDescription": "Counts the number of times when a request de=
stined for the AK ingress bounced.",
         "UMask": "0x2",
         "Unit": "R2PCIe"
     },
     {
-        "BriefDescription": "R2 AK Ring in Use; Clockwise and Even",
-        "Counter": "0,1,2,3",
-        "EventCode": "0x8",
-        "EventName": "UNC_R2_RING_AK_USED.CW_EVEN",
+        "BriefDescription": "AK Ingress Bounced; Up",
+        "EventCode": "0x12",
+        "EventName": "UNC_R2_RING_AK_BOUNCES.UP",
         "PerPkg": "1",
+        "PublicDescription": "Counts the number of times when a request de=
stined for the AK ingress bounced.",
         "UMask": "0x1",
         "Unit": "R2PCIe"
     },
     {
-        "BriefDescription": "R2 AK Ring in Use; Clockwise and Odd",
-        "Counter": "0,1,2,3",
+        "BriefDescription": "R2 AK Ring in Use; Counterclockwise",
         "EventCode": "0x8",
-        "EventName": "UNC_R2_RING_AK_USED.CW_ODD",
+        "EventName": "UNC_R2_RING_AK_USED.CCW",
         "PerPkg": "1",
-        "UMask": "0x2",
+        "PublicDescription": "Counts the number of cycles that the AK ring=
 is being used at this ring stop.  This includes when packets are passing b=
y and when packets are being sunk, but does not include when packets are be=
ing sent from the ring stop.",
+        "UMask": "0xc",
         "Unit": "R2PCIe"
     },
     {
         "BriefDescription": "R2 AK Ring in Use; Counterclockwise and Even"=
,
-        "Counter": "0,1,2,3",
         "EventCode": "0x8",
         "EventName": "UNC_R2_RING_AK_USED.CCW_EVEN",
         "PerPkg": "1",
+        "PublicDescription": "Counts the number of cycles that the AK ring=
 is being used at this ring stop.  This includes when packets are passing b=
y and when packets are being sunk, but does not include when packets are be=
ing sent from the ring stop.; Filters for the Counterclockwise and Even rin=
g polarity.",
         "UMask": "0x4",
         "Unit": "R2PCIe"
     },
     {
         "BriefDescription": "R2 AK Ring in Use; Counterclockwise and Odd",
-        "Counter": "0,1,2,3",
         "EventCode": "0x8",
         "EventName": "UNC_R2_RING_AK_USED.CCW_ODD",
         "PerPkg": "1",
+        "PublicDescription": "Counts the number of cycles that the AK ring=
 is being used at this ring stop.  This includes when packets are passing b=
y and when packets are being sunk, but does not include when packets are be=
ing sent from the ring stop.; Filters for the Counterclockwise and Odd ring=
 polarity.",
         "UMask": "0x8",
         "Unit": "R2PCIe"
     },
     {
         "BriefDescription": "R2 AK Ring in Use; Clockwise",
-        "Counter": "0,1,2,3",
         "EventCode": "0x8",
         "EventName": "UNC_R2_RING_AK_USED.CW",
         "PerPkg": "1",
+        "PublicDescription": "Counts the number of cycles that the AK ring=
 is being used at this ring stop.  This includes when packets are passing b=
y and when packets are being sunk, but does not include when packets are be=
ing sent from the ring stop.",
         "UMask": "0x3",
         "Unit": "R2PCIe"
     },
     {
-        "BriefDescription": "R2 AK Ring in Use; Counterclockwise",
-        "Counter": "0,1,2,3",
+        "BriefDescription": "R2 AK Ring in Use; Clockwise and Even",
         "EventCode": "0x8",
-        "EventName": "UNC_R2_RING_AK_USED.CCW",
+        "EventName": "UNC_R2_RING_AK_USED.CW_EVEN",
         "PerPkg": "1",
-        "UMask": "0xC",
+        "PublicDescription": "Counts the number of cycles that the AK ring=
 is being used at this ring stop.  This includes when packets are passing b=
y and when packets are being sunk, but does not include when packets are be=
ing sent from the ring stop.; Filters for the Clockwise and Even ring polar=
ity.",
+        "UMask": "0x1",
         "Unit": "R2PCIe"
     },
     {
-        "BriefDescription": "R2 BL Ring in Use; Clockwise and Even",
-        "Counter": "0,1,2,3",
-        "EventCode": "0x9",
-        "EventName": "UNC_R2_RING_BL_USED.CW_EVEN",
+        "BriefDescription": "R2 AK Ring in Use; Clockwise and Odd",
+        "EventCode": "0x8",
+        "EventName": "UNC_R2_RING_AK_USED.CW_ODD",
         "PerPkg": "1",
-        "UMask": "0x1",
+        "PublicDescription": "Counts the number of cycles that the AK ring=
 is being used at this ring stop.  This includes when packets are passing b=
y and when packets are being sunk, but does not include when packets are be=
ing sent from the ring stop.; Filters for the Clockwise and Odd ring polari=
ty.",
+        "UMask": "0x2",
         "Unit": "R2PCIe"
     },
     {
-        "BriefDescription": "R2 BL Ring in Use; Clockwise and Odd",
-        "Counter": "0,1,2,3",
+        "BriefDescription": "R2 BL Ring in Use; Counterclockwise",
         "EventCode": "0x9",
-        "EventName": "UNC_R2_RING_BL_USED.CW_ODD",
+        "EventName": "UNC_R2_RING_BL_USED.CCW",
         "PerPkg": "1",
-        "UMask": "0x2",
+        "PublicDescription": "Counts the number of cycles that the BL ring=
 is being used at this ring stop.  This includes when packets are passing b=
y and when packets are being sunk, but does not include when packets are be=
ing sent from the ring stop.",
+        "UMask": "0xc",
         "Unit": "R2PCIe"
     },
     {
         "BriefDescription": "R2 BL Ring in Use; Counterclockwise and Even"=
,
-        "Counter": "0,1,2,3",
         "EventCode": "0x9",
         "EventName": "UNC_R2_RING_BL_USED.CCW_EVEN",
         "PerPkg": "1",
+        "PublicDescription": "Counts the number of cycles that the BL ring=
 is being used at this ring stop.  This includes when packets are passing b=
y and when packets are being sunk, but does not include when packets are be=
ing sent from the ring stop.; Filters for the Counterclockwise and Even rin=
g polarity.",
         "UMask": "0x4",
         "Unit": "R2PCIe"
     },
     {
         "BriefDescription": "R2 BL Ring in Use; Counterclockwise and Odd",
-        "Counter": "0,1,2,3",
         "EventCode": "0x9",
         "EventName": "UNC_R2_RING_BL_USED.CCW_ODD",
         "PerPkg": "1",
+        "PublicDescription": "Counts the number of cycles that the BL ring=
 is being used at this ring stop.  This includes when packets are passing b=
y and when packets are being sunk, but does not include when packets are be=
ing sent from the ring stop.; Filters for the Counterclockwise and Odd ring=
 polarity.",
         "UMask": "0x8",
         "Unit": "R2PCIe"
     },
     {
         "BriefDescription": "R2 BL Ring in Use; Clockwise",
-        "Counter": "0,1,2,3",
         "EventCode": "0x9",
         "EventName": "UNC_R2_RING_BL_USED.CW",
         "PerPkg": "1",
+        "PublicDescription": "Counts the number of cycles that the BL ring=
 is being used at this ring stop.  This includes when packets are passing b=
y and when packets are being sunk, but does not include when packets are be=
ing sent from the ring stop.",
         "UMask": "0x3",
         "Unit": "R2PCIe"
     },
     {
-        "BriefDescription": "R2 BL Ring in Use; Counterclockwise",
-        "Counter": "0,1,2,3",
+        "BriefDescription": "R2 BL Ring in Use; Clockwise and Even",
         "EventCode": "0x9",
-        "EventName": "UNC_R2_RING_BL_USED.CCW",
+        "EventName": "UNC_R2_RING_BL_USED.CW_EVEN",
         "PerPkg": "1",
-        "UMask": "0xC",
+        "PublicDescription": "Counts the number of cycles that the BL ring=
 is being used at this ring stop.  This includes when packets are passing b=
y and when packets are being sunk, but does not include when packets are be=
ing sent from the ring stop.; Filters for the Clockwise and Even ring polar=
ity.",
+        "UMask": "0x1",
         "Unit": "R2PCIe"
     },
     {
-        "BriefDescription": "R2 IV Ring in Use; Clockwise",
-        "Counter": "0,1,2,3",
+        "BriefDescription": "R2 BL Ring in Use; Clockwise and Odd",
+        "EventCode": "0x9",
+        "EventName": "UNC_R2_RING_BL_USED.CW_ODD",
+        "PerPkg": "1",
+        "PublicDescription": "Counts the number of cycles that the BL ring=
 is being used at this ring stop.  This includes when packets are passing b=
y and when packets are being sunk, but does not include when packets are be=
ing sent from the ring stop.; Filters for the Clockwise and Odd ring polari=
ty.",
+        "UMask": "0x2",
+        "Unit": "R2PCIe"
+    },
+    {
+        "BriefDescription": "R2 IV Ring in Use; Any",
         "EventCode": "0xA",
-        "EventName": "UNC_R2_RING_IV_USED.CW",
+        "EventName": "UNC_R2_RING_IV_USED.ANY",
         "PerPkg": "1",
-        "UMask": "0x3",
+        "PublicDescription": "Counts the number of cycles that the IV ring=
 is being used at this ring stop.  This includes when packets are passing b=
y and when packets are being sent, but does not include when packets are be=
ing sunk into the ring stop.",
+        "UMask": "0xf",
         "Unit": "R2PCIe"
     },
     {
         "BriefDescription": "R2 IV Ring in Use; Counterclockwise",
-        "Counter": "0,1,2,3",
         "EventCode": "0xA",
         "EventName": "UNC_R2_RING_IV_USED.CCW",
         "PerPkg": "1",
-        "UMask": "0xC",
+        "PublicDescription": "Counts the number of cycles that the IV ring=
 is being used at this ring stop.  This includes when packets are passing b=
y and when packets are being sent, but does not include when packets are be=
ing sunk into the ring stop.",
+        "UMask": "0xc",
         "Unit": "R2PCIe"
     },
     {
-        "BriefDescription": "R2 IV Ring in Use; Any",
-        "Counter": "0,1,2,3",
+        "BriefDescription": "R2 IV Ring in Use; Clockwise",
         "EventCode": "0xA",
-        "EventName": "UNC_R2_RING_IV_USED.ANY",
+        "EventName": "UNC_R2_RING_IV_USED.CW",
         "PerPkg": "1",
-        "UMask": "0xF",
+        "PublicDescription": "Counts the number of cycles that the IV ring=
 is being used at this ring stop.  This includes when packets are passing b=
y and when packets are being sent, but does not include when packets are be=
ing sunk into the ring stop.",
+        "UMask": "0x3",
         "Unit": "R2PCIe"
     },
     {
         "BriefDescription": "Ingress Cycles Not Empty; NCB",
-        "Counter": "0,1",
         "EventCode": "0x10",
         "EventName": "UNC_R2_RxR_CYCLES_NE.NCB",
         "PerPkg": "1",
+        "PublicDescription": "Counts the number of cycles when the R2PCIe =
Ingress is not empty.  This tracks one of the three rings that are used by =
the R2PCIe agent.  This can be used in conjunction with the R2PCIe Ingress =
Occupancy Accumulator event in order to calculate average queue occupancy. =
 Multiple ingress buffers can be tracked at a given time using multiple cou=
nters.; NCB Ingress Queue",
         "UMask": "0x10",
         "Unit": "R2PCIe"
     },
     {
         "BriefDescription": "Ingress Cycles Not Empty; NCS",
-        "Counter": "0,1",
         "EventCode": "0x10",
         "EventName": "UNC_R2_RxR_CYCLES_NE.NCS",
         "PerPkg": "1",
+        "PublicDescription": "Counts the number of cycles when the R2PCIe =
Ingress is not empty.  This tracks one of the three rings that are used by =
the R2PCIe agent.  This can be used in conjunction with the R2PCIe Ingress =
Occupancy Accumulator event in order to calculate average queue occupancy. =
 Multiple ingress buffers can be tracked at a given time using multiple cou=
nters.; NCS Ingress Queue",
         "UMask": "0x20",
         "Unit": "R2PCIe"
     },
     {
         "BriefDescription": "Ingress Allocations; NCB",
-        "Counter": "0,1",
         "EventCode": "0x11",
         "EventName": "UNC_R2_RxR_INSERTS.NCB",
         "PerPkg": "1",
+        "PublicDescription": "Counts the number of allocations into the R2=
PCIe Ingress.  This tracks one of the three rings that are used by the R2PC=
Ie agent.  This can be used in conjunction with the R2PCIe Ingress Occupanc=
y Accumulator event in order to calculate average queue latency.  Multiple =
ingress buffers can be tracked at a given time using multiple counters.; NC=
B Ingress Queue",
         "UMask": "0x10",
         "Unit": "R2PCIe"
     },
     {
         "BriefDescription": "Ingress Allocations; NCS",
-        "Counter": "0,1",
         "EventCode": "0x11",
         "EventName": "UNC_R2_RxR_INSERTS.NCS",
         "PerPkg": "1",
+        "PublicDescription": "Counts the number of allocations into the R2=
PCIe Ingress.  This tracks one of the three rings that are used by the R2PC=
Ie agent.  This can be used in conjunction with the R2PCIe Ingress Occupanc=
y Accumulator event in order to calculate average queue latency.  Multiple =
ingress buffers can be tracked at a given time using multiple counters.; NC=
S Ingress Queue",
         "UMask": "0x20",
         "Unit": "R2PCIe"
     },
@@ -832,24 +819,25 @@
         "EventCode": "0x13",
         "EventName": "UNC_R2_RxR_OCCUPANCY.DRS",
         "PerPkg": "1",
+        "PublicDescription": "Accumulates the occupancy of a given R2PCIe =
Ingress queue in each cycles.  This tracks one of the three ring Ingress bu=
ffers.  This can be used with the R2PCIe Ingress Not Empty event to calcula=
te average occupancy or the R2PCIe Ingress Allocations event in order to ca=
lculate average queuing latency.; DRS Ingress Queue",
         "UMask": "0x8",
         "Unit": "R2PCIe"
     },
     {
         "BriefDescription": "SBo0 Credits Acquired; For AD Ring",
-        "Counter": "0,1",
         "EventCode": "0x28",
         "EventName": "UNC_R2_SBO0_CREDITS_ACQUIRED.AD",
         "PerPkg": "1",
+        "PublicDescription": "Number of Sbo 0 credits acquired in a given =
cycle, per ring.",
         "UMask": "0x1",
         "Unit": "R2PCIe"
     },
     {
         "BriefDescription": "SBo0 Credits Acquired; For BL Ring",
-        "Counter": "0,1",
         "EventCode": "0x28",
         "EventName": "UNC_R2_SBO0_CREDITS_ACQUIRED.BL",
         "PerPkg": "1",
+        "PublicDescription": "Number of Sbo 0 credits acquired in a given =
cycle, per ring.",
         "UMask": "0x2",
         "Unit": "R2PCIe"
     },
@@ -858,6 +846,7 @@
         "EventCode": "0x2A",
         "EventName": "UNC_R2_SBO0_CREDIT_OCCUPANCY.AD",
         "PerPkg": "1",
+        "PublicDescription": "Number of Sbo 0 credits in use in a given cy=
cle, per ring.",
         "UMask": "0x1",
         "Unit": "R2PCIe"
     },
@@ -866,42 +855,43 @@
         "EventCode": "0x2A",
         "EventName": "UNC_R2_SBO0_CREDIT_OCCUPANCY.BL",
         "PerPkg": "1",
+        "PublicDescription": "Number of Sbo 0 credits in use in a given cy=
cle, per ring.",
         "UMask": "0x2",
         "Unit": "R2PCIe"
     },
     {
         "BriefDescription": "Stall on No Sbo Credits; For SBo0, AD Ring",
-        "Counter": "0,1",
         "EventCode": "0x2C",
         "EventName": "UNC_R2_STALL_NO_SBO_CREDIT.SBO0_AD",
         "PerPkg": "1",
+        "PublicDescription": "Number of cycles Egress is stalled waiting f=
or an Sbo credit to become available.  Per Sbo, per Ring.",
         "UMask": "0x1",
         "Unit": "R2PCIe"
     },
     {
-        "BriefDescription": "Stall on No Sbo Credits; For SBo1, AD Ring",
-        "Counter": "0,1",
+        "BriefDescription": "Stall on No Sbo Credits; For SBo0, BL Ring",
         "EventCode": "0x2C",
-        "EventName": "UNC_R2_STALL_NO_SBO_CREDIT.SBO1_AD",
+        "EventName": "UNC_R2_STALL_NO_SBO_CREDIT.SBO0_BL",
         "PerPkg": "1",
-        "UMask": "0x2",
+        "PublicDescription": "Number of cycles Egress is stalled waiting f=
or an Sbo credit to become available.  Per Sbo, per Ring.",
+        "UMask": "0x4",
         "Unit": "R2PCIe"
     },
     {
-        "BriefDescription": "Stall on No Sbo Credits; For SBo0, BL Ring",
-        "Counter": "0,1",
+        "BriefDescription": "Stall on No Sbo Credits; For SBo1, AD Ring",
         "EventCode": "0x2C",
-        "EventName": "UNC_R2_STALL_NO_SBO_CREDIT.SBO0_BL",
+        "EventName": "UNC_R2_STALL_NO_SBO_CREDIT.SBO1_AD",
         "PerPkg": "1",
-        "UMask": "0x4",
+        "PublicDescription": "Number of cycles Egress is stalled waiting f=
or an Sbo credit to become available.  Per Sbo, per Ring.",
+        "UMask": "0x2",
         "Unit": "R2PCIe"
     },
     {
         "BriefDescription": "Stall on No Sbo Credits; For SBo1, BL Ring",
-        "Counter": "0,1",
         "EventCode": "0x2C",
         "EventName": "UNC_R2_STALL_NO_SBO_CREDIT.SBO1_BL",
         "PerPkg": "1",
+        "PublicDescription": "Number of cycles Egress is stalled waiting f=
or an Sbo credit to become available.  Per Sbo, per Ring.",
         "UMask": "0x8",
         "Unit": "R2PCIe"
     },
@@ -910,6 +900,7 @@
         "EventCode": "0x25",
         "EventName": "UNC_R2_TxR_CYCLES_FULL.AD",
         "PerPkg": "1",
+        "PublicDescription": "Counts the number of cycles when the R2PCIe =
Egress buffer is full.; AD Egress Queue",
         "UMask": "0x1",
         "Unit": "R2PCIe"
     },
@@ -918,6 +909,7 @@
         "EventCode": "0x25",
         "EventName": "UNC_R2_TxR_CYCLES_FULL.AK",
         "PerPkg": "1",
+        "PublicDescription": "Counts the number of cycles when the R2PCIe =
Egress buffer is full.; AK Egress Queue",
         "UMask": "0x2",
         "Unit": "R2PCIe"
     },
@@ -926,6 +918,7 @@
         "EventCode": "0x25",
         "EventName": "UNC_R2_TxR_CYCLES_FULL.BL",
         "PerPkg": "1",
+        "PublicDescription": "Counts the number of cycles when the R2PCIe =
Egress buffer is full.; BL Egress Queue",
         "UMask": "0x4",
         "Unit": "R2PCIe"
     },
@@ -934,6 +927,7 @@
         "EventCode": "0x23",
         "EventName": "UNC_R2_TxR_CYCLES_NE.AD",
         "PerPkg": "1",
+        "PublicDescription": "Counts the number of cycles when the R2PCIe =
Egress is not empty.  This tracks one of the three rings that are used by t=
he R2PCIe agent.  This can be used in conjunction with the R2PCIe Egress Oc=
cupancy Accumulator event in order to calculate average queue occupancy.  O=
nly a single Egress queue can be tracked at any given time.  It is not poss=
ible to filter based on direction or polarity.; AD Egress Queue",
         "UMask": "0x1",
         "Unit": "R2PCIe"
     },
@@ -942,6 +936,7 @@
         "EventCode": "0x23",
         "EventName": "UNC_R2_TxR_CYCLES_NE.AK",
         "PerPkg": "1",
+        "PublicDescription": "Counts the number of cycles when the R2PCIe =
Egress is not empty.  This tracks one of the three rings that are used by t=
he R2PCIe agent.  This can be used in conjunction with the R2PCIe Egress Oc=
cupancy Accumulator event in order to calculate average queue occupancy.  O=
nly a single Egress queue can be tracked at any given time.  It is not poss=
ible to filter based on direction or polarity.; AK Egress Queue",
         "UMask": "0x2",
         "Unit": "R2PCIe"
     },
@@ -950,911 +945,896 @@
         "EventCode": "0x23",
         "EventName": "UNC_R2_TxR_CYCLES_NE.BL",
         "PerPkg": "1",
+        "PublicDescription": "Counts the number of cycles when the R2PCIe =
Egress is not empty.  This tracks one of the three rings that are used by t=
he R2PCIe agent.  This can be used in conjunction with the R2PCIe Egress Oc=
cupancy Accumulator event in order to calculate average queue occupancy.  O=
nly a single Egress queue can be tracked at any given time.  It is not poss=
ible to filter based on direction or polarity.; BL Egress Queue",
         "UMask": "0x4",
         "Unit": "R2PCIe"
     },
     {
         "BriefDescription": "Egress CCW NACK; AD CCW",
-        "Counter": "0,1",
         "EventCode": "0x26",
         "EventName": "UNC_R2_TxR_NACK_CW.DN_AD",
         "PerPkg": "1",
+        "PublicDescription": "AD CounterClockwise Egress Queue",
         "UMask": "0x1",
         "Unit": "R2PCIe"
     },
     {
-        "BriefDescription": "Egress CCW NACK; BL CCW",
-        "Counter": "0,1",
+        "BriefDescription": "Egress CCW NACK; AK CCW",
         "EventCode": "0x26",
-        "EventName": "UNC_R2_TxR_NACK_CW.DN_BL",
+        "EventName": "UNC_R2_TxR_NACK_CW.DN_AK",
         "PerPkg": "1",
-        "UMask": "0x2",
+        "PublicDescription": "AK CounterClockwise Egress Queue",
+        "UMask": "0x4",
         "Unit": "R2PCIe"
     },
     {
-        "BriefDescription": "Egress CCW NACK; AK CCW",
-        "Counter": "0,1",
+        "BriefDescription": "Egress CCW NACK; BL CCW",
         "EventCode": "0x26",
-        "EventName": "UNC_R2_TxR_NACK_CW.DN_AK",
+        "EventName": "UNC_R2_TxR_NACK_CW.DN_BL",
         "PerPkg": "1",
-        "UMask": "0x4",
+        "PublicDescription": "BL CounterClockwise Egress Queue",
+        "UMask": "0x2",
         "Unit": "R2PCIe"
     },
     {
         "BriefDescription": "Egress CCW NACK; AK CCW",
-        "Counter": "0,1",
         "EventCode": "0x26",
         "EventName": "UNC_R2_TxR_NACK_CW.UP_AD",
         "PerPkg": "1",
+        "PublicDescription": "BL CounterClockwise Egress Queue",
         "UMask": "0x8",
         "Unit": "R2PCIe"
     },
     {
-        "BriefDescription": "Egress CCW NACK; BL CCW",
-        "Counter": "0,1",
+        "BriefDescription": "Egress CCW NACK; BL CW",
         "EventCode": "0x26",
-        "EventName": "UNC_R2_TxR_NACK_CW.UP_BL",
+        "EventName": "UNC_R2_TxR_NACK_CW.UP_AK",
         "PerPkg": "1",
-        "UMask": "0x10",
+        "PublicDescription": "AD Clockwise Egress Queue",
+        "UMask": "0x20",
         "Unit": "R2PCIe"
     },
     {
-        "BriefDescription": "Egress CCW NACK; BL CW",
-        "Counter": "0,1",
+        "BriefDescription": "Egress CCW NACK; BL CCW",
         "EventCode": "0x26",
-        "EventName": "UNC_R2_TxR_NACK_CW.UP_AK",
+        "EventName": "UNC_R2_TxR_NACK_CW.UP_BL",
         "PerPkg": "1",
-        "UMask": "0x20",
+        "PublicDescription": "AD CounterClockwise Egress Queue",
+        "UMask": "0x10",
         "Unit": "R2PCIe"
     },
     {
         "BriefDescription": "Number of uclks in domain",
-        "Counter": "0,1,2",
         "EventCode": "0x1",
         "EventName": "UNC_R3_CLOCKTICKS",
         "PerPkg": "1",
+        "PublicDescription": "Counts the number of uclks in the QPI uclk d=
omain.  This could be slightly different than the count in the Ubox because=
 of enable/freeze delays.  However, because the QPI Agent is close to the U=
box, they generally should not diverge by more than a handful of cycles.",
         "Unit": "R3QPI"
     },
     {
         "BriefDescription": "CBox AD Credits Empty",
-        "Counter": "0,1",
         "EventCode": "0x1F",
-        "EventName": "UNC_R3_C_HI_AD_CREDITS_EMPTY.CBO8",
+        "EventName": "UNC_R3_C_HI_AD_CREDITS_EMPTY.CBO10",
         "PerPkg": "1",
-        "UMask": "0x1",
+        "PublicDescription": "No credits available to send to Cbox on the =
AD Ring (covers higher CBoxes); Cbox 10",
+        "UMask": "0x4",
         "Unit": "R3QPI"
     },
     {
         "BriefDescription": "CBox AD Credits Empty",
-        "Counter": "0,1",
         "EventCode": "0x1F",
-        "EventName": "UNC_R3_C_HI_AD_CREDITS_EMPTY.CBO9",
+        "EventName": "UNC_R3_C_HI_AD_CREDITS_EMPTY.CBO11",
         "PerPkg": "1",
-        "UMask": "0x2",
+        "PublicDescription": "No credits available to send to Cbox on the =
AD Ring (covers higher CBoxes); Cbox 11",
+        "UMask": "0x8",
         "Unit": "R3QPI"
     },
     {
         "BriefDescription": "CBox AD Credits Empty",
-        "Counter": "0,1",
         "EventCode": "0x1F",
-        "EventName": "UNC_R3_C_HI_AD_CREDITS_EMPTY.CBO10",
+        "EventName": "UNC_R3_C_HI_AD_CREDITS_EMPTY.CBO12",
         "PerPkg": "1",
-        "UMask": "0x4",
+        "PublicDescription": "No credits available to send to Cbox on the =
AD Ring (covers higher CBoxes); Cbox 12",
+        "UMask": "0x10",
         "Unit": "R3QPI"
     },
     {
         "BriefDescription": "CBox AD Credits Empty",
-        "Counter": "0,1",
         "EventCode": "0x1F",
-        "EventName": "UNC_R3_C_HI_AD_CREDITS_EMPTY.CBO11",
+        "EventName": "UNC_R3_C_HI_AD_CREDITS_EMPTY.CBO13",
         "PerPkg": "1",
-        "UMask": "0x8",
+        "PublicDescription": "No credits available to send to Cbox on the =
AD Ring (covers higher CBoxes); Cbox 13",
+        "UMask": "0x20",
         "Unit": "R3QPI"
     },
     {
         "BriefDescription": "CBox AD Credits Empty",
-        "Counter": "0,1",
         "EventCode": "0x1F",
-        "EventName": "UNC_R3_C_HI_AD_CREDITS_EMPTY.CBO12",
+        "EventName": "UNC_R3_C_HI_AD_CREDITS_EMPTY.CBO14_16",
         "PerPkg": "1",
-        "UMask": "0x10",
+        "PublicDescription": "No credits available to send to Cbox on the =
AD Ring (covers higher CBoxes); Cbox 14&16",
+        "UMask": "0x40",
         "Unit": "R3QPI"
     },
     {
         "BriefDescription": "CBox AD Credits Empty",
-        "Counter": "0,1",
         "EventCode": "0x1F",
-        "EventName": "UNC_R3_C_HI_AD_CREDITS_EMPTY.CBO13",
+        "EventName": "UNC_R3_C_HI_AD_CREDITS_EMPTY.CBO8",
         "PerPkg": "1",
-        "UMask": "0x20",
+        "PublicDescription": "No credits available to send to Cbox on the =
AD Ring (covers higher CBoxes); Cbox 8",
+        "UMask": "0x1",
         "Unit": "R3QPI"
     },
     {
         "BriefDescription": "CBox AD Credits Empty",
-        "Counter": "0,1",
         "EventCode": "0x1F",
-        "EventName": "UNC_R3_C_HI_AD_CREDITS_EMPTY.CBO14_16",
+        "EventName": "UNC_R3_C_HI_AD_CREDITS_EMPTY.CBO9",
         "PerPkg": "1",
-        "UMask": "0x40",
+        "PublicDescription": "No credits available to send to Cbox on the =
AD Ring (covers higher CBoxes); Cbox 9",
+        "UMask": "0x2",
         "Unit": "R3QPI"
     },
     {
         "BriefDescription": "CBox AD Credits Empty",
-        "Counter": "0,1",
         "EventCode": "0x1F",
         "EventName": "UNC_R3_C_HI_AD_CREDITS_EMPTY.CBO_15_17",
         "PerPkg": "1",
+        "PublicDescription": "No credits available to send to Cbox on the =
AD Ring (covers higher CBoxes); Cbox 15&17",
         "UMask": "0x80",
         "Unit": "R3QPI"
     },
     {
         "BriefDescription": "CBox AD Credits Empty",
-        "Counter": "0,1",
         "EventCode": "0x22",
         "EventName": "UNC_R3_C_LO_AD_CREDITS_EMPTY.CBO0",
         "PerPkg": "1",
+        "PublicDescription": "No credits available to send to Cbox on the =
AD Ring (covers lower CBoxes); Cbox 0",
         "UMask": "0x1",
         "Unit": "R3QPI"
     },
     {
         "BriefDescription": "CBox AD Credits Empty",
-        "Counter": "0,1",
         "EventCode": "0x22",
         "EventName": "UNC_R3_C_LO_AD_CREDITS_EMPTY.CBO1",
         "PerPkg": "1",
+        "PublicDescription": "No credits available to send to Cbox on the =
AD Ring (covers lower CBoxes); Cbox 1",
         "UMask": "0x2",
         "Unit": "R3QPI"
     },
     {
         "BriefDescription": "CBox AD Credits Empty",
-        "Counter": "0,1",
         "EventCode": "0x22",
         "EventName": "UNC_R3_C_LO_AD_CREDITS_EMPTY.CBO2",
         "PerPkg": "1",
+        "PublicDescription": "No credits available to send to Cbox on the =
AD Ring (covers lower CBoxes); Cbox 2",
         "UMask": "0x4",
         "Unit": "R3QPI"
     },
     {
         "BriefDescription": "CBox AD Credits Empty",
-        "Counter": "0,1",
         "EventCode": "0x22",
         "EventName": "UNC_R3_C_LO_AD_CREDITS_EMPTY.CBO3",
         "PerPkg": "1",
+        "PublicDescription": "No credits available to send to Cbox on the =
AD Ring (covers lower CBoxes); Cbox 3",
         "UMask": "0x8",
         "Unit": "R3QPI"
     },
     {
         "BriefDescription": "CBox AD Credits Empty",
-        "Counter": "0,1",
         "EventCode": "0x22",
         "EventName": "UNC_R3_C_LO_AD_CREDITS_EMPTY.CBO4",
         "PerPkg": "1",
+        "PublicDescription": "No credits available to send to Cbox on the =
AD Ring (covers lower CBoxes); Cbox 4",
         "UMask": "0x10",
         "Unit": "R3QPI"
     },
     {
         "BriefDescription": "CBox AD Credits Empty",
-        "Counter": "0,1",
         "EventCode": "0x22",
         "EventName": "UNC_R3_C_LO_AD_CREDITS_EMPTY.CBO5",
         "PerPkg": "1",
+        "PublicDescription": "No credits available to send to Cbox on the =
AD Ring (covers lower CBoxes); Cbox 5",
         "UMask": "0x20",
         "Unit": "R3QPI"
     },
     {
         "BriefDescription": "CBox AD Credits Empty",
-        "Counter": "0,1",
         "EventCode": "0x22",
         "EventName": "UNC_R3_C_LO_AD_CREDITS_EMPTY.CBO6",
         "PerPkg": "1",
+        "PublicDescription": "No credits available to send to Cbox on the =
AD Ring (covers lower CBoxes); Cbox 6",
         "UMask": "0x40",
         "Unit": "R3QPI"
     },
     {
         "BriefDescription": "CBox AD Credits Empty",
-        "Counter": "0,1",
         "EventCode": "0x22",
         "EventName": "UNC_R3_C_LO_AD_CREDITS_EMPTY.CBO7",
         "PerPkg": "1",
+        "PublicDescription": "No credits available to send to Cbox on the =
AD Ring (covers lower CBoxes); Cbox 7",
         "UMask": "0x80",
         "Unit": "R3QPI"
     },
     {
         "BriefDescription": "HA/R2 AD Credits Empty",
-        "Counter": "0,1",
         "EventCode": "0x2D",
         "EventName": "UNC_R3_HA_R2_BL_CREDITS_EMPTY.HA0",
         "PerPkg": "1",
+        "PublicDescription": "No credits available to send to either HA or=
 R2 on the BL Ring; HA0",
         "UMask": "0x1",
         "Unit": "R3QPI"
     },
     {
         "BriefDescription": "HA/R2 AD Credits Empty",
-        "Counter": "0,1",
         "EventCode": "0x2D",
         "EventName": "UNC_R3_HA_R2_BL_CREDITS_EMPTY.HA1",
         "PerPkg": "1",
+        "PublicDescription": "No credits available to send to either HA or=
 R2 on the BL Ring; HA1",
         "UMask": "0x2",
         "Unit": "R3QPI"
     },
     {
         "BriefDescription": "HA/R2 AD Credits Empty",
-        "Counter": "0,1",
         "EventCode": "0x2D",
         "EventName": "UNC_R3_HA_R2_BL_CREDITS_EMPTY.R2_NCB",
         "PerPkg": "1",
+        "PublicDescription": "No credits available to send to either HA or=
 R2 on the BL Ring; R2 NCB Messages",
         "UMask": "0x4",
         "Unit": "R3QPI"
     },
     {
         "BriefDescription": "HA/R2 AD Credits Empty",
-        "Counter": "0,1",
         "EventCode": "0x2D",
         "EventName": "UNC_R3_HA_R2_BL_CREDITS_EMPTY.R2_NCS",
         "PerPkg": "1",
+        "PublicDescription": "No credits available to send to either HA or=
 R2 on the BL Ring; R2 NCS Messages",
         "UMask": "0x8",
         "Unit": "R3QPI"
     },
     {
         "BriefDescription": "IOT Backpressure",
-        "Counter": "0,1,2",
         "EventCode": "0xB",
-        "EventName": "UNC_R3_IOT_BACKPRESSURE.SAT",
+        "EventName": "UNC_R3_IOT_BACKPRESSURE.HUB",
         "PerPkg": "1",
-        "UMask": "0x1",
+        "UMask": "0x2",
         "Unit": "R3QPI"
     },
     {
         "BriefDescription": "IOT Backpressure",
-        "Counter": "0,1,2",
         "EventCode": "0xB",
-        "EventName": "UNC_R3_IOT_BACKPRESSURE.HUB",
+        "EventName": "UNC_R3_IOT_BACKPRESSURE.SAT",
         "PerPkg": "1",
-        "UMask": "0x2",
+        "UMask": "0x1",
         "Unit": "R3QPI"
     },
     {
         "BriefDescription": "IOT Common Trigger Sequencer - Hi",
-        "Counter": "0,1,2",
         "EventCode": "0xD",
         "EventName": "UNC_R3_IOT_CTS_HI.CTS2",
         "PerPkg": "1",
+        "PublicDescription": "Debug Mask/Match Tie-Ins",
         "UMask": "0x1",
         "Unit": "R3QPI"
     },
     {
         "BriefDescription": "IOT Common Trigger Sequencer - Hi",
-        "Counter": "0,1,2",
         "EventCode": "0xD",
         "EventName": "UNC_R3_IOT_CTS_HI.CTS3",
         "PerPkg": "1",
+        "PublicDescription": "Debug Mask/Match Tie-Ins",
         "UMask": "0x2",
         "Unit": "R3QPI"
     },
     {
         "BriefDescription": "IOT Common Trigger Sequencer - Lo",
-        "Counter": "0,1,2",
         "EventCode": "0xC",
         "EventName": "UNC_R3_IOT_CTS_LO.CTS0",
         "PerPkg": "1",
+        "PublicDescription": "Debug Mask/Match Tie-Ins",
         "UMask": "0x1",
         "Unit": "R3QPI"
     },
     {
         "BriefDescription": "IOT Common Trigger Sequencer - Lo",
-        "Counter": "0,1,2",
         "EventCode": "0xC",
         "EventName": "UNC_R3_IOT_CTS_LO.CTS1",
         "PerPkg": "1",
+        "PublicDescription": "Debug Mask/Match Tie-Ins",
         "UMask": "0x2",
         "Unit": "R3QPI"
     },
     {
         "BriefDescription": "QPI0 AD Credits Empty",
-        "Counter": "0,1",
         "EventCode": "0x20",
-        "EventName": "UNC_R3_QPI0_AD_CREDITS_EMPTY.VNA",
+        "EventName": "UNC_R3_QPI0_AD_CREDITS_EMPTY.VN0_HOM",
         "PerPkg": "1",
-        "UMask": "0x1",
+        "PublicDescription": "No credits available to send to QPI0 on the =
AD Ring; VN0 HOM Messages",
+        "UMask": "0x2",
         "Unit": "R3QPI"
     },
     {
         "BriefDescription": "QPI0 AD Credits Empty",
-        "Counter": "0,1",
         "EventCode": "0x20",
-        "EventName": "UNC_R3_QPI0_AD_CREDITS_EMPTY.VN0_HOM",
+        "EventName": "UNC_R3_QPI0_AD_CREDITS_EMPTY.VN0_NDR",
         "PerPkg": "1",
-        "UMask": "0x2",
+        "PublicDescription": "No credits available to send to QPI0 on the =
AD Ring; VN0 NDR Messages",
+        "UMask": "0x8",
         "Unit": "R3QPI"
     },
     {
         "BriefDescription": "QPI0 AD Credits Empty",
-        "Counter": "0,1",
         "EventCode": "0x20",
         "EventName": "UNC_R3_QPI0_AD_CREDITS_EMPTY.VN0_SNP",
         "PerPkg": "1",
+        "PublicDescription": "No credits available to send to QPI0 on the =
AD Ring; VN0 SNP Messages",
         "UMask": "0x4",
         "Unit": "R3QPI"
     },
     {
         "BriefDescription": "QPI0 AD Credits Empty",
-        "Counter": "0,1",
         "EventCode": "0x20",
-        "EventName": "UNC_R3_QPI0_AD_CREDITS_EMPTY.VN0_NDR",
+        "EventName": "UNC_R3_QPI0_AD_CREDITS_EMPTY.VN1_HOM",
         "PerPkg": "1",
-        "UMask": "0x8",
+        "PublicDescription": "No credits available to send to QPI0 on the =
AD Ring; VN1 HOM Messages",
+        "UMask": "0x10",
         "Unit": "R3QPI"
     },
     {
         "BriefDescription": "QPI0 AD Credits Empty",
-        "Counter": "0,1",
         "EventCode": "0x20",
-        "EventName": "UNC_R3_QPI0_AD_CREDITS_EMPTY.VN1_HOM",
+        "EventName": "UNC_R3_QPI0_AD_CREDITS_EMPTY.VN1_NDR",
         "PerPkg": "1",
-        "UMask": "0x10",
+        "PublicDescription": "No credits available to send to QPI0 on the =
AD Ring; VN1 NDR Messages",
+        "UMask": "0x40",
         "Unit": "R3QPI"
     },
     {
         "BriefDescription": "QPI0 AD Credits Empty",
-        "Counter": "0,1",
         "EventCode": "0x20",
         "EventName": "UNC_R3_QPI0_AD_CREDITS_EMPTY.VN1_SNP",
         "PerPkg": "1",
+        "PublicDescription": "No credits available to send to QPI0 on the =
AD Ring; VN1 SNP Messages",
         "UMask": "0x20",
         "Unit": "R3QPI"
     },
     {
         "BriefDescription": "QPI0 AD Credits Empty",
-        "Counter": "0,1",
         "EventCode": "0x20",
-        "EventName": "UNC_R3_QPI0_AD_CREDITS_EMPTY.VN1_NDR",
+        "EventName": "UNC_R3_QPI0_AD_CREDITS_EMPTY.VNA",
         "PerPkg": "1",
-        "UMask": "0x40",
+        "PublicDescription": "No credits available to send to QPI0 on the =
AD Ring; VNA",
+        "UMask": "0x1",
         "Unit": "R3QPI"
     },
     {
         "BriefDescription": "QPI0 BL Credits Empty",
-        "Counter": "0,1",
         "EventCode": "0x21",
-        "EventName": "UNC_R3_QPI0_BL_CREDITS_EMPTY.VNA",
+        "EventName": "UNC_R3_QPI0_BL_CREDITS_EMPTY.VN1_HOM",
         "PerPkg": "1",
-        "UMask": "0x1",
+        "PublicDescription": "No credits available to send to QPI0 on the =
BL Ring; VN1 HOM Messages",
+        "UMask": "0x10",
         "Unit": "R3QPI"
     },
     {
         "BriefDescription": "QPI0 BL Credits Empty",
-        "Counter": "0,1",
         "EventCode": "0x21",
-        "EventName": "UNC_R3_QPI0_BL_CREDITS_EMPTY.VN1_HOM",
+        "EventName": "UNC_R3_QPI0_BL_CREDITS_EMPTY.VN1_NDR",
         "PerPkg": "1",
-        "UMask": "0x10",
+        "PublicDescription": "No credits available to send to QPI0 on the =
BL Ring; VN1 NDR Messages",
+        "UMask": "0x40",
         "Unit": "R3QPI"
     },
     {
         "BriefDescription": "QPI0 BL Credits Empty",
-        "Counter": "0,1",
         "EventCode": "0x21",
         "EventName": "UNC_R3_QPI0_BL_CREDITS_EMPTY.VN1_SNP",
         "PerPkg": "1",
+        "PublicDescription": "No credits available to send to QPI0 on the =
BL Ring; VN1 SNP Messages",
         "UMask": "0x20",
         "Unit": "R3QPI"
     },
     {
         "BriefDescription": "QPI0 BL Credits Empty",
-        "Counter": "0,1",
         "EventCode": "0x21",
-        "EventName": "UNC_R3_QPI0_BL_CREDITS_EMPTY.VN1_NDR",
+        "EventName": "UNC_R3_QPI0_BL_CREDITS_EMPTY.VNA",
         "PerPkg": "1",
-        "UMask": "0x40",
+        "PublicDescription": "No credits available to send to QPI0 on the =
BL Ring; VNA",
+        "UMask": "0x1",
         "Unit": "R3QPI"
     },
     {
         "BriefDescription": "QPI1 AD Credits Empty",
-        "Counter": "0,1",
         "EventCode": "0x2E",
-        "EventName": "UNC_R3_QPI1_AD_CREDITS_EMPTY.VNA",
+        "EventName": "UNC_R3_QPI1_AD_CREDITS_EMPTY.VN1_HOM",
         "PerPkg": "1",
-        "UMask": "0x1",
+        "PublicDescription": "No credits available to send to QPI1 on the =
AD Ring; VN1 HOM Messages",
+        "UMask": "0x10",
         "Unit": "R3QPI"
     },
     {
         "BriefDescription": "QPI1 AD Credits Empty",
-        "Counter": "0,1",
         "EventCode": "0x2E",
-        "EventName": "UNC_R3_QPI1_AD_CREDITS_EMPTY.VN1_HOM",
+        "EventName": "UNC_R3_QPI1_AD_CREDITS_EMPTY.VN1_NDR",
         "PerPkg": "1",
-        "UMask": "0x10",
+        "PublicDescription": "No credits available to send to QPI1 on the =
AD Ring; VN1 NDR Messages",
+        "UMask": "0x40",
         "Unit": "R3QPI"
     },
     {
         "BriefDescription": "QPI1 AD Credits Empty",
-        "Counter": "0,1",
         "EventCode": "0x2E",
         "EventName": "UNC_R3_QPI1_AD_CREDITS_EMPTY.VN1_SNP",
         "PerPkg": "1",
+        "PublicDescription": "No credits available to send to QPI1 on the =
AD Ring; VN1 SNP Messages",
         "UMask": "0x20",
         "Unit": "R3QPI"
     },
     {
         "BriefDescription": "QPI1 AD Credits Empty",
-        "Counter": "0,1",
         "EventCode": "0x2E",
-        "EventName": "UNC_R3_QPI1_AD_CREDITS_EMPTY.VN1_NDR",
+        "EventName": "UNC_R3_QPI1_AD_CREDITS_EMPTY.VNA",
         "PerPkg": "1",
-        "UMask": "0x40",
+        "PublicDescription": "No credits available to send to QPI1 on the =
AD Ring; VNA",
+        "UMask": "0x1",
         "Unit": "R3QPI"
     },
     {
         "BriefDescription": "QPI1 BL Credits Empty",
-        "Counter": "0,1",
         "EventCode": "0x2F",
-        "EventName": "UNC_R3_QPI1_BL_CREDITS_EMPTY.VNA",
+        "EventName": "UNC_R3_QPI1_BL_CREDITS_EMPTY.VN0_HOM",
         "PerPkg": "1",
-        "UMask": "0x1",
+        "PublicDescription": "No credits available to send to QPI1 on the =
BL Ring; VN0 HOM Messages",
+        "UMask": "0x2",
         "Unit": "R3QPI"
     },
     {
         "BriefDescription": "QPI1 BL Credits Empty",
-        "Counter": "0,1",
         "EventCode": "0x2F",
-        "EventName": "UNC_R3_QPI1_BL_CREDITS_EMPTY.VN0_HOM",
+        "EventName": "UNC_R3_QPI1_BL_CREDITS_EMPTY.VN0_NDR",
         "PerPkg": "1",
-        "UMask": "0x2",
+        "PublicDescription": "No credits available to send to QPI1 on the =
BL Ring; VN0 NDR Messages",
+        "UMask": "0x8",
         "Unit": "R3QPI"
     },
     {
         "BriefDescription": "QPI1 BL Credits Empty",
-        "Counter": "0,1",
         "EventCode": "0x2F",
         "EventName": "UNC_R3_QPI1_BL_CREDITS_EMPTY.VN0_SNP",
         "PerPkg": "1",
+        "PublicDescription": "No credits available to send to QPI1 on the =
BL Ring; VN0 SNP Messages",
         "UMask": "0x4",
         "Unit": "R3QPI"
     },
     {
         "BriefDescription": "QPI1 BL Credits Empty",
-        "Counter": "0,1",
         "EventCode": "0x2F",
-        "EventName": "UNC_R3_QPI1_BL_CREDITS_EMPTY.VN0_NDR",
+        "EventName": "UNC_R3_QPI1_BL_CREDITS_EMPTY.VN1_HOM",
         "PerPkg": "1",
-        "UMask": "0x8",
+        "PublicDescription": "No credits available to send to QPI1 on the =
BL Ring; VN1 HOM Messages",
+        "UMask": "0x10",
         "Unit": "R3QPI"
     },
     {
         "BriefDescription": "QPI1 BL Credits Empty",
-        "Counter": "0,1",
         "EventCode": "0x2F",
-        "EventName": "UNC_R3_QPI1_BL_CREDITS_EMPTY.VN1_HOM",
+        "EventName": "UNC_R3_QPI1_BL_CREDITS_EMPTY.VN1_NDR",
         "PerPkg": "1",
-        "UMask": "0x10",
+        "PublicDescription": "No credits available to send to QPI1 on the =
BL Ring; VN1 NDR Messages",
+        "UMask": "0x40",
         "Unit": "R3QPI"
     },
     {
         "BriefDescription": "QPI1 BL Credits Empty",
-        "Counter": "0,1",
         "EventCode": "0x2F",
         "EventName": "UNC_R3_QPI1_BL_CREDITS_EMPTY.VN1_SNP",
         "PerPkg": "1",
+        "PublicDescription": "No credits available to send to QPI1 on the =
BL Ring; VN1 SNP Messages",
         "UMask": "0x20",
         "Unit": "R3QPI"
     },
     {
         "BriefDescription": "QPI1 BL Credits Empty",
-        "Counter": "0,1",
         "EventCode": "0x2F",
-        "EventName": "UNC_R3_QPI1_BL_CREDITS_EMPTY.VN1_NDR",
-        "PerPkg": "1",
-        "UMask": "0x40",
-        "Unit": "R3QPI"
-    },
-    {
-        "BriefDescription": "R3 AD Ring in Use; Clockwise and Even",
-        "Counter": "0,1,2",
-        "EventCode": "0x7",
-        "EventName": "UNC_R3_RING_AD_USED.CW_EVEN",
+        "EventName": "UNC_R3_QPI1_BL_CREDITS_EMPTY.VNA",
         "PerPkg": "1",
+        "PublicDescription": "No credits available to send to QPI1 on the =
BL Ring; VNA",
         "UMask": "0x1",
         "Unit": "R3QPI"
     },
     {
-        "BriefDescription": "R3 AD Ring in Use; Clockwise and Odd",
-        "Counter": "0,1,2",
+        "BriefDescription": "R3 AD Ring in Use; Counterclockwise",
         "EventCode": "0x7",
-        "EventName": "UNC_R3_RING_AD_USED.CW_ODD",
+        "EventName": "UNC_R3_RING_AD_USED.CCW",
         "PerPkg": "1",
-        "UMask": "0x2",
+        "PublicDescription": "Counts the number of cycles that the AD ring=
 is being used at this ring stop.  This includes when packets are passing b=
y and when packets are being sunk, but does not include when packets are be=
ing sent from the ring stop.",
+        "UMask": "0xc",
         "Unit": "R3QPI"
     },
     {
         "BriefDescription": "R3 AD Ring in Use; Counterclockwise and Even"=
,
-        "Counter": "0,1,2",
         "EventCode": "0x7",
         "EventName": "UNC_R3_RING_AD_USED.CCW_EVEN",
         "PerPkg": "1",
+        "PublicDescription": "Counts the number of cycles that the AD ring=
 is being used at this ring stop.  This includes when packets are passing b=
y and when packets are being sunk, but does not include when packets are be=
ing sent from the ring stop.; Filters for the Counterclockwise and Even rin=
g polarity.",
         "UMask": "0x4",
         "Unit": "R3QPI"
     },
     {
         "BriefDescription": "R3 AD Ring in Use; Counterclockwise and Odd",
-        "Counter": "0,1,2",
         "EventCode": "0x7",
         "EventName": "UNC_R3_RING_AD_USED.CCW_ODD",
         "PerPkg": "1",
+        "PublicDescription": "Counts the number of cycles that the AD ring=
 is being used at this ring stop.  This includes when packets are passing b=
y and when packets are being sunk, but does not include when packets are be=
ing sent from the ring stop.; Filters for the Counterclockwise and Odd ring=
 polarity.",
         "UMask": "0x8",
         "Unit": "R3QPI"
     },
     {
         "BriefDescription": "R3 AD Ring in Use; Clockwise",
-        "Counter": "0,1,2",
         "EventCode": "0x7",
         "EventName": "UNC_R3_RING_AD_USED.CW",
         "PerPkg": "1",
+        "PublicDescription": "Counts the number of cycles that the AD ring=
 is being used at this ring stop.  This includes when packets are passing b=
y and when packets are being sunk, but does not include when packets are be=
ing sent from the ring stop.",
         "UMask": "0x3",
         "Unit": "R3QPI"
     },
     {
-        "BriefDescription": "R3 AD Ring in Use; Counterclockwise",
-        "Counter": "0,1,2",
+        "BriefDescription": "R3 AD Ring in Use; Clockwise and Even",
         "EventCode": "0x7",
-        "EventName": "UNC_R3_RING_AD_USED.CCW",
+        "EventName": "UNC_R3_RING_AD_USED.CW_EVEN",
         "PerPkg": "1",
-        "UMask": "0xC",
+        "PublicDescription": "Counts the number of cycles that the AD ring=
 is being used at this ring stop.  This includes when packets are passing b=
y and when packets are being sunk, but does not include when packets are be=
ing sent from the ring stop.; Filters for the Clockwise and Even ring polar=
ity.",
+        "UMask": "0x1",
         "Unit": "R3QPI"
     },
     {
-        "BriefDescription": "R3 AK Ring in Use; Clockwise and Even",
-        "Counter": "0,1,2",
-        "EventCode": "0x8",
-        "EventName": "UNC_R3_RING_AK_USED.CW_EVEN",
+        "BriefDescription": "R3 AD Ring in Use; Clockwise and Odd",
+        "EventCode": "0x7",
+        "EventName": "UNC_R3_RING_AD_USED.CW_ODD",
         "PerPkg": "1",
-        "UMask": "0x1",
+        "PublicDescription": "Counts the number of cycles that the AD ring=
 is being used at this ring stop.  This includes when packets are passing b=
y and when packets are being sunk, but does not include when packets are be=
ing sent from the ring stop.; Filters for the Clockwise and Odd ring polari=
ty.",
+        "UMask": "0x2",
         "Unit": "R3QPI"
     },
     {
-        "BriefDescription": "R3 AK Ring in Use; Clockwise and Odd",
-        "Counter": "0,1,2",
+        "BriefDescription": "R3 AK Ring in Use; Counterclockwise",
         "EventCode": "0x8",
-        "EventName": "UNC_R3_RING_AK_USED.CW_ODD",
+        "EventName": "UNC_R3_RING_AK_USED.CCW",
         "PerPkg": "1",
-        "UMask": "0x2",
+        "PublicDescription": "Counts the number of cycles that the AK ring=
 is being used at this ring stop.  This includes when packets are passing b=
y and when packets are being sunk, but does not include when packets are be=
ing sent from the ring stop.",
+        "UMask": "0xc",
         "Unit": "R3QPI"
     },
     {
         "BriefDescription": "R3 AK Ring in Use; Counterclockwise and Even"=
,
-        "Counter": "0,1,2",
         "EventCode": "0x8",
         "EventName": "UNC_R3_RING_AK_USED.CCW_EVEN",
         "PerPkg": "1",
+        "PublicDescription": "Counts the number of cycles that the AK ring=
 is being used at this ring stop.  This includes when packets are passing b=
y and when packets are being sunk, but does not include when packets are be=
ing sent from the ring stop.; Filters for the Counterclockwise and Even rin=
g polarity.",
         "UMask": "0x4",
         "Unit": "R3QPI"
     },
     {
         "BriefDescription": "R3 AK Ring in Use; Counterclockwise and Odd",
-        "Counter": "0,1,2",
         "EventCode": "0x8",
         "EventName": "UNC_R3_RING_AK_USED.CCW_ODD",
         "PerPkg": "1",
+        "PublicDescription": "Counts the number of cycles that the AK ring=
 is being used at this ring stop.  This includes when packets are passing b=
y and when packets are being sunk, but does not include when packets are be=
ing sent from the ring stop.; Filters for the Counterclockwise and Odd ring=
 polarity.",
         "UMask": "0x8",
         "Unit": "R3QPI"
     },
     {
         "BriefDescription": "R3 AK Ring in Use; Clockwise",
-        "Counter": "0,1,2",
         "EventCode": "0x8",
         "EventName": "UNC_R3_RING_AK_USED.CW",
         "PerPkg": "1",
+        "PublicDescription": "Counts the number of cycles that the AK ring=
 is being used at this ring stop.  This includes when packets are passing b=
y and when packets are being sunk, but does not include when packets are be=
ing sent from the ring stop.",
         "UMask": "0x3",
         "Unit": "R3QPI"
     },
     {
-        "BriefDescription": "R3 AK Ring in Use; Counterclockwise",
-        "Counter": "0,1,2",
+        "BriefDescription": "R3 AK Ring in Use; Clockwise and Even",
         "EventCode": "0x8",
-        "EventName": "UNC_R3_RING_AK_USED.CCW",
+        "EventName": "UNC_R3_RING_AK_USED.CW_EVEN",
         "PerPkg": "1",
-        "UMask": "0xC",
+        "PublicDescription": "Counts the number of cycles that the AK ring=
 is being used at this ring stop.  This includes when packets are passing b=
y and when packets are being sunk, but does not include when packets are be=
ing sent from the ring stop.; Filters for the Clockwise and Even ring polar=
ity.",
+        "UMask": "0x1",
         "Unit": "R3QPI"
     },
     {
-        "BriefDescription": "R3 BL Ring in Use; Clockwise and Even",
-        "Counter": "0,1,2",
-        "EventCode": "0x9",
-        "EventName": "UNC_R3_RING_BL_USED.CW_EVEN",
+        "BriefDescription": "R3 AK Ring in Use; Clockwise and Odd",
+        "EventCode": "0x8",
+        "EventName": "UNC_R3_RING_AK_USED.CW_ODD",
         "PerPkg": "1",
-        "UMask": "0x1",
+        "PublicDescription": "Counts the number of cycles that the AK ring=
 is being used at this ring stop.  This includes when packets are passing b=
y and when packets are being sunk, but does not include when packets are be=
ing sent from the ring stop.; Filters for the Clockwise and Odd ring polari=
ty.",
+        "UMask": "0x2",
         "Unit": "R3QPI"
     },
     {
-        "BriefDescription": "R3 BL Ring in Use; Clockwise and Odd",
-        "Counter": "0,1,2",
+        "BriefDescription": "R3 BL Ring in Use; Counterclockwise",
         "EventCode": "0x9",
-        "EventName": "UNC_R3_RING_BL_USED.CW_ODD",
+        "EventName": "UNC_R3_RING_BL_USED.CCW",
         "PerPkg": "1",
-        "UMask": "0x2",
+        "PublicDescription": "Counts the number of cycles that the BL ring=
 is being used at this ring stop.  This includes when packets are passing b=
y and when packets are being sunk, but does not include when packets are be=
ing sent from the ring stop.",
+        "UMask": "0xc",
         "Unit": "R3QPI"
     },
     {
         "BriefDescription": "R3 BL Ring in Use; Counterclockwise and Even"=
,
-        "Counter": "0,1,2",
         "EventCode": "0x9",
         "EventName": "UNC_R3_RING_BL_USED.CCW_EVEN",
         "PerPkg": "1",
+        "PublicDescription": "Counts the number of cycles that the BL ring=
 is being used at this ring stop.  This includes when packets are passing b=
y and when packets are being sunk, but does not include when packets are be=
ing sent from the ring stop.; Filters for the Counterclockwise and Even rin=
g polarity.",
         "UMask": "0x4",
         "Unit": "R3QPI"
     },
     {
         "BriefDescription": "R3 BL Ring in Use; Counterclockwise and Odd",
-        "Counter": "0,1,2",
         "EventCode": "0x9",
         "EventName": "UNC_R3_RING_BL_USED.CCW_ODD",
         "PerPkg": "1",
+        "PublicDescription": "Counts the number of cycles that the BL ring=
 is being used at this ring stop.  This includes when packets are passing b=
y and when packets are being sunk, but does not include when packets are be=
ing sent from the ring stop.; Filters for the Counterclockwise and Odd ring=
 polarity.",
         "UMask": "0x8",
         "Unit": "R3QPI"
     },
     {
         "BriefDescription": "R3 BL Ring in Use; Clockwise",
-        "Counter": "0,1,2",
         "EventCode": "0x9",
         "EventName": "UNC_R3_RING_BL_USED.CW",
         "PerPkg": "1",
+        "PublicDescription": "Counts the number of cycles that the BL ring=
 is being used at this ring stop.  This includes when packets are passing b=
y and when packets are being sunk, but does not include when packets are be=
ing sent from the ring stop.",
         "UMask": "0x3",
         "Unit": "R3QPI"
     },
     {
-        "BriefDescription": "R3 BL Ring in Use; Counterclockwise",
-        "Counter": "0,1,2",
+        "BriefDescription": "R3 BL Ring in Use; Clockwise and Even",
         "EventCode": "0x9",
-        "EventName": "UNC_R3_RING_BL_USED.CCW",
+        "EventName": "UNC_R3_RING_BL_USED.CW_EVEN",
         "PerPkg": "1",
-        "UMask": "0xC",
+        "PublicDescription": "Counts the number of cycles that the BL ring=
 is being used at this ring stop.  This includes when packets are passing b=
y and when packets are being sunk, but does not include when packets are be=
ing sent from the ring stop.; Filters for the Clockwise and Even ring polar=
ity.",
+        "UMask": "0x1",
         "Unit": "R3QPI"
     },
     {
-        "BriefDescription": "R3 IV Ring in Use; Clockwise",
-        "Counter": "0,1,2",
-        "EventCode": "0xA",
-        "EventName": "UNC_R3_RING_IV_USED.CW",
+        "BriefDescription": "R3 BL Ring in Use; Clockwise and Odd",
+        "EventCode": "0x9",
+        "EventName": "UNC_R3_RING_BL_USED.CW_ODD",
         "PerPkg": "1",
-        "UMask": "0x3",
+        "PublicDescription": "Counts the number of cycles that the BL ring=
 is being used at this ring stop.  This includes when packets are passing b=
y and when packets are being sunk, but does not include when packets are be=
ing sent from the ring stop.; Filters for the Clockwise and Odd ring polari=
ty.",
+        "UMask": "0x2",
         "Unit": "R3QPI"
     },
     {
         "BriefDescription": "R3 IV Ring in Use; Any",
-        "Counter": "0,1,2",
         "EventCode": "0xA",
         "EventName": "UNC_R3_RING_IV_USED.ANY",
         "PerPkg": "1",
-        "UMask": "0xF",
+        "PublicDescription": "Counts the number of cycles that the IV ring=
 is being used at this ring stop.  This includes when packets are passing b=
y and when packets are being sent, but does not include when packets are be=
ing sunk into the ring stop.",
+        "UMask": "0xf",
+        "Unit": "R3QPI"
+    },
+    {
+        "BriefDescription": "R3 IV Ring in Use; Clockwise",
+        "EventCode": "0xA",
+        "EventName": "UNC_R3_RING_IV_USED.CW",
+        "PerPkg": "1",
+        "PublicDescription": "Counts the number of cycles that the IV ring=
 is being used at this ring stop.  This includes when packets are passing b=
y and when packets are being sent, but does not include when packets are be=
ing sunk into the ring stop.",
+        "UMask": "0x3",
         "Unit": "R3QPI"
     },
     {
         "BriefDescription": "Ring Stop Starved; AK",
-        "Counter": "0,1,2",
         "EventCode": "0xE",
         "EventName": "UNC_R3_RING_SINK_STARVED.AK",
         "PerPkg": "1",
+        "PublicDescription": "Number of cycles the ringstop is in starvati=
on (per ring)",
         "UMask": "0x2",
         "Unit": "R3QPI"
     },
     {
         "BriefDescription": "Ingress Cycles Not Empty; HOM",
-        "Counter": "0,1",
         "EventCode": "0x10",
         "EventName": "UNC_R3_RxR_CYCLES_NE.HOM",
         "PerPkg": "1",
+        "PublicDescription": "Counts the number of cycles when the QPI Ing=
ress is not empty.  This tracks one of the three rings that are used by the=
 QPI agent.  This can be used in conjunction with the QPI Ingress Occupancy=
 Accumulator event in order to calculate average queue occupancy.  Multiple=
 ingress buffers can be tracked at a given time using multiple counters.; H=
OM Ingress Queue",
         "UMask": "0x1",
         "Unit": "R3QPI"
     },
+    {
+        "BriefDescription": "Ingress Cycles Not Empty; NDR",
+        "EventCode": "0x10",
+        "EventName": "UNC_R3_RxR_CYCLES_NE.NDR",
+        "PerPkg": "1",
+        "PublicDescription": "Counts the number of cycles when the QPI Ing=
ress is not empty.  This tracks one of the three rings that are used by the=
 QPI agent.  This can be used in conjunction with the QPI Ingress Occupancy=
 Accumulator event in order to calculate average queue occupancy.  Multiple=
 ingress buffers can be tracked at a given time using multiple counters.; N=
DR Ingress Queue",
+        "UMask": "0x4",
+        "Unit": "R3QPI"
+    },
     {
         "BriefDescription": "Ingress Cycles Not Empty; SNP",
-        "Counter": "0,1",
         "EventCode": "0x10",
         "EventName": "UNC_R3_RxR_CYCLES_NE.SNP",
         "PerPkg": "1",
+        "PublicDescription": "Counts the number of cycles when the QPI Ing=
ress is not empty.  This tracks one of the three rings that are used by the=
 QPI agent.  This can be used in conjunction with the QPI Ingress Occupancy=
 Accumulator event in order to calculate average queue occupancy.  Multiple=
 ingress buffers can be tracked at a given time using multiple counters.; S=
NP Ingress Queue",
         "UMask": "0x2",
         "Unit": "R3QPI"
     },
     {
-        "BriefDescription": "Ingress Cycles Not Empty; NDR",
-        "Counter": "0,1",
-        "EventCode": "0x10",
-        "EventName": "UNC_R3_RxR_CYCLES_NE.NDR",
+        "BriefDescription": "VN1 Ingress Cycles Not Empty; DRS",
+        "EventCode": "0x14",
+        "EventName": "UNC_R3_RxR_CYCLES_NE_VN1.DRS",
         "PerPkg": "1",
-        "UMask": "0x4",
+        "PublicDescription": "Counts the number of cycles when the QPI VN1=
  Ingress is not empty.  This tracks one of the three rings that are used b=
y the QPI agent.  This can be used in conjunction with the QPI VN1  Ingress=
 Occupancy Accumulator event in order to calculate average queue occupancy.=
  Multiple ingress buffers can be tracked at a given time using multiple co=
unters.; DRS Ingress Queue",
+        "UMask": "0x8",
         "Unit": "R3QPI"
     },
     {
         "BriefDescription": "VN1 Ingress Cycles Not Empty; HOM",
-        "Counter": "0,1",
         "EventCode": "0x14",
         "EventName": "UNC_R3_RxR_CYCLES_NE_VN1.HOM",
         "PerPkg": "1",
+        "PublicDescription": "Counts the number of cycles when the QPI VN1=
  Ingress is not empty.  This tracks one of the three rings that are used b=
y the QPI agent.  This can be used in conjunction with the QPI VN1  Ingress=
 Occupancy Accumulator event in order to calculate average queue occupancy.=
  Multiple ingress buffers can be tracked at a given time using multiple co=
unters.; HOM Ingress Queue",
         "UMask": "0x1",
         "Unit": "R3QPI"
     },
     {
-        "BriefDescription": "VN1 Ingress Cycles Not Empty; SNP",
-        "Counter": "0,1",
+        "BriefDescription": "VN1 Ingress Cycles Not Empty; NCB",
         "EventCode": "0x14",
-        "EventName": "UNC_R3_RxR_CYCLES_NE_VN1.SNP",
+        "EventName": "UNC_R3_RxR_CYCLES_NE_VN1.NCB",
         "PerPkg": "1",
-        "UMask": "0x2",
+        "PublicDescription": "Counts the number of cycles when the QPI VN1=
  Ingress is not empty.  This tracks one of the three rings that are used b=
y the QPI agent.  This can be used in conjunction with the QPI VN1  Ingress=
 Occupancy Accumulator event in order to calculate average queue occupancy.=
  Multiple ingress buffers can be tracked at a given time using multiple co=
unters.; NCB Ingress Queue",
+        "UMask": "0x10",
         "Unit": "R3QPI"
     },
     {
-        "BriefDescription": "VN1 Ingress Cycles Not Empty; NDR",
-        "Counter": "0,1",
+        "BriefDescription": "VN1 Ingress Cycles Not Empty; NCS",
         "EventCode": "0x14",
-        "EventName": "UNC_R3_RxR_CYCLES_NE_VN1.NDR",
+        "EventName": "UNC_R3_RxR_CYCLES_NE_VN1.NCS",
         "PerPkg": "1",
-        "UMask": "0x4",
+        "PublicDescription": "Counts the number of cycles when the QPI VN1=
  Ingress is not empty.  This tracks one of the three rings that are used b=
y the QPI agent.  This can be used in conjunction with the QPI VN1  Ingress=
 Occupancy Accumulator event in order to calculate average queue occupancy.=
  Multiple ingress buffers can be tracked at a given time using multiple co=
unters.; NCS Ingress Queue",
+        "UMask": "0x20",
         "Unit": "R3QPI"
     },
     {
-        "BriefDescription": "VN1 Ingress Cycles Not Empty; DRS",
-        "Counter": "0,1",
+        "BriefDescription": "VN1 Ingress Cycles Not Empty; NDR",
         "EventCode": "0x14",
-        "EventName": "UNC_R3_RxR_CYCLES_NE_VN1.DRS",
+        "EventName": "UNC_R3_RxR_CYCLES_NE_VN1.NDR",
         "PerPkg": "1",
-        "UMask": "0x8",
+        "PublicDescription": "Counts the number of cycles when the QPI VN1=
  Ingress is not empty.  This tracks one of the three rings that are used b=
y the QPI agent.  This can be used in conjunction with the QPI VN1  Ingress=
 Occupancy Accumulator event in order to calculate average queue occupancy.=
  Multiple ingress buffers can be tracked at a given time using multiple co=
unters.; NDR Ingress Queue",
+        "UMask": "0x4",
         "Unit": "R3QPI"
     },
     {
-        "BriefDescription": "VN1 Ingress Cycles Not Empty; NCB",
-        "Counter": "0,1",
+        "BriefDescription": "VN1 Ingress Cycles Not Empty; SNP",
         "EventCode": "0x14",
-        "EventName": "UNC_R3_RxR_CYCLES_NE_VN1.NCB",
+        "EventName": "UNC_R3_RxR_CYCLES_NE_VN1.SNP",
         "PerPkg": "1",
-        "UMask": "0x10",
+        "PublicDescription": "Counts the number of cycles when the QPI VN1=
  Ingress is not empty.  This tracks one of the three rings that are used b=
y the QPI agent.  This can be used in conjunction with the QPI VN1  Ingress=
 Occupancy Accumulator event in order to calculate average queue occupancy.=
  Multiple ingress buffers can be tracked at a given time using multiple co=
unters.; SNP Ingress Queue",
+        "UMask": "0x2",
         "Unit": "R3QPI"
     },
     {
-        "BriefDescription": "VN1 Ingress Cycles Not Empty; NCS",
-        "Counter": "0,1",
-        "EventCode": "0x14",
-        "EventName": "UNC_R3_RxR_CYCLES_NE_VN1.NCS",
+        "BriefDescription": "Ingress Allocations; DRS",
+        "EventCode": "0x11",
+        "EventName": "UNC_R3_RxR_INSERTS.DRS",
         "PerPkg": "1",
-        "UMask": "0x20",
+        "PublicDescription": "Counts the number of allocations into the QP=
I Ingress.  This tracks one of the three rings that are used by the QPI age=
nt.  This can be used in conjunction with the QPI Ingress Occupancy Accumul=
ator event in order to calculate average queue latency.  Multiple ingress b=
uffers can be tracked at a given time using multiple counters.; DRS Ingress=
 Queue",
+        "UMask": "0x8",
         "Unit": "R3QPI"
     },
     {
         "BriefDescription": "Ingress Allocations; HOM",
-        "Counter": "0,1",
         "EventCode": "0x11",
         "EventName": "UNC_R3_RxR_INSERTS.HOM",
         "PerPkg": "1",
+        "PublicDescription": "Counts the number of allocations into the QP=
I Ingress.  This tracks one of the three rings that are used by the QPI age=
nt.  This can be used in conjunction with the QPI Ingress Occupancy Accumul=
ator event in order to calculate average queue latency.  Multiple ingress b=
uffers can be tracked at a given time using multiple counters.; HOM Ingress=
 Queue",
         "UMask": "0x1",
         "Unit": "R3QPI"
     },
-    {
-        "BriefDescription": "Ingress Allocations; SNP",
-        "Counter": "0,1",
-        "EventCode": "0x11",
-        "EventName": "UNC_R3_RxR_INSERTS.SNP",
-        "PerPkg": "1",
-        "UMask": "0x2",
-        "Unit": "R3QPI"
-    },
-    {
-        "BriefDescription": "Ingress Allocations; NDR",
-        "Counter": "0,1",
-        "EventCode": "0x11",
-        "EventName": "UNC_R3_RxR_INSERTS.NDR",
-        "PerPkg": "1",
-        "UMask": "0x4",
-        "Unit": "R3QPI"
-    },
-    {
-        "BriefDescription": "Ingress Allocations; DRS",
-        "Counter": "0,1",
-        "EventCode": "0x11",
-        "EventName": "UNC_R3_RxR_INSERTS.DRS",
-        "PerPkg": "1",
-        "UMask": "0x8",
-        "Unit": "R3QPI"
-    },
     {
         "BriefDescription": "Ingress Allocations; NCB",
-        "Counter": "0,1",
         "EventCode": "0x11",
         "EventName": "UNC_R3_RxR_INSERTS.NCB",
         "PerPkg": "1",
+        "PublicDescription": "Counts the number of allocations into the QP=
I Ingress.  This tracks one of the three rings that are used by the QPI age=
nt.  This can be used in conjunction with the QPI Ingress Occupancy Accumul=
ator event in order to calculate average queue latency.  Multiple ingress b=
uffers can be tracked at a given time using multiple counters.; NCB Ingress=
 Queue",
         "UMask": "0x10",
         "Unit": "R3QPI"
     },
     {
         "BriefDescription": "Ingress Allocations; NCS",
-        "Counter": "0,1",
         "EventCode": "0x11",
         "EventName": "UNC_R3_RxR_INSERTS.NCS",
         "PerPkg": "1",
+        "PublicDescription": "Counts the number of allocations into the QP=
I Ingress.  This tracks one of the three rings that are used by the QPI age=
nt.  This can be used in conjunction with the QPI Ingress Occupancy Accumul=
ator event in order to calculate average queue latency.  Multiple ingress b=
uffers can be tracked at a given time using multiple counters.; NCS Ingress=
 Queue",
         "UMask": "0x20",
         "Unit": "R3QPI"
     },
     {
-        "BriefDescription": "VN1 Ingress Allocations; HOM",
-        "Counter": "0,1",
-        "EventCode": "0x15",
-        "EventName": "UNC_R3_RxR_INSERTS_VN1.HOM",
+        "BriefDescription": "Ingress Allocations; NDR",
+        "EventCode": "0x11",
+        "EventName": "UNC_R3_RxR_INSERTS.NDR",
         "PerPkg": "1",
-        "UMask": "0x1",
+        "PublicDescription": "Counts the number of allocations into the QP=
I Ingress.  This tracks one of the three rings that are used by the QPI age=
nt.  This can be used in conjunction with the QPI Ingress Occupancy Accumul=
ator event in order to calculate average queue latency.  Multiple ingress b=
uffers can be tracked at a given time using multiple counters.; NDR Ingress=
 Queue",
+        "UMask": "0x4",
         "Unit": "R3QPI"
     },
     {
-        "BriefDescription": "VN1 Ingress Allocations; SNP",
-        "Counter": "0,1",
-        "EventCode": "0x15",
-        "EventName": "UNC_R3_RxR_INSERTS_VN1.SNP",
+        "BriefDescription": "Ingress Allocations; SNP",
+        "EventCode": "0x11",
+        "EventName": "UNC_R3_RxR_INSERTS.SNP",
         "PerPkg": "1",
+        "PublicDescription": "Counts the number of allocations into the QP=
I Ingress.  This tracks one of the three rings that are used by the QPI age=
nt.  This can be used in conjunction with the QPI Ingress Occupancy Accumul=
ator event in order to calculate average queue latency.  Multiple ingress b=
uffers can be tracked at a given time using multiple counters.; SNP Ingress=
 Queue",
         "UMask": "0x2",
         "Unit": "R3QPI"
     },
     {
-        "BriefDescription": "VN1 Ingress Allocations; NDR",
-        "Counter": "0,1",
+        "BriefDescription": "VN1 Ingress Allocations; DRS",
         "EventCode": "0x15",
-        "EventName": "UNC_R3_RxR_INSERTS_VN1.NDR",
+        "EventName": "UNC_R3_RxR_INSERTS_VN1.DRS",
         "PerPkg": "1",
-        "UMask": "0x4",
+        "PublicDescription": "Counts the number of allocations into the QP=
I VN1  Ingress.  This tracks one of the three rings that are used by the QP=
I agent.  This can be used in conjunction with the QPI VN1  Ingress Occupan=
cy Accumulator event in order to calculate average queue latency.  Multiple=
 ingress buffers can be tracked at a given time using multiple counters.; D=
RS Ingress Queue",
+        "UMask": "0x8",
         "Unit": "R3QPI"
     },
     {
-        "BriefDescription": "VN1 Ingress Allocations; DRS",
-        "Counter": "0,1",
+        "BriefDescription": "VN1 Ingress Allocations; HOM",
         "EventCode": "0x15",
-        "EventName": "UNC_R3_RxR_INSERTS_VN1.DRS",
+        "EventName": "UNC_R3_RxR_INSERTS_VN1.HOM",
         "PerPkg": "1",
-        "UMask": "0x8",
+        "PublicDescription": "Counts the number of allocations into the QP=
I VN1  Ingress.  This tracks one of the three rings that are used by the QP=
I agent.  This can be used in conjunction with the QPI VN1  Ingress Occupan=
cy Accumulator event in order to calculate average queue latency.  Multiple=
 ingress buffers can be tracked at a given time using multiple counters.; H=
OM Ingress Queue",
+        "UMask": "0x1",
         "Unit": "R3QPI"
     },
     {
         "BriefDescription": "VN1 Ingress Allocations; NCB",
-        "Counter": "0,1",
         "EventCode": "0x15",
         "EventName": "UNC_R3_RxR_INSERTS_VN1.NCB",
         "PerPkg": "1",
+        "PublicDescription": "Counts the number of allocations into the QP=
I VN1  Ingress.  This tracks one of the three rings that are used by the QP=
I agent.  This can be used in conjunction with the QPI VN1  Ingress Occupan=
cy Accumulator event in order to calculate average queue latency.  Multiple=
 ingress buffers can be tracked at a given time using multiple counters.; N=
CB Ingress Queue",
         "UMask": "0x10",
         "Unit": "R3QPI"
     },
     {
         "BriefDescription": "VN1 Ingress Allocations; NCS",
-        "Counter": "0,1",
         "EventCode": "0x15",
         "EventName": "UNC_R3_RxR_INSERTS_VN1.NCS",
         "PerPkg": "1",
+        "PublicDescription": "Counts the number of allocations into the QP=
I VN1  Ingress.  This tracks one of the three rings that are used by the QP=
I agent.  This can be used in conjunction with the QPI VN1  Ingress Occupan=
cy Accumulator event in order to calculate average queue latency.  Multiple=
 ingress buffers can be tracked at a given time using multiple counters.; N=
CS Ingress Queue",
         "UMask": "0x20",
         "Unit": "R3QPI"
     },
     {
-        "BriefDescription": "VN1 Ingress Occupancy Accumulator; HOM",
-        "EventCode": "0x13",
-        "EventName": "UNC_R3_RxR_OCCUPANCY_VN1.HOM",
+        "BriefDescription": "VN1 Ingress Allocations; NDR",
+        "EventCode": "0x15",
+        "EventName": "UNC_R3_RxR_INSERTS_VN1.NDR",
         "PerPkg": "1",
-        "UMask": "0x1",
+        "PublicDescription": "Counts the number of allocations into the QP=
I VN1  Ingress.  This tracks one of the three rings that are used by the QP=
I agent.  This can be used in conjunction with the QPI VN1  Ingress Occupan=
cy Accumulator event in order to calculate average queue latency.  Multiple=
 ingress buffers can be tracked at a given time using multiple counters.; N=
DR Ingress Queue",
+        "UMask": "0x4",
         "Unit": "R3QPI"
     },
     {
-        "BriefDescription": "VN1 Ingress Occupancy Accumulator; SNP",
-        "EventCode": "0x13",
-        "EventName": "UNC_R3_RxR_OCCUPANCY_VN1.SNP",
+        "BriefDescription": "VN1 Ingress Allocations; SNP",
+        "EventCode": "0x15",
+        "EventName": "UNC_R3_RxR_INSERTS_VN1.SNP",
         "PerPkg": "1",
+        "PublicDescription": "Counts the number of allocations into the QP=
I VN1  Ingress.  This tracks one of the three rings that are used by the QP=
I agent.  This can be used in conjunction with the QPI VN1  Ingress Occupan=
cy Accumulator event in order to calculate average queue latency.  Multiple=
 ingress buffers can be tracked at a given time using multiple counters.; S=
NP Ingress Queue",
         "UMask": "0x2",
         "Unit": "R3QPI"
     },
     {
-        "BriefDescription": "VN1 Ingress Occupancy Accumulator; NDR",
+        "BriefDescription": "VN1 Ingress Occupancy Accumulator; DRS",
         "EventCode": "0x13",
-        "EventName": "UNC_R3_RxR_OCCUPANCY_VN1.NDR",
+        "EventName": "UNC_R3_RxR_OCCUPANCY_VN1.DRS",
         "PerPkg": "1",
-        "UMask": "0x4",
+        "PublicDescription": "Accumulates the occupancy of a given QPI VN1=
  Ingress queue in each cycles.  This tracks one of the three ring Ingress =
buffers.  This can be used with the QPI VN1  Ingress Not Empty event to cal=
culate average occupancy or the QPI VN1  Ingress Allocations event in order=
 to calculate average queuing latency.; DRS Ingress Queue",
+        "UMask": "0x8",
         "Unit": "R3QPI"
     },
     {
-        "BriefDescription": "VN1 Ingress Occupancy Accumulator; DRS",
+        "BriefDescription": "VN1 Ingress Occupancy Accumulator; HOM",
         "EventCode": "0x13",
-        "EventName": "UNC_R3_RxR_OCCUPANCY_VN1.DRS",
+        "EventName": "UNC_R3_RxR_OCCUPANCY_VN1.HOM",
         "PerPkg": "1",
-        "UMask": "0x8",
+        "PublicDescription": "Accumulates the occupancy of a given QPI VN1=
  Ingress queue in each cycles.  This tracks one of the three ring Ingress =
buffers.  This can be used with the QPI VN1  Ingress Not Empty event to cal=
culate average occupancy or the QPI VN1  Ingress Allocations event in order=
 to calculate average queuing latency.; HOM Ingress Queue",
+        "UMask": "0x1",
         "Unit": "R3QPI"
     },
     {
@@ -1862,6 +1842,7 @@
         "EventCode": "0x13",
         "EventName": "UNC_R3_RxR_OCCUPANCY_VN1.NCB",
         "PerPkg": "1",
+        "PublicDescription": "Accumulates the occupancy of a given QPI VN1=
  Ingress queue in each cycles.  This tracks one of the three ring Ingress =
buffers.  This can be used with the QPI VN1  Ingress Not Empty event to cal=
culate average occupancy or the QPI VN1  Ingress Allocations event in order=
 to calculate average queuing latency.; NCB Ingress Queue",
         "UMask": "0x10",
         "Unit": "R3QPI"
     },
@@ -1870,24 +1851,43 @@
         "EventCode": "0x13",
         "EventName": "UNC_R3_RxR_OCCUPANCY_VN1.NCS",
         "PerPkg": "1",
+        "PublicDescription": "Accumulates the occupancy of a given QPI VN1=
  Ingress queue in each cycles.  This tracks one of the three ring Ingress =
buffers.  This can be used with the QPI VN1  Ingress Not Empty event to cal=
culate average occupancy or the QPI VN1  Ingress Allocations event in order=
 to calculate average queuing latency.; NCS Ingress Queue",
         "UMask": "0x20",
         "Unit": "R3QPI"
     },
+    {
+        "BriefDescription": "VN1 Ingress Occupancy Accumulator; NDR",
+        "EventCode": "0x13",
+        "EventName": "UNC_R3_RxR_OCCUPANCY_VN1.NDR",
+        "PerPkg": "1",
+        "PublicDescription": "Accumulates the occupancy of a given QPI VN1=
  Ingress queue in each cycles.  This tracks one of the three ring Ingress =
buffers.  This can be used with the QPI VN1  Ingress Not Empty event to cal=
culate average occupancy or the QPI VN1  Ingress Allocations event in order=
 to calculate average queuing latency.; NDR Ingress Queue",
+        "UMask": "0x4",
+        "Unit": "R3QPI"
+    },
+    {
+        "BriefDescription": "VN1 Ingress Occupancy Accumulator; SNP",
+        "EventCode": "0x13",
+        "EventName": "UNC_R3_RxR_OCCUPANCY_VN1.SNP",
+        "PerPkg": "1",
+        "PublicDescription": "Accumulates the occupancy of a given QPI VN1=
  Ingress queue in each cycles.  This tracks one of the three ring Ingress =
buffers.  This can be used with the QPI VN1  Ingress Not Empty event to cal=
culate average occupancy or the QPI VN1  Ingress Allocations event in order=
 to calculate average queuing latency.; SNP Ingress Queue",
+        "UMask": "0x2",
+        "Unit": "R3QPI"
+    },
     {
         "BriefDescription": "SBo0 Credits Acquired; For AD Ring",
-        "Counter": "0,1",
         "EventCode": "0x28",
         "EventName": "UNC_R3_SBO0_CREDITS_ACQUIRED.AD",
         "PerPkg": "1",
+        "PublicDescription": "Number of Sbo 0 credits acquired in a given =
cycle, per ring.",
         "UMask": "0x1",
         "Unit": "R3QPI"
     },
     {
         "BriefDescription": "SBo0 Credits Acquired; For BL Ring",
-        "Counter": "0,1",
         "EventCode": "0x28",
         "EventName": "UNC_R3_SBO0_CREDITS_ACQUIRED.BL",
         "PerPkg": "1",
+        "PublicDescription": "Number of Sbo 0 credits acquired in a given =
cycle, per ring.",
         "UMask": "0x2",
         "Unit": "R3QPI"
     },
@@ -1896,6 +1896,7 @@
         "EventCode": "0x2A",
         "EventName": "UNC_R3_SBO0_CREDIT_OCCUPANCY.AD",
         "PerPkg": "1",
+        "PublicDescription": "Number of Sbo 0 credits in use in a given cy=
cle, per ring.",
         "UMask": "0x1",
         "Unit": "R3QPI"
     },
@@ -1904,24 +1905,25 @@
         "EventCode": "0x2A",
         "EventName": "UNC_R3_SBO0_CREDIT_OCCUPANCY.BL",
         "PerPkg": "1",
+        "PublicDescription": "Number of Sbo 0 credits in use in a given cy=
cle, per ring.",
         "UMask": "0x2",
         "Unit": "R3QPI"
     },
     {
         "BriefDescription": "SBo1 Credits Acquired; For AD Ring",
-        "Counter": "0,1",
         "EventCode": "0x29",
         "EventName": "UNC_R3_SBO1_CREDITS_ACQUIRED.AD",
         "PerPkg": "1",
+        "PublicDescription": "Number of Sbo 1 credits acquired in a given =
cycle, per ring.",
         "UMask": "0x1",
         "Unit": "R3QPI"
     },
     {
         "BriefDescription": "SBo1 Credits Acquired; For BL Ring",
-        "Counter": "0,1",
         "EventCode": "0x29",
         "EventName": "UNC_R3_SBO1_CREDITS_ACQUIRED.BL",
         "PerPkg": "1",
+        "PublicDescription": "Number of Sbo 1 credits acquired in a given =
cycle, per ring.",
         "UMask": "0x2",
         "Unit": "R3QPI"
     },
@@ -1930,6 +1932,7 @@
         "EventCode": "0x2B",
         "EventName": "UNC_R3_SBO1_CREDIT_OCCUPANCY.AD",
         "PerPkg": "1",
+        "PublicDescription": "Number of Sbo 1 credits in use in a given cy=
cle, per ring.",
         "UMask": "0x1",
         "Unit": "R3QPI"
     },
@@ -1938,390 +1941,390 @@
         "EventCode": "0x2B",
         "EventName": "UNC_R3_SBO1_CREDIT_OCCUPANCY.BL",
         "PerPkg": "1",
+        "PublicDescription": "Number of Sbo 1 credits in use in a given cy=
cle, per ring.",
         "UMask": "0x2",
         "Unit": "R3QPI"
     },
     {
         "BriefDescription": "Stall on No Sbo Credits; For SBo0, AD Ring",
-        "Counter": "0,1",
         "EventCode": "0x2C",
         "EventName": "UNC_R3_STALL_NO_SBO_CREDIT.SBO0_AD",
         "PerPkg": "1",
+        "PublicDescription": "Number of cycles Egress is stalled waiting f=
or an Sbo credit to become available.  Per Sbo, per Ring.",
         "UMask": "0x1",
         "Unit": "R3QPI"
     },
     {
-        "BriefDescription": "Stall on No Sbo Credits; For SBo1, AD Ring",
-        "Counter": "0,1",
+        "BriefDescription": "Stall on No Sbo Credits; For SBo0, BL Ring",
         "EventCode": "0x2C",
-        "EventName": "UNC_R3_STALL_NO_SBO_CREDIT.SBO1_AD",
+        "EventName": "UNC_R3_STALL_NO_SBO_CREDIT.SBO0_BL",
         "PerPkg": "1",
-        "UMask": "0x2",
+        "PublicDescription": "Number of cycles Egress is stalled waiting f=
or an Sbo credit to become available.  Per Sbo, per Ring.",
+        "UMask": "0x4",
         "Unit": "R3QPI"
     },
     {
-        "BriefDescription": "Stall on No Sbo Credits; For SBo0, BL Ring",
-        "Counter": "0,1",
+        "BriefDescription": "Stall on No Sbo Credits; For SBo1, AD Ring",
         "EventCode": "0x2C",
-        "EventName": "UNC_R3_STALL_NO_SBO_CREDIT.SBO0_BL",
+        "EventName": "UNC_R3_STALL_NO_SBO_CREDIT.SBO1_AD",
         "PerPkg": "1",
-        "UMask": "0x4",
+        "PublicDescription": "Number of cycles Egress is stalled waiting f=
or an Sbo credit to become available.  Per Sbo, per Ring.",
+        "UMask": "0x2",
         "Unit": "R3QPI"
     },
     {
         "BriefDescription": "Stall on No Sbo Credits; For SBo1, BL Ring",
-        "Counter": "0,1",
         "EventCode": "0x2C",
         "EventName": "UNC_R3_STALL_NO_SBO_CREDIT.SBO1_BL",
         "PerPkg": "1",
+        "PublicDescription": "Number of cycles Egress is stalled waiting f=
or an Sbo credit to become available.  Per Sbo, per Ring.",
         "UMask": "0x8",
         "Unit": "R3QPI"
     },
     {
         "BriefDescription": "Egress CCW NACK; AD CCW",
-        "Counter": "0,1",
         "EventCode": "0x26",
         "EventName": "UNC_R3_TxR_NACK.DN_AD",
         "PerPkg": "1",
+        "PublicDescription": "AD CounterClockwise Egress Queue",
         "UMask": "0x1",
         "Unit": "R3QPI"
     },
-    {
-        "BriefDescription": "Egress CCW NACK; BL CCW",
-        "Counter": "0,1",
-        "EventCode": "0x26",
-        "EventName": "UNC_R3_TxR_NACK.DN_BL",
-        "PerPkg": "1",
-        "UMask": "0x2",
-        "Unit": "R3QPI"
-    },
     {
         "BriefDescription": "Egress CCW NACK; AK CCW",
-        "Counter": "0,1",
         "EventCode": "0x26",
         "EventName": "UNC_R3_TxR_NACK.DN_AK",
         "PerPkg": "1",
+        "PublicDescription": "AK CounterClockwise Egress Queue",
         "UMask": "0x4",
         "Unit": "R3QPI"
     },
     {
-        "BriefDescription": "Egress CCW NACK; AK CCW",
-        "Counter": "0,1",
+        "BriefDescription": "Egress CCW NACK; BL CCW",
         "EventCode": "0x26",
-        "EventName": "UNC_R3_TxR_NACK.UP_AD",
+        "EventName": "UNC_R3_TxR_NACK.DN_BL",
         "PerPkg": "1",
-        "UMask": "0x8",
+        "PublicDescription": "BL CounterClockwise Egress Queue",
+        "UMask": "0x2",
         "Unit": "R3QPI"
     },
     {
-        "BriefDescription": "Egress CCW NACK; BL CCW",
-        "Counter": "0,1",
+        "BriefDescription": "Egress CCW NACK; AK CCW",
         "EventCode": "0x26",
-        "EventName": "UNC_R3_TxR_NACK.UP_BL",
+        "EventName": "UNC_R3_TxR_NACK.UP_AD",
         "PerPkg": "1",
-        "UMask": "0x10",
+        "PublicDescription": "BL CounterClockwise Egress Queue",
+        "UMask": "0x8",
         "Unit": "R3QPI"
     },
     {
         "BriefDescription": "Egress CCW NACK; BL CW",
-        "Counter": "0,1",
         "EventCode": "0x26",
         "EventName": "UNC_R3_TxR_NACK.UP_AK",
         "PerPkg": "1",
+        "PublicDescription": "AD Clockwise Egress Queue",
         "UMask": "0x20",
         "Unit": "R3QPI"
     },
     {
-        "BriefDescription": "VN0 Credit Acquisition Failed on DRS; HOM Mes=
sage Class",
-        "Counter": "0,1",
-        "EventCode": "0x37",
-        "EventName": "UNC_R3_VN0_CREDITS_REJECT.HOM",
-        "PerPkg": "1",
-        "UMask": "0x1",
-        "Unit": "R3QPI"
-    },
-    {
-        "BriefDescription": "VN0 Credit Acquisition Failed on DRS; SNP Mes=
sage Class",
-        "Counter": "0,1",
-        "EventCode": "0x37",
-        "EventName": "UNC_R3_VN0_CREDITS_REJECT.SNP",
+        "BriefDescription": "Egress CCW NACK; BL CCW",
+        "EventCode": "0x26",
+        "EventName": "UNC_R3_TxR_NACK.UP_BL",
         "PerPkg": "1",
-        "UMask": "0x2",
+        "PublicDescription": "AD CounterClockwise Egress Queue",
+        "UMask": "0x10",
         "Unit": "R3QPI"
     },
     {
-        "BriefDescription": "VN0 Credit Acquisition Failed on DRS; NDR Mes=
sage Class",
-        "Counter": "0,1",
+        "BriefDescription": "VN0 Credit Acquisition Failed on DRS; DRS Mes=
sage Class",
         "EventCode": "0x37",
-        "EventName": "UNC_R3_VN0_CREDITS_REJECT.NDR",
+        "EventName": "UNC_R3_VN0_CREDITS_REJECT.DRS",
         "PerPkg": "1",
-        "UMask": "0x4",
+        "PublicDescription": "Number of times a request failed to acquire =
a DRS VN0 credit.  In order for a request to be transferred across QPI, it =
must be guaranteed to have a flit buffer on the remote socket to sink into.=
  There are two credit pools, VNA and VN0.  VNA is a shared pool used to ac=
hieve high performance.  The VN0 pool has reserved entries for each message=
 class and is used to prevent deadlock.  Requests first attempt to acquire =
a VNA credit, and then fall back to VN0 if they fail.  This therefore count=
s the number of times when a request failed to acquire either a VNA or VN0 =
credit and is delayed.  This should generally be a rare situation.; Filter =
for Data Response (DRS).  DRS is generally used to transmit data with coher=
ency.  For example, remote reads and writes, or cache to cache transfers wi=
ll transmit their data using DRS.",
+        "UMask": "0x8",
         "Unit": "R3QPI"
     },
     {
-        "BriefDescription": "VN0 Credit Acquisition Failed on DRS; DRS Mes=
sage Class",
-        "Counter": "0,1",
+        "BriefDescription": "VN0 Credit Acquisition Failed on DRS; HOM Mes=
sage Class",
         "EventCode": "0x37",
-        "EventName": "UNC_R3_VN0_CREDITS_REJECT.DRS",
+        "EventName": "UNC_R3_VN0_CREDITS_REJECT.HOM",
         "PerPkg": "1",
-        "UMask": "0x8",
+        "PublicDescription": "Number of times a request failed to acquire =
a DRS VN0 credit.  In order for a request to be transferred across QPI, it =
must be guaranteed to have a flit buffer on the remote socket to sink into.=
  There are two credit pools, VNA and VN0.  VNA is a shared pool used to ac=
hieve high performance.  The VN0 pool has reserved entries for each message=
 class and is used to prevent deadlock.  Requests first attempt to acquire =
a VNA credit, and then fall back to VN0 if they fail.  This therefore count=
s the number of times when a request failed to acquire either a VNA or VN0 =
credit and is delayed.  This should generally be a rare situation.; Filter =
for the Home (HOM) message class.  HOM is generally used to send requests, =
request responses, and snoop responses.",
+        "UMask": "0x1",
         "Unit": "R3QPI"
     },
     {
         "BriefDescription": "VN0 Credit Acquisition Failed on DRS; NCB Mes=
sage Class",
-        "Counter": "0,1",
         "EventCode": "0x37",
         "EventName": "UNC_R3_VN0_CREDITS_REJECT.NCB",
         "PerPkg": "1",
+        "PublicDescription": "Number of times a request failed to acquire =
a DRS VN0 credit.  In order for a request to be transferred across QPI, it =
must be guaranteed to have a flit buffer on the remote socket to sink into.=
  There are two credit pools, VNA and VN0.  VNA is a shared pool used to ac=
hieve high performance.  The VN0 pool has reserved entries for each message=
 class and is used to prevent deadlock.  Requests first attempt to acquire =
a VNA credit, and then fall back to VN0 if they fail.  This therefore count=
s the number of times when a request failed to acquire either a VNA or VN0 =
credit and is delayed.  This should generally be a rare situation.; Filter =
for Non-Coherent Broadcast (NCB).  NCB is generally used to transmit data w=
ithout coherency.  For example, non-coherent read data returns.",
         "UMask": "0x10",
         "Unit": "R3QPI"
     },
     {
         "BriefDescription": "VN0 Credit Acquisition Failed on DRS; NCS Mes=
sage Class",
-        "Counter": "0,1",
         "EventCode": "0x37",
         "EventName": "UNC_R3_VN0_CREDITS_REJECT.NCS",
         "PerPkg": "1",
+        "PublicDescription": "Number of times a request failed to acquire =
a DRS VN0 credit.  In order for a request to be transferred across QPI, it =
must be guaranteed to have a flit buffer on the remote socket to sink into.=
  There are two credit pools, VNA and VN0.  VNA is a shared pool used to ac=
hieve high performance.  The VN0 pool has reserved entries for each message=
 class and is used to prevent deadlock.  Requests first attempt to acquire =
a VNA credit, and then fall back to VN0 if they fail.  This therefore count=
s the number of times when a request failed to acquire either a VNA or VN0 =
credit and is delayed.  This should generally be a rare situation.; Filter =
for Non-Coherent Standard (NCS).  NCS is commonly used for ?",
         "UMask": "0x20",
         "Unit": "R3QPI"
     },
     {
-        "BriefDescription": "VN0 Credit Used; HOM Message Class",
-        "Counter": "0,1",
-        "EventCode": "0x36",
-        "EventName": "UNC_R3_VN0_CREDITS_USED.HOM",
+        "BriefDescription": "VN0 Credit Acquisition Failed on DRS; NDR Mes=
sage Class",
+        "EventCode": "0x37",
+        "EventName": "UNC_R3_VN0_CREDITS_REJECT.NDR",
         "PerPkg": "1",
-        "UMask": "0x1",
+        "PublicDescription": "Number of times a request failed to acquire =
a DRS VN0 credit.  In order for a request to be transferred across QPI, it =
must be guaranteed to have a flit buffer on the remote socket to sink into.=
  There are two credit pools, VNA and VN0.  VNA is a shared pool used to ac=
hieve high performance.  The VN0 pool has reserved entries for each message=
 class and is used to prevent deadlock.  Requests first attempt to acquire =
a VNA credit, and then fall back to VN0 if they fail.  This therefore count=
s the number of times when a request failed to acquire either a VNA or VN0 =
credit and is delayed.  This should generally be a rare situation.; NDR pac=
kets are used to transmit a variety of protocol flits including grants and =
completions (CMP).",
+        "UMask": "0x4",
         "Unit": "R3QPI"
     },
     {
-        "BriefDescription": "VN0 Credit Used; SNP Message Class",
-        "Counter": "0,1",
-        "EventCode": "0x36",
-        "EventName": "UNC_R3_VN0_CREDITS_USED.SNP",
+        "BriefDescription": "VN0 Credit Acquisition Failed on DRS; SNP Mes=
sage Class",
+        "EventCode": "0x37",
+        "EventName": "UNC_R3_VN0_CREDITS_REJECT.SNP",
         "PerPkg": "1",
+        "PublicDescription": "Number of times a request failed to acquire =
a DRS VN0 credit.  In order for a request to be transferred across QPI, it =
must be guaranteed to have a flit buffer on the remote socket to sink into.=
  There are two credit pools, VNA and VN0.  VNA is a shared pool used to ac=
hieve high performance.  The VN0 pool has reserved entries for each message=
 class and is used to prevent deadlock.  Requests first attempt to acquire =
a VNA credit, and then fall back to VN0 if they fail.  This therefore count=
s the number of times when a request failed to acquire either a VNA or VN0 =
credit and is delayed.  This should generally be a rare situation.; Filter =
for Snoop (SNP) message class.  SNP is used for outgoing snoops.  Note that=
 snoop responses flow on the HOM message class.",
         "UMask": "0x2",
         "Unit": "R3QPI"
     },
     {
-        "BriefDescription": "VN0 Credit Used; NDR Message Class",
-        "Counter": "0,1",
+        "BriefDescription": "VN0 Credit Used; DRS Message Class",
         "EventCode": "0x36",
-        "EventName": "UNC_R3_VN0_CREDITS_USED.NDR",
+        "EventName": "UNC_R3_VN0_CREDITS_USED.DRS",
         "PerPkg": "1",
-        "UMask": "0x4",
+        "PublicDescription": "Number of times a VN0 credit was used on the=
 DRS message channel.  In order for a request to be transferred across QPI,=
 it must be guaranteed to have a flit buffer on the remote socket to sink i=
nto.  There are two credit pools, VNA and VN0.  VNA is a shared pool used t=
o achieve high performance.  The VN0 pool has reserved entries for each mes=
sage class and is used to prevent deadlock.  Requests first attempt to acqu=
ire a VNA credit, and then fall back to VN0 if they fail.  This counts the =
number of times a VN0 credit was used.  Note that a single VN0 credit holds=
 access to potentially multiple flit buffers.  For example, a transfer that=
 uses VNA could use 9 flit buffers and in that case uses 9 credits.  A tran=
sfer on VN0 will only count a single credit even though it may use multiple=
 buffers.; Filter for Data Response (DRS).  DRS is generally used to transm=
it data with coherency.  For example, remote reads and writes, or cache to =
cache transfers will transmit their data using DRS.",
+        "UMask": "0x8",
         "Unit": "R3QPI"
     },
     {
-        "BriefDescription": "VN0 Credit Used; DRS Message Class",
-        "Counter": "0,1",
+        "BriefDescription": "VN0 Credit Used; HOM Message Class",
         "EventCode": "0x36",
-        "EventName": "UNC_R3_VN0_CREDITS_USED.DRS",
+        "EventName": "UNC_R3_VN0_CREDITS_USED.HOM",
         "PerPkg": "1",
-        "UMask": "0x8",
+        "PublicDescription": "Number of times a VN0 credit was used on the=
 DRS message channel.  In order for a request to be transferred across QPI,=
 it must be guaranteed to have a flit buffer on the remote socket to sink i=
nto.  There are two credit pools, VNA and VN0.  VNA is a shared pool used t=
o achieve high performance.  The VN0 pool has reserved entries for each mes=
sage class and is used to prevent deadlock.  Requests first attempt to acqu=
ire a VNA credit, and then fall back to VN0 if they fail.  This counts the =
number of times a VN0 credit was used.  Note that a single VN0 credit holds=
 access to potentially multiple flit buffers.  For example, a transfer that=
 uses VNA could use 9 flit buffers and in that case uses 9 credits.  A tran=
sfer on VN0 will only count a single credit even though it may use multiple=
 buffers.; Filter for the Home (HOM) message class.  HOM is generally used =
to send requests, request responses, and snoop responses.",
+        "UMask": "0x1",
         "Unit": "R3QPI"
     },
     {
         "BriefDescription": "VN0 Credit Used; NCB Message Class",
-        "Counter": "0,1",
         "EventCode": "0x36",
         "EventName": "UNC_R3_VN0_CREDITS_USED.NCB",
         "PerPkg": "1",
+        "PublicDescription": "Number of times a VN0 credit was used on the=
 DRS message channel.  In order for a request to be transferred across QPI,=
 it must be guaranteed to have a flit buffer on the remote socket to sink i=
nto.  There are two credit pools, VNA and VN0.  VNA is a shared pool used t=
o achieve high performance.  The VN0 pool has reserved entries for each mes=
sage class and is used to prevent deadlock.  Requests first attempt to acqu=
ire a VNA credit, and then fall back to VN0 if they fail.  This counts the =
number of times a VN0 credit was used.  Note that a single VN0 credit holds=
 access to potentially multiple flit buffers.  For example, a transfer that=
 uses VNA could use 9 flit buffers and in that case uses 9 credits.  A tran=
sfer on VN0 will only count a single credit even though it may use multiple=
 buffers.; Filter for Non-Coherent Broadcast (NCB).  NCB is generally used =
to transmit data without coherency.  For example, non-coherent read data re=
turns.",
         "UMask": "0x10",
         "Unit": "R3QPI"
     },
     {
         "BriefDescription": "VN0 Credit Used; NCS Message Class",
-        "Counter": "0,1",
         "EventCode": "0x36",
         "EventName": "UNC_R3_VN0_CREDITS_USED.NCS",
         "PerPkg": "1",
+        "PublicDescription": "Number of times a VN0 credit was used on the=
 DRS message channel.  In order for a request to be transferred across QPI,=
 it must be guaranteed to have a flit buffer on the remote socket to sink i=
nto.  There are two credit pools, VNA and VN0.  VNA is a shared pool used t=
o achieve high performance.  The VN0 pool has reserved entries for each mes=
sage class and is used to prevent deadlock.  Requests first attempt to acqu=
ire a VNA credit, and then fall back to VN0 if they fail.  This counts the =
number of times a VN0 credit was used.  Note that a single VN0 credit holds=
 access to potentially multiple flit buffers.  For example, a transfer that=
 uses VNA could use 9 flit buffers and in that case uses 9 credits.  A tran=
sfer on VN0 will only count a single credit even though it may use multiple=
 buffers.; Filter for Non-Coherent Standard (NCS).  NCS is commonly used fo=
r ?",
         "UMask": "0x20",
         "Unit": "R3QPI"
     },
     {
-        "BriefDescription": "VN1 Credit Acquisition Failed on DRS; HOM Mes=
sage Class",
-        "Counter": "0,1",
-        "EventCode": "0x39",
-        "EventName": "UNC_R3_VN1_CREDITS_REJECT.HOM",
+        "BriefDescription": "VN0 Credit Used; NDR Message Class",
+        "EventCode": "0x36",
+        "EventName": "UNC_R3_VN0_CREDITS_USED.NDR",
         "PerPkg": "1",
-        "UMask": "0x1",
+        "PublicDescription": "Number of times a VN0 credit was used on the=
 DRS message channel.  In order for a request to be transferred across QPI,=
 it must be guaranteed to have a flit buffer on the remote socket to sink i=
nto.  There are two credit pools, VNA and VN0.  VNA is a shared pool used t=
o achieve high performance.  The VN0 pool has reserved entries for each mes=
sage class and is used to prevent deadlock.  Requests first attempt to acqu=
ire a VNA credit, and then fall back to VN0 if they fail.  This counts the =
number of times a VN0 credit was used.  Note that a single VN0 credit holds=
 access to potentially multiple flit buffers.  For example, a transfer that=
 uses VNA could use 9 flit buffers and in that case uses 9 credits.  A tran=
sfer on VN0 will only count a single credit even though it may use multiple=
 buffers.; NDR packets are used to transmit a variety of protocol flits inc=
luding grants and completions (CMP).",
+        "UMask": "0x4",
         "Unit": "R3QPI"
     },
     {
-        "BriefDescription": "VN1 Credit Acquisition Failed on DRS; SNP Mes=
sage Class",
-        "Counter": "0,1",
-        "EventCode": "0x39",
-        "EventName": "UNC_R3_VN1_CREDITS_REJECT.SNP",
+        "BriefDescription": "VN0 Credit Used; SNP Message Class",
+        "EventCode": "0x36",
+        "EventName": "UNC_R3_VN0_CREDITS_USED.SNP",
         "PerPkg": "1",
+        "PublicDescription": "Number of times a VN0 credit was used on the=
 DRS message channel.  In order for a request to be transferred across QPI,=
 it must be guaranteed to have a flit buffer on the remote socket to sink i=
nto.  There are two credit pools, VNA and VN0.  VNA is a shared pool used t=
o achieve high performance.  The VN0 pool has reserved entries for each mes=
sage class and is used to prevent deadlock.  Requests first attempt to acqu=
ire a VNA credit, and then fall back to VN0 if they fail.  This counts the =
number of times a VN0 credit was used.  Note that a single VN0 credit holds=
 access to potentially multiple flit buffers.  For example, a transfer that=
 uses VNA could use 9 flit buffers and in that case uses 9 credits.  A tran=
sfer on VN0 will only count a single credit even though it may use multiple=
 buffers.; Filter for Snoop (SNP) message class.  SNP is used for outgoing =
snoops.  Note that snoop responses flow on the HOM message class.",
         "UMask": "0x2",
         "Unit": "R3QPI"
     },
     {
-        "BriefDescription": "VN1 Credit Acquisition Failed on DRS; NDR Mes=
sage Class",
-        "Counter": "0,1",
+        "BriefDescription": "VN1 Credit Acquisition Failed on DRS; DRS Mes=
sage Class",
         "EventCode": "0x39",
-        "EventName": "UNC_R3_VN1_CREDITS_REJECT.NDR",
+        "EventName": "UNC_R3_VN1_CREDITS_REJECT.DRS",
         "PerPkg": "1",
-        "UMask": "0x4",
+        "PublicDescription": "Number of times a request failed to acquire =
a VN1 credit.  In order for a request to be transferred across QPI, it must=
 be guaranteed to have a flit buffer on the remote socket to sink into.  Th=
ere are two credit pools, VNA and VN1.  VNA is a shared pool used to achiev=
e high performance.  The VN1 pool has reserved entries for each message cla=
ss and is used to prevent deadlock.  Requests first attempt to acquire a VN=
A credit, and then fall back to VN1 if they fail.  This therefore counts th=
e number of times when a request failed to acquire either a VNA or VN1 cred=
it and is delayed.  This should generally be a rare situation.; Filter for =
Data Response (DRS).  DRS is generally used to transmit data with coherency=
.  For example, remote reads and writes, or cache to cache transfers will t=
ransmit their data using DRS.",
+        "UMask": "0x8",
         "Unit": "R3QPI"
     },
     {
-        "BriefDescription": "VN1 Credit Acquisition Failed on DRS; DRS Mes=
sage Class",
-        "Counter": "0,1",
+        "BriefDescription": "VN1 Credit Acquisition Failed on DRS; HOM Mes=
sage Class",
         "EventCode": "0x39",
-        "EventName": "UNC_R3_VN1_CREDITS_REJECT.DRS",
+        "EventName": "UNC_R3_VN1_CREDITS_REJECT.HOM",
         "PerPkg": "1",
-        "UMask": "0x8",
+        "PublicDescription": "Number of times a request failed to acquire =
a VN1 credit.  In order for a request to be transferred across QPI, it must=
 be guaranteed to have a flit buffer on the remote socket to sink into.  Th=
ere are two credit pools, VNA and VN1.  VNA is a shared pool used to achiev=
e high performance.  The VN1 pool has reserved entries for each message cla=
ss and is used to prevent deadlock.  Requests first attempt to acquire a VN=
A credit, and then fall back to VN1 if they fail.  This therefore counts th=
e number of times when a request failed to acquire either a VNA or VN1 cred=
it and is delayed.  This should generally be a rare situation.; Filter for =
the Home (HOM) message class.  HOM is generally used to send requests, requ=
est responses, and snoop responses.",
+        "UMask": "0x1",
         "Unit": "R3QPI"
     },
     {
         "BriefDescription": "VN1 Credit Acquisition Failed on DRS; NCB Mes=
sage Class",
-        "Counter": "0,1",
         "EventCode": "0x39",
         "EventName": "UNC_R3_VN1_CREDITS_REJECT.NCB",
         "PerPkg": "1",
+        "PublicDescription": "Number of times a request failed to acquire =
a VN1 credit.  In order for a request to be transferred across QPI, it must=
 be guaranteed to have a flit buffer on the remote socket to sink into.  Th=
ere are two credit pools, VNA and VN1.  VNA is a shared pool used to achiev=
e high performance.  The VN1 pool has reserved entries for each message cla=
ss and is used to prevent deadlock.  Requests first attempt to acquire a VN=
A credit, and then fall back to VN1 if they fail.  This therefore counts th=
e number of times when a request failed to acquire either a VNA or VN1 cred=
it and is delayed.  This should generally be a rare situation.; Filter for =
Non-Coherent Broadcast (NCB).  NCB is generally used to transmit data witho=
ut coherency.  For example, non-coherent read data returns.",
         "UMask": "0x10",
         "Unit": "R3QPI"
     },
     {
         "BriefDescription": "VN1 Credit Acquisition Failed on DRS; NCS Mes=
sage Class",
-        "Counter": "0,1",
         "EventCode": "0x39",
         "EventName": "UNC_R3_VN1_CREDITS_REJECT.NCS",
         "PerPkg": "1",
+        "PublicDescription": "Number of times a request failed to acquire =
a VN1 credit.  In order for a request to be transferred across QPI, it must=
 be guaranteed to have a flit buffer on the remote socket to sink into.  Th=
ere are two credit pools, VNA and VN1.  VNA is a shared pool used to achiev=
e high performance.  The VN1 pool has reserved entries for each message cla=
ss and is used to prevent deadlock.  Requests first attempt to acquire a VN=
A credit, and then fall back to VN1 if they fail.  This therefore counts th=
e number of times when a request failed to acquire either a VNA or VN1 cred=
it and is delayed.  This should generally be a rare situation.; Filter for =
Non-Coherent Standard (NCS).  NCS is commonly used for ?",
         "UMask": "0x20",
         "Unit": "R3QPI"
     },
     {
-        "BriefDescription": "VN1 Credit Used; HOM Message Class",
-        "Counter": "0,1",
-        "EventCode": "0x38",
-        "EventName": "UNC_R3_VN1_CREDITS_USED.HOM",
+        "BriefDescription": "VN1 Credit Acquisition Failed on DRS; NDR Mes=
sage Class",
+        "EventCode": "0x39",
+        "EventName": "UNC_R3_VN1_CREDITS_REJECT.NDR",
         "PerPkg": "1",
-        "UMask": "0x1",
+        "PublicDescription": "Number of times a request failed to acquire =
a VN1 credit.  In order for a request to be transferred across QPI, it must=
 be guaranteed to have a flit buffer on the remote socket to sink into.  Th=
ere are two credit pools, VNA and VN1.  VNA is a shared pool used to achiev=
e high performance.  The VN1 pool has reserved entries for each message cla=
ss and is used to prevent deadlock.  Requests first attempt to acquire a VN=
A credit, and then fall back to VN1 if they fail.  This therefore counts th=
e number of times when a request failed to acquire either a VNA or VN1 cred=
it and is delayed.  This should generally be a rare situation.; NDR packets=
 are used to transmit a variety of protocol flits including grants and comp=
letions (CMP).",
+        "UMask": "0x4",
         "Unit": "R3QPI"
     },
     {
-        "BriefDescription": "VN1 Credit Used; SNP Message Class",
-        "Counter": "0,1",
-        "EventCode": "0x38",
-        "EventName": "UNC_R3_VN1_CREDITS_USED.SNP",
+        "BriefDescription": "VN1 Credit Acquisition Failed on DRS; SNP Mes=
sage Class",
+        "EventCode": "0x39",
+        "EventName": "UNC_R3_VN1_CREDITS_REJECT.SNP",
         "PerPkg": "1",
+        "PublicDescription": "Number of times a request failed to acquire =
a VN1 credit.  In order for a request to be transferred across QPI, it must=
 be guaranteed to have a flit buffer on the remote socket to sink into.  Th=
ere are two credit pools, VNA and VN1.  VNA is a shared pool used to achiev=
e high performance.  The VN1 pool has reserved entries for each message cla=
ss and is used to prevent deadlock.  Requests first attempt to acquire a VN=
A credit, and then fall back to VN1 if they fail.  This therefore counts th=
e number of times when a request failed to acquire either a VNA or VN1 cred=
it and is delayed.  This should generally be a rare situation.; Filter for =
Snoop (SNP) message class.  SNP is used for outgoing snoops.  Note that sno=
op responses flow on the HOM message class.",
         "UMask": "0x2",
         "Unit": "R3QPI"
     },
     {
-        "BriefDescription": "VN1 Credit Used; NDR Message Class",
-        "Counter": "0,1",
+        "BriefDescription": "VN1 Credit Used; DRS Message Class",
         "EventCode": "0x38",
-        "EventName": "UNC_R3_VN1_CREDITS_USED.NDR",
+        "EventName": "UNC_R3_VN1_CREDITS_USED.DRS",
         "PerPkg": "1",
-        "UMask": "0x4",
+        "PublicDescription": "Number of times a VN1 credit was used on the=
 DRS message channel.  In order for a request to be transferred across QPI,=
 it must be guaranteed to have a flit buffer on the remote socket to sink i=
nto.  There are two credit pools, VNA and VN1.  VNA is a shared pool used t=
o achieve high performance.  The VN1 pool has reserved entries for each mes=
sage class and is used to prevent deadlock.  Requests first attempt to acqu=
ire a VNA credit, and then fall back to VN1 if they fail.  This counts the =
number of times a VN1 credit was used.  Note that a single VN1 credit holds=
 access to potentially multiple flit buffers.  For example, a transfer that=
 uses VNA could use 9 flit buffers and in that case uses 9 credits.  A tran=
sfer on VN1 will only count a single credit even though it may use multiple=
 buffers.; Filter for Data Response (DRS).  DRS is generally used to transm=
it data with coherency.  For example, remote reads and writes, or cache to =
cache transfers will transmit their data using DRS.",
+        "UMask": "0x8",
         "Unit": "R3QPI"
     },
     {
-        "BriefDescription": "VN1 Credit Used; DRS Message Class",
-        "Counter": "0,1",
+        "BriefDescription": "VN1 Credit Used; HOM Message Class",
         "EventCode": "0x38",
-        "EventName": "UNC_R3_VN1_CREDITS_USED.DRS",
+        "EventName": "UNC_R3_VN1_CREDITS_USED.HOM",
         "PerPkg": "1",
-        "UMask": "0x8",
+        "PublicDescription": "Number of times a VN1 credit was used on the=
 DRS message channel.  In order for a request to be transferred across QPI,=
 it must be guaranteed to have a flit buffer on the remote socket to sink i=
nto.  There are two credit pools, VNA and VN1.  VNA is a shared pool used t=
o achieve high performance.  The VN1 pool has reserved entries for each mes=
sage class and is used to prevent deadlock.  Requests first attempt to acqu=
ire a VNA credit, and then fall back to VN1 if they fail.  This counts the =
number of times a VN1 credit was used.  Note that a single VN1 credit holds=
 access to potentially multiple flit buffers.  For example, a transfer that=
 uses VNA could use 9 flit buffers and in that case uses 9 credits.  A tran=
sfer on VN1 will only count a single credit even though it may use multiple=
 buffers.; Filter for the Home (HOM) message class.  HOM is generally used =
to send requests, request responses, and snoop responses.",
+        "UMask": "0x1",
         "Unit": "R3QPI"
     },
     {
         "BriefDescription": "VN1 Credit Used; NCB Message Class",
-        "Counter": "0,1",
         "EventCode": "0x38",
         "EventName": "UNC_R3_VN1_CREDITS_USED.NCB",
         "PerPkg": "1",
+        "PublicDescription": "Number of times a VN1 credit was used on the=
 DRS message channel.  In order for a request to be transferred across QPI,=
 it must be guaranteed to have a flit buffer on the remote socket to sink i=
nto.  There are two credit pools, VNA and VN1.  VNA is a shared pool used t=
o achieve high performance.  The VN1 pool has reserved entries for each mes=
sage class and is used to prevent deadlock.  Requests first attempt to acqu=
ire a VNA credit, and then fall back to VN1 if they fail.  This counts the =
number of times a VN1 credit was used.  Note that a single VN1 credit holds=
 access to potentially multiple flit buffers.  For example, a transfer that=
 uses VNA could use 9 flit buffers and in that case uses 9 credits.  A tran=
sfer on VN1 will only count a single credit even though it may use multiple=
 buffers.; Filter for Non-Coherent Broadcast (NCB).  NCB is generally used =
to transmit data without coherency.  For example, non-coherent read data re=
turns.",
         "UMask": "0x10",
         "Unit": "R3QPI"
     },
     {
         "BriefDescription": "VN1 Credit Used; NCS Message Class",
-        "Counter": "0,1",
         "EventCode": "0x38",
         "EventName": "UNC_R3_VN1_CREDITS_USED.NCS",
         "PerPkg": "1",
+        "PublicDescription": "Number of times a VN1 credit was used on the=
 DRS message channel.  In order for a request to be transferred across QPI,=
 it must be guaranteed to have a flit buffer on the remote socket to sink i=
nto.  There are two credit pools, VNA and VN1.  VNA is a shared pool used t=
o achieve high performance.  The VN1 pool has reserved entries for each mes=
sage class and is used to prevent deadlock.  Requests first attempt to acqu=
ire a VNA credit, and then fall back to VN1 if they fail.  This counts the =
number of times a VN1 credit was used.  Note that a single VN1 credit holds=
 access to potentially multiple flit buffers.  For example, a transfer that=
 uses VNA could use 9 flit buffers and in that case uses 9 credits.  A tran=
sfer on VN1 will only count a single credit even though it may use multiple=
 buffers.; Filter for Non-Coherent Standard (NCS).  NCS is commonly used fo=
r ?",
         "UMask": "0x20",
         "Unit": "R3QPI"
     },
+    {
+        "BriefDescription": "VN1 Credit Used; NDR Message Class",
+        "EventCode": "0x38",
+        "EventName": "UNC_R3_VN1_CREDITS_USED.NDR",
+        "PerPkg": "1",
+        "PublicDescription": "Number of times a VN1 credit was used on the=
 DRS message channel.  In order for a request to be transferred across QPI,=
 it must be guaranteed to have a flit buffer on the remote socket to sink i=
nto.  There are two credit pools, VNA and VN1.  VNA is a shared pool used t=
o achieve high performance.  The VN1 pool has reserved entries for each mes=
sage class and is used to prevent deadlock.  Requests first attempt to acqu=
ire a VNA credit, and then fall back to VN1 if they fail.  This counts the =
number of times a VN1 credit was used.  Note that a single VN1 credit holds=
 access to potentially multiple flit buffers.  For example, a transfer that=
 uses VNA could use 9 flit buffers and in that case uses 9 credits.  A tran=
sfer on VN1 will only count a single credit even though it may use multiple=
 buffers.; NDR packets are used to transmit a variety of protocol flits inc=
luding grants and completions (CMP).",
+        "UMask": "0x4",
+        "Unit": "R3QPI"
+    },
+    {
+        "BriefDescription": "VN1 Credit Used; SNP Message Class",
+        "EventCode": "0x38",
+        "EventName": "UNC_R3_VN1_CREDITS_USED.SNP",
+        "PerPkg": "1",
+        "PublicDescription": "Number of times a VN1 credit was used on the=
 DRS message channel.  In order for a request to be transferred across QPI,=
 it must be guaranteed to have a flit buffer on the remote socket to sink i=
nto.  There are two credit pools, VNA and VN1.  VNA is a shared pool used t=
o achieve high performance.  The VN1 pool has reserved entries for each mes=
sage class and is used to prevent deadlock.  Requests first attempt to acqu=
ire a VNA credit, and then fall back to VN1 if they fail.  This counts the =
number of times a VN1 credit was used.  Note that a single VN1 credit holds=
 access to potentially multiple flit buffers.  For example, a transfer that=
 uses VNA could use 9 flit buffers and in that case uses 9 credits.  A tran=
sfer on VN1 will only count a single credit even though it may use multiple=
 buffers.; Filter for Snoop (SNP) message class.  SNP is used for outgoing =
snoops.  Note that snoop responses flow on the HOM message class.",
+        "UMask": "0x2",
+        "Unit": "R3QPI"
+    },
     {
         "BriefDescription": "VNA credit Acquisitions; HOM Message Class",
-        "Counter": "0,1",
         "EventCode": "0x33",
         "EventName": "UNC_R3_VNA_CREDITS_ACQUIRED.AD",
         "PerPkg": "1",
+        "PublicDescription": "Number of QPI VNA Credit acquisitions.  This=
 event can be used in conjunction with the VNA In-Use Accumulator to calcul=
ate the average lifetime of a credit holder.  VNA credits are used by all m=
essage classes in order to communicate across QPI.  If a packet is unable t=
o acquire credits, it will then attempt to use credts from the VN0 pool.  N=
ote that a single packet may require multiple flit buffers (i.e. when data =
is being transferred).  Therefore, this event will increment by the number =
of credits acquired in each cycle.  Filtering based on message class is not=
 provided.  One can count the number of packets transferred in a given mess=
age class using an qfclk event.; Filter for the Home (HOM) message class.  =
HOM is generally used to send requests, request responses, and snoop respon=
ses.",
         "UMask": "0x1",
         "Unit": "R3QPI"
     },
     {
         "BriefDescription": "VNA credit Acquisitions; HOM Message Class",
-        "Counter": "0,1",
         "EventCode": "0x33",
         "EventName": "UNC_R3_VNA_CREDITS_ACQUIRED.BL",
         "PerPkg": "1",
+        "PublicDescription": "Number of QPI VNA Credit acquisitions.  This=
 event can be used in conjunction with the VNA In-Use Accumulator to calcul=
ate the average lifetime of a credit holder.  VNA credits are used by all m=
essage classes in order to communicate across QPI.  If a packet is unable t=
o acquire credits, it will then attempt to use credts from the VN0 pool.  N=
ote that a single packet may require multiple flit buffers (i.e. when data =
is being transferred).  Therefore, this event will increment by the number =
of credits acquired in each cycle.  Filtering based on message class is not=
 provided.  One can count the number of packets transferred in a given mess=
age class using an qfclk event.; Filter for the Home (HOM) message class.  =
HOM is generally used to send requests, request responses, and snoop respon=
ses.",
         "UMask": "0x4",
         "Unit": "R3QPI"
     },
     {
-        "BriefDescription": "VNA Credit Reject; HOM Message Class",
-        "Counter": "0,1",
+        "BriefDescription": "VNA Credit Reject; DRS Message Class",
         "EventCode": "0x34",
-        "EventName": "UNC_R3_VNA_CREDITS_REJECT.HOM",
+        "EventName": "UNC_R3_VNA_CREDITS_REJECT.DRS",
         "PerPkg": "1",
-        "UMask": "0x1",
+        "PublicDescription": "Number of attempted VNA credit acquisitions =
that were rejected because the VNA credit pool was full (or almost full).  =
It is possible to filter this event by message class.  Some packets use mor=
e than one flit buffer, and therefore must acquire multiple credits.  There=
fore, one could get a reject even if the VNA credits were not fully used up=
.  The VNA pool is generally used to provide the bulk of the QPI bandwidth =
(as opposed to the VN0 pool which is used to guarantee forward progress).  =
VNA credits can run out if the flit buffer on the receiving side starts to =
queue up substantially.  This can happen if the rest of the uncore is unabl=
e to drain the requests fast enough.; Filter for Data Response (DRS).  DRS =
is generally used to transmit data with coherency.  For example, remote rea=
ds and writes, or cache to cache transfers will transmit their data using D=
RS.",
+        "UMask": "0x8",
         "Unit": "R3QPI"
     },
     {
-        "BriefDescription": "VNA Credit Reject; SNP Message Class",
-        "Counter": "0,1",
+        "BriefDescription": "VNA Credit Reject; HOM Message Class",
         "EventCode": "0x34",
-        "EventName": "UNC_R3_VNA_CREDITS_REJECT.SNP",
+        "EventName": "UNC_R3_VNA_CREDITS_REJECT.HOM",
         "PerPkg": "1",
-        "UMask": "0x2",
+        "PublicDescription": "Number of attempted VNA credit acquisitions =
that were rejected because the VNA credit pool was full (or almost full).  =
It is possible to filter this event by message class.  Some packets use mor=
e than one flit buffer, and therefore must acquire multiple credits.  There=
fore, one could get a reject even if the VNA credits were not fully used up=
.  The VNA pool is generally used to provide the bulk of the QPI bandwidth =
(as opposed to the VN0 pool which is used to guarantee forward progress).  =
VNA credits can run out if the flit buffer on the receiving side starts to =
queue up substantially.  This can happen if the rest of the uncore is unabl=
e to drain the requests fast enough.; Filter for the Home (HOM) message cla=
ss.  HOM is generally used to send requests, request responses, and snoop r=
esponses.",
+        "UMask": "0x1",
         "Unit": "R3QPI"
     },
     {
-        "BriefDescription": "VNA Credit Reject; NDR Message Class",
-        "Counter": "0,1",
+        "BriefDescription": "VNA Credit Reject; NCB Message Class",
         "EventCode": "0x34",
-        "EventName": "UNC_R3_VNA_CREDITS_REJECT.NDR",
+        "EventName": "UNC_R3_VNA_CREDITS_REJECT.NCB",
         "PerPkg": "1",
-        "UMask": "0x4",
+        "PublicDescription": "Number of attempted VNA credit acquisitions =
that were rejected because the VNA credit pool was full (or almost full).  =
It is possible to filter this event by message class.  Some packets use mor=
e than one flit buffer, and therefore must acquire multiple credits.  There=
fore, one could get a reject even if the VNA credits were not fully used up=
.  The VNA pool is generally used to provide the bulk of the QPI bandwidth =
(as opposed to the VN0 pool which is used to guarantee forward progress).  =
VNA credits can run out if the flit buffer on the receiving side starts to =
queue up substantially.  This can happen if the rest of the uncore is unabl=
e to drain the requests fast enough.; Filter for Non-Coherent Broadcast (NC=
B).  NCB is generally used to transmit data without coherency.  For example=
, non-coherent read data returns.",
+        "UMask": "0x10",
         "Unit": "R3QPI"
     },
     {
-        "BriefDescription": "VNA Credit Reject; DRS Message Class",
-        "Counter": "0,1",
+        "BriefDescription": "VNA Credit Reject; NCS Message Class",
         "EventCode": "0x34",
-        "EventName": "UNC_R3_VNA_CREDITS_REJECT.DRS",
+        "EventName": "UNC_R3_VNA_CREDITS_REJECT.NCS",
         "PerPkg": "1",
-        "UMask": "0x8",
+        "PublicDescription": "Number of attempted VNA credit acquisitions =
that were rejected because the VNA credit pool was full (or almost full).  =
It is possible to filter this event by message class.  Some packets use mor=
e than one flit buffer, and therefore must acquire multiple credits.  There=
fore, one could get a reject even if the VNA credits were not fully used up=
.  The VNA pool is generally used to provide the bulk of the QPI bandwidth =
(as opposed to the VN0 pool which is used to guarantee forward progress).  =
VNA credits can run out if the flit buffer on the receiving side starts to =
queue up substantially.  This can happen if the rest of the uncore is unabl=
e to drain the requests fast enough.; Filter for Non-Coherent Standard (NCS=
).",
+        "UMask": "0x20",
         "Unit": "R3QPI"
     },
     {
-        "BriefDescription": "VNA Credit Reject; NCB Message Class",
-        "Counter": "0,1",
+        "BriefDescription": "VNA Credit Reject; NDR Message Class",
         "EventCode": "0x34",
-        "EventName": "UNC_R3_VNA_CREDITS_REJECT.NCB",
+        "EventName": "UNC_R3_VNA_CREDITS_REJECT.NDR",
         "PerPkg": "1",
-        "UMask": "0x10",
+        "PublicDescription": "Number of attempted VNA credit acquisitions =
that were rejected because the VNA credit pool was full (or almost full).  =
It is possible to filter this event by message class.  Some packets use mor=
e than one flit buffer, and therefore must acquire multiple credits.  There=
fore, one could get a reject even if the VNA credits were not fully used up=
.  The VNA pool is generally used to provide the bulk of the QPI bandwidth =
(as opposed to the VN0 pool which is used to guarantee forward progress).  =
VNA credits can run out if the flit buffer on the receiving side starts to =
queue up substantially.  This can happen if the rest of the uncore is unabl=
e to drain the requests fast enough.; NDR packets are used to transmit a va=
riety of protocol flits including grants and completions (CMP).",
+        "UMask": "0x4",
         "Unit": "R3QPI"
     },
     {
-        "BriefDescription": "VNA Credit Reject; NCS Message Class",
-        "Counter": "0,1",
+        "BriefDescription": "VNA Credit Reject; SNP Message Class",
         "EventCode": "0x34",
-        "EventName": "UNC_R3_VNA_CREDITS_REJECT.NCS",
+        "EventName": "UNC_R3_VNA_CREDITS_REJECT.SNP",
         "PerPkg": "1",
-        "UMask": "0x20",
+        "PublicDescription": "Number of attempted VNA credit acquisitions =
that were rejected because the VNA credit pool was full (or almost full).  =
It is possible to filter this event by message class.  Some packets use mor=
e than one flit buffer, and therefore must acquire multiple credits.  There=
fore, one could get a reject even if the VNA credits were not fully used up=
.  The VNA pool is generally used to provide the bulk of the QPI bandwidth =
(as opposed to the VN0 pool which is used to guarantee forward progress).  =
VNA credits can run out if the flit buffer on the receiving side starts to =
queue up substantially.  This can happen if the rest of the uncore is unabl=
e to drain the requests fast enough.; Filter for Snoop (SNP) message class.=
  SNP is used for outgoing snoops.  Note that snoop responses flow on the H=
OM message class.",
+        "UMask": "0x2",
         "Unit": "R3QPI"
     },
     {
         "BriefDescription": "Bounce Control",
-        "Counter": "0,1,2,3",
         "EventCode": "0xA",
         "EventName": "UNC_S_BOUNCE_CONTROL",
         "PerPkg": "1",
@@ -2329,184 +2332,182 @@
     },
     {
         "BriefDescription": "Uncore Clocks",
-        "Counter": "0,1,2,3",
         "EventName": "UNC_S_CLOCKTICKS",
         "PerPkg": "1",
         "Unit": "SBO"
     },
     {
         "BriefDescription": "FaST wire asserted",
-        "Counter": "0,1,2,3",
         "EventCode": "0x9",
         "EventName": "UNC_S_FAST_ASSERTED",
         "PerPkg": "1",
+        "PublicDescription": "Counts the number of cycles either the local=
 or incoming distress signals are asserted.  Incoming distress includes up,=
 dn and across.",
         "Unit": "SBO"
     },
     {
-        "BriefDescription": "AD Ring In Use; Up and Even",
-        "Counter": "0,1,2,3",
-        "EventCode": "0x1B",
-        "EventName": "UNC_S_RING_AD_USED.UP_EVEN",
-        "PerPkg": "1",
-        "UMask": "0x1",
-        "Unit": "SBO"
-    },
-    {
-        "BriefDescription": "AD Ring In Use; Up and Odd",
-        "Counter": "0,1,2,3",
+        "BriefDescription": "AD Ring In Use; Down",
         "EventCode": "0x1B",
-        "EventName": "UNC_S_RING_AD_USED.UP_ODD",
+        "EventName": "UNC_S_RING_AD_USED.DOWN",
         "PerPkg": "1",
-        "UMask": "0x2",
+        "PublicDescription": "Counts the number of cycles that the AD ring=
 is being used at this ring stop.  This includes when packets are passing b=
y and when packets are being sent, but does not include when packets are be=
ing sunk into the ring stop.  We really have two rings in HSX -- a clockwis=
e ring and a counter-clockwise ring.  On the left side of the ring, the UP =
direction is on the clockwise ring and DN is on the counter-clockwise ring.=
  On the right side of the ring, this is reversed.  The first half of the C=
Bos are on the left side of the ring, and the 2nd half are on the right sid=
e of the ring.  In other words (for example), in a 4c part, Cbo 0 UP AD is =
NOT the same ring as CBo 2 UP AD because they are on opposite sides of the =
ring.",
+        "UMask": "0xc",
         "Unit": "SBO"
     },
     {
         "BriefDescription": "AD Ring In Use; Down and Event",
-        "Counter": "0,1,2,3",
         "EventCode": "0x1B",
         "EventName": "UNC_S_RING_AD_USED.DOWN_EVEN",
         "PerPkg": "1",
+        "PublicDescription": "Counts the number of cycles that the AD ring=
 is being used at this ring stop.  This includes when packets are passing b=
y and when packets are being sent, but does not include when packets are be=
ing sunk into the ring stop.  We really have two rings in HSX -- a clockwis=
e ring and a counter-clockwise ring.  On the left side of the ring, the UP =
direction is on the clockwise ring and DN is on the counter-clockwise ring.=
  On the right side of the ring, this is reversed.  The first half of the C=
Bos are on the left side of the ring, and the 2nd half are on the right sid=
e of the ring.  In other words (for example), in a 4c part, Cbo 0 UP AD is =
NOT the same ring as CBo 2 UP AD because they are on opposite sides of the =
ring.; Filters for the Down and Event ring polarity.",
         "UMask": "0x4",
         "Unit": "SBO"
     },
     {
         "BriefDescription": "AD Ring In Use; Down and Odd",
-        "Counter": "0,1,2,3",
         "EventCode": "0x1B",
         "EventName": "UNC_S_RING_AD_USED.DOWN_ODD",
         "PerPkg": "1",
+        "PublicDescription": "Counts the number of cycles that the AD ring=
 is being used at this ring stop.  This includes when packets are passing b=
y and when packets are being sent, but does not include when packets are be=
ing sunk into the ring stop.  We really have two rings in HSX -- a clockwis=
e ring and a counter-clockwise ring.  On the left side of the ring, the UP =
direction is on the clockwise ring and DN is on the counter-clockwise ring.=
  On the right side of the ring, this is reversed.  The first half of the C=
Bos are on the left side of the ring, and the 2nd half are on the right sid=
e of the ring.  In other words (for example), in a 4c part, Cbo 0 UP AD is =
NOT the same ring as CBo 2 UP AD because they are on opposite sides of the =
ring.; Filters for the Down and Odd ring polarity.",
         "UMask": "0x8",
         "Unit": "SBO"
     },
     {
         "BriefDescription": "AD Ring In Use; Up",
-        "Counter": "0,1,2,3",
         "EventCode": "0x1B",
         "EventName": "UNC_S_RING_AD_USED.UP",
         "PerPkg": "1",
+        "PublicDescription": "Counts the number of cycles that the AD ring=
 is being used at this ring stop.  This includes when packets are passing b=
y and when packets are being sent, but does not include when packets are be=
ing sunk into the ring stop.  We really have two rings in HSX -- a clockwis=
e ring and a counter-clockwise ring.  On the left side of the ring, the UP =
direction is on the clockwise ring and DN is on the counter-clockwise ring.=
  On the right side of the ring, this is reversed.  The first half of the C=
Bos are on the left side of the ring, and the 2nd half are on the right sid=
e of the ring.  In other words (for example), in a 4c part, Cbo 0 UP AD is =
NOT the same ring as CBo 2 UP AD because they are on opposite sides of the =
ring.",
         "UMask": "0x3",
         "Unit": "SBO"
     },
     {
-        "BriefDescription": "AD Ring In Use; Down",
-        "Counter": "0,1,2,3",
+        "BriefDescription": "AD Ring In Use; Up and Even",
         "EventCode": "0x1B",
-        "EventName": "UNC_S_RING_AD_USED.DOWN",
+        "EventName": "UNC_S_RING_AD_USED.UP_EVEN",
         "PerPkg": "1",
-        "UMask": "0xC",
+        "PublicDescription": "Counts the number of cycles that the AD ring=
 is being used at this ring stop.  This includes when packets are passing b=
y and when packets are being sent, but does not include when packets are be=
ing sunk into the ring stop.  We really have two rings in HSX -- a clockwis=
e ring and a counter-clockwise ring.  On the left side of the ring, the UP =
direction is on the clockwise ring and DN is on the counter-clockwise ring.=
  On the right side of the ring, this is reversed.  The first half of the C=
Bos are on the left side of the ring, and the 2nd half are on the right sid=
e of the ring.  In other words (for example), in a 4c part, Cbo 0 UP AD is =
NOT the same ring as CBo 2 UP AD because they are on opposite sides of the =
ring.; Filters for the Up and Even ring polarity.",
+        "UMask": "0x1",
         "Unit": "SBO"
     },
     {
-        "BriefDescription": "AK Ring In Use; Up and Even",
-        "Counter": "0,1,2,3",
-        "EventCode": "0x1C",
-        "EventName": "UNC_S_RING_AK_USED.UP_EVEN",
+        "BriefDescription": "AD Ring In Use; Up and Odd",
+        "EventCode": "0x1B",
+        "EventName": "UNC_S_RING_AD_USED.UP_ODD",
         "PerPkg": "1",
-        "UMask": "0x1",
+        "PublicDescription": "Counts the number of cycles that the AD ring=
 is being used at this ring stop.  This includes when packets are passing b=
y and when packets are being sent, but does not include when packets are be=
ing sunk into the ring stop.  We really have two rings in HSX -- a clockwis=
e ring and a counter-clockwise ring.  On the left side of the ring, the UP =
direction is on the clockwise ring and DN is on the counter-clockwise ring.=
  On the right side of the ring, this is reversed.  The first half of the C=
Bos are on the left side of the ring, and the 2nd half are on the right sid=
e of the ring.  In other words (for example), in a 4c part, Cbo 0 UP AD is =
NOT the same ring as CBo 2 UP AD because they are on opposite sides of the =
ring.; Filters for the Up and Odd ring polarity.",
+        "UMask": "0x2",
         "Unit": "SBO"
     },
     {
-        "BriefDescription": "AK Ring In Use; Up and Odd",
-        "Counter": "0,1,2,3",
+        "BriefDescription": "AK Ring In Use; Down",
         "EventCode": "0x1C",
-        "EventName": "UNC_S_RING_AK_USED.UP_ODD",
+        "EventName": "UNC_S_RING_AK_USED.DOWN",
         "PerPkg": "1",
-        "UMask": "0x2",
+        "PublicDescription": "Counts the number of cycles that the AK ring=
 is being used at this ring stop.  This includes when packets are passing b=
y and when packets are being sent, but does not include when packets are be=
ing sunk into the ring stop. We really have two rings in HSX -- a clockwise=
 ring and a counter-clockwise ring.  On the left side of the ring, the UP d=
irection is on the clockwise ring and DN is on the counter-clockwise ring. =
 On the right side of the ring, this is reversed.  The first half of the CB=
os are on the left side of the ring, and the 2nd half are on the right side=
 of the ring.  In other words (for example), in a 4c part, Cbo 0 UP AD is N=
OT the same ring as CBo 2 UP AD because they are on opposite sides of the r=
ing.",
+        "UMask": "0xc",
         "Unit": "SBO"
     },
     {
         "BriefDescription": "AK Ring In Use; Down and Event",
-        "Counter": "0,1,2,3",
         "EventCode": "0x1C",
         "EventName": "UNC_S_RING_AK_USED.DOWN_EVEN",
         "PerPkg": "1",
+        "PublicDescription": "Counts the number of cycles that the AK ring=
 is being used at this ring stop.  This includes when packets are passing b=
y and when packets are being sent, but does not include when packets are be=
ing sunk into the ring stop. We really have two rings in HSX -- a clockwise=
 ring and a counter-clockwise ring.  On the left side of the ring, the UP d=
irection is on the clockwise ring and DN is on the counter-clockwise ring. =
 On the right side of the ring, this is reversed.  The first half of the CB=
os are on the left side of the ring, and the 2nd half are on the right side=
 of the ring.  In other words (for example), in a 4c part, Cbo 0 UP AD is N=
OT the same ring as CBo 2 UP AD because they are on opposite sides of the r=
ing.; Filters for the Down and Event ring polarity.",
         "UMask": "0x4",
         "Unit": "SBO"
     },
     {
         "BriefDescription": "AK Ring In Use; Down and Odd",
-        "Counter": "0,1,2,3",
         "EventCode": "0x1C",
         "EventName": "UNC_S_RING_AK_USED.DOWN_ODD",
         "PerPkg": "1",
+        "PublicDescription": "Counts the number of cycles that the AK ring=
 is being used at this ring stop.  This includes when packets are passing b=
y and when packets are being sent, but does not include when packets are be=
ing sunk into the ring stop. We really have two rings in HSX -- a clockwise=
 ring and a counter-clockwise ring.  On the left side of the ring, the UP d=
irection is on the clockwise ring and DN is on the counter-clockwise ring. =
 On the right side of the ring, this is reversed.  The first half of the CB=
os are on the left side of the ring, and the 2nd half are on the right side=
 of the ring.  In other words (for example), in a 4c part, Cbo 0 UP AD is N=
OT the same ring as CBo 2 UP AD because they are on opposite sides of the r=
ing.; Filters for the Down and Odd ring polarity.",
         "UMask": "0x8",
         "Unit": "SBO"
     },
     {
         "BriefDescription": "AK Ring In Use; Up",
-        "Counter": "0,1,2,3",
         "EventCode": "0x1C",
         "EventName": "UNC_S_RING_AK_USED.UP",
         "PerPkg": "1",
+        "PublicDescription": "Counts the number of cycles that the AK ring=
 is being used at this ring stop.  This includes when packets are passing b=
y and when packets are being sent, but does not include when packets are be=
ing sunk into the ring stop. We really have two rings in HSX -- a clockwise=
 ring and a counter-clockwise ring.  On the left side of the ring, the UP d=
irection is on the clockwise ring and DN is on the counter-clockwise ring. =
 On the right side of the ring, this is reversed.  The first half of the CB=
os are on the left side of the ring, and the 2nd half are on the right side=
 of the ring.  In other words (for example), in a 4c part, Cbo 0 UP AD is N=
OT the same ring as CBo 2 UP AD because they are on opposite sides of the r=
ing.",
         "UMask": "0x3",
         "Unit": "SBO"
     },
     {
-        "BriefDescription": "AK Ring In Use; Down",
-        "Counter": "0,1,2,3",
+        "BriefDescription": "AK Ring In Use; Up and Even",
         "EventCode": "0x1C",
-        "EventName": "UNC_S_RING_AK_USED.DOWN",
+        "EventName": "UNC_S_RING_AK_USED.UP_EVEN",
         "PerPkg": "1",
-        "UMask": "0xC",
+        "PublicDescription": "Counts the number of cycles that the AK ring=
 is being used at this ring stop.  This includes when packets are passing b=
y and when packets are being sent, but does not include when packets are be=
ing sunk into the ring stop. We really have two rings in HSX -- a clockwise=
 ring and a counter-clockwise ring.  On the left side of the ring, the UP d=
irection is on the clockwise ring and DN is on the counter-clockwise ring. =
 On the right side of the ring, this is reversed.  The first half of the CB=
os are on the left side of the ring, and the 2nd half are on the right side=
 of the ring.  In other words (for example), in a 4c part, Cbo 0 UP AD is N=
OT the same ring as CBo 2 UP AD because they are on opposite sides of the r=
ing.; Filters for the Up and Even ring polarity.",
+        "UMask": "0x1",
         "Unit": "SBO"
     },
     {
-        "BriefDescription": "BL Ring in Use; Up and Even",
-        "Counter": "0,1,2,3",
-        "EventCode": "0x1D",
-        "EventName": "UNC_S_RING_BL_USED.UP_EVEN",
+        "BriefDescription": "AK Ring In Use; Up and Odd",
+        "EventCode": "0x1C",
+        "EventName": "UNC_S_RING_AK_USED.UP_ODD",
         "PerPkg": "1",
-        "UMask": "0x1",
+        "PublicDescription": "Counts the number of cycles that the AK ring=
 is being used at this ring stop.  This includes when packets are passing b=
y and when packets are being sent, but does not include when packets are be=
ing sunk into the ring stop. We really have two rings in HSX -- a clockwise=
 ring and a counter-clockwise ring.  On the left side of the ring, the UP d=
irection is on the clockwise ring and DN is on the counter-clockwise ring. =
 On the right side of the ring, this is reversed.  The first half of the CB=
os are on the left side of the ring, and the 2nd half are on the right side=
 of the ring.  In other words (for example), in a 4c part, Cbo 0 UP AD is N=
OT the same ring as CBo 2 UP AD because they are on opposite sides of the r=
ing.; Filters for the Up and Odd ring polarity.",
+        "UMask": "0x2",
         "Unit": "SBO"
     },
     {
-        "BriefDescription": "BL Ring in Use; Up and Odd",
-        "Counter": "0,1,2,3",
+        "BriefDescription": "BL Ring in Use; Down",
         "EventCode": "0x1D",
-        "EventName": "UNC_S_RING_BL_USED.UP_ODD",
+        "EventName": "UNC_S_RING_BL_USED.DOWN",
         "PerPkg": "1",
-        "UMask": "0x2",
+        "PublicDescription": "Counts the number of cycles that the BL ring=
 is being used at this ring stop.  This includes when packets are passing b=
y and when packets are being sent, but does not include when packets are be=
ing sunk into the ring stop. We really have two rings in HSX -- a clockwise=
 ring and a counter-clockwise ring.  On the left side of the ring, the UP d=
irection is on the clockwise ring and DN is on the counter-clockwise ring. =
 On the right side of the ring, this is reversed.  The first half of the CB=
os are on the left side of the ring, and the 2nd half are on the right side=
 of the ring.  In other words (for example), in a 4c part, Cbo 0 UP AD is N=
OT the same ring as CBo 2 UP AD because they are on opposite sides of the r=
ing.",
+        "UMask": "0xc",
         "Unit": "SBO"
     },
     {
         "BriefDescription": "BL Ring in Use; Down and Event",
-        "Counter": "0,1,2,3",
         "EventCode": "0x1D",
         "EventName": "UNC_S_RING_BL_USED.DOWN_EVEN",
         "PerPkg": "1",
+        "PublicDescription": "Counts the number of cycles that the BL ring=
 is being used at this ring stop.  This includes when packets are passing b=
y and when packets are being sent, but does not include when packets are be=
ing sunk into the ring stop. We really have two rings in HSX -- a clockwise=
 ring and a counter-clockwise ring.  On the left side of the ring, the UP d=
irection is on the clockwise ring and DN is on the counter-clockwise ring. =
 On the right side of the ring, this is reversed.  The first half of the CB=
os are on the left side of the ring, and the 2nd half are on the right side=
 of the ring.  In other words (for example), in a 4c part, Cbo 0 UP AD is N=
OT the same ring as CBo 2 UP AD because they are on opposite sides of the r=
ing.; Filters for the Down and Event ring polarity.",
         "UMask": "0x4",
         "Unit": "SBO"
     },
     {
         "BriefDescription": "BL Ring in Use; Down and Odd",
-        "Counter": "0,1,2,3",
         "EventCode": "0x1D",
         "EventName": "UNC_S_RING_BL_USED.DOWN_ODD",
         "PerPkg": "1",
+        "PublicDescription": "Counts the number of cycles that the BL ring=
 is being used at this ring stop.  This includes when packets are passing b=
y and when packets are being sent, but does not include when packets are be=
ing sunk into the ring stop. We really have two rings in HSX -- a clockwise=
 ring and a counter-clockwise ring.  On the left side of the ring, the UP d=
irection is on the clockwise ring and DN is on the counter-clockwise ring. =
 On the right side of the ring, this is reversed.  The first half of the CB=
os are on the left side of the ring, and the 2nd half are on the right side=
 of the ring.  In other words (for example), in a 4c part, Cbo 0 UP AD is N=
OT the same ring as CBo 2 UP AD because they are on opposite sides of the r=
ing.; Filters for the Down and Odd ring polarity.",
         "UMask": "0x8",
         "Unit": "SBO"
     },
     {
         "BriefDescription": "BL Ring in Use; Up",
-        "Counter": "0,1,2,3",
         "EventCode": "0x1D",
-        "EventName": "UNC_S_RING_BL_USED.UP",
+        "EventName": "UNC_S_RING_BL_USED.UP",
+        "PerPkg": "1",
+        "PublicDescription": "Counts the number of cycles that the BL ring=
 is being used at this ring stop.  This includes when packets are passing b=
y and when packets are being sent, but does not include when packets are be=
ing sunk into the ring stop. We really have two rings in HSX -- a clockwise=
 ring and a counter-clockwise ring.  On the left side of the ring, the UP d=
irection is on the clockwise ring and DN is on the counter-clockwise ring. =
 On the right side of the ring, this is reversed.  The first half of the CB=
os are on the left side of the ring, and the 2nd half are on the right side=
 of the ring.  In other words (for example), in a 4c part, Cbo 0 UP AD is N=
OT the same ring as CBo 2 UP AD because they are on opposite sides of the r=
ing.",
+        "UMask": "0x3",
+        "Unit": "SBO"
+    },
+    {
+        "BriefDescription": "BL Ring in Use; Up and Even",
+        "EventCode": "0x1D",
+        "EventName": "UNC_S_RING_BL_USED.UP_EVEN",
         "PerPkg": "1",
-        "UMask": "0x3",
+        "PublicDescription": "Counts the number of cycles that the BL ring=
 is being used at this ring stop.  This includes when packets are passing b=
y and when packets are being sent, but does not include when packets are be=
ing sunk into the ring stop. We really have two rings in HSX -- a clockwise=
 ring and a counter-clockwise ring.  On the left side of the ring, the UP d=
irection is on the clockwise ring and DN is on the counter-clockwise ring. =
 On the right side of the ring, this is reversed.  The first half of the CB=
os are on the left side of the ring, and the 2nd half are on the right side=
 of the ring.  In other words (for example), in a 4c part, Cbo 0 UP AD is N=
OT the same ring as CBo 2 UP AD because they are on opposite sides of the r=
ing.; Filters for the Up and Even ring polarity.",
+        "UMask": "0x1",
         "Unit": "SBO"
     },
     {
-        "BriefDescription": "BL Ring in Use; Down",
-        "Counter": "0,1,2,3",
+        "BriefDescription": "BL Ring in Use; Up and Odd",
         "EventCode": "0x1D",
-        "EventName": "UNC_S_RING_BL_USED.DOWN",
+        "EventName": "UNC_S_RING_BL_USED.UP_ODD",
         "PerPkg": "1",
-        "UMask": "0xC",
+        "PublicDescription": "Counts the number of cycles that the BL ring=
 is being used at this ring stop.  This includes when packets are passing b=
y and when packets are being sent, but does not include when packets are be=
ing sunk into the ring stop. We really have two rings in HSX -- a clockwise=
 ring and a counter-clockwise ring.  On the left side of the ring, the UP d=
irection is on the clockwise ring and DN is on the counter-clockwise ring. =
 On the right side of the ring, this is reversed.  The first half of the CB=
os are on the left side of the ring, and the 2nd half are on the right side=
 of the ring.  In other words (for example), in a 4c part, Cbo 0 UP AD is N=
OT the same ring as CBo 2 UP AD because they are on opposite sides of the r=
ing.; Filters for the Up and Odd ring polarity.",
+        "UMask": "0x2",
         "Unit": "SBO"
     },
     {
-        "BriefDescription": "Number of LLC responses that bounced on the R=
ing",
-        "Counter": "0,1,2,3",
+        "BriefDescription": "Number of LLC responses that bounced on the R=
ing.",
         "EventCode": "0x5",
         "EventName": "UNC_S_RING_BOUNCES.AD_CACHE",
         "PerPkg": "1",
@@ -2515,7 +2516,6 @@
     },
     {
         "BriefDescription": "Number of LLC responses that bounced on the R=
ing.; Acknowledgements to core",
-        "Counter": "0,1,2,3",
         "EventCode": "0x5",
         "EventName": "UNC_S_RING_BOUNCES.AK_CORE",
         "PerPkg": "1",
@@ -2524,7 +2524,6 @@
     },
     {
         "BriefDescription": "Number of LLC responses that bounced on the R=
ing.; Data Responses to core",
-        "Counter": "0,1,2,3",
         "EventCode": "0x5",
         "EventName": "UNC_S_RING_BOUNCES.BL_CORE",
         "PerPkg": "1",
@@ -2532,8 +2531,7 @@
         "Unit": "SBO"
     },
     {
-        "BriefDescription": "Number of LLC responses that bounced on the R=
ing.; Snoops of processor's cache",
-        "Counter": "0,1,2,3",
+        "BriefDescription": "Number of LLC responses that bounced on the R=
ing.; Snoops of processor's cache.",
         "EventCode": "0x5",
         "EventName": "UNC_S_RING_BOUNCES.IV_CORE",
         "PerPkg": "1",
@@ -2542,25 +2540,24 @@
     },
     {
         "BriefDescription": "BL Ring in Use; Any",
-        "Counter": "0,1,2,3",
         "EventCode": "0x1E",
-        "EventName": "UNC_S_RING_IV_USED.UP",
+        "EventName": "UNC_S_RING_IV_USED.DN",
         "PerPkg": "1",
-        "UMask": "0x3",
+        "PublicDescription": "Counts the number of cycles that the BL ring=
 is being used at this ring stop.  This includes when packets are passing b=
y and when packets are being sent, but does not include when packets are be=
ing sunk into the ring stop.  There is only 1 IV ring in HSX.  Therefore, i=
f one wants to monitor the Even ring, they should select both UP_EVEN and D=
N_EVEN.  To monitor the Odd ring, they should select both UP_ODD and DN_ODD=
.; Filters any polarity",
+        "UMask": "0xc",
         "Unit": "SBO"
     },
     {
         "BriefDescription": "BL Ring in Use; Any",
-        "Counter": "0,1,2,3",
         "EventCode": "0x1E",
-        "EventName": "UNC_S_RING_IV_USED.DN",
+        "EventName": "UNC_S_RING_IV_USED.UP",
         "PerPkg": "1",
-        "UMask": "0xC",
+        "PublicDescription": "Counts the number of cycles that the BL ring=
 is being used at this ring stop.  This includes when packets are passing b=
y and when packets are being sent, but does not include when packets are be=
ing sunk into the ring stop.  There is only 1 IV ring in HSX.  Therefore, i=
f one wants to monitor the Even ring, they should select both UP_EVEN and D=
N_EVEN.  To monitor the Odd ring, they should select both UP_ODD and DN_ODD=
.; Filters any polarity",
+        "UMask": "0x3",
         "Unit": "SBO"
     },
     {
         "BriefDescription": "UNC_S_RING_SINK_STARVED.AD_CACHE",
-        "Counter": "0,1,2,3",
         "EventCode": "0x6",
         "EventName": "UNC_S_RING_SINK_STARVED.AD_CACHE",
         "PerPkg": "1",
@@ -2569,7 +2566,6 @@
     },
     {
         "BriefDescription": "UNC_S_RING_SINK_STARVED.AK_CORE",
-        "Counter": "0,1,2,3",
         "EventCode": "0x6",
         "EventName": "UNC_S_RING_SINK_STARVED.AK_CORE",
         "PerPkg": "1",
@@ -2578,7 +2574,6 @@
     },
     {
         "BriefDescription": "UNC_S_RING_SINK_STARVED.BL_CORE",
-        "Counter": "0,1,2,3",
         "EventCode": "0x6",
         "EventName": "UNC_S_RING_SINK_STARVED.BL_CORE",
         "PerPkg": "1",
@@ -2587,277 +2582,275 @@
     },
     {
         "BriefDescription": "UNC_S_RING_SINK_STARVED.IV_CORE",
-        "Counter": "0,1,2,3",
         "EventCode": "0x6",
         "EventName": "UNC_S_RING_SINK_STARVED.IV_CORE",
         "PerPkg": "1",
         "UMask": "0x8",
         "Unit": "SBO"
     },
-    {
-        "BriefDescription": "Injection Starvation; AD - Credits",
-        "Counter": "0,1,2,3",
-        "EventCode": "0x15",
-        "EventName": "UNC_S_RxR_BUSY_STARVED.AD_CRD",
-        "PerPkg": "1",
-        "UMask": "0x1",
-        "Unit": "SBO"
-    },
     {
         "BriefDescription": "Injection Starvation; AD - Bounces",
-        "Counter": "0,1,2,3",
         "EventCode": "0x15",
         "EventName": "UNC_S_RxR_BUSY_STARVED.AD_BNC",
         "PerPkg": "1",
+        "PublicDescription": "Counts injection starvation.  This starvatio=
n is triggered when the Ingress cannot send a transaction onto the ring for=
 a long period of time.  In this case, the Ingress but unable to forward to=
 Egress because a message (credited/bounceable) is  being sent.",
         "UMask": "0x2",
         "Unit": "SBO"
     },
     {
-        "BriefDescription": "Injection Starvation; BL - Credits",
-        "Counter": "0,1,2,3",
+        "BriefDescription": "Injection Starvation; AD - Credits",
         "EventCode": "0x15",
-        "EventName": "UNC_S_RxR_BUSY_STARVED.BL_CRD",
+        "EventName": "UNC_S_RxR_BUSY_STARVED.AD_CRD",
         "PerPkg": "1",
-        "UMask": "0x4",
+        "PublicDescription": "Counts injection starvation.  This starvatio=
n is triggered when the Ingress cannot send a transaction onto the ring for=
 a long period of time.  In this case, the Ingress but unable to forward to=
 Egress because a message (credited/bounceable) is  being sent.",
+        "UMask": "0x1",
         "Unit": "SBO"
     },
     {
         "BriefDescription": "Injection Starvation; BL - Bounces",
-        "Counter": "0,1,2,3",
         "EventCode": "0x15",
         "EventName": "UNC_S_RxR_BUSY_STARVED.BL_BNC",
         "PerPkg": "1",
+        "PublicDescription": "Counts injection starvation.  This starvatio=
n is triggered when the Ingress cannot send a transaction onto the ring for=
 a long period of time.  In this case, the Ingress but unable to forward to=
 Egress because a message (credited/bounceable) is  being sent.",
         "UMask": "0x8",
         "Unit": "SBO"
     },
     {
-        "BriefDescription": "Bypass; AD - Credits",
-        "Counter": "0,1,2,3",
-        "EventCode": "0x12",
-        "EventName": "UNC_S_RxR_BYPASS.AD_CRD",
+        "BriefDescription": "Injection Starvation; BL - Credits",
+        "EventCode": "0x15",
+        "EventName": "UNC_S_RxR_BUSY_STARVED.BL_CRD",
         "PerPkg": "1",
-        "UMask": "0x1",
+        "PublicDescription": "Counts injection starvation.  This starvatio=
n is triggered when the Ingress cannot send a transaction onto the ring for=
 a long period of time.  In this case, the Ingress but unable to forward to=
 Egress because a message (credited/bounceable) is  being sent.",
+        "UMask": "0x4",
         "Unit": "SBO"
     },
     {
         "BriefDescription": "Bypass; AD - Bounces",
-        "Counter": "0,1,2,3",
         "EventCode": "0x12",
         "EventName": "UNC_S_RxR_BYPASS.AD_BNC",
         "PerPkg": "1",
+        "PublicDescription": "Bypass the Sbo Ingress.",
         "UMask": "0x2",
         "Unit": "SBO"
     },
     {
-        "BriefDescription": "Bypass; BL - Credits",
-        "Counter": "0,1,2,3",
+        "BriefDescription": "Bypass; AD - Credits",
         "EventCode": "0x12",
-        "EventName": "UNC_S_RxR_BYPASS.BL_CRD",
+        "EventName": "UNC_S_RxR_BYPASS.AD_CRD",
         "PerPkg": "1",
-        "UMask": "0x4",
+        "PublicDescription": "Bypass the Sbo Ingress.",
+        "UMask": "0x1",
+        "Unit": "SBO"
+    },
+    {
+        "BriefDescription": "Bypass; AK",
+        "EventCode": "0x12",
+        "EventName": "UNC_S_RxR_BYPASS.AK",
+        "PerPkg": "1",
+        "PublicDescription": "Bypass the Sbo Ingress.",
+        "UMask": "0x10",
         "Unit": "SBO"
     },
     {
         "BriefDescription": "Bypass; BL - Bounces",
-        "Counter": "0,1,2,3",
         "EventCode": "0x12",
         "EventName": "UNC_S_RxR_BYPASS.BL_BNC",
         "PerPkg": "1",
+        "PublicDescription": "Bypass the Sbo Ingress.",
         "UMask": "0x8",
         "Unit": "SBO"
     },
     {
-        "BriefDescription": "Bypass; AK",
-        "Counter": "0,1,2,3",
+        "BriefDescription": "Bypass; BL - Credits",
         "EventCode": "0x12",
-        "EventName": "UNC_S_RxR_BYPASS.AK",
+        "EventName": "UNC_S_RxR_BYPASS.BL_CRD",
         "PerPkg": "1",
-        "UMask": "0x10",
+        "PublicDescription": "Bypass the Sbo Ingress.",
+        "UMask": "0x4",
         "Unit": "SBO"
     },
     {
         "BriefDescription": "Bypass; IV",
-        "Counter": "0,1,2,3",
         "EventCode": "0x12",
         "EventName": "UNC_S_RxR_BYPASS.IV",
         "PerPkg": "1",
+        "PublicDescription": "Bypass the Sbo Ingress.",
         "UMask": "0x20",
         "Unit": "SBO"
     },
-    {
-        "BriefDescription": "Injection Starvation; AD - Credits",
-        "Counter": "0,1,2,3",
-        "EventCode": "0x14",
-        "EventName": "UNC_S_RxR_CRD_STARVED.AD_CRD",
-        "PerPkg": "1",
-        "UMask": "0x1",
-        "Unit": "SBO"
-    },
     {
         "BriefDescription": "Injection Starvation; AD - Bounces",
-        "Counter": "0,1,2,3",
         "EventCode": "0x14",
         "EventName": "UNC_S_RxR_CRD_STARVED.AD_BNC",
         "PerPkg": "1",
+        "PublicDescription": "Counts injection starvation.  This starvatio=
n is triggered when the Ingress cannot send a transaction onto the ring for=
 a long period of time.  In this case, the Ingress but unable to forward to=
 Egress due to lack of credit.",
         "UMask": "0x2",
         "Unit": "SBO"
     },
     {
-        "BriefDescription": "Injection Starvation; BL - Credits",
-        "Counter": "0,1,2,3",
+        "BriefDescription": "Injection Starvation; AD - Credits",
         "EventCode": "0x14",
-        "EventName": "UNC_S_RxR_CRD_STARVED.BL_CRD",
+        "EventName": "UNC_S_RxR_CRD_STARVED.AD_CRD",
         "PerPkg": "1",
-        "UMask": "0x4",
+        "PublicDescription": "Counts injection starvation.  This starvatio=
n is triggered when the Ingress cannot send a transaction onto the ring for=
 a long period of time.  In this case, the Ingress but unable to forward to=
 Egress due to lack of credit.",
+        "UMask": "0x1",
         "Unit": "SBO"
     },
     {
-        "BriefDescription": "Injection Starvation; BL - Bounces",
-        "Counter": "0,1,2,3",
+        "BriefDescription": "Injection Starvation; AK",
         "EventCode": "0x14",
-        "EventName": "UNC_S_RxR_CRD_STARVED.BL_BNC",
+        "EventName": "UNC_S_RxR_CRD_STARVED.AK",
         "PerPkg": "1",
-        "UMask": "0x8",
+        "PublicDescription": "Counts injection starvation.  This starvatio=
n is triggered when the Ingress cannot send a transaction onto the ring for=
 a long period of time.  In this case, the Ingress but unable to forward to=
 Egress due to lack of credit.",
+        "UMask": "0x10",
         "Unit": "SBO"
     },
     {
-        "BriefDescription": "Injection Starvation; AK",
-        "Counter": "0,1,2,3",
+        "BriefDescription": "Injection Starvation; BL - Bounces",
         "EventCode": "0x14",
-        "EventName": "UNC_S_RxR_CRD_STARVED.AK",
+        "EventName": "UNC_S_RxR_CRD_STARVED.BL_BNC",
         "PerPkg": "1",
-        "UMask": "0x10",
+        "PublicDescription": "Counts injection starvation.  This starvatio=
n is triggered when the Ingress cannot send a transaction onto the ring for=
 a long period of time.  In this case, the Ingress but unable to forward to=
 Egress due to lack of credit.",
+        "UMask": "0x8",
         "Unit": "SBO"
     },
     {
-        "BriefDescription": "Injection Starvation; IV",
-        "Counter": "0,1,2,3",
+        "BriefDescription": "Injection Starvation; BL - Credits",
         "EventCode": "0x14",
-        "EventName": "UNC_S_RxR_CRD_STARVED.IV",
+        "EventName": "UNC_S_RxR_CRD_STARVED.BL_CRD",
         "PerPkg": "1",
-        "UMask": "0x20",
+        "PublicDescription": "Counts injection starvation.  This starvatio=
n is triggered when the Ingress cannot send a transaction onto the ring for=
 a long period of time.  In this case, the Ingress but unable to forward to=
 Egress due to lack of credit.",
+        "UMask": "0x4",
         "Unit": "SBO"
     },
     {
         "BriefDescription": "Injection Starvation; IVF Credit",
-        "Counter": "0,1,2,3",
         "EventCode": "0x14",
         "EventName": "UNC_S_RxR_CRD_STARVED.IFV",
         "PerPkg": "1",
+        "PublicDescription": "Counts injection starvation.  This starvatio=
n is triggered when the Ingress cannot send a transaction onto the ring for=
 a long period of time.  In this case, the Ingress but unable to forward to=
 Egress due to lack of credit.",
         "UMask": "0x40",
         "Unit": "SBO"
     },
     {
-        "BriefDescription": "Ingress Allocations; AD - Credits",
-        "Counter": "0,1,2,3",
-        "EventCode": "0x13",
-        "EventName": "UNC_S_RxR_INSERTS.AD_CRD",
+        "BriefDescription": "Injection Starvation; IV",
+        "EventCode": "0x14",
+        "EventName": "UNC_S_RxR_CRD_STARVED.IV",
         "PerPkg": "1",
-        "UMask": "0x1",
+        "PublicDescription": "Counts injection starvation.  This starvatio=
n is triggered when the Ingress cannot send a transaction onto the ring for=
 a long period of time.  In this case, the Ingress but unable to forward to=
 Egress due to lack of credit.",
+        "UMask": "0x20",
         "Unit": "SBO"
     },
     {
         "BriefDescription": "Ingress Allocations; AD - Bounces",
-        "Counter": "0,1,2,3",
         "EventCode": "0x13",
         "EventName": "UNC_S_RxR_INSERTS.AD_BNC",
         "PerPkg": "1",
+        "PublicDescription": "Number of allocations into the Sbo Ingress  =
The Ingress is used to queue up requests received from the ring.",
         "UMask": "0x2",
         "Unit": "SBO"
     },
     {
-        "BriefDescription": "Ingress Allocations; BL - Credits",
-        "Counter": "0,1,2,3",
+        "BriefDescription": "Ingress Allocations; AD - Credits",
         "EventCode": "0x13",
-        "EventName": "UNC_S_RxR_INSERTS.BL_CRD",
+        "EventName": "UNC_S_RxR_INSERTS.AD_CRD",
         "PerPkg": "1",
-        "UMask": "0x4",
+        "PublicDescription": "Number of allocations into the Sbo Ingress  =
The Ingress is used to queue up requests received from the ring.",
+        "UMask": "0x1",
+        "Unit": "SBO"
+    },
+    {
+        "BriefDescription": "Ingress Allocations; AK",
+        "EventCode": "0x13",
+        "EventName": "UNC_S_RxR_INSERTS.AK",
+        "PerPkg": "1",
+        "PublicDescription": "Number of allocations into the Sbo Ingress  =
The Ingress is used to queue up requests received from the ring.",
+        "UMask": "0x10",
         "Unit": "SBO"
     },
     {
         "BriefDescription": "Ingress Allocations; BL - Bounces",
-        "Counter": "0,1,2,3",
         "EventCode": "0x13",
         "EventName": "UNC_S_RxR_INSERTS.BL_BNC",
         "PerPkg": "1",
+        "PublicDescription": "Number of allocations into the Sbo Ingress  =
The Ingress is used to queue up requests received from the ring.",
         "UMask": "0x8",
         "Unit": "SBO"
     },
     {
-        "BriefDescription": "Ingress Allocations; AK",
-        "Counter": "0,1,2,3",
+        "BriefDescription": "Ingress Allocations; BL - Credits",
         "EventCode": "0x13",
-        "EventName": "UNC_S_RxR_INSERTS.AK",
+        "EventName": "UNC_S_RxR_INSERTS.BL_CRD",
         "PerPkg": "1",
-        "UMask": "0x10",
+        "PublicDescription": "Number of allocations into the Sbo Ingress  =
The Ingress is used to queue up requests received from the ring.",
+        "UMask": "0x4",
         "Unit": "SBO"
     },
     {
         "BriefDescription": "Ingress Allocations; IV",
-        "Counter": "0,1,2,3",
         "EventCode": "0x13",
         "EventName": "UNC_S_RxR_INSERTS.IV",
         "PerPkg": "1",
+        "PublicDescription": "Number of allocations into the Sbo Ingress  =
The Ingress is used to queue up requests received from the ring.",
         "UMask": "0x20",
         "Unit": "SBO"
     },
     {
-        "BriefDescription": "Ingress Occupancy; AD - Credits",
-        "Counter": "0,1,2,3",
+        "BriefDescription": "Ingress Occupancy; AD - Bounces",
         "EventCode": "0x11",
-        "EventName": "UNC_S_RxR_OCCUPANCY.AD_CRD",
+        "EventName": "UNC_S_RxR_OCCUPANCY.AD_BNC",
         "PerPkg": "1",
-        "UMask": "0x1",
+        "PublicDescription": "Occupancy event for the Ingress buffers in t=
he Sbo.  The Ingress is used to queue up requests received from the ring.",
+        "UMask": "0x2",
         "Unit": "SBO"
     },
     {
-        "BriefDescription": "Ingress Occupancy; AD - Bounces",
-        "Counter": "0,1,2,3",
+        "BriefDescription": "Ingress Occupancy; AD - Credits",
         "EventCode": "0x11",
-        "EventName": "UNC_S_RxR_OCCUPANCY.AD_BNC",
+        "EventName": "UNC_S_RxR_OCCUPANCY.AD_CRD",
         "PerPkg": "1",
-        "UMask": "0x2",
+        "PublicDescription": "Occupancy event for the Ingress buffers in t=
he Sbo.  The Ingress is used to queue up requests received from the ring.",
+        "UMask": "0x1",
         "Unit": "SBO"
     },
     {
-        "BriefDescription": "Ingress Occupancy; BL - Credits",
-        "Counter": "0,1,2,3",
+        "BriefDescription": "Ingress Occupancy; AK",
         "EventCode": "0x11",
-        "EventName": "UNC_S_RxR_OCCUPANCY.BL_CRD",
+        "EventName": "UNC_S_RxR_OCCUPANCY.AK",
         "PerPkg": "1",
-        "UMask": "0x4",
+        "PublicDescription": "Occupancy event for the Ingress buffers in t=
he Sbo.  The Ingress is used to queue up requests received from the ring.",
+        "UMask": "0x10",
         "Unit": "SBO"
     },
     {
         "BriefDescription": "Ingress Occupancy; BL - Bounces",
-        "Counter": "0,1,2,3",
         "EventCode": "0x11",
         "EventName": "UNC_S_RxR_OCCUPANCY.BL_BNC",
         "PerPkg": "1",
+        "PublicDescription": "Occupancy event for the Ingress buffers in t=
he Sbo.  The Ingress is used to queue up requests received from the ring.",
         "UMask": "0x8",
         "Unit": "SBO"
     },
     {
-        "BriefDescription": "Ingress Occupancy; AK",
-        "Counter": "0,1,2,3",
+        "BriefDescription": "Ingress Occupancy; BL - Credits",
         "EventCode": "0x11",
-        "EventName": "UNC_S_RxR_OCCUPANCY.AK",
+        "EventName": "UNC_S_RxR_OCCUPANCY.BL_CRD",
         "PerPkg": "1",
-        "UMask": "0x10",
+        "PublicDescription": "Occupancy event for the Ingress buffers in t=
he Sbo.  The Ingress is used to queue up requests received from the ring.",
+        "UMask": "0x4",
         "Unit": "SBO"
     },
     {
         "BriefDescription": "Ingress Occupancy; IV",
-        "Counter": "0,1,2,3",
         "EventCode": "0x11",
         "EventName": "UNC_S_RxR_OCCUPANCY.IV",
         "PerPkg": "1",
+        "PublicDescription": "Occupancy event for the Ingress buffers in t=
he Sbo.  The Ingress is used to queue up requests received from the ring.",
         "UMask": "0x20",
         "Unit": "SBO"
     },
     {
         "BriefDescription": "UNC_S_TxR_ADS_USED.AD",
-        "Counter": "0,1,2,3",
         "EventCode": "0x4",
         "EventName": "UNC_S_TxR_ADS_USED.AD",
         "PerPkg": "1",
@@ -2866,7 +2859,6 @@
     },
     {
         "BriefDescription": "UNC_S_TxR_ADS_USED.AK",
-        "Counter": "0,1,2,3",
         "EventCode": "0x4",
         "EventName": "UNC_S_TxR_ADS_USED.AK",
         "PerPkg": "1",
@@ -2875,7 +2867,6 @@
     },
     {
         "BriefDescription": "UNC_S_TxR_ADS_USED.BL",
-        "Counter": "0,1,2,3",
         "EventCode": "0x4",
         "EventName": "UNC_S_TxR_ADS_USED.BL",
         "PerPkg": "1",
@@ -2883,288 +2874,287 @@
         "Unit": "SBO"
     },
     {
-        "BriefDescription": "Egress Allocations; AD - Credits",
-        "Counter": "0,1,2,3",
+        "BriefDescription": "Egress Allocations; AD - Bounces",
         "EventCode": "0x2",
-        "EventName": "UNC_S_TxR_INSERTS.AD_CRD",
+        "EventName": "UNC_S_TxR_INSERTS.AD_BNC",
         "PerPkg": "1",
-        "UMask": "0x1",
+        "PublicDescription": "Number of allocations into the Sbo Egress.  =
The Egress is used to queue up requests destined for the ring.",
+        "UMask": "0x2",
         "Unit": "SBO"
     },
     {
-        "BriefDescription": "Egress Allocations; AD - Bounces",
-        "Counter": "0,1,2,3",
+        "BriefDescription": "Egress Allocations; AD - Credits",
         "EventCode": "0x2",
-        "EventName": "UNC_S_TxR_INSERTS.AD_BNC",
+        "EventName": "UNC_S_TxR_INSERTS.AD_CRD",
         "PerPkg": "1",
-        "UMask": "0x2",
+        "PublicDescription": "Number of allocations into the Sbo Egress.  =
The Egress is used to queue up requests destined for the ring.",
+        "UMask": "0x1",
         "Unit": "SBO"
     },
     {
-        "BriefDescription": "Egress Allocations; BL - Credits",
-        "Counter": "0,1,2,3",
+        "BriefDescription": "Egress Allocations; AK",
         "EventCode": "0x2",
-        "EventName": "UNC_S_TxR_INSERTS.BL_CRD",
+        "EventName": "UNC_S_TxR_INSERTS.AK",
         "PerPkg": "1",
-        "UMask": "0x4",
+        "PublicDescription": "Number of allocations into the Sbo Egress.  =
The Egress is used to queue up requests destined for the ring.",
+        "UMask": "0x10",
         "Unit": "SBO"
     },
     {
         "BriefDescription": "Egress Allocations; BL - Bounces",
-        "Counter": "0,1,2,3",
         "EventCode": "0x2",
         "EventName": "UNC_S_TxR_INSERTS.BL_BNC",
         "PerPkg": "1",
+        "PublicDescription": "Number of allocations into the Sbo Egress.  =
The Egress is used to queue up requests destined for the ring.",
         "UMask": "0x8",
         "Unit": "SBO"
     },
     {
-        "BriefDescription": "Egress Allocations; AK",
-        "Counter": "0,1,2,3",
+        "BriefDescription": "Egress Allocations; BL - Credits",
         "EventCode": "0x2",
-        "EventName": "UNC_S_TxR_INSERTS.AK",
+        "EventName": "UNC_S_TxR_INSERTS.BL_CRD",
         "PerPkg": "1",
-        "UMask": "0x10",
+        "PublicDescription": "Number of allocations into the Sbo Egress.  =
The Egress is used to queue up requests destined for the ring.",
+        "UMask": "0x4",
         "Unit": "SBO"
     },
     {
         "BriefDescription": "Egress Allocations; IV",
-        "Counter": "0,1,2,3",
         "EventCode": "0x2",
         "EventName": "UNC_S_TxR_INSERTS.IV",
         "PerPkg": "1",
+        "PublicDescription": "Number of allocations into the Sbo Egress.  =
The Egress is used to queue up requests destined for the ring.",
         "UMask": "0x20",
         "Unit": "SBO"
     },
     {
-        "BriefDescription": "Egress Occupancy; AD - Credits",
-        "Counter": "0,1,2,3",
+        "BriefDescription": "Egress Occupancy; AD - Bounces",
         "EventCode": "0x1",
-        "EventName": "UNC_S_TxR_OCCUPANCY.AD_CRD",
+        "EventName": "UNC_S_TxR_OCCUPANCY.AD_BNC",
         "PerPkg": "1",
-        "UMask": "0x1",
+        "PublicDescription": "Occupancy event for the Egress buffers in th=
e Sbo.  The egress is used to queue up requests destined for the ring.",
+        "UMask": "0x2",
         "Unit": "SBO"
     },
     {
-        "BriefDescription": "Egress Occupancy; AD - Bounces",
-        "Counter": "0,1,2,3",
+        "BriefDescription": "Egress Occupancy; AD - Credits",
         "EventCode": "0x1",
-        "EventName": "UNC_S_TxR_OCCUPANCY.AD_BNC",
+        "EventName": "UNC_S_TxR_OCCUPANCY.AD_CRD",
         "PerPkg": "1",
-        "UMask": "0x2",
+        "PublicDescription": "Occupancy event for the Egress buffers in th=
e Sbo.  The egress is used to queue up requests destined for the ring.",
+        "UMask": "0x1",
         "Unit": "SBO"
     },
     {
-        "BriefDescription": "Egress Occupancy; BL - Credits",
-        "Counter": "0,1,2,3",
+        "BriefDescription": "Egress Occupancy; AK",
         "EventCode": "0x1",
-        "EventName": "UNC_S_TxR_OCCUPANCY.BL_CRD",
+        "EventName": "UNC_S_TxR_OCCUPANCY.AK",
         "PerPkg": "1",
-        "UMask": "0x4",
+        "PublicDescription": "Occupancy event for the Egress buffers in th=
e Sbo.  The egress is used to queue up requests destined for the ring.",
+        "UMask": "0x10",
         "Unit": "SBO"
     },
     {
         "BriefDescription": "Egress Occupancy; BL - Bounces",
-        "Counter": "0,1,2,3",
         "EventCode": "0x1",
         "EventName": "UNC_S_TxR_OCCUPANCY.BL_BNC",
         "PerPkg": "1",
+        "PublicDescription": "Occupancy event for the Egress buffers in th=
e Sbo.  The egress is used to queue up requests destined for the ring.",
         "UMask": "0x8",
         "Unit": "SBO"
     },
     {
-        "BriefDescription": "Egress Occupancy; AK",
-        "Counter": "0,1,2,3",
+        "BriefDescription": "Egress Occupancy; BL - Credits",
         "EventCode": "0x1",
-        "EventName": "UNC_S_TxR_OCCUPANCY.AK",
+        "EventName": "UNC_S_TxR_OCCUPANCY.BL_CRD",
         "PerPkg": "1",
-        "UMask": "0x10",
+        "PublicDescription": "Occupancy event for the Egress buffers in th=
e Sbo.  The egress is used to queue up requests destined for the ring.",
+        "UMask": "0x4",
         "Unit": "SBO"
     },
     {
         "BriefDescription": "Egress Occupancy; IV",
-        "Counter": "0,1,2,3",
         "EventCode": "0x1",
         "EventName": "UNC_S_TxR_OCCUPANCY.IV",
         "PerPkg": "1",
+        "PublicDescription": "Occupancy event for the Egress buffers in th=
e Sbo.  The egress is used to queue up requests destined for the ring.",
         "UMask": "0x20",
         "Unit": "SBO"
     },
     {
         "BriefDescription": "Injection Starvation; Onto AD Ring",
-        "Counter": "0,1,2,3",
         "EventCode": "0x3",
         "EventName": "UNC_S_TxR_STARVED.AD",
         "PerPkg": "1",
+        "PublicDescription": "Counts injection starvation.  This starvatio=
n is triggered when the Egress cannot send a transaction onto the ring for =
a long period of time.",
         "UMask": "0x1",
         "Unit": "SBO"
     },
     {
         "BriefDescription": "Injection Starvation; Onto AK Ring",
-        "Counter": "0,1,2,3",
         "EventCode": "0x3",
         "EventName": "UNC_S_TxR_STARVED.AK",
         "PerPkg": "1",
+        "PublicDescription": "Counts injection starvation.  This starvatio=
n is triggered when the Egress cannot send a transaction onto the ring for =
a long period of time.",
         "UMask": "0x2",
         "Unit": "SBO"
     },
     {
         "BriefDescription": "Injection Starvation; Onto BL Ring",
-        "Counter": "0,1,2,3",
         "EventCode": "0x3",
         "EventName": "UNC_S_TxR_STARVED.BL",
         "PerPkg": "1",
+        "PublicDescription": "Counts injection starvation.  This starvatio=
n is triggered when the Egress cannot send a transaction onto the ring for =
a long period of time.",
         "UMask": "0x4",
         "Unit": "SBO"
     },
     {
         "BriefDescription": "Injection Starvation; Onto IV Ring",
-        "Counter": "0,1,2,3",
         "EventCode": "0x3",
         "EventName": "UNC_S_TxR_STARVED.IV",
         "PerPkg": "1",
+        "PublicDescription": "Counts injection starvation.  This starvatio=
n is triggered when the Egress cannot send a transaction onto the ring for =
a long period of time.",
         "UMask": "0x8",
         "Unit": "SBO"
     },
+    {
+        "BriefDescription": "UNC_U_CLOCKTICKS",
+        "EventName": "UNC_U_CLOCKTICKS",
+        "PerPkg": "1",
+        "Unit": "UBOX"
+    },
     {
         "BriefDescription": "VLW Received",
-        "Counter": "0,1",
         "EventCode": "0x42",
         "EventName": "UNC_U_EVENT_MSG.DOORBELL_RCVD",
         "PerPkg": "1",
+        "PublicDescription": "Virtual Logical Wire (legacy) message were r=
eceived from Uncore.   Specify the thread to filter on using NCUPMONCTRLGLC=
TR.ThreadID.",
         "UMask": "0x8",
         "Unit": "UBOX"
     },
     {
         "BriefDescription": "Filter Match",
-        "Counter": "0,1",
         "EventCode": "0x41",
-        "EventName": "UNC_U_FILTER_MATCH.ENABLE",
+        "EventName": "UNC_U_FILTER_MATCH.DISABLE",
         "PerPkg": "1",
-        "UMask": "0x1",
+        "PublicDescription": "Filter match per thread (w/ or w/o Filter En=
able).  Specify the thread to filter on using NCUPMONCTRLGLCTR.ThreadID.",
+        "UMask": "0x2",
         "Unit": "UBOX"
     },
     {
         "BriefDescription": "Filter Match",
-        "Counter": "0,1",
         "EventCode": "0x41",
-        "EventName": "UNC_U_FILTER_MATCH.DISABLE",
+        "EventName": "UNC_U_FILTER_MATCH.ENABLE",
         "PerPkg": "1",
-        "UMask": "0x2",
+        "PublicDescription": "Filter match per thread (w/ or w/o Filter En=
able).  Specify the thread to filter on using NCUPMONCTRLGLCTR.ThreadID.",
+        "UMask": "0x1",
         "Unit": "UBOX"
     },
     {
         "BriefDescription": "Filter Match",
-        "Counter": "0,1",
         "EventCode": "0x41",
-        "EventName": "UNC_U_FILTER_MATCH.U2C_ENABLE",
+        "EventName": "UNC_U_FILTER_MATCH.U2C_DISABLE",
         "PerPkg": "1",
-        "UMask": "0x4",
+        "PublicDescription": "Filter match per thread (w/ or w/o Filter En=
able).  Specify the thread to filter on using NCUPMONCTRLGLCTR.ThreadID.",
+        "UMask": "0x8",
         "Unit": "UBOX"
     },
     {
         "BriefDescription": "Filter Match",
-        "Counter": "0,1",
         "EventCode": "0x41",
-        "EventName": "UNC_U_FILTER_MATCH.U2C_DISABLE",
+        "EventName": "UNC_U_FILTER_MATCH.U2C_ENABLE",
         "PerPkg": "1",
-        "UMask": "0x8",
+        "PublicDescription": "Filter match per thread (w/ or w/o Filter En=
able).  Specify the thread to filter on using NCUPMONCTRLGLCTR.ThreadID.",
+        "UMask": "0x4",
         "Unit": "UBOX"
     },
     {
         "BriefDescription": "Cycles PHOLD Assert to Ack; Assert to ACK",
-        "Counter": "0,1",
         "EventCode": "0x45",
         "EventName": "UNC_U_PHOLD_CYCLES.ASSERT_TO_ACK",
         "PerPkg": "1",
+        "PublicDescription": "PHOLD cycles.  Filter from source CoreID.",
         "UMask": "0x1",
         "Unit": "UBOX"
     },
     {
         "BriefDescription": "RACU Request",
-        "Counter": "0,1",
         "EventCode": "0x46",
         "EventName": "UNC_U_RACU_REQUESTS",
         "PerPkg": "1",
+        "PublicDescription": "Number outstanding register requests within =
message channel tracker",
         "Unit": "UBOX"
     },
     {
-        "BriefDescription": "Monitor Sent to T0; Monitor T0",
-        "Counter": "0,1",
-        "EventCode": "0x43",
-        "EventName": "UNC_U_U2C_EVENTS.MONITOR_T0",
-        "PerPkg": "1",
-        "UMask": "0x1",
-        "Unit": "UBOX"
-    },
-    {
-        "BriefDescription": "Monitor Sent to T0; Monitor T1",
-        "Counter": "0,1",
+        "BriefDescription": "Monitor Sent to T0; Correctable Machine Check=
",
         "EventCode": "0x43",
-        "EventName": "UNC_U_U2C_EVENTS.MONITOR_T1",
+        "EventName": "UNC_U_U2C_EVENTS.CMC",
         "PerPkg": "1",
-        "UMask": "0x2",
+        "PublicDescription": "Events coming from Uncore can be sent to one=
 or all cores",
+        "UMask": "0x10",
         "Unit": "UBOX"
     },
     {
         "BriefDescription": "Monitor Sent to T0; Livelock",
-        "Counter": "0,1",
         "EventCode": "0x43",
         "EventName": "UNC_U_U2C_EVENTS.LIVELOCK",
         "PerPkg": "1",
+        "PublicDescription": "Events coming from Uncore can be sent to one=
 or all cores; Filter by core",
         "UMask": "0x4",
         "Unit": "UBOX"
     },
     {
         "BriefDescription": "Monitor Sent to T0; LTError",
-        "Counter": "0,1",
         "EventCode": "0x43",
         "EventName": "UNC_U_U2C_EVENTS.LTERROR",
         "PerPkg": "1",
+        "PublicDescription": "Events coming from Uncore can be sent to one=
 or all cores; Filter by core",
         "UMask": "0x8",
         "Unit": "UBOX"
     },
     {
-        "BriefDescription": "Monitor Sent to T0; Correctable Machine Check=
",
-        "Counter": "0,1",
+        "BriefDescription": "Monitor Sent to T0; Monitor T0",
         "EventCode": "0x43",
-        "EventName": "UNC_U_U2C_EVENTS.CMC",
+        "EventName": "UNC_U_U2C_EVENTS.MONITOR_T0",
         "PerPkg": "1",
-        "UMask": "0x10",
+        "PublicDescription": "Events coming from Uncore can be sent to one=
 or all cores; Filter by core",
+        "UMask": "0x1",
         "Unit": "UBOX"
     },
     {
-        "BriefDescription": "Monitor Sent to T0; Uncorrectable Machine Che=
ck",
-        "Counter": "0,1",
+        "BriefDescription": "Monitor Sent to T0; Monitor T1",
         "EventCode": "0x43",
-        "EventName": "UNC_U_U2C_EVENTS.UMC",
+        "EventName": "UNC_U_U2C_EVENTS.MONITOR_T1",
         "PerPkg": "1",
-        "UMask": "0x20",
+        "PublicDescription": "Events coming from Uncore can be sent to one=
 or all cores; Filter by core",
+        "UMask": "0x2",
         "Unit": "UBOX"
     },
     {
-        "BriefDescription": "Monitor Sent to T0; Trap",
-        "Counter": "0,1",
+        "BriefDescription": "Monitor Sent to T0; Other",
         "EventCode": "0x43",
-        "EventName": "UNC_U_U2C_EVENTS.TRAP",
+        "EventName": "UNC_U_U2C_EVENTS.OTHER",
         "PerPkg": "1",
-        "UMask": "0x40",
+        "PublicDescription": "Events coming from Uncore can be sent to one=
 or all cores; PREQ, PSMI, P2U, Thermal, PCUSMI, PMI",
+        "UMask": "0x80",
         "Unit": "UBOX"
     },
     {
-        "BriefDescription": "Monitor Sent to T0; Other",
-        "Counter": "0,1",
+        "BriefDescription": "Monitor Sent to T0; Trap",
         "EventCode": "0x43",
-        "EventName": "UNC_U_U2C_EVENTS.OTHER",
+        "EventName": "UNC_U_U2C_EVENTS.TRAP",
         "PerPkg": "1",
-        "UMask": "0x80",
+        "PublicDescription": "Events coming from Uncore can be sent to one=
 or all cores",
+        "UMask": "0x40",
         "Unit": "UBOX"
     },
     {
-        "BriefDescription": "UNC_U_CLOCKTICKS",
-        "Counter": "0,1",
-        "EventName": "UNC_U_CLOCKTICKS",
+        "BriefDescription": "Monitor Sent to T0; Uncorrectable Machine Che=
ck",
+        "EventCode": "0x43",
+        "EventName": "UNC_U_U2C_EVENTS.UMC",
         "PerPkg": "1",
+        "PublicDescription": "Events coming from Uncore can be sent to one=
 or all cores",
+        "UMask": "0x20",
         "Unit": "UBOX"
     }
 ]
diff --git a/tools/perf/pmu-events/arch/x86/haswellx/uncore-power.json b/to=
ols/perf/pmu-events/arch/x86/haswellx/uncore-power.json
index 86b7c22af96b..daebf1050acb 100644
--- a/tools/perf/pmu-events/arch/x86/haswellx/uncore-power.json
+++ b/tools/perf/pmu-events/arch/x86/haswellx/uncore-power.json
@@ -1,497 +1,497 @@
 [
     {
         "BriefDescription": "pclk Cycles",
-        "Counter": "0,1,2,3",
         "EventName": "UNC_P_CLOCKTICKS",
         "PerPkg": "1",
+        "PublicDescription": "The PCU runs off a fixed 800 MHz clock.  Thi=
s event counts the number of pclk cycles measured while the counter was ena=
bled.  The pclk, like the Memory Controller's dclk, counts at a constant ra=
te making it a good measure of actual wall time.",
         "Unit": "PCU"
     },
     {
         "BriefDescription": "Core C State Transition Cycles",
-        "Counter": "0,1,2,3",
         "EventCode": "0x60",
         "EventName": "UNC_P_CORE0_TRANSITION_CYCLES",
         "PerPkg": "1",
+        "PublicDescription": "Number of cycles spent performing core C sta=
te transitions.  There is one event per core.",
         "Unit": "PCU"
     },
     {
         "BriefDescription": "Core C State Transition Cycles",
-        "Counter": "0,1,2,3",
         "EventCode": "0x6A",
         "EventName": "UNC_P_CORE10_TRANSITION_CYCLES",
         "PerPkg": "1",
+        "PublicDescription": "Number of cycles spent performing core C sta=
te transitions.  There is one event per core.",
         "Unit": "PCU"
     },
     {
         "BriefDescription": "Core C State Transition Cycles",
-        "Counter": "0,1,2,3",
         "EventCode": "0x6B",
         "EventName": "UNC_P_CORE11_TRANSITION_CYCLES",
         "PerPkg": "1",
+        "PublicDescription": "Number of cycles spent performing core C sta=
te transitions.  There is one event per core.",
         "Unit": "PCU"
     },
     {
         "BriefDescription": "Core C State Transition Cycles",
-        "Counter": "0,1,2,3",
         "EventCode": "0x6C",
         "EventName": "UNC_P_CORE12_TRANSITION_CYCLES",
         "PerPkg": "1",
+        "PublicDescription": "Number of cycles spent performing core C sta=
te transitions.  There is one event per core.",
         "Unit": "PCU"
     },
     {
         "BriefDescription": "Core C State Transition Cycles",
-        "Counter": "0,1,2,3",
         "EventCode": "0x6D",
         "EventName": "UNC_P_CORE13_TRANSITION_CYCLES",
         "PerPkg": "1",
+        "PublicDescription": "Number of cycles spent performing core C sta=
te transitions.  There is one event per core.",
         "Unit": "PCU"
     },
     {
         "BriefDescription": "Core C State Transition Cycles",
-        "Counter": "0,1,2,3",
         "EventCode": "0x6E",
         "EventName": "UNC_P_CORE14_TRANSITION_CYCLES",
         "PerPkg": "1",
+        "PublicDescription": "Number of cycles spent performing core C sta=
te transitions.  There is one event per core.",
         "Unit": "PCU"
     },
     {
         "BriefDescription": "Core C State Transition Cycles",
-        "Counter": "0,1,2,3",
         "EventCode": "0x6F",
         "EventName": "UNC_P_CORE15_TRANSITION_CYCLES",
         "PerPkg": "1",
+        "PublicDescription": "Number of cycles spent performing core C sta=
te transitions.  There is one event per core.",
         "Unit": "PCU"
     },
     {
         "BriefDescription": "Core C State Transition Cycles",
-        "Counter": "0,1,2,3",
         "EventCode": "0x70",
         "EventName": "UNC_P_CORE16_TRANSITION_CYCLES",
         "PerPkg": "1",
+        "PublicDescription": "Number of cycles spent performing core C sta=
te transitions.  There is one event per core.",
         "Unit": "PCU"
     },
     {
         "BriefDescription": "Core C State Transition Cycles",
-        "Counter": "0,1,2,3",
         "EventCode": "0x71",
         "EventName": "UNC_P_CORE17_TRANSITION_CYCLES",
         "PerPkg": "1",
+        "PublicDescription": "Number of cycles spent performing core C sta=
te transitions.  There is one event per core.",
         "Unit": "PCU"
     },
     {
         "BriefDescription": "Core C State Transition Cycles",
-        "Counter": "0,1,2,3",
         "EventCode": "0x61",
         "EventName": "UNC_P_CORE1_TRANSITION_CYCLES",
         "PerPkg": "1",
+        "PublicDescription": "Number of cycles spent performing core C sta=
te transitions.  There is one event per core.",
         "Unit": "PCU"
     },
     {
         "BriefDescription": "Core C State Transition Cycles",
-        "Counter": "0,1,2,3",
         "EventCode": "0x62",
         "EventName": "UNC_P_CORE2_TRANSITION_CYCLES",
         "PerPkg": "1",
+        "PublicDescription": "Number of cycles spent performing core C sta=
te transitions.  There is one event per core.",
         "Unit": "PCU"
     },
     {
         "BriefDescription": "Core C State Transition Cycles",
-        "Counter": "0,1,2,3",
         "EventCode": "0x63",
         "EventName": "UNC_P_CORE3_TRANSITION_CYCLES",
         "PerPkg": "1",
+        "PublicDescription": "Number of cycles spent performing core C sta=
te transitions.  There is one event per core.",
         "Unit": "PCU"
     },
     {
         "BriefDescription": "Core C State Transition Cycles",
-        "Counter": "0,1,2,3",
         "EventCode": "0x64",
         "EventName": "UNC_P_CORE4_TRANSITION_CYCLES",
         "PerPkg": "1",
+        "PublicDescription": "Number of cycles spent performing core C sta=
te transitions.  There is one event per core.",
         "Unit": "PCU"
     },
     {
         "BriefDescription": "Core C State Transition Cycles",
-        "Counter": "0,1,2,3",
         "EventCode": "0x65",
         "EventName": "UNC_P_CORE5_TRANSITION_CYCLES",
         "PerPkg": "1",
+        "PublicDescription": "Number of cycles spent performing core C sta=
te transitions.  There is one event per core.",
         "Unit": "PCU"
     },
     {
         "BriefDescription": "Core C State Transition Cycles",
-        "Counter": "0,1,2,3",
         "EventCode": "0x66",
         "EventName": "UNC_P_CORE6_TRANSITION_CYCLES",
         "PerPkg": "1",
+        "PublicDescription": "Number of cycles spent performing core C sta=
te transitions.  There is one event per core.",
         "Unit": "PCU"
     },
     {
         "BriefDescription": "Core C State Transition Cycles",
-        "Counter": "0,1,2,3",
         "EventCode": "0x67",
         "EventName": "UNC_P_CORE7_TRANSITION_CYCLES",
         "PerPkg": "1",
+        "PublicDescription": "Number of cycles spent performing core C sta=
te transitions.  There is one event per core.",
         "Unit": "PCU"
     },
     {
         "BriefDescription": "Core C State Transition Cycles",
-        "Counter": "0,1,2,3",
         "EventCode": "0x68",
         "EventName": "UNC_P_CORE8_TRANSITION_CYCLES",
         "PerPkg": "1",
+        "PublicDescription": "Number of cycles spent performing core C sta=
te transitions.  There is one event per core.",
         "Unit": "PCU"
     },
     {
         "BriefDescription": "Core C State Transition Cycles",
-        "Counter": "0,1,2,3",
         "EventCode": "0x69",
         "EventName": "UNC_P_CORE9_TRANSITION_CYCLES",
         "PerPkg": "1",
+        "PublicDescription": "Number of cycles spent performing core C sta=
te transitions.  There is one event per core.",
         "Unit": "PCU"
     },
     {
         "BriefDescription": "Core C State Demotions",
-        "Counter": "0,1,2,3",
         "EventCode": "0x30",
         "EventName": "UNC_P_DEMOTIONS_CORE0",
         "PerPkg": "1",
+        "PublicDescription": "Counts the number of times when a configurab=
le cores had a C-state demotion",
         "Unit": "PCU"
     },
     {
         "BriefDescription": "Core C State Demotions",
-        "Counter": "0,1,2,3",
         "EventCode": "0x31",
         "EventName": "UNC_P_DEMOTIONS_CORE1",
         "PerPkg": "1",
+        "PublicDescription": "Counts the number of times when a configurab=
le cores had a C-state demotion",
         "Unit": "PCU"
     },
     {
         "BriefDescription": "Core C State Demotions",
-        "Counter": "0,1,2,3",
         "EventCode": "0x3A",
         "EventName": "UNC_P_DEMOTIONS_CORE10",
         "PerPkg": "1",
+        "PublicDescription": "Counts the number of times when a configurab=
le cores had a C-state demotion",
         "Unit": "PCU"
     },
     {
         "BriefDescription": "Core C State Demotions",
-        "Counter": "0,1,2,3",
         "EventCode": "0x3B",
         "EventName": "UNC_P_DEMOTIONS_CORE11",
         "PerPkg": "1",
+        "PublicDescription": "Counts the number of times when a configurab=
le cores had a C-state demotion",
         "Unit": "PCU"
     },
     {
         "BriefDescription": "Core C State Demotions",
-        "Counter": "0,1,2,3",
         "EventCode": "0x3C",
         "EventName": "UNC_P_DEMOTIONS_CORE12",
         "PerPkg": "1",
+        "PublicDescription": "Counts the number of times when a configurab=
le cores had a C-state demotion",
         "Unit": "PCU"
     },
     {
         "BriefDescription": "Core C State Demotions",
-        "Counter": "0,1,2,3",
         "EventCode": "0x3D",
         "EventName": "UNC_P_DEMOTIONS_CORE13",
         "PerPkg": "1",
+        "PublicDescription": "Counts the number of times when a configurab=
le cores had a C-state demotion",
         "Unit": "PCU"
     },
     {
         "BriefDescription": "Core C State Demotions",
-        "Counter": "0,1,2,3",
         "EventCode": "0x3E",
         "EventName": "UNC_P_DEMOTIONS_CORE14",
         "PerPkg": "1",
+        "PublicDescription": "Counts the number of times when a configurab=
le cores had a C-state demotion",
         "Unit": "PCU"
     },
     {
         "BriefDescription": "Core C State Demotions",
-        "Counter": "0,1,2,3",
         "EventCode": "0x3F",
         "EventName": "UNC_P_DEMOTIONS_CORE15",
         "PerPkg": "1",
+        "PublicDescription": "Counts the number of times when a configurab=
le cores had a C-state demotion",
         "Unit": "PCU"
     },
     {
         "BriefDescription": "Core C State Demotions",
-        "Counter": "0,1,2,3",
         "EventCode": "0x40",
         "EventName": "UNC_P_DEMOTIONS_CORE16",
         "PerPkg": "1",
+        "PublicDescription": "Counts the number of times when a configurab=
le cores had a C-state demotion",
         "Unit": "PCU"
     },
     {
         "BriefDescription": "Core C State Demotions",
-        "Counter": "0,1,2,3",
         "EventCode": "0x41",
         "EventName": "UNC_P_DEMOTIONS_CORE17",
         "PerPkg": "1",
+        "PublicDescription": "Counts the number of times when a configurab=
le cores had a C-state demotion",
         "Unit": "PCU"
     },
     {
         "BriefDescription": "Core C State Demotions",
-        "Counter": "0,1,2,3",
         "EventCode": "0x32",
         "EventName": "UNC_P_DEMOTIONS_CORE2",
         "PerPkg": "1",
+        "PublicDescription": "Counts the number of times when a configurab=
le cores had a C-state demotion",
         "Unit": "PCU"
     },
     {
         "BriefDescription": "Core C State Demotions",
-        "Counter": "0,1,2,3",
         "EventCode": "0x33",
         "EventName": "UNC_P_DEMOTIONS_CORE3",
         "PerPkg": "1",
+        "PublicDescription": "Counts the number of times when a configurab=
le cores had a C-state demotion",
         "Unit": "PCU"
     },
     {
         "BriefDescription": "Core C State Demotions",
-        "Counter": "0,1,2,3",
         "EventCode": "0x34",
         "EventName": "UNC_P_DEMOTIONS_CORE4",
         "PerPkg": "1",
+        "PublicDescription": "Counts the number of times when a configurab=
le cores had a C-state demotion",
         "Unit": "PCU"
     },
     {
         "BriefDescription": "Core C State Demotions",
-        "Counter": "0,1,2,3",
         "EventCode": "0x35",
         "EventName": "UNC_P_DEMOTIONS_CORE5",
         "PerPkg": "1",
+        "PublicDescription": "Counts the number of times when a configurab=
le cores had a C-state demotion",
         "Unit": "PCU"
     },
     {
         "BriefDescription": "Core C State Demotions",
-        "Counter": "0,1,2,3",
         "EventCode": "0x36",
         "EventName": "UNC_P_DEMOTIONS_CORE6",
         "PerPkg": "1",
+        "PublicDescription": "Counts the number of times when a configurab=
le cores had a C-state demotion",
         "Unit": "PCU"
     },
     {
         "BriefDescription": "Core C State Demotions",
-        "Counter": "0,1,2,3",
         "EventCode": "0x37",
         "EventName": "UNC_P_DEMOTIONS_CORE7",
         "PerPkg": "1",
+        "PublicDescription": "Counts the number of times when a configurab=
le cores had a C-state demotion",
         "Unit": "PCU"
     },
     {
         "BriefDescription": "Core C State Demotions",
-        "Counter": "0,1,2,3",
         "EventCode": "0x38",
         "EventName": "UNC_P_DEMOTIONS_CORE8",
         "PerPkg": "1",
+        "PublicDescription": "Counts the number of times when a configurab=
le cores had a C-state demotion",
         "Unit": "PCU"
     },
     {
         "BriefDescription": "Core C State Demotions",
-        "Counter": "0,1,2,3",
         "EventCode": "0x39",
         "EventName": "UNC_P_DEMOTIONS_CORE9",
         "PerPkg": "1",
+        "PublicDescription": "Counts the number of times when a configurab=
le cores had a C-state demotion",
         "Unit": "PCU"
     },
     {
         "BriefDescription": "Frequency Residency",
-        "Counter": "0,1,2,3",
         "EventCode": "0xB",
         "EventName": "UNC_P_FREQ_BAND0_CYCLES",
         "PerPkg": "1",
+        "PublicDescription": "Counts the number of cycles that the uncore =
was running at a frequency greater than or equal to the frequency that is c=
onfigured in the filter.  One can use all four counters with this event, so=
 it is possible to track up to 4 configurable bands.  One can use edge dete=
ct in conjunction with this event to track the number of times that we tran=
sitioned into a frequency greater than or equal to the configurable frequen=
cy. One can also use inversion to track cycles when we were less than the c=
onfigured frequency.",
         "Unit": "PCU"
     },
     {
         "BriefDescription": "Frequency Residency",
-        "Counter": "0,1,2,3",
         "EventCode": "0xC",
         "EventName": "UNC_P_FREQ_BAND1_CYCLES",
         "PerPkg": "1",
+        "PublicDescription": "Counts the number of cycles that the uncore =
was running at a frequency greater than or equal to the frequency that is c=
onfigured in the filter.  One can use all four counters with this event, so=
 it is possible to track up to 4 configurable bands.  One can use edge dete=
ct in conjunction with this event to track the number of times that we tran=
sitioned into a frequency greater than or equal to the configurable frequen=
cy. One can also use inversion to track cycles when we were less than the c=
onfigured frequency.",
         "Unit": "PCU"
     },
     {
         "BriefDescription": "Frequency Residency",
-        "Counter": "0,1,2,3",
         "EventCode": "0xD",
         "EventName": "UNC_P_FREQ_BAND2_CYCLES",
         "PerPkg": "1",
+        "PublicDescription": "Counts the number of cycles that the uncore =
was running at a frequency greater than or equal to the frequency that is c=
onfigured in the filter.  One can use all four counters with this event, so=
 it is possible to track up to 4 configurable bands.  One can use edge dete=
ct in conjunction with this event to track the number of times that we tran=
sitioned into a frequency greater than or equal to the configurable frequen=
cy. One can also use inversion to track cycles when we were less than the c=
onfigured frequency.",
         "Unit": "PCU"
     },
     {
         "BriefDescription": "Frequency Residency",
-        "Counter": "0,1,2,3",
         "EventCode": "0xE",
         "EventName": "UNC_P_FREQ_BAND3_CYCLES",
         "PerPkg": "1",
+        "PublicDescription": "Counts the number of cycles that the uncore =
was running at a frequency greater than or equal to the frequency that is c=
onfigured in the filter.  One can use all four counters with this event, so=
 it is possible to track up to 4 configurable bands.  One can use edge dete=
ct in conjunction with this event to track the number of times that we tran=
sitioned into a frequency greater than or equal to the configurable frequen=
cy. One can also use inversion to track cycles when we were less than the c=
onfigured frequency.",
         "Unit": "PCU"
     },
     {
         "BriefDescription": "Thermal Strongest Upper Limit Cycles",
-        "Counter": "0,1,2,3",
         "EventCode": "0x4",
         "EventName": "UNC_P_FREQ_MAX_LIMIT_THERMAL_CYCLES",
         "PerPkg": "1",
+        "PublicDescription": "Counts the number of cycles when thermal con=
ditions are the upper limit on frequency.  This is related to the THERMAL_T=
HROTTLE CYCLES_ABOVE_TEMP event, which always counts cycles when we are abo=
ve the thermal temperature.  This event (STRONGEST_UPPER_LIMIT) is sampled =
at the output of the algorithm that determines the actual frequency, while =
THERMAL_THROTTLE looks at the input.",
         "Unit": "PCU"
     },
     {
         "BriefDescription": "OS Strongest Upper Limit Cycles",
-        "Counter": "0,1,2,3",
         "EventCode": "0x6",
         "EventName": "UNC_P_FREQ_MAX_OS_CYCLES",
         "PerPkg": "1",
+        "PublicDescription": "Counts the number of cycles when the OS is t=
he upper limit on frequency.",
         "Unit": "PCU"
     },
     {
         "BriefDescription": "Power Strongest Upper Limit Cycles",
-        "Counter": "0,1,2,3",
         "EventCode": "0x5",
         "EventName": "UNC_P_FREQ_MAX_POWER_CYCLES",
         "PerPkg": "1",
+        "PublicDescription": "Counts the number of cycles when power is th=
e upper limit on frequency.",
         "Unit": "PCU"
     },
     {
         "BriefDescription": "IO P Limit Strongest Lower Limit Cycles",
-        "Counter": "0,1,2,3",
         "EventCode": "0x73",
         "EventName": "UNC_P_FREQ_MIN_IO_P_CYCLES",
         "PerPkg": "1",
+        "PublicDescription": "Counts the number of cycles when IO P Limit =
is preventing us from dropping the frequency lower.  This algorithm monitor=
s the needs to the IO subsystem on both local and remote sockets and will m=
aintain a frequency high enough to maintain good IO BW.  This is necessary =
for when all the IA cores on a socket are idle but a user still would like =
to maintain high IO Bandwidth.",
         "Unit": "PCU"
     },
     {
         "BriefDescription": "Cycles spent changing Frequency",
-        "Counter": "0,1,2,3",
         "EventCode": "0x74",
         "EventName": "UNC_P_FREQ_TRANS_CYCLES",
         "PerPkg": "1",
+        "PublicDescription": "Counts the number of cycles when the system =
is changing frequency.  This can not be filtered by thread ID.  One can als=
o use it with the occupancy counter that monitors number of threads in C0 t=
o estimate the performance impact that frequency transitions had on the sys=
tem.",
         "Unit": "PCU"
     },
     {
         "BriefDescription": "Memory Phase Shedding Cycles",
-        "Counter": "0,1,2,3",
         "EventCode": "0x2F",
         "EventName": "UNC_P_MEMORY_PHASE_SHEDDING_CYCLES",
         "PerPkg": "1",
+        "PublicDescription": "Counts the number of cycles that the PCU has=
 triggered memory phase shedding.  This is a mode that can be run in the iM=
C physicals that saves power at the expense of additional latency.",
         "Unit": "PCU"
     },
     {
         "BriefDescription": "Package C State Residency - C0",
-        "Counter": "0,1,2,3",
         "EventCode": "0x2A",
         "EventName": "UNC_P_PKG_RESIDENCY_C0_CYCLES",
         "PerPkg": "1",
+        "PublicDescription": "Counts the number of cycles when the package=
 was in C0.  This event can be used in conjunction with edge detect to coun=
t C0 entrances (or exits using invert).  Residency events do not include tr=
ansition times.",
+        "Unit": "PCU"
+    },
+    {
+        "BriefDescription": "Package C State Residency - C1E",
+        "EventCode": "0x4E",
+        "EventName": "UNC_P_PKG_RESIDENCY_C1E_CYCLES",
+        "PerPkg": "1",
+        "PublicDescription": "Counts the number of cycles when the package=
 was in C1E.  This event can be used in conjunction with edge detect to cou=
nt C1E entrances (or exits using invert).  Residency events do not include =
transition times.",
         "Unit": "PCU"
     },
     {
         "BriefDescription": "Package C State Residency - C2E",
-        "Counter": "0,1,2,3",
         "EventCode": "0x2B",
         "EventName": "UNC_P_PKG_RESIDENCY_C2E_CYCLES",
         "PerPkg": "1",
+        "PublicDescription": "Counts the number of cycles when the package=
 was in C2E.  This event can be used in conjunction with edge detect to cou=
nt C2E entrances (or exits using invert).  Residency events do not include =
transition times.",
         "Unit": "PCU"
     },
     {
         "BriefDescription": "Package C State Residency - C3",
-        "Counter": "0,1,2,3",
         "EventCode": "0x2C",
         "EventName": "UNC_P_PKG_RESIDENCY_C3_CYCLES",
         "PerPkg": "1",
+        "PublicDescription": "Counts the number of cycles when the package=
 was in C3.  This event can be used in conjunction with edge detect to coun=
t C3 entrances (or exits using invert).  Residency events do not include tr=
ansition times.",
         "Unit": "PCU"
     },
     {
         "BriefDescription": "Package C State Residency - C6",
-        "Counter": "0,1,2,3",
         "EventCode": "0x2D",
         "EventName": "UNC_P_PKG_RESIDENCY_C6_CYCLES",
         "PerPkg": "1",
+        "PublicDescription": "Counts the number of cycles when the package=
 was in C6.  This event can be used in conjunction with edge detect to coun=
t C6 entrances (or exits using invert).  Residency events do not include tr=
ansition times.",
         "Unit": "PCU"
     },
     {
         "BriefDescription": "Package C7 State Residency",
-        "Counter": "0,1,2,3",
         "EventCode": "0x2E",
         "EventName": "UNC_P_PKG_RESIDENCY_C7_CYCLES",
         "PerPkg": "1",
+        "PublicDescription": "Counts the number of cycles when the package=
 was in C7.  This event can be used in conjunction with edge detect to coun=
t C7 entrances (or exits using invert).  Residency events do not include tr=
ansition times.",
         "Unit": "PCU"
     },
     {
         "BriefDescription": "Number of cores in C-State; C0 and C1",
-        "Counter": "0,1,2,3",
         "EventCode": "0x80",
         "EventName": "UNC_P_POWER_STATE_OCCUPANCY.CORES_C0",
         "PerPkg": "1",
+        "PublicDescription": "This is an occupancy event that tracks the n=
umber of cores that are in the chosen C-State.  It can be used by itself to=
 get the average number of cores in that C-state with thresholding to gener=
ate histograms, or with other PCU events and occupancy triggering to captur=
e other details.",
         "Unit": "PCU"
     },
     {
         "BriefDescription": "Number of cores in C-State; C3",
-        "Counter": "0,1,2,3",
         "EventCode": "0x80",
         "EventName": "UNC_P_POWER_STATE_OCCUPANCY.CORES_C3",
         "PerPkg": "1",
+        "PublicDescription": "This is an occupancy event that tracks the n=
umber of cores that are in the chosen C-State.  It can be used by itself to=
 get the average number of cores in that C-state with thresholding to gener=
ate histograms, or with other PCU events and occupancy triggering to captur=
e other details.",
         "Unit": "PCU"
     },
     {
         "BriefDescription": "Number of cores in C-State; C6 and C7",
-        "Counter": "0,1,2,3",
         "EventCode": "0x80",
         "EventName": "UNC_P_POWER_STATE_OCCUPANCY.CORES_C6",
         "PerPkg": "1",
+        "PublicDescription": "This is an occupancy event that tracks the n=
umber of cores that are in the chosen C-State.  It can be used by itself to=
 get the average number of cores in that C-state with thresholding to gener=
ate histograms, or with other PCU events and occupancy triggering to captur=
e other details.",
         "Unit": "PCU"
     },
     {
         "BriefDescription": "External Prochot",
-        "Counter": "0,1,2,3",
         "EventCode": "0xA",
         "EventName": "UNC_P_PROCHOT_EXTERNAL_CYCLES",
         "PerPkg": "1",
+        "PublicDescription": "Counts the number of cycles that we are in e=
xternal PROCHOT mode.  This mode is triggered when a sensor off the die det=
ermines that something off-die (like DRAM) is too hot and must throttle to =
avoid damaging the chip.",
         "Unit": "PCU"
     },
     {
         "BriefDescription": "Internal Prochot",
-        "Counter": "0,1,2,3",
         "EventCode": "0x9",
         "EventName": "UNC_P_PROCHOT_INTERNAL_CYCLES",
         "PerPkg": "1",
+        "PublicDescription": "Counts the number of cycles that we are in I=
nternal PROCHOT mode.  This mode is triggered when a sensor on the die dete=
rmines that we are too hot and must throttle to avoid damaging the chip.",
         "Unit": "PCU"
     },
     {
         "BriefDescription": "Total Core C State Transition Cycles",
-        "Counter": "0,1,2,3",
         "EventCode": "0x72",
         "EventName": "UNC_P_TOTAL_TRANSITION_CYCLES",
         "PerPkg": "1",
+        "PublicDescription": "Number of cycles spent performing core C sta=
te transitions across all cores.",
         "Unit": "PCU"
     },
     {
         "BriefDescription": "UNC_P_UFS_TRANSITIONS_NO_CHANGE",
-        "Counter": "0,1,2,3",
         "EventCode": "0x79",
         "EventName": "UNC_P_UFS_TRANSITIONS_NO_CHANGE",
         "PerPkg": "1",
+        "PublicDescription": "Ring GV with same final and initial frequenc=
y",
         "Unit": "PCU"
     },
     {
-        "BriefDescription": "VR Hot",
-        "Counter": "0,1,2,3",
-        "EventCode": "0x42",
-        "EventName": "UNC_P_VR_HOT_CYCLES",
-        "PerPkg": "1",
-        "Unit": "PCU"
-    },
-    {
-        "BriefDescription": "Package C State Residency - C1E",
-        "Counter": "0,1,2,3",
-        "EventCode": "0x4E",
-        "EventName": "UNC_P_PKG_RESIDENCY_C1E_CYCLES",
+        "BriefDescription": "UNC_P_UFS_TRANSITIONS_RING_GV",
+        "EventCode": "0x79",
+        "EventName": "UNC_P_UFS_TRANSITIONS_RING_GV",
         "PerPkg": "1",
+        "PublicDescription": "Ring GV with same final and initial frequenc=
y",
         "Unit": "PCU"
     },
     {
-        "BriefDescription": "UNC_P_UFS_TRANSITIONS_RING_GV",
-        "Counter": "0,1,2,3",
-        "EventCode": "0x79",
-        "EventName": "UNC_P_UFS_TRANSITIONS_RING_GV",
+        "BriefDescription": "VR Hot",
+        "EventCode": "0x42",
+        "EventName": "UNC_P_VR_HOT_CYCLES",
         "PerPkg": "1",
+        "PublicDescription": "VR Hot : Number of cycles that a CPU SVID VR=
 is hot.  Does not cover DRAM VRs",
         "Unit": "PCU"
     }
 ]
diff --git a/tools/perf/pmu-events/arch/x86/haswellx/virtual-memory.json b/=
tools/perf/pmu-events/arch/x86/haswellx/virtual-memory.json
index 57d2a6452fec..87a4ec1ee7d7 100644
--- a/tools/perf/pmu-events/arch/x86/haswellx/virtual-memory.json
+++ b/tools/perf/pmu-events/arch/x86/haswellx/virtual-memory.json
@@ -1,8 +1,6 @@
 [
     {
         "BriefDescription": "Load misses in all DTLB levels that cause pag=
e walks",
-        "Counter": "0,1,2,3",
-        "CounterHTOff": "0,1,2,3,4,5,6,7",
         "EventCode": "0x08",
         "EventName": "DTLB_LOAD_MISSES.MISS_CAUSES_A_WALK",
         "PublicDescription": "Misses in all TLB levels that cause a page w=
alk of any page size.",
@@ -11,8 +9,6 @@
     },
     {
         "BriefDescription": "DTLB demand load misses with low part of line=
ar-to-physical address translation missed",
-        "Counter": "0,1,2,3",
-        "CounterHTOff": "0,1,2,3,4,5,6,7",
         "EventCode": "0x08",
         "EventName": "DTLB_LOAD_MISSES.PDE_CACHE_MISS",
         "PublicDescription": "DTLB demand load misses with low part of lin=
ear-to-physical address translation missed.",
@@ -21,8 +17,6 @@
     },
     {
         "BriefDescription": "Load operations that miss the first DTLB leve=
l but hit the second and do not cause page walks",
-        "Counter": "0,1,2,3",
-        "CounterHTOff": "0,1,2,3,4,5,6,7",
         "EventCode": "0x08",
         "EventName": "DTLB_LOAD_MISSES.STLB_HIT",
         "PublicDescription": "Number of cache load STLB hits. No page walk=
.",
@@ -31,8 +25,6 @@
     },
     {
         "BriefDescription": "Load misses that miss the  DTLB and hit the S=
TLB (2M)",
-        "Counter": "0,1,2,3",
-        "CounterHTOff": "0,1,2,3,4,5,6,7",
         "EventCode": "0x08",
         "EventName": "DTLB_LOAD_MISSES.STLB_HIT_2M",
         "PublicDescription": "This event counts load operations from a 2M =
page that miss the first DTLB level but hit the second and do not cause pag=
e walks.",
@@ -41,8 +33,6 @@
     },
     {
         "BriefDescription": "Load misses that miss the  DTLB and hit the S=
TLB (4K)",
-        "Counter": "0,1,2,3",
-        "CounterHTOff": "0,1,2,3,4,5,6,7",
         "EventCode": "0x08",
         "EventName": "DTLB_LOAD_MISSES.STLB_HIT_4K",
         "PublicDescription": "This event counts load operations from a 4K =
page that miss the first DTLB level but hit the second and do not cause pag=
e walks.",
@@ -51,8 +41,6 @@
     },
     {
         "BriefDescription": "Demand load Miss in all translation lookaside=
 buffer (TLB) levels causes a page walk that completes of any page size.",
-        "Counter": "0,1,2,3",
-        "CounterHTOff": "0,1,2,3,4,5,6,7",
         "EventCode": "0x08",
         "EventName": "DTLB_LOAD_MISSES.WALK_COMPLETED",
         "PublicDescription": "Completed page walks in any TLB of any page =
size due to demand load misses.",
@@ -61,8 +49,6 @@
     },
     {
         "BriefDescription": "Load miss in all TLB levels causes a page wal=
k that completes. (1G)",
-        "Counter": "0,1,2,3",
-        "CounterHTOff": "0,1,2,3,4,5,6,7",
         "EventCode": "0x08",
         "EventName": "DTLB_LOAD_MISSES.WALK_COMPLETED_1G",
         "SampleAfterValue": "2000003",
@@ -70,8 +56,6 @@
     },
     {
         "BriefDescription": "Demand load Miss in all translation lookaside=
 buffer (TLB) levels causes a page walk that completes (2M/4M).",
-        "Counter": "0,1,2,3",
-        "CounterHTOff": "0,1,2,3,4,5,6,7",
         "EventCode": "0x08",
         "EventName": "DTLB_LOAD_MISSES.WALK_COMPLETED_2M_4M",
         "PublicDescription": "Completed page walks due to demand load miss=
es that caused 2M/4M page walks in any TLB levels.",
@@ -80,8 +64,6 @@
     },
     {
         "BriefDescription": "Demand load Miss in all translation lookaside=
 buffer (TLB) levels causes a page walk that completes (4K).",
-        "Counter": "0,1,2,3",
-        "CounterHTOff": "0,1,2,3,4,5,6,7",
         "EventCode": "0x08",
         "EventName": "DTLB_LOAD_MISSES.WALK_COMPLETED_4K",
         "PublicDescription": "Completed page walks due to demand load miss=
es that caused 4K page walks in any TLB levels.",
@@ -90,8 +72,6 @@
     },
     {
         "BriefDescription": "Cycles when PMH is busy with page walks",
-        "Counter": "0,1,2,3",
-        "CounterHTOff": "0,1,2,3,4,5,6,7",
         "EventCode": "0x08",
         "EventName": "DTLB_LOAD_MISSES.WALK_DURATION",
         "PublicDescription": "This event counts cycles when the  page miss=
 handler (PMH) is servicing page walks caused by DTLB load misses.",
@@ -100,8 +80,6 @@
     },
     {
         "BriefDescription": "Store misses in all DTLB levels that cause pa=
ge walks",
-        "Counter": "0,1,2,3",
-        "CounterHTOff": "0,1,2,3,4,5,6,7",
         "EventCode": "0x49",
         "EventName": "DTLB_STORE_MISSES.MISS_CAUSES_A_WALK",
         "PublicDescription": "Miss in all TLB levels causes a page walk of=
 any page size (4K/2M/4M/1G).",
@@ -110,8 +88,6 @@
     },
     {
         "BriefDescription": "DTLB store misses with low part of linear-to-=
physical address translation missed",
-        "Counter": "0,1,2,3",
-        "CounterHTOff": "0,1,2,3,4,5,6,7",
         "EventCode": "0x49",
         "EventName": "DTLB_STORE_MISSES.PDE_CACHE_MISS",
         "PublicDescription": "DTLB store misses with low part of linear-to=
-physical address translation missed.",
@@ -120,8 +96,6 @@
     },
     {
         "BriefDescription": "Store operations that miss the first TLB leve=
l but hit the second and do not cause page walks",
-        "Counter": "0,1,2,3",
-        "CounterHTOff": "0,1,2,3,4,5,6,7",
         "EventCode": "0x49",
         "EventName": "DTLB_STORE_MISSES.STLB_HIT",
         "PublicDescription": "Store operations that miss the first TLB lev=
el but hit the second and do not cause page walks.",
@@ -130,8 +104,6 @@
     },
     {
         "BriefDescription": "Store misses that miss the  DTLB and hit the =
STLB (2M)",
-        "Counter": "0,1,2,3",
-        "CounterHTOff": "0,1,2,3,4,5,6,7",
         "EventCode": "0x49",
         "EventName": "DTLB_STORE_MISSES.STLB_HIT_2M",
         "PublicDescription": "This event counts store operations from a 2M=
 page that miss the first DTLB level but hit the second and do not cause pa=
ge walks.",
@@ -140,8 +112,6 @@
     },
     {
         "BriefDescription": "Store misses that miss the  DTLB and hit the =
STLB (4K)",
-        "Counter": "0,1,2,3",
-        "CounterHTOff": "0,1,2,3,4,5,6,7",
         "EventCode": "0x49",
         "EventName": "DTLB_STORE_MISSES.STLB_HIT_4K",
         "PublicDescription": "This event counts store operations from a 4K=
 page that miss the first DTLB level but hit the second and do not cause pa=
ge walks.",
@@ -150,8 +120,6 @@
     },
     {
         "BriefDescription": "Store misses in all DTLB levels that cause co=
mpleted page walks",
-        "Counter": "0,1,2,3",
-        "CounterHTOff": "0,1,2,3,4,5,6,7",
         "EventCode": "0x49",
         "EventName": "DTLB_STORE_MISSES.WALK_COMPLETED",
         "PublicDescription": "Completed page walks due to store miss in an=
y TLB levels of any page size (4K/2M/4M/1G).",
@@ -160,8 +128,6 @@
     },
     {
         "BriefDescription": "Store misses in all DTLB levels that cause co=
mpleted page walks. (1G)",
-        "Counter": "0,1,2,3",
-        "CounterHTOff": "0,1,2,3,4,5,6,7",
         "EventCode": "0x49",
         "EventName": "DTLB_STORE_MISSES.WALK_COMPLETED_1G",
         "SampleAfterValue": "100003",
@@ -169,8 +135,6 @@
     },
     {
         "BriefDescription": "Store misses in all DTLB levels that cause co=
mpleted page walks (2M/4M)",
-        "Counter": "0,1,2,3",
-        "CounterHTOff": "0,1,2,3,4,5,6,7",
         "EventCode": "0x49",
         "EventName": "DTLB_STORE_MISSES.WALK_COMPLETED_2M_4M",
         "PublicDescription": "Completed page walks due to store misses in =
one or more TLB levels of 2M/4M page structure.",
@@ -179,8 +143,6 @@
     },
     {
         "BriefDescription": "Store miss in all TLB levels causes a page wa=
lk that completes. (4K)",
-        "Counter": "0,1,2,3",
-        "CounterHTOff": "0,1,2,3,4,5,6,7",
         "EventCode": "0x49",
         "EventName": "DTLB_STORE_MISSES.WALK_COMPLETED_4K",
         "PublicDescription": "Completed page walks due to store misses in =
one or more TLB levels of 4K page structure.",
@@ -189,8 +151,6 @@
     },
     {
         "BriefDescription": "Cycles when PMH is busy with page walks",
-        "Counter": "0,1,2,3",
-        "CounterHTOff": "0,1,2,3,4,5,6,7",
         "EventCode": "0x49",
         "EventName": "DTLB_STORE_MISSES.WALK_DURATION",
         "PublicDescription": "This event counts cycles when the  page miss=
 handler (PMH) is servicing page walks caused by DTLB store misses.",
@@ -199,8 +159,6 @@
     },
     {
         "BriefDescription": "Cycle count for an Extended Page table walk."=
,
-        "Counter": "0,1,2,3",
-        "CounterHTOff": "0,1,2,3,4,5,6,7",
         "EventCode": "0x4f",
         "EventName": "EPT.WALK_CYCLES",
         "SampleAfterValue": "2000003",
@@ -208,8 +166,6 @@
     },
     {
         "BriefDescription": "Flushing of the Instruction TLB (ITLB) pages,=
 includes 4k/2M/4M pages.",
-        "Counter": "0,1,2,3",
-        "CounterHTOff": "0,1,2,3,4,5,6,7",
         "EventCode": "0xae",
         "EventName": "ITLB.ITLB_FLUSH",
         "PublicDescription": "Counts the number of ITLB flushes, includes =
4k/2M/4M pages.",
@@ -218,8 +174,6 @@
     },
     {
         "BriefDescription": "Misses at all ITLB levels that cause page wal=
ks",
-        "Counter": "0,1,2,3",
-        "CounterHTOff": "0,1,2,3,4,5,6,7",
         "EventCode": "0x85",
         "EventName": "ITLB_MISSES.MISS_CAUSES_A_WALK",
         "PublicDescription": "Misses in ITLB that causes a page walk of an=
y page size.",
@@ -228,8 +182,6 @@
     },
     {
         "BriefDescription": "Operations that miss the first ITLB level but=
 hit the second and do not cause any page walks",
-        "Counter": "0,1,2,3",
-        "CounterHTOff": "0,1,2,3,4,5,6,7",
         "EventCode": "0x85",
         "EventName": "ITLB_MISSES.STLB_HIT",
         "PublicDescription": "ITLB misses that hit STLB. No page walk.",
@@ -238,8 +190,6 @@
     },
     {
         "BriefDescription": "Code misses that miss the  DTLB and hit the S=
TLB (2M)",
-        "Counter": "0,1,2,3",
-        "CounterHTOff": "0,1,2,3,4,5,6,7",
         "EventCode": "0x85",
         "EventName": "ITLB_MISSES.STLB_HIT_2M",
         "PublicDescription": "ITLB misses that hit STLB (2M).",
@@ -248,8 +198,6 @@
     },
     {
         "BriefDescription": "Core misses that miss the  DTLB and hit the S=
TLB (4K)",
-        "Counter": "0,1,2,3",
-        "CounterHTOff": "0,1,2,3,4,5,6,7",
         "EventCode": "0x85",
         "EventName": "ITLB_MISSES.STLB_HIT_4K",
         "PublicDescription": "ITLB misses that hit STLB (4K).",
@@ -258,8 +206,6 @@
     },
     {
         "BriefDescription": "Misses in all ITLB levels that cause complete=
d page walks",
-        "Counter": "0,1,2,3",
-        "CounterHTOff": "0,1,2,3,4,5,6,7",
         "EventCode": "0x85",
         "EventName": "ITLB_MISSES.WALK_COMPLETED",
         "PublicDescription": "Completed page walks in ITLB of any page siz=
e.",
@@ -268,8 +214,6 @@
     },
     {
         "BriefDescription": "Store miss in all TLB levels causes a page wa=
lk that completes. (1G)",
-        "Counter": "0,1,2,3",
-        "CounterHTOff": "0,1,2,3,4,5,6,7",
         "EventCode": "0x85",
         "EventName": "ITLB_MISSES.WALK_COMPLETED_1G",
         "SampleAfterValue": "100003",
@@ -277,8 +221,6 @@
     },
     {
         "BriefDescription": "Code miss in all TLB levels causes a page wal=
k that completes. (2M/4M)",
-        "Counter": "0,1,2,3",
-        "CounterHTOff": "0,1,2,3,4,5,6,7",
         "EventCode": "0x85",
         "EventName": "ITLB_MISSES.WALK_COMPLETED_2M_4M",
         "PublicDescription": "Completed page walks due to misses in ITLB 2=
M/4M page entries.",
@@ -287,8 +229,6 @@
     },
     {
         "BriefDescription": "Code miss in all TLB levels causes a page wal=
k that completes. (4K)",
-        "Counter": "0,1,2,3",
-        "CounterHTOff": "0,1,2,3,4,5,6,7",
         "EventCode": "0x85",
         "EventName": "ITLB_MISSES.WALK_COMPLETED_4K",
         "PublicDescription": "Completed page walks due to misses in ITLB 4=
K page entries.",
@@ -297,8 +237,6 @@
     },
     {
         "BriefDescription": "Cycles when PMH is busy with page walks",
-        "Counter": "0,1,2,3",
-        "CounterHTOff": "0,1,2,3,4,5,6,7",
         "EventCode": "0x85",
         "EventName": "ITLB_MISSES.WALK_DURATION",
         "PublicDescription": "This event counts cycles when the  page miss=
 handler (PMH) is servicing page walks caused by ITLB misses.",
@@ -307,8 +245,6 @@
     },
     {
         "BriefDescription": "Number of DTLB page walker hits in the L1+FB"=
,
-        "Counter": "0,1,2,3",
-        "CounterHTOff": "0,1,2,3",
         "EventCode": "0xBC",
         "EventName": "PAGE_WALKER_LOADS.DTLB_L1",
         "PublicDescription": "Number of DTLB page walker loads that hit in=
 the L1+FB.",
@@ -317,8 +253,6 @@
     },
     {
         "BriefDescription": "Number of DTLB page walker hits in the L2",
-        "Counter": "0,1,2,3",
-        "CounterHTOff": "0,1,2,3",
         "EventCode": "0xBC",
         "EventName": "PAGE_WALKER_LOADS.DTLB_L2",
         "PublicDescription": "Number of DTLB page walker loads that hit in=
 the L2.",
@@ -327,8 +261,6 @@
     },
     {
         "BriefDescription": "Number of DTLB page walker hits in the L3 + X=
SNP",
-        "Counter": "0,1,2,3",
-        "CounterHTOff": "0,1,2,3",
         "Errata": "HSD25",
         "EventCode": "0xBC",
         "EventName": "PAGE_WALKER_LOADS.DTLB_L3",
@@ -338,8 +270,6 @@
     },
     {
         "BriefDescription": "Number of DTLB page walker hits in Memory",
-        "Counter": "0,1,2,3",
-        "CounterHTOff": "0,1,2,3",
         "Errata": "HSD25",
         "EventCode": "0xBC",
         "EventName": "PAGE_WALKER_LOADS.DTLB_MEMORY",
@@ -349,8 +279,6 @@
     },
     {
         "BriefDescription": "Counts the number of Extended Page Table walk=
s from the DTLB that hit in the L1 and FB.",
-        "Counter": "0,1,2,3",
-        "CounterHTOff": "0,1,2,3",
         "EventCode": "0xBC",
         "EventName": "PAGE_WALKER_LOADS.EPT_DTLB_L1",
         "SampleAfterValue": "2000003",
@@ -358,8 +286,6 @@
     },
     {
         "BriefDescription": "Counts the number of Extended Page Table walk=
s from the DTLB that hit in the L2.",
-        "Counter": "0,1,2,3",
-        "CounterHTOff": "0,1,2,3",
         "EventCode": "0xBC",
         "EventName": "PAGE_WALKER_LOADS.EPT_DTLB_L2",
         "SampleAfterValue": "2000003",
@@ -367,8 +293,6 @@
     },
     {
         "BriefDescription": "Counts the number of Extended Page Table walk=
s from the DTLB that hit in the L3.",
-        "Counter": "0,1,2,3",
-        "CounterHTOff": "0,1,2,3",
         "EventCode": "0xBC",
         "EventName": "PAGE_WALKER_LOADS.EPT_DTLB_L3",
         "SampleAfterValue": "2000003",
@@ -376,8 +300,6 @@
     },
     {
         "BriefDescription": "Counts the number of Extended Page Table walk=
s from the DTLB that hit in memory.",
-        "Counter": "0,1,2,3",
-        "CounterHTOff": "0,1,2,3",
         "EventCode": "0xBC",
         "EventName": "PAGE_WALKER_LOADS.EPT_DTLB_MEMORY",
         "SampleAfterValue": "2000003",
@@ -385,8 +307,6 @@
     },
     {
         "BriefDescription": "Counts the number of Extended Page Table walk=
s from the ITLB that hit in the L1 and FB.",
-        "Counter": "0,1,2,3",
-        "CounterHTOff": "0,1,2,3",
         "EventCode": "0xBC",
         "EventName": "PAGE_WALKER_LOADS.EPT_ITLB_L1",
         "SampleAfterValue": "2000003",
@@ -394,8 +314,6 @@
     },
     {
         "BriefDescription": "Counts the number of Extended Page Table walk=
s from the ITLB that hit in the L2.",
-        "Counter": "0,1,2,3",
-        "CounterHTOff": "0,1,2,3",
         "EventCode": "0xBC",
         "EventName": "PAGE_WALKER_LOADS.EPT_ITLB_L2",
         "SampleAfterValue": "2000003",
@@ -403,8 +321,6 @@
     },
     {
         "BriefDescription": "Counts the number of Extended Page Table walk=
s from the ITLB that hit in the L2.",
-        "Counter": "0,1,2,3",
-        "CounterHTOff": "0,1,2,3",
         "EventCode": "0xBC",
         "EventName": "PAGE_WALKER_LOADS.EPT_ITLB_L3",
         "SampleAfterValue": "2000003",
@@ -412,8 +328,6 @@
     },
     {
         "BriefDescription": "Counts the number of Extended Page Table walk=
s from the ITLB that hit in memory.",
-        "Counter": "0,1,2,3",
-        "CounterHTOff": "0,1,2,3",
         "EventCode": "0xBC",
         "EventName": "PAGE_WALKER_LOADS.EPT_ITLB_MEMORY",
         "SampleAfterValue": "2000003",
@@ -421,8 +335,6 @@
     },
     {
         "BriefDescription": "Number of ITLB page walker hits in the L1+FB"=
,
-        "Counter": "0,1,2,3",
-        "CounterHTOff": "0,1,2,3",
         "EventCode": "0xBC",
         "EventName": "PAGE_WALKER_LOADS.ITLB_L1",
         "PublicDescription": "Number of ITLB page walker loads that hit in=
 the L1+FB.",
@@ -431,8 +343,6 @@
     },
     {
         "BriefDescription": "Number of ITLB page walker hits in the L2",
-        "Counter": "0,1,2,3",
-        "CounterHTOff": "0,1,2,3",
         "EventCode": "0xBC",
         "EventName": "PAGE_WALKER_LOADS.ITLB_L2",
         "PublicDescription": "Number of ITLB page walker loads that hit in=
 the L2.",
@@ -441,8 +351,6 @@
     },
     {
         "BriefDescription": "Number of ITLB page walker hits in the L3 + X=
SNP",
-        "Counter": "0,1,2,3",
-        "CounterHTOff": "0,1,2,3",
         "Errata": "HSD25",
         "EventCode": "0xBC",
         "EventName": "PAGE_WALKER_LOADS.ITLB_L3",
@@ -452,8 +360,6 @@
     },
     {
         "BriefDescription": "Number of ITLB page walker hits in Memory",
-        "Counter": "0,1,2,3",
-        "CounterHTOff": "0,1,2,3",
         "Errata": "HSD25",
         "EventCode": "0xBC",
         "EventName": "PAGE_WALKER_LOADS.ITLB_MEMORY",
@@ -463,8 +369,6 @@
     },
     {
         "BriefDescription": "DTLB flush attempts of the thread-specific en=
tries",
-        "Counter": "0,1,2,3",
-        "CounterHTOff": "0,1,2,3,4,5,6,7",
         "EventCode": "0xBD",
         "EventName": "TLB_FLUSH.DTLB_THREAD",
         "PublicDescription": "DTLB flush attempts of the thread-specific e=
ntries.",
@@ -473,8 +377,6 @@
     },
     {
         "BriefDescription": "STLB flush attempts",
-        "Counter": "0,1,2,3",
-        "CounterHTOff": "0,1,2,3,4,5,6,7",
         "EventCode": "0xBD",
         "EventName": "TLB_FLUSH.STLB_ANY",
         "PublicDescription": "Count number of STLB flush attempts.",
--=20
2.39.0.314.g84b9a713c41-goog

