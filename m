Return-Path: <linux-kernel-owner@vger.kernel.org>
X-Original-To: lists+linux-kernel@lfdr.de
Delivered-To: lists+linux-kernel@lfdr.de
Received: from out1.vger.email (out1.vger.email [IPv6:2620:137:e000::1:20])
	by mail.lfdr.de (Postfix) with ESMTP id 3925A65FCAD
	for <lists+linux-kernel@lfdr.de>; Fri,  6 Jan 2023 09:24:29 +0100 (CET)
Received: (majordomo@vger.kernel.org) by vger.kernel.org via listexpand
        id S232058AbjAFIYZ (ORCPT <rfc822;lists+linux-kernel@lfdr.de>);
        Fri, 6 Jan 2023 03:24:25 -0500
Received: from lindbergh.monkeyblade.net ([23.128.96.19]:44556 "EHLO
        lindbergh.monkeyblade.net" rhost-flags-OK-OK-OK-OK) by vger.kernel.org
        with ESMTP id S231998AbjAFIYX (ORCPT
        <rfc822;linux-kernel@vger.kernel.org>);
        Fri, 6 Jan 2023 03:24:23 -0500
Received: from szxga01-in.huawei.com (szxga01-in.huawei.com [45.249.212.187])
        by lindbergh.monkeyblade.net (Postfix) with ESMTPS id ADC03625E5
        for <linux-kernel@vger.kernel.org>; Fri,  6 Jan 2023 00:24:21 -0800 (PST)
Received: from dggpemm500016.china.huawei.com (unknown [172.30.72.56])
        by szxga01-in.huawei.com (SkyGuard) with ESMTP id 4NpGYQ1PMGznV9b;
        Fri,  6 Jan 2023 16:22:50 +0800 (CST)
Received: from huawei.com (10.67.175.41) by dggpemm500016.china.huawei.com
 (7.185.36.25) with Microsoft SMTP Server (version=TLS1_2,
 cipher=TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256) id 15.1.2375.34; Fri, 6 Jan
 2023 16:24:18 +0800
From:   Yipeng Zou <zouyipeng@huawei.com>
To:     <tglx@linutronix.de>, <maz@kernel.org>,
        <linux-kernel@vger.kernel.org>,
        <linux-arm-kernel@lists.infradead.org>
CC:     <hewenliang4@huawei.com>, <zouyipeng@huawei.com>,
        <chris.zjh@huawei.com>, <liaochang1@huawei.com>
Subject: [RFC PATCH] irqchip/gic-v3: wait irq done to set affinity
Date:   Fri, 6 Jan 2023 16:21:36 +0800
Message-ID: <20230106082136.68501-1-zouyipeng@huawei.com>
X-Mailer: git-send-email 2.17.1
MIME-Version: 1.0
Content-Type: text/plain
X-Originating-IP: [10.67.175.41]
X-ClientProxiedBy: dggems702-chm.china.huawei.com (10.3.19.179) To
 dggpemm500016.china.huawei.com (7.185.36.25)
X-CFilter-Loop: Reflected
X-Spam-Status: No, score=-4.2 required=5.0 tests=BAYES_00,RCVD_IN_DNSWL_MED,
        SPF_HELO_NONE,SPF_PASS autolearn=ham autolearn_force=no version=3.4.6
X-Spam-Checker-Version: SpamAssassin 3.4.6 (2021-04-09) on
        lindbergh.monkeyblade.net
Precedence: bulk
List-ID: <linux-kernel.vger.kernel.org>
X-Mailing-List: linux-kernel@vger.kernel.org

Recently we have some problem about gic set affinity in our test.

This patch just aim to make some discuss about this problem.

For now, the implementation of gic set affinity going to take effects
immediately, and without check if any irq are being processed.

So, This leads to some problem, think about this scenario:

1. First, we have an irq was generated by an device.

2. In the processing of this irq(after handle event, before clear
IRQD_IRQ_INPROGRESS flag), we modify the route and the gic takes effect
immediately,at the same time the new one was generated again.

3. The new irq will be processing in other cpu which different form the
old one.

4. The new irq going to be discarded because of the flag IRQD_IRQ_INPROGRESS
has been set.

I notice that if we set IRQF_ONESHOT when register the irq, this problem
will gone.

But I'm also thinking about change the gic_set_affinity function, to wait
current irq done on all cpus before gic_write_irouter.
I'm not sure if that's appropriate.

Is the best workaround to use IRQF_ONESHOT to prevent reentrancy?

Please let me know, if have any other suggestions on this issue.

Signed-off-by: Yipeng Zou <zouyipeng@huawei.com>
---
 drivers/irqchip/irq-gic-v3.c | 2 ++
 1 file changed, 2 insertions(+)

diff --git a/drivers/irqchip/irq-gic-v3.c b/drivers/irqchip/irq-gic-v3.c
index 997104d4338e..e9b9f15f07f8 100644
--- a/drivers/irqchip/irq-gic-v3.c
+++ b/drivers/irqchip/irq-gic-v3.c
@@ -1348,6 +1348,8 @@ static int gic_set_affinity(struct irq_data *d, const struct cpumask *mask_val,
 	reg = gic_dist_base(d) + offset + (index * 8);
 	val = gic_mpidr_to_affinity(cpu_logical_map(cpu));
 
+	// wait irq done on all cpus
+
 	gic_write_irouter(val, reg);
 
 	/*
-- 
2.17.1

